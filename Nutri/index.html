<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"">
    <meta name="theme-color" content="#729c9c">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Groceries">
    <meta name="google-signin-client_id" content="778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups">
    <title>Groceries</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://apis.google.com/js/picker.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app" style="display: none;">
        <div v-if="!isSignedIn">
            <div id="googleSignInButton" style="display: flex; align-items: center; justify-content: center; height: 100dvh; width: 100%;"></div>
        </div>
        <div v-else-if="isSignedIn && user" class="main-content">
            <div class="sidenav" :class="{ 'open': isSidenavOpen }">
                <span class="close-sidenav" @click="toggleSidenav">&times;</span>
                <div class="user-info-wrapper"><p class="user-info">{{ user.email }} </p><button @click="signOut">Sign Out</button></div>
                <nav class="nav-menu">
                    <a :class="{ active: currentPage === 'groceries' }" @click="currentPage = 'groceries'; toggleSidenav()" href="#">Groceries</a>
                    <a :class="{ active: currentPage === 'locations' }" @click="currentPage = 'locations'; toggleSidenav()" href="#">Locations</a>
                    <a :class="{ active: currentPage === 'history' }" @click="currentPage = 'history'; toggleSidenav()" href="#">History</a>
                    <a :class="{ active: currentPage === 'dashboard' }" @click="currentPage = 'dashboard'; toggleSidenav()" href="#">Dashboard</a>
                </nav>
                <div class="sheet-info">
                    <p v-if="sheetId"><strong>Current Sheet ID</strong><br>{{ sheetId }}</p>
                    <div>
                        <button @click="createNewSheet">New Sheet</button>
                        <button @click="showPicker">Load Sheet</button>
                    </div>
                </div>
            </div>
            <div v-if="!sheetId" style="display: flex; align-items: center; justify-content: center; width: 100%;">
                <button @click="createNewSheet">New Sheet</button>
                <button @click="showPicker">Load Sheet</button>
            </div>
            <component v-if="sheetId" :is="currentPageComponent" :sheet-id="sheetId" ref="currentPageRef" :toggle-sidenav="toggleSidenav" :is-editing="isEditing" :start-editing="startEditing" :stop-editing="stopEditing"></component>
        </div>
    </div>

    <script type="module">
        import GoogleAuth, { CLIENT_ID } from './googleAuth.js?v=1';
        import { DashboardPage } from './DashboardPage.js';

        let app;
        (async function() {
            const { createApp, ref, computed, onMounted, onBeforeUnmount, watch, defineComponent } = Vue;

            const GroceriesPage = {
                props: ['sheetId', 'toggleSidenav', 'startEditing', 'stopEditing'],
                setup(props) {
                    const locations = ref([]);
                    const groceryItems = ref([]);
                    const recentlyCheckedOff = ref([]);
                    const loading = ref(false);
                    const error = ref(null);
                    const selectedLocation = ref(null);
                    const selectedItems = ref([]);
                    const selectAll = ref(false);
                    const inputValues = ref({});
                    const groceryListRef = ref(null);
                    const sortingEnabled = ref(false);
                    let sortableInstance = null;

                    function initSortable() {
                        if (groceryListRef.value) {
                            if (groceryListRef.value._sortable && typeof groceryListRef.value._sortable.destroy === 'function') {
                                groceryListRef.value._sortable.destroy();
                            }
                            
                            if (sortingEnabled.value) {
                                groceryListRef.value._sortable = new Sortable(groceryListRef.value, {
                                    animation: 150,
                                    ghostClass: 'sortable-ghost',
                                    handle: '.drag-handle', // Use the drag handle for sorting
                                    onEnd: async ({ oldIndex, newIndex }) => {
                                        const item = filteredGroceryItems.value.splice(oldIndex, 1)[0];
                                        filteredGroceryItems.value.splice(newIndex, 0, item);
                                        
                                        // Update the order of items
                                        filteredGroceryItems.value.forEach((item, index) => {
                                            item.order = index;
                                        });

                                        // Update the items in the sheet
                                        for (const item of filteredGroceryItems.value) {
                                            await updateItemInSheet(item);
                                        }
                                    }
                                });
                            } else {
                                delete groceryListRef.value._sortable;
                            }
                        }
                    }

                    function toggleSorting() {
                        sortingEnabled.value = !sortingEnabled.value;
                        selectedItems.value = []; // Clear selections when toggling sort
                        Vue.nextTick(() => {
                            initSortable();
                        });
                    }

                    function toggleSelectAll(items) {
                        if (selectedItems.value.length === items.length) {
                            selectedItems.value = [];
                        } else {
                            selectedItems.value = items.map(item => item.id);
                        }
                    }

                    function deselectAll() {
                        selectedItems.value = [];
                    }

                    async function performSelectedAction(action) {
                        if (selectedItems.value.length === 0) return;

                        switch (action) {
                            case 'delete':
                            if (confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                                // Implement delete logic
                                console.log('Deleting items:', selectedItems.value);
                            }
                            break;
                            case 'changeLocation':
                            // Implement change location logic
                            console.log('Changing location for items:', selectedItems.value);
                            break;
                            case 'changeDate':
                            const newDate = prompt("Enter new date (YYYY-MM-DD) or leave empty to remove date:");
                            for (const itemId of selectedItems.value) {
                                const item = groceryItems.value.find(i => i.id === itemId);
                                if (item) {
                                    if (newDate) {
                                        item.dateChecked = new Date(newDate).getTime();
                                        item.date = new Date(newDate).toLocaleDateString();
                                    } else {
                                        item.dateChecked = null;
                                        item.date = '';
                                    }
                                    try {
                                        await updateItemInSheet(item);
                                        // Handle successful update
                                    } catch (err) {
                                        console.error('Failed to update item:', err);
                                        error.value = 'Failed to update item. Please try again.';
                                    }
                                }
                            }
                            updateRecentlyCheckedOff();
                            updateLocationStats();
                            break;
                        }

                        selectedItems.value = []; // Clear selections after action
                    }

                    // Fetch locations and grocery items
                    async function fetchData() {
                        console.log('Starting fetchData');
                        loading.value = true;
                        error.value = null;
                        const currentSelectedLocationId = selectedLocation.value;
                        try {
                            // Check token validity
                            const isValid = await GoogleAuth.isTokenValid();
                            if (!isValid) {
                                console.log('Token is not valid, refreshing...');
                                await GoogleAuth.getAccessToken(); // This should refresh the token
                                console.log('Token is now valid');
                            }

                            console.log('Fetching groceries data');
                            const groceriesResponse = await GoogleAuth.loadSheetData(props.sheetId, 'Groceries!A2:H');
                            console.log('Groceries data received:', groceriesResponse);

                            const values = groceriesResponse.values || [];
                            groceryItems.value = values.map(row => ({
                                id: row[0],
                                title: row[1],
                                amount: parseInt(row[2]),
                                price: parseFloat(row[3].replace(',', '.')),
                                order: parseInt(row[4]),
                                location: row[5],
                                dateChecked: row[6] ? parseInt(row[6]) : null,
                                date: row[7],
                                checked: !!row[6]
                            }));

                            console.log('Fetching locations data');
                            const locationsResponse = await GoogleAuth.loadSheetData(props.sheetId, 'Locations!A2:E');
                            console.log('Locations data received:', locationsResponse);

                            const locationsValues = locationsResponse.values || [];
                            locations.value = locationsValues
                                .filter(row => row[3] !== 'true') // Filter out hidden locations
                                .map(row => ({
                                    id: row[2],
                                    title: row[0],
                                    order: parseInt(row[1]) || 0, // Parse the order value
                                    itemCount: 0,
                                    totalPrice: 0
                                }))
                                .sort((a, b) => a.order - b.order); // Sort locations by order

                            console.log('Updating location stats');
                            updateLocationStats();

                            // Restore the previously selected location, or default to the first one if it no longer exists
                            if (locations.value.some(loc => loc.id === currentSelectedLocationId)) {
                                selectedLocation.value = currentSelectedLocationId;
                            } else if (locations.value.length > 0) {
                                selectedLocation.value = locations.value[0].id;
                            }

                            console.log('Updating recently checked off items');
                            updateRecentlyCheckedOff();

                        } catch (err) {
                            console.error('Error fetching data:', err);
                            if (err.message.includes('Authentication failed')) {
                                error.value = 'Authentication failed. Please sign in again.';
                                // Trigger sign out or re-authentication process
                                await GoogleAuth.signOut();
                                // You might want to redirect to a sign-in page or show a sign-in prompt here
                            } else {
                                error.value = 'Failed to fetch data. Please try again.';
                            }
                        } finally {
                            loading.value = false;
                            console.log('fetchData completed');
                        }
                    }

                    function updateLocationStats() {
                        //console.log("Updating location stats");
                        const locationTotals = {};
                        groceryItems.value.forEach(item => {
                            if (!item.dateChecked) {  // Only consider unchecked items
                                if (!locationTotals[item.location]) {
                                    locationTotals[item.location] = {
                                        itemCount: 0,
                                        totalPrice: 0
                                    };
                                }
                                locationTotals[item.location].itemCount++;
                                
                                let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                                if (!isNaN(price)) {
                                    locationTotals[item.location].totalPrice += price;
                                }
                            }
                        });

                        locations.value.forEach(location => {
                            const stats = locationTotals[location.id] || { itemCount: 0, totalPrice: 0 };
                            location.itemCount = stats.itemCount;
                            location.totalPrice = stats.totalPrice;
                            //console.log(`Location: ${location.title}, Count: ${location.itemCount}, Total: ${location.totalPrice}`);
                        });
                    }

                    function updateRecentlyCheckedOff() {
                        const checkedItems = groceryItems.value.filter(item => 
                            item.dateChecked && item.location === selectedLocation.value
                        );
                        const groupedItems = _.groupBy(checkedItems, item => {
                            // Ensure we're using the date in the local timezone
                            const date = new Date(item.dateChecked);
                            return date.toISOString().split('T')[0]; // YYYY-MM-DD format
                        });
                        
                        // Create a map of existing groups with their collapsed state
                        const existingGroupsMap = new Map(
                            recentlyCheckedOff.value.map(group => [group.date, group.collapsed])
                        );

                        recentlyCheckedOff.value = Object.entries(groupedItems).map(([date, items]) => ({
                            date,
                            items: items.sort((a, b) => a.order - b.order), // Sort items within each group by order
                            total: items.reduce((sum, item) => {
                                let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                                return sum + (price);
                            }, 0),
                            collapsed: existingGroupsMap.has(date) ? existingGroupsMap.get(date) : true // Preserve collapsed state or default to true
                        }))
                        .sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort groups by date, latest first
                    }

                    async function toggleItemCheck(item) {
                        loading.value = true;
                        try {
                            const now = Date.now();
                            if (!item.checked) {
                                // Item is being checked off
                                item.dateChecked = now;
                                item.date = new Date(now).toLocaleDateString();
                                // Assign the highest order number + 1 to put it at the end of the list
                                const maxOrder = Math.max(...groceryItems.value.map(i => i.order), 0);
                                item.order = maxOrder + 1;
                            } else {
                                // Item is being unchecked
                                item.dateChecked = null;
                                item.date = '';
                                // You might want to reset the order or keep it as is
                            }
                            item.checked = !item.checked;

                            try {
                                await updateItemInSheet(item);
                                // Handle successful update
                                updateLocationStats();
                                updateRecentlyCheckedOff();
                            } catch (err) {
                                console.error('Failed to update item:', err);
                                error.value = 'Failed to update item. Please try again.';
                            }
                        } catch (err) {
                            console.error('Error toggling item check:', err);
                            error.value = 'Failed to update item. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function addGroceryItem() {
                        const newItem = {
                            id: `item_${Date.now()}`,
                            title: '',
                            amount: 0,
                            price: 0,
                            order: groceryItems.value.length,
                            location: selectedLocation.value,
                            dateChecked: null,
                            date: '',
                            checked: false
                        };

                        groceryItems.value.push(newItem);
                        try {
                            await updateItemInSheet(newItem);
                            // Handle successful update
                            updateLocationStats();

                            // Use nextTick to ensure the DOM has updated before trying to focus
                            Vue.nextTick(() => {
                                const newItemInput = document.querySelector(`input[data-item-id="${newItem.id}"]`);
                                if (newItemInput) {
                                    newItemInput.focus();
                                }
                            });
                        } catch (err) {
                            console.error('Failed to update item:', err);
                            error.value = 'Failed to update item. Please try again.';
                        }
                    }

                    async function updateItemInSheet(item) {
                        console.log('updateItemInSheet', item);
                        const itemIndex = groceryItems.value.findIndex(i => i.id === item.id);
                        if (itemIndex === -1) {
                            throw new Error('Item not found in local array');
                        }

                        try {
                            const rowIndex = itemIndex + 2; // +2 because sheet is 1-indexed and has a header row
                            const locationTitleFormula = `=IF(ISBLANK(F${rowIndex});"";INDEX(Locations!A:A; MATCH(F${rowIndex}; Locations!C:C; 0)))`;
                            const dateFormula = `=IF(ISBLANK(G${rowIndex});"";EPOCHTODATE(G${rowIndex};2))`;

                            const cellValues = [
                                { userEnteredValue: { stringValue: item.id } },
                                { userEnteredValue: { stringValue: item.title } },
                                { userEnteredValue: { numberValue: item.amount } },
                                { userEnteredValue: { stringValue: formatPrice(item.price) } },
                                { userEnteredValue: { numberValue: item.order } },
                                { userEnteredValue: { stringValue: item.location } },
                                { userEnteredValue: { numberValue: item.dateChecked ? Number(item.dateChecked) : null } },
                                { userEnteredValue: { formulaValue: dateFormula } },
                                { userEnteredValue: { formulaValue: locationTitleFormula } }
                            ];

                            // Check if the row exists
                            const range = `Groceries!A${rowIndex}:A${rowIndex}`;
                            const response = await GoogleAuth.getValues(props.sheetId, range);

                            let requests;
                            if (response.values && response.values.length > 0) {
                                // Row exists, use updateCells
                                requests = [{
                                    updateCells: {
                                        rows: [{ values: cellValues }],
                                        fields: '*',
                                        start: {
                                            sheetId: await getSheetId(props.sheetId, 'Groceries'),
                                            rowIndex: rowIndex - 1,
                                            columnIndex: 0
                                        }
                                    }
                                }];
                            } else {
                                // Row doesn't exist, use appendCells
                                requests = [{
                                    appendCells: {
                                        sheetId: await getSheetId(props.sheetId, 'Groceries'),
                                        rows: [{ values: cellValues }],
                                        fields: '*'
                                    }
                                }];
                            }

                            console.log('Batch Update Requests:', JSON.stringify(requests, null, 2));

                            await GoogleAuth.batchUpdateSpreadsheet(props.sheetId, requests);
                            console.log('Item updated successfully in sheet');
                        } catch (err) {
                            console.error('Error updating item in sheet:', err);
                            throw err;
                        }
                    }

                    function selectLocation(locationId) {
                        selectedLocation.value = locationId;
                        updateRecentlyCheckedOff();
                        selectedItems.value = []; // Clear selections
                    }

                    function parsePrice(value) {
                        if (typeof value === 'number') return value;
                        if (!value) return 0;
                        
                        // Remove any non-digit, non-comma, non-minus characters
                        value = value.replace(/[^\d,-]/g, '');
                        
                        // Replace comma with dot for parsing
                        value = value.replace(',', '.');
                        
                        // Parse the value, ensuring it's a number with two decimal places
                        return parseFloat(parseFloat(value).toFixed(2));
                    }

                    function formatPrice(price) {
                        if (price === null || price === undefined || isNaN(price)) return '0,00';
                        
                        // Convert to string, replace dot with comma, and ensure two decimal places
                        let formattedPrice = Math.abs(price).toFixed(2).replace('.', ',');
                        
                        // Add minus sign if negative
                        if (price < 0) formattedPrice = '-' + formattedPrice;
                        
                        return formattedPrice;
                    }

                    function formatPriceForDisplay(item) {
                        const storedInput = inputValues.value[item.id];
                        if (storedInput !== undefined) {
                            return storedInput;
                        }
                        return formatPrice(item.price);
                    }

                    async function handlePriceBlur(item, event) {
                        // Get the stored input value or use the current item price
                        const inputValue = inputValues.value[item.id] || formatPrice(item.price);
                        
                        // Parse and format the price
                        const newPrice = parsePrice(inputValue);
                        const formattedPrice = formatPrice(newPrice);
                        
                        // Update the item price and input value
                        item.price = newPrice;
                        event.target.value = formattedPrice;
                        
                        // Clear the temporary input value
                        delete inputValues.value[item.id];
                        
                        try {
                            await updateItemInSheet(item);
                            // Handle successful update
                            updateLocationStats();
                            updateRecentlyCheckedOff();
                        } catch (err) {
                            console.error('Failed to update item:', err);
                            error.value = 'Failed to update item. Please try again.';
                        }
                    }

                    async function updateItemField(item, field, value) {
                        if (typeof value === 'string') {
                            // For text inputs: capitalize first letter and remove trailing spaces
                            value = value.charAt(0).toUpperCase() + value.slice(1).trimEnd();
                        }

                        if (field === 'price') {
                            value = parsePrice(value);
                        } else if (field === 'amount') {
                            value = parseInt(value) || null;  // Convert to integer or null if invalid
                        }

                        item[field] = value;
                        try {
                            await updateItemInSheet(item);
                            // Handle successful update
                            updateLocationStats();
                        } catch (err) {
                            console.error('Failed to update item:', err);
                            error.value = 'Failed to update item. Please try again.';
                        }
                    }

                    async function duplicateSelectedItems() {
                        for (const itemId of selectedItems.value) {
                            const originalItem = groceryItems.value.find(item => item.id === itemId);
                            if (originalItem) {
                            const newItem = {
                                id: `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                title: originalItem.title,
                                amount: originalItem.amount,
                                price: originalItem.price,
                                order: groceryItems.value.length,
                                location: originalItem.location,
                                dateChecked: null,
                                date: '',
                                checked: false
                            };

                            groceryItems.value.push(newItem);
                            try {
                                await updateItemInSheet(newItem);
                                // Handle successful update
                                updateLocationStats();
                            } catch (err) {
                                console.error('Failed to duplicate item:', err);
                                error.value = 'Failed to duplicate item. Please try again.';
                            }
                            }
                        }
                        // Clear selections after duplication
                        selectedItems.value = [];
                    }

                    async function deleteSelectedItems() {
                        if (selectedItems.value.length === 0) return;

                        // Ask for confirmation
                        if (!confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                            return; // If the user cancels, exit the function
                        }

                        try {
                            const sheetId = await getSheetId(props.sheetId, 'Groceries');

                            const deleteRequests = [];
                            const itemsToDelete = [...selectedItems.value].sort((a, b) => b - a); // Sort in descending order

                            for (const itemId of itemsToDelete) {
                                const itemIndex = groceryItems.value.findIndex(item => item.id === itemId);
                                if (itemIndex !== -1) {
                                    const rowIndex = itemIndex + 2; // +2 because sheet is 1-indexed and has a header row

                                    deleteRequests.push({
                                        deleteDimension: {
                                            range: {
                                                sheetId: sheetId,
                                                dimension: 'ROWS',
                                                startIndex: rowIndex - 1,
                                                endIndex: rowIndex
                                            }
                                        }
                                    });

                                    groceryItems.value.splice(itemIndex, 1);
                                }
                            }

                            if (deleteRequests.length > 0) {
                                await GoogleAuth.batchUpdateSpreadsheet(props.sheetId, deleteRequests);
                            }

                            // Clear the selectedItems array
                            selectedItems.value = [];

                            updateLocationStats();
                            updateRecentlyCheckedOff();
                            error.value = null;
                        } catch (err) {
                            console.error('Error deleting grocery items:', err);
                            error.value = 'Failed to delete items. Please try again.';
                        }
                    }

                    async function getSheetId(spreadsheetId, sheetName) {
                        const accessToken = await GoogleAuth.getAccessToken();
                        const response = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?fields=sheets.properties`, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        });
                        const data = await response.json();
                        const sheet = data.sheets.find(s => s.properties.title === sheetName);
                        return sheet ? sheet.properties.sheetId : null;
                    }

                    async function changeLocationForSelected(newLocationId) {
                        if (selectedItems.value.length === 0 || !newLocationId) return;
                        
                        loading.value = true;
                        error.value = null;
                        
                        try {
                            for (const itemId of selectedItems.value) {
                                const item = groceryItems.value.find(i => i.id === itemId);
                                if (item) {
                                    item.location = newLocationId;
                                    try {
                                        await updateItemInSheet(item);
                                        // Handle successful update
                                    } catch (err) {
                                        console.error('Failed to update item:', err);
                                        error.value = 'Failed to update item. Please try again.';
                                    }
                                }
                            }
                            
                            // Clear selection after changing location
                            selectedItems.value = [];
                            
                            // Update location stats after changing locations
                            updateLocationStats();
                            
                            // Update recently checked off items
                            updateRecentlyCheckedOff();
                            
                            console.log('Location changed successfully for selected items');
                        } catch (err) {
                            console.error('Error changing location for items:', err);
                            error.value = 'Failed to change location for items. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function changeDateForSelected(newDate) {
                        console.log('changeDateForSelected', newDate);
                        if (selectedItems.value.length === 0) return;

                        loading.value = true;
                        try {
                            for (const itemId of selectedItems.value) {
                                const item = groceryItems.value.find(i => i.id === itemId);
                                if (item) {
                                    if (newDate === null || newDate === '') {
                                        // Clear the date
                                        item.dateChecked = null;
                                        item.date = '';
                                        item.checked = false;
                                    } else {
                                        // Set the new date
                                        item.dateChecked = new Date(newDate).getTime();
                                        item.date = new Date(newDate).toLocaleDateString();
                                        item.checked = true;
                                    }
                                    await updateItemInSheet(item);
                                }
                            }

                            updateRecentlyCheckedOff();
                            updateLocationStats();
                            //selectedItems.value = []; // Clear selections after action
                            error.value = null;
                        } catch (err) {
                            console.error('Error changing date:', err);
                            error.value = 'Failed to change date. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    function inputDateForSelected(value) {
                        if (value.target.value === '') {
                            changeDateForSelected(null);
                        }
                    }

                    const filteredGroceryItems = computed(() => {
                        return groceryItems.value
                            .filter(item => item.location === selectedLocation.value && !item.dateChecked)
                            .sort((a, b) => a.order - b.order);
                    });

                    function handlePriceInput(item, event) {
                        //console.log('handlePriceInput', item, event);
                        let inputValue = event.target.value;
                        
                        // Allow minus sign, digits, and at most one comma
                        inputValue = inputValue.replace(/[^-\d,]/g, '');
                        
                        // Ensure only one minus sign at the start
                        if (inputValue.startsWith('-')) {
                            inputValue = '-' + inputValue.substring(1).replace(/-/g, '');
                        }
                        
                        // Ensure only one comma
                        const commaIndex = inputValue.indexOf(',');
                        if (commaIndex !== -1) {
                            inputValue = inputValue.slice(0, commaIndex + 1) + inputValue.slice(commaIndex + 1).replace(',', '');
                        }
                        
                        // Limit to two decimal places if comma is present
                        /*const parts = inputValue.split(',');
                        if (parts.length > 1) {
                            parts[1] = parts[1].slice(0, 2);
                            inputValue = parts.join(',');
                        }*/
                        
                        // Update the input value without full formatting
                        event.target.value = inputValue;
                        
                        // Update the item price
                        //item.price = parsePrice(inputValue);

                        // Store the input value temporarily
                        inputValues.value[item.id] = inputValue;
                    }

                    function handleAmountFocus(item, event) {
                        if (event.target.value === '' || event.target.value === '0') {
                            event.target.value = '';
                            item.amount = null;  // or '' if you prefer
                        }
                    }

                    function handlePriceFocus(item, event) {
                        if (event.target.value === '' || event.target.value === '0' || event.target.value === '0,00') {
                            event.target.value = '';
                            inputValues.value[item.id] = '';
                        }
                    }

                    async function handlePriceBlur(item, event) {
                        //console.log('handlePriceBlur', item, event);
                        // Get the stored input value or use the current item price
                        const inputValue = inputValues.value[item.id] || formatPrice(item.price);
                        
                        // Parse and format the price
                        const newPrice = parsePrice(inputValue);
                        const formattedPrice = formatPrice(newPrice);
                        
                        // Update the item price and input value
                        item.price = newPrice;
                        event.target.value = formattedPrice;
                        
                        // Clear the temporary input value
                        delete inputValues.value[item.id];
                        
                        try {
                            await updateItemInSheet(item);
                            // Handle successful update
                            updateLocationStats();
                            updateRecentlyCheckedOff();
                        } catch (err) {
                            console.error('Failed to update item:', err);
                            error.value = 'Failed to update item. Please try again.';
                        }
                    }

                    function handleKeyPress(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            // Perform your "done" action here, e.g., blur the input
                            event.target.blur();
                        }
                    }

                    const suggestions = ref([]);
                    const currentEditingItem = ref(null);

                    function processHistoricalData() {
                        const now = Date.now();
                        const oneMonthAgo = now - 30 * 24 * 60 * 60 * 1000; // 30 days ago
                        
                        return groceryItems.value.reduce((acc, item) => {
                            // Skip items without a checked_date
                            if (!item.dateChecked) return acc;

                            if (!acc[item.title]) {
                                acc[item.title] = {
                                    id: item.id, // Add this line to store the item ID
                                    count: 0,
                                    lastPurchase: 0,
                                    score: 0,
                                    locations: {},
                                    mostRecent: null
                                };
                            }
                            
                            acc[item.title].count++;
                            
                            if (!acc[item.title].locations[item.location]) {
                                acc[item.title].locations[item.location] = {
                                    lastPurchases: []
                                };
                            }
                            
                            // Add current purchase to the location's lastPurchases
                            acc[item.title].locations[item.location].lastPurchases.push({
                                date: item.dateChecked,
                                quantity: item.amount,
                                price: item.price
                            });
                            
                            // Sort lastPurchases by date (most recent first) and keep only the last 5
                            acc[item.title].locations[item.location].lastPurchases.sort((a, b) => b.date - a.date);
                            acc[item.title].locations[item.location].lastPurchases = acc[item.title].locations[item.location].lastPurchases.slice(0, 5);
                            
                            if (item.dateChecked > acc[item.title].lastPurchase) {
                                acc[item.title].lastPurchase = item.dateChecked;
                                acc[item.title].mostRecent = {
                                    quantity: item.amount,
                                    price: item.price,
                                    location: item.location
                                };
                            }
                            
                            // Calculate score: higher for more frequent and recent purchases
                            const recencyScore = item.dateChecked > oneMonthAgo ? 2 : 1;
                            acc[item.title].score = acc[item.title].count * recencyScore;
                            
                            return acc;
                        }, {});
                    }

                    function filterSuggestions(input, itemId) {
                        if (!input) {
                            suggestions.value = [];
                            return;
                        }
                        currentEditingItem.value = itemId;
                        const currentItem = groceryItems.value.find(item => item.id === itemId);
                        const currentLocation = currentItem ? currentItem.location : null;
                        
                        console.log('Current item:', currentItem);
                        console.log('Current location:', currentLocation);

                        const historicalData = processHistoricalData();
                        console.log('Historical data:', historicalData);

                        const matches = Object.keys(historicalData)
                            .filter(title => {
                                const matchesInput = title.toLowerCase().includes(input.toLowerCase());
                                const itemData = historicalData[title];
                                const matchesLocation = itemData.locations[currentLocation] !== undefined;
                                const isNotCurrentItem = itemId !== itemData.id; // Compare by ID instead of title
                                console.log(`Title: ${title}, Matches input: ${matchesInput}, Matches location: ${matchesLocation}, Is not current item: ${isNotCurrentItem}`);
                                return matchesInput && matchesLocation && isNotCurrentItem;
                            })
                            .sort((a, b) => {
                                // Prioritize exact matches
                                if (a.toLowerCase() === input.toLowerCase()) return -1;
                                if (b.toLowerCase() === input.toLowerCase()) return 1;
                                // Then sort by score
                                return historicalData[b].score - historicalData[a].score;
                            });
                        
                        console.log('Matches:', matches);

                        if (matches.length === 1) {
                            const title = matches[0];
                            const data = historicalData[title];
                            const lastPurchases = data.locations[currentLocation].lastPurchases;
                            
                            suggestions.value = lastPurchases.map(purchase => ({
                                title,
                                lastPurchase: new Date(purchase.date).toLocaleDateString(),
                                quantity: purchase.quantity,
                                price: purchase.price,
                                location: currentLocation
                            }));
                        } else {
                            suggestions.value = matches.slice(0, 5).map(title => {
                                const data = historicalData[title];
                                const lastPurchase = data.locations[currentLocation].lastPurchases[0];
                                return {
                                    title,
                                    lastPurchase: new Date(lastPurchase.date).toLocaleDateString(),
                                    quantity: lastPurchase.quantity,
                                    price: lastPurchase.price,
                                    location: currentLocation
                                };
                            });
                        }

                        console.log('Suggestions:', suggestions.value);
                    }

                    function selectSuggestion(suggestion) {
                        const item = groceryItems.value.find(item => item.id === currentEditingItem.value);
                        if (item) {
                            console.log('Selected suggestion:', suggestion);
                            console.log('Current item before update:', { ...item });
                            
                            if (item.location !== suggestion.location) {
                                console.warn('Location mismatch:', item.location, suggestion.location);
                                // You might want to add some user feedback here
                            }

                            item.title = suggestion.title;
                            item.amount = suggestion.quantity;
                            item.price = suggestion.price;
                            
                            console.log('Current item after update:', { ...item });
                            
                            updateItemField(item, 'title', suggestion.title);
                            updateItemField(item, 'amount', suggestion.quantity);
                            updateItemField(item, 'price', suggestion.price);
                        }
                        suggestions.value = [];
                        currentEditingItem.value = null;
                    }

                    onBeforeUnmount(() => {
                        suggestions.value = [];
                        currentEditingItem.value = null;
                    });

                    function force_scroll_sideways(element) {
                        if (!element) return;
                        element.addEventListener("wheel", (event) => {
                            event.preventDefault();
                            let magnitude = event.deltaX === 0 ? (event.deltaY > 0 ? 30 : -30) : event.deltaX;
                            element.scrollBy({ left: magnitude });
                        });
                    }

                    onMounted(async () => {
                        console.log('Component mounted');
                        try {
                            console.log('Waiting for Google Auth to initialize...');
                            await GoogleAuth.initGoogleAuth();
                            console.log('Google Auth initialized');

                            console.log('Calling fetchData...');
                            await fetchData();

                            if (locations.value.length > 0) {
                                console.log('Selecting first location');
                                selectLocation(locations.value[0].id);
                            }

                            const element = document.querySelector(".location-tabs");
                            force_scroll_sideways(element);

                            await Vue.nextTick();
                            initSortable();
                        } catch (error) {
                            console.error("Error during component mount:", error);
                            // Handle the error appropriately
                        }
                    });

                    return {
                        locations,
                        groceryItems,
                        recentlyCheckedOff,
                        loading,
                        error,
                        fetchData,
                        selectedLocation,
                        selectedItems,
                        filteredGroceryItems,
                        toggleItemCheck,
                        addGroceryItem,
                        selectLocation,
                        updateItemField,
                        formatPriceForDisplay,
                        formatPrice,
                        duplicateSelectedItems,
                        deleteSelectedItems,
                        changeLocationForSelected,
                        changeDateForSelected,
                        updateLocationStats,
                        selectAll,
                        toggleSelectAll,
                        deselectAll,
                        performSelectedAction,
                        updateRecentlyCheckedOff,
                        handlePriceInput,
                        handlePriceBlur,
                        handlePriceFocus,
                        handleAmountFocus,
                        inputValues,
                        handleKeyPress,
                        groceryListRef,
                        initSortable,
                        toggleSorting,
                        sortingEnabled,
                        inputDateForSelected,
                        suggestions,
                        currentEditingItem,
                        filterSuggestions,
                        selectSuggestion
                    };
                },
                template: `
                    <div class="groceries-page page-content">
                        <div class="header">
                            <div class="header-title">
                                <span class="hamburger-menu" @click="toggleSidenav"></span>
                                <h2>Groceries <button @click="fetchData"><i class="icon material-icons" style="font-size: 14px;">refresh</i></button></h2>
                                <button @click="toggleSorting" class="sort-button">
                                    {{ sortingEnabled ? 'Disable Sorting' : 'Enable Sorting' }}
                                </button>
                                <small v-if="loading" class="loading">Loading...</small>
                                <div v-if="error" class="error">{{ error }}</div>
                            </div>
                            
                            <!-- Location tabs -->
                            <div class="location-tabs">
                                <div 
                                    v-for="location in locations" 
                                    :key="location.id" 
                                    class="location-tab"
                                    :class="{ 'active': location.id === selectedLocation }"
                                    @click="selectLocation(location.id)"
                                >
                                    {{ location.title }} ({{ location.itemCount }})
                                    <div class="location-total">{{ formatPrice(location.totalPrice) }}</div>
                                </div>
                            </div>
                        </div>
                        <div class="wrapper">
                            <!-- Grocery items to purchase -->
                            <div class="grocery-list">
                                <table v-if="filteredGroceryItems.length > 0">
                                    <thead>
                                        <tr>
                                            <th width="30"><input type="checkbox" :checked="selectedItems.length === filteredGroceryItems.length" @change="toggleSelectAll(filteredGroceryItems)"></th>
                                            <th>Item</th>
                                            <th width="60">Quantity</th>
                                            <th width="60">Price</th>
                                        </tr>
                                    </thead>
                                    <tbody ref="groceryListRef">
                                        <tr v-for="item in filteredGroceryItems" :key="item.id">
                                            <td class="select-checkbox" width="30">
                                                <input v-if="!sortingEnabled" type="checkbox" v-model="selectedItems" :value="item.id">
                                                <span v-else class="drag-handle"></span>
                                            </td>
                                            <td class="item-title">
                                                <input 
                                                    type="text" 
                                                    v-model="item.title" 
                                                    :data-item-id="item.id" 
                                                    @focus="startEditing" 
                                                    @blur="stopEditing" 
                                                    @input="filterSuggestions(item.title, item.id)"
                                                    @change="updateItemField(item, 'title', $event.target.value)"
                                                >
                                                <ul v-if="suggestions && suggestions.length > 0 && currentEditingItem === item.id" class="suggestions">
                                                    <li v-for="suggestion in suggestions" :key="suggestion.title + suggestion.lastPurchase" @mousedown.prevent="selectSuggestion(suggestion)">
                                                        {{ suggestion.title }}
                                                        <br>
                                                        Last purchase: {{ suggestion.lastPurchase }}
                                                        <br>
                                                        Quantity: {{ suggestion.quantity }}, Price: {{ formatPrice(suggestion.price) }}
                                                    </li>
                                                </ul>
                                            </td>
                                            <td class="item-amount" width="60"><input type="number" v-model.number="item.amount" :data-item-id="item.id" @focus="($event) => { handleAmountFocus(item, $event); startEditing(); }" @blur="stopEditing" @change="updateItemField(item, 'amount', $event.target.value)"></td>
                                            <td class="item-price" width="60">
                                                <input 
                                                    :value="formatPriceForDisplay(item)"
                                                    @input="handlePriceInput(item, $event)"
                                                    @focus="($event) => { handlePriceFocus(item, $event); startEditing(); }"
                                                    @blur="($event) => { handlePriceBlur(item, $event); stopEditing(); }"
                                                    @keypress="handleKeyPress"
                                                    inputmode="decimal"
                                                    enterkeyhint="done"
                                                >
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p v-else class="no-items-message"></p>
                            </div>

                            <!-- Actions for selected items -->
                            <div v-if="selectedItems.length > 0" class="selected-actions">
                                <div class="header-title">
                                    <i class="icon material-icons" @click="deselectAll">arrow_back</i>
                                    <h2>{{ selectedItems.length }} Selected</h2>
                                </div>
                                <div class="wrapper">
                                    <select style="width: 100px;" @change="changeLocationForSelected($event.target.value)">
                                        <option value="">Location</option>
                                        <option v-for="location in locations" :key="location.id" :value="location.id">
                                            {{ location.title }}
                                        </option>
                                    </select>
                                    <input type="date" @change="changeDateForSelected($event.target.value)" @input="inputDateForSelected($event)">
                                    <button @click="duplicateSelectedItems">Duplicate</button>
                                    <button class="alert" @click="deleteSelectedItems">Delete</button>
                                </div>
                            </div>

                            <!-- Recently checked off items -->
                            <div class="recently-checked-off">
                                <h3>Recently Checked Off Items</h3>
                                <div v-for="group in recentlyCheckedOff" :key="group.date" class="recently-checked-off-group">
                                <h4 @click="group.collapsed = !group.collapsed">
                                    {{ group.date }}<span style="margin-left: auto;">{{ formatPrice(group.total) }}</span>
                                </h4>
                                <table v-if="!group.collapsed">
                                    <thead>
                                    <tr>
                                        <th width="30"><input type="checkbox" :checked="selectedItems.length === group.items.length" @change="toggleSelectAll(group.items)"></th>
                                        <th>Item</th>
                                        <th width="60">Quantity</th>
                                        <th width="60">Price</th>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    <tr v-for="item in group.items" :key="item.id" :data-id="item.id">
                                        <td class="select-checkbox" width="30"><input type="checkbox" v-model="selectedItems" :value="item.id"></td>
                                        <td class="item-title"><input type="text" v-model="item.title" @focus="startEditing" @blur="stopEditing" @change="updateItemInSheet(item)"></td>
                                        <td class="item-amount" width="60"><input type="number" v-model.number="item.amount" @focus="($event) => { handleAmountFocus(item, $event); startEditing(); }" @blur="stopEditing" @change="updateItemInSheet(item)"></td>
                                        <td class="item-price" width="60">
                                            <input  
                                                    :value="formatPriceForDisplay(item)"
                                                    @input="handlePriceInput(item, $event)"
                                                    @focus="startEditing"
                                                    @blur="($event) => { handlePriceBlur(item, $event); stopEditing(); }"
                                                    @keypress="handleKeyPress"
                                                    inputmode="decimal"
                                                    enterkeyhint="done"
                                                >
                                        </td>
                                    </tr>
                                    </tbody>
                                </table>
                                </div>
                            </div>
                        </div>

                        <button @click="addGroceryItem" class="add-grocery-button">Add Grocery</button>
                        </div>
                    `
                    
            };

            const LocationsPage = {
                props: ['sheetId', 'toggleSidenav', 'setupChangeDetection', 'startEditing', 'stopEditing'],
                setup(props) {
                    const locations = ref([]);
                    const stableLocations = ref([]);
                    const globalSearch = ref('');
                    const sortColumn = ref('title');
                    const sortDirection = ref('asc');
                    const currentLocationsPage = ref(1);
                    const itemsPerPage = ref(10);
                    const columns = ['title', 'city', 'order', 'hidden'];
                    const loading = ref(false);
                    const error = ref(null);
                    const selectAll = ref(false);
                    const editingLocationId = ref(null);
                    const focusNextId = ref(null);

                    function applySort() {
                        stableLocations.value = [...stableLocations.value].sort((a, b) => {
                            if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                            if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                            return stableLocations.value.indexOf(a) - stableLocations.value.indexOf(b);
                        });
                    }

                    const paginatedLocations = computed(() => {
                        const startIndex = (currentLocationsPage.value - 1) * itemsPerPage.value;
                        return stableLocations.value.slice(startIndex, startIndex + itemsPerPage.value);
                    });

                    const totalPages = computed(() => Math.ceil(stableLocations.value.length / itemsPerPage.value));

                    const selectedLocations = computed(() => 
                        locations.value.filter(location => location.selected)
                    );

                    function sort(column) {
                        if (sortColumn.value === column) {
                            sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortColumn.value = column;
                            sortDirection.value = 'asc';
                        }
                        applyFilterAndSort();
                    }

                    function applyFilterAndSort() {
                        const filtered = locations.value.filter(location =>
                            Object.values(location).some(value =>
                            String(value).toLowerCase().includes(globalSearch.value.toLowerCase())
                            )
                        );

                        stableLocations.value = filtered.sort((a, b) => {
                            if (sortColumn.value === 'order') {
                                return sortDirection.value === 'asc' ? a.order - b.order : b.order - a.order;
                            }
                            if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                            if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                            return 0;
                        });
                    }

                    function changePage(page) {
                        stopChangeDetection();
                        
                        currentLocationsPage.value = page;
                    }

                    const debounceUpdate = _.debounce(updateLocation, 1500);

                    const debounceSearch = _.debounce(() => {
                        currentLocationsPage.value = 1;
                        applyFilterAndSort();
                    }, 300);

                    watch(globalSearch, debounceSearch);

                    async function fetchLocations() {
                        loading.value = true;
                        error.value = null;
                        try {
                            const response = await GoogleAuth.loadSheetData(props.sheetId, 'Locations!A2:F');
                            const values = response.values || [];
                            locations.value = values.map(row => ({
                                title: row[0],
                                order: parseInt(row[1]) || 0,
                                id: row[2],
                                hidden: row[3] === 'true',
                                city: row[4] || ''
                            }));
                            applyFilterAndSort();
                        } catch (err) {
                            console.error('Error fetching locations:', err);
                            error.value = 'Failed to fetch locations. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    function formatCapitalizeFirst(value) {
                        return value.charAt(0).toUpperCase() + value.slice(1);
                    }
                    function formatTextInput(value) {
                        return value.charAt(0).toUpperCase() + value.slice(1).trimEnd();
                    }

                    async function updateLocation(location) {
                        loading.value = true;
                        error.value = null;

                        if (typeof location.title === 'string') {
                            location.title = formatTextInput(location.title);
                        }
                        if (typeof location.city === 'string') {
                            location.city = formatTextInput(location.city);
                        }

                        try {
                            await GoogleAuth.updateSheetData(props.sheetId, `Locations!A${locations.value.indexOf(location) + 2}:F${locations.value.indexOf(location) + 2}`, [[location.title, location.order, location.id, location.hidden.toString(), location.city]]);
                        } catch (err) {
                            console.error('Error updating location:', err);
                            error.value = 'Failed to update location. Please try again.';
                        } finally {
                            loading.value = false;
                            if (editingLocationId.value !== location.id) {
                                applyFilterAndSort();
                            }
                        }
                    }

                    function handleLocationInput(location, field, event) {
                        editingLocationId.value = location.id;
                        if (field === 'title' || field === 'city') {
                            location[field] = formatCapitalizeFirst(event.target.value);
                        } else if (field === 'order') {
                            location[field] = event.target.value ? parseInt(event.target.value, 10) : 0;
                        } else {
                            location[field] = event.target.value;
                        }
                    }
                    function handleLocationBlur(location) {
                        updateLocation(location);
                        editingLocationId.value = null;
                    }

                    function handleKeyDown(location, field, event) {
                        if (event.key === 'Tab') {
                            console.log('Tab key pressed');
                            const currentIndex = stableLocations.value.findIndex(loc => loc.id === location.id);
                            
                            let nextField, nextLocation;
                            if (field === 'title') {
                                nextField = 'city';
                                nextLocation = location;
                            } else if (field === 'city') {
                                const nextIndex = currentIndex + 1;
                                nextLocation = stableLocations.value[nextIndex];
                                nextField = nextLocation ? 'title' : null;
                            }

                            setTimeout(function() {
                                if (nextLocation) {
                                    const nextIndex = stableLocations.value.findIndex(loc => loc.id === nextLocation.id);
                                    const newPage = Math.floor(nextIndex / itemsPerPage.value) + 1;

                                    if (newPage !== currentLocationsPage.value) {
                                        currentLocationsPage.value = newPage;
                                        focusNextId.value = `${nextLocation.id}-${nextField}`;
                                    } else {
                                        Vue.nextTick(() => {
                                            const nextInput = document.querySelector(`input[data-location-id="${nextLocation.id}"][data-field="${nextField}"]`);
                                            if (nextInput) nextInput.focus();
                                        });
                                    }
                                }
                            }, 300);
                        }
                    }

                    watch(currentLocationsPage, () => {
                        if (focusNextId.value) {
                            Vue.nextTick(() => {
                                const [locationId, field] = focusNextId.value.split('-');
                                const nextInput = document.querySelector(`input[data-location-id="${locationId}"][data-field="${field}"]`);
                                if (nextInput) nextInput.focus();
                                focusNextId.value = null;
                            });
                        }
                    });

                    async function addNewLocation() {
                        loading.value = true;
                        error.value = null;
                        const newLocation = {
                            id: `loc_${Date.now()}`,
                            title: '',
                            order: locations.value.length.toString(),
                            city: '',
                            hidden: false,
                            selected: false
                        };

                        try {
                            // Get the current number of rows in the Locations sheet
                            const response = await GoogleAuth.loadSheetData(props.sheetId, 'Locations!A:A');
                            const currentRowCount = response.values ? response.values.length : 0;

                            // Append the new location to the end of the sheet
                            await GoogleAuth.updateSheetData(props.sheetId, `Locations!A${currentRowCount + 1}:F${currentRowCount + 1}`, [[newLocation.title, newLocation.order, newLocation.id, newLocation.hidden.toString(), newLocation.city]]);

                            locations.value.push(newLocation);

                            applyFilterAndSort();

                            const newLocationIndex = stableLocations.value.findIndex(loc => loc.id === newLocation.id);
                            if (newLocationIndex !== -1) {
                                const newPage = Math.floor(newLocationIndex / itemsPerPage.value) + 1;
                                currentLocationsPage.value = newPage;
                            }

                            Vue.nextTick(() => {
                                const newLocationInput = document.querySelector(`input[data-location-id="${newLocation.id}"]`);
                                if (newLocationInput) {
                                    newLocationInput.focus();
                                }
                            });
                        } catch (err) {
                            console.error('Error adding new location:', err);
                            locations.value.pop();
                            error.value = 'Failed to add new location. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    function toggleSelectAll() {
                        locations.value.forEach(location => location.selected = selectAll.value);
                    }

                    async function deleteSelected() {
                        if (selectedLocations.value.length === 0) return;
                        if (confirm(`Are you sure you want to delete ${selectedLocations.value.length} location(s)?`)) {
                            loading.value = true;
                            error.value = null;
                            try {
                                const locationsToDelete = locations.value.filter(location => location.selected);
                                const indicesToDelete = locationsToDelete
                                    .map(location => locations.value.indexOf(location) + 2)
                                    .sort((a, b) => b - a);

                                // Remove from Google Sheet
                                for (let index of indicesToDelete) {
                                    await GoogleAuth.updateSheetData(props.sheetId, `Locations!A${index}:E${index}`, [['', '', '', '', '']]);
                                }

                                // Remove from local array
                                locations.value = locations.value.filter(location => !location.selected);
                                // Update stableLocations
                                stableLocations.value = stableLocations.value.filter(location => !location.selected);
                                selectAll.value = false;

                                console.log('Locations deleted successfully');
                                // Reapply filter and sort
                                applyFilterAndSort();
                            } catch (err) {
                                console.error('Error deleting locations:', err);
                                error.value = 'Failed to delete locations. Please try again.';
                            } finally {
                                loading.value = false;
                            }
                        }
                    }

                    function resetPagination() {
                        currentLocationsPage.value = 1;
                    }

                    let currentModifiedTime = null;
                    let changeDetectionInterval = null;

                    function setupChangeDetection(sheetId, fetchLocations) {
                        //The same function name is used for the LocationsPage.
                        console.log("Setting up change detection for sheet:", sheetId);
                        
                        async function checkForChanges() {
                            if (isEditing.value) {
                                console.log("User is editing, skipping change check");
                                return;
                            }
                            
                            console.log("Checking for changes in sheet:", sheetId);
                            try {
                                const metadata = await GoogleAuth.getSheetMetadata(sheetId);
                                console.log("Sheet title:", metadata.title);
                                console.log("Last checked time:", sheetLastChecked[sheetId]);
                                console.log("New modified time:", metadata.modifiedTime);
                                
                                const lastCheckedDate = sheetLastChecked[sheetId] ? new Date(sheetLastChecked[sheetId]) : null;
                                const newModifiedDate = new Date(metadata.modifiedTime);
                                
                                if (!lastCheckedDate || newModifiedDate > lastCheckedDate) {
                                    sheetLastChecked[sheetId] = metadata.modifiedTime;
                                    console.log('Sheet updated, refreshing data...');
                                    await fetchLocations();
                                } else {
                                    console.log('Sheet still up to date.');
                                }
                            } catch (error) {
                                console.error('Error checking for updates:', error);
                            }
                        }

                        // Clear existing interval if any
                        if (changeDetectionInterval) {
                            clearInterval(changeDetectionInterval);
                        }

                        // Set up new interval
                        changeDetectionInterval = setInterval(checkForChanges, 30000); // Check every 30 seconds

                        // Perform an initial check
                        checkForChanges();
                    }

                    function stopChangeDetection() {
                        if (changeDetectionInterval) {
                            clearInterval(changeDetectionInterval);
                            changeDetectionInterval = null;
                        }
                    }

                    function getLocationColumnClass(column) {
                        return `location-${column.toLowerCase()}`;
                    }

                    onMounted(() => {
                        fetchLocations();
                        if (props.setupChangeDetection) {
                            props.setupChangeDetection(props.sheetId, fetchLocations);
                        }
                    });

                    watch(globalSearch, debounceSearch);

                    return {
                        locations,
                        globalSearch,
                        columns,
                        sortColumn,
                        sortDirection,
                        currentLocationsPage,
                        totalPages,
                        paginatedLocations,
                        loading,
                        error,
                        sort,
                        changePage,
                        updateLocation,
                        debounceUpdate,
                        addNewLocation,
                        fetchLocations,
                        selectAll,
                        selectedLocations,
                        toggleSelectAll,
                        deleteSelected,
                        debounceSearch,
                        resetPagination,
                        setupChangeDetection,
                        stopChangeDetection,
                        getLocationColumnClass,
                        handleLocationInput,
                        handleLocationBlur,
                        handleKeyDown,
                        focusNextId,
                    };
                },
                template: `
                    <div class="locations-page page-content">
                        <div class="header">
                            <div class="header-title">
                                <span class="hamburger-menu" @click="toggleSidenav"></span>
                                <h2>Locations <button @click="fetchLocations"><i class="icon material-icons" style="font-size: 14px;">refresh</i></button> <small v-if="loading" class="loading">Loading...</small></h2>
                                <div v-if="error" class="error">{{ error }}</div>
                            </div>
                            <div class="controls">
                                <div class="input-wrapper"><input type="search" v-model="globalSearch" placeholder="Search locations..." @input="debounceSearch"></div>
                                <button class="alert" @click="deleteSelected" :disabled="selectedLocations.length === 0">Delete Selected</button>
                            </div>
                        </div>
                        <div class="locations-list responsive">
                            <table>
                                <thead>
                                    <tr>
                                        <th width="30" class="location-checkbox"><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                        <th v-for="column in columns" :key="column" @click="sort(column)" :class="getLocationColumnClass(column)">
                                            {{ column }}
                                            <span v-if="sortColumn === column">{{ sortDirection === 'asc' ? '' : '' }}</span>
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="location in paginatedLocations" :key="location.id">
                                        <td><input type="checkbox" v-model="location.selected"></td>
                                        <td v-for="column in columns" :key="column" :class="getLocationColumnClass(column)">
                                            <input v-if="column !== 'hidden'" type="text" v-model="location[column]" :data-location-id="location.id" :data-field="column" @input="handleLocationInput(location, column, $event)" @focus="startEditing" @blur="($event) => { handleLocationBlur(location, $event); stopEditing(); }" @keydown="handleKeyDown(location, column, $event)">
                                            <input v-else type="checkbox" v-model="location.hidden" @change="updateLocation(location)">
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="pagination">
                            <button @click="currentLocationsPage > 1 && currentLocationsPage--" :disabled="currentLocationsPage === 1">Previous</button>
                            <span>Page {{ currentLocationsPage }} of {{ totalPages }}</span>
                            <button @click="currentLocationsPage < totalPages && currentLocationsPage++" :disabled="currentLocationsPage === totalPages">Next</button>
                        </div>
                        <button class="add-location-button" @click="addNewLocation">Add Location</button>
                    </div>
                `
            };

            const HistoryPage = {
                props: ['sheetId', 'toggleSidenav'],
                setup(props) {
                    const historyItems = ref([]);
                    const loading = ref(false);
                    const error = ref(null);
                    const columns = ['title', 'amount', 'price', 'date', 'location'];
                    const filters = ref({ title: '', amount: '', price: '', date: '', location: '' });
                    const sortKey = ref('date');
                    const sortOrder = ref('desc');
                    const currentPage = ref(1);
                    const itemsPerPage = ref(50);

                    const sortedAndFilteredHistory = computed(() => {
                        let result = historyItems.value;

                        // Apply filters
                        columns.forEach(column => {
                            if (filters.value[column]) {
                                result = result.filter(item => 
                                    String(item[column]).toLowerCase().includes(filters.value[column].toLowerCase())
                                );
                            }
                        });

                        // Apply sorting
                        result.sort((a, b) => {
                            let modifier = sortOrder.value === 'desc' ? -1 : 1;
                            if (a[sortKey.value] < b[sortKey.value]) return -1 * modifier;
                            if (a[sortKey.value] > b[sortKey.value]) return 1 * modifier;
                            return 0;
                        });

                        return result;
                    });

                    const paginatedHistory = computed(() => {
                        const startIndex = (currentPage.value - 1) * itemsPerPage.value;
                        return sortedAndFilteredHistory.value.slice(startIndex, startIndex + itemsPerPage.value);
                    });

                    const totalPages = computed(() => Math.ceil(sortedAndFilteredHistory.value.length / itemsPerPage.value));

                    function applyFilters() {
                        currentPage.value = 1; // Reset to first page when filters change
                    }

                    function sortBy(key) {
                        if (sortKey.value === key) {
                            sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortKey.value = key;
                            sortOrder.value = 'asc';
                        }
                        currentPage.value = 1; // Reset to first page when sort changes
                    }

                    function getSortIndicator(key) {
                        if (sortKey.value === key) {
                            return sortOrder.value === 'asc' ? '' : '';
                        }
                        return '';
                    }

                    function formatPrice(price) {
                        return price.toFixed(2).replace('.', ',');
                    }

                    async function fetchData() {
                        loading.value = true;
                        error.value = null;
                        try {
                            // Fetch locations
                            const locationsResponse = await GoogleAuth.loadSheetData(props.sheetId, 'Locations!A2:C');
                            const locationsValues = locationsResponse.values || [];
                            const locations = locationsValues.reduce((acc, [title, , id]) => {
                                acc[id] = title;
                                return acc;
                            }, {});

                            // Fetch grocery items
                            const groceriesResponse = await GoogleAuth.loadSheetData(props.sheetId, 'Groceries!A2:H');
                            const values = groceriesResponse.values || [];

                            historyItems.value = values.map(row => ({
                                id: row[0],
                                title: row[1],
                                amount: parseInt(row[2]),
                                price: parseFloat(row[3].replace(',', '.')),
                                location: locations[row[5]] || row[5],
                                date: row[7] ? new Date(parseInt(row[6])).toISOString().split('T')[0] : '',
                            }));

                        } catch (err) {
                            console.error('Error fetching data:', err);
                            error.value = 'Failed to fetch data. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }

                    onMounted(fetchData);

                    return {
                        historyItems,
                        loading,
                        error,
                        filters,
                        columns,
                        paginatedHistory,
                        currentPage,
                        totalPages,
                        fetchData,
                        applyFilters,
                        sortBy,
                        getSortIndicator,
                        formatPrice
                    };
                },
                template: `
                    <div class="history-page page-content">
                        <div class="header">
                            <div class="header-title">
                                <span class="hamburger-menu" @click="toggleSidenav"></span>
                                <h2>History <button @click="fetchData"><i class="icon material-icons" style="font-size: 14px;">refresh</i></button></h2>
                                <small v-if="loading" class="loading">Loading...</small>
                                <div v-if="error" class="error">{{ error }}</div>
                            </div>
                            <div class="controls">
                                <input type="search" v-model="filters.title" placeholder="Filter Title" @input="applyFilters">
                                <input type="search" v-model="filters.location" placeholder="Filter Location" @input="applyFilters">
                                <input type="search" v-model="filters.date" placeholder="Filter Date" @input="applyFilters">
                            </div>
                        </div>
                        <div class="history-list">
                            <table>
                                <thead>
                                    <tr>
                                        <th v-for="column in columns" :key="column" @click="sortBy(column)">
                                            {{ column.charAt(0).toUpperCase() + column.slice(1) }}
                                            {{ getSortIndicator(column) }}
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="item in paginatedHistory" :key="item.id">
                                        <td>{{ item.title }}</td>
                                        <td width="60">{{ item.amount }}</td>
                                        <td width="60">{{ formatPrice(item.price) }}</td>
                                        <td width="100">{{ item.date }}</td>
                                        <td width="100">{{ item.location }}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="pagination">
                            <button @click="currentPage > 1 && currentPage--" :disabled="currentPage === 1">Previous</button>
                            <span>Page {{ currentPage }} of {{ totalPages }}</span>
                            <button @click="currentPage < totalPages && currentPage++" :disabled="currentPage === totalPages">Next</button>
                        </div>
                    </div>
                `
            };

            console.log("Starting Vue app initialization");

            function waitForScripts() {
                return new Promise((resolve, reject) => {
                    const checkInterval = 100;
                    const maxAttempts = 100;
                    let attempts = 0;

                    const interval = setInterval(() => {
                        attempts++;
                        if (typeof google !== 'undefined' && typeof google.accounts !== 'undefined') {
                            clearInterval(interval);
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            clearInterval(interval);
                            console.error("Google object:", typeof google);
                            console.error("Google accounts object:", typeof google !== 'undefined' ? typeof google.accounts : 'Google not defined');
                            reject(new Error("Scripts google.accounts failed to load."));
                        }
                    }, checkInterval);
                });
            }

            waitForScripts().then(() => {
                console.log("All required scripts loaded");

                app = createApp({
                    components: {
                        GroceriesPage,
                        LocationsPage,
                        HistoryPage,
                        DashboardPage
                    },
                    setup() {
                        console.log("Vue setup function called");

                        const CLIENT_ID = '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com';
                        const API_KEY = 'AIzaSyDjwvPH2It7i1feQRPTmQyY_yhNSG-1BmE';
                        const isSignedIn = ref(false);
                        const user = ref(null);
                        const sheetId = ref(null);
                        const tokenClient = ref(null);
                        const currentPage = ref('groceries');
                        const pickerApiLoaded = ref(false);
                        const loading = ref(false);
                        const locationPageRef = ref(null);
                        const currentPageRef = ref(null);
                        const isEditing = ref(false);
                        const sheetLastChecked = ref({});

                        const startEditing = () => {
                            isEditing.value = true;
                        };

                        const stopEditing = () => {
                            isEditing.value = false;
                        };

                        const currentPageComponent = computed(() => {
                            switch (currentPage.value) {
                                case 'groceries':
                                    return GroceriesPage;
                                case 'locations':
                                    return LocationsPage;
                                case 'history':
                                    return HistoryPage;
                                case 'dashboard':
                                    return DashboardPage;
                                default:
                                    return null;
                            }
                        });

                        async function initializeGoogleAuth() {
                            try {
                                await GoogleAuth.initGoogleAuth();
                                console.log("Google Auth initialized");
                            } catch (error) {
                                console.error("Error initializing Google Auth:", error);
                            }
                        }

                        function handleCredentialResponse(response) {
                            console.log("Handling credential response in index.html");
                            if (response.credential) {
                                try {
                                    const decodedToken = parseJwt(response.credential);
                                    if (decodedToken && decodedToken.email) {
                                        user.value = {
                                            email: decodedToken.email,
                                            name: decodedToken.name,
                                            picture: decodedToken.picture
                                        };
                                        isSignedIn.value = true;
                                        console.log("User signed in:", isSignedIn.value);
                                        localStorage.setItem('gsi_session', response.credential);
                                        
                                        const tokenClient = GoogleAuth.getTokenClient();
                                        if (tokenClient) {
                                            tokenClient.callback = async (resp) => {
                                                if (resp.error !== undefined) {
                                                    throw(resp);
                                                }
                                                await checkForStoredSheet();
                                            };
                                            tokenClient.requestAccessToken({prompt: ''});
                                        } else {
                                            console.error("Token client not properly initialized");
                                        }
                                    } else {
                                        throw new Error("Invalid token structure");
                                    }
                                } catch (error) {
                                    console.error("Error parsing JWT token:", error);
                                    isSignedIn.value = false;
                                    user.value = null;
                                    localStorage.removeItem('gsi_session');
                                    initializeGoogleSignIn();
                                }
                            } else {
                                console.error("No credential in response");
                                isSignedIn.value = false;
                                user.value = null;
                                initializeGoogleSignIn();
                            }
                        }

                        // Make sure this function is defined in the global scope
                        window.handleCredentialResponse = handleCredentialResponse;

                        function checkSavedSession() {
                            const savedSession = localStorage.getItem('gsi_session');
                            if (savedSession) {
                                handleCredentialResponse({ credential: savedSession });
                                return true;
                            }
                            return false;
                        }

                        function parseJwt(token) {
                            try {
                                const base64Url = token.split('.')[1];
                                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                                }).join(''));
                                return JSON.parse(jsonPayload);
                            } catch (error) {
                                console.error("Error parsing JWT:", error);
                                return null;
                            }
                        }

                        function initializeGoogleSignIn() {
                            google.accounts.id.initialize({
                                client_id: CLIENT_ID,
                                callback: handleCredentialResponse,
                                auto_select: true,
                                cancel_on_tap_outside: false
                            });
                            google.accounts.id.renderButton(
                                document.getElementById('googleSignInButton'), 
                                { theme: 'outline', size: 'large' }
                            );
                            google.accounts.id.prompt();
                        }

                        function checkForStoredSheet() {
                            console.log('Checking for stored sheet');
                            const storedSheetId = localStorage.getItem('lastUsedSheetId');
                            if (storedSheetId) {
                                console.log('Found stored sheet ID:', storedSheetId);
                                sheetId.value = storedSheetId;
                                if (typeof setupChangeDetection === 'function') {
                                console.log('Calling setupChangeDetection');
                                setupChangeDetection(storedSheetId);
                                } else {
                                console.error('setupChangeDetection is not a function');
                                }
                            } else {
                                console.log('No stored sheet ID found');
                                // User will need to create a new sheet or select one
                            }
                        }

                        async function createNewSheet() {
                            try {
                                sheetId.value = await GoogleAuth.createNewSheet('GroceriesApp');
                                localStorage.setItem('lastUsedSheetId', sheetId.value);
                                console.log('New sheet created:', sheetId.value);
                                await initializeNewSheet();
                            } catch (err) {
                                console.error('Error creating new sheet:', err);
                            }
                        }

                        async function initializeNewSheet() {
                            console.log("Initializing new sheet");
                            try {
                                await GoogleAuth.updateSheetData(sheetId.value, 'Groceries!A1:H1', [['id', 'title', 'amount', 'price', 'order', 'location', 'date_checked', 'date']]);
                                await GoogleAuth.updateSheetData(sheetId.value, 'Locations!A1:F1', [['title', 'order', 'id', 'hide_in_groceries', 'city']]);
                                console.log('New sheet initialized');
                            } catch (err) {
                                console.error('Error initializing new sheet:', err);
                            }
                        }

                        function signOut() {
                            console.log("Signing out");
                            GoogleAuth.signOut();
                            isSignedIn.value = false;
                            user.value = null;
                            sheetId.value = null;
                            localStorage.removeItem('gsi_session');
                            localStorage.removeItem('lastUsedSheetId');

                            google.accounts.id.renderButton(
                                document.getElementById('googleSignInButton'), 
                                { theme: 'outline', size: 'large' }
                            );
                            google.accounts.id.prompt();
                            stopChangeDetection();
                        }

                        function loadPickerApi() {
                            return new Promise((resolve, reject) => {
                                gapi.load('picker', { callback: resolve, onerror: reject });
                            });
                        }

                        function pickerCallback(data) {
                            if (data.action === google.picker.Action.PICKED) {
                                const fileId = data.docs[0].id;
                                console.log('The user selected: ' + fileId);
                                sheetId.value = fileId;
                                localStorage.setItem('lastUsedSheetId', fileId);

                                // Reset the last checked time for this sheet
                                delete sheetLastChecked[fileId];

                                // Fetch data and set up change detection for the new sheet
                                fetchCurrentPageData().then(() => {
                                    setupChangeDetection(fileId, fetchCurrentPageData);
                                });
                            }
                        }

                        async function showPicker() {
                            console.log("Showing Google Picker");
                            try {
                                await loadPickerApi();
                                const accessToken = await GoogleAuth.getAccessToken();
                                
                                const view = new google.picker.View(google.picker.ViewId.SPREADSHEETS);
                                const picker = new google.picker.PickerBuilder()
                                    .enableFeature(google.picker.Feature.NAV_HIDDEN)
                                    .setAppId(CLIENT_ID)
                                    .setOAuthToken(accessToken)
                                    .addView(view)
                                    .addView(new google.picker.DocsUploadView())
                                    .setDeveloperKey(API_KEY)
                                    .setCallback(pickerCallback)
                                    .build();
                                picker.setVisible(true);
                            } catch (error) {
                                console.error('Error showing Google Picker:', error);
                            }
                        }

                        function toggleSidenav() {
                            $('.sidenav').toggleClass('open');
                        }

                        function setupTokenCheck() {
                            setInterval(async () => {
                                if (isSignedIn.value && !(await GoogleAuth.isTokenValid())) {
                                    window.handleAuthFailure();
                                }
                            }, 60000);  // Check every minute
                        }

                        function checkForUpdates() {
                            if ('serviceWorker' in navigator) {
                                navigator.serviceWorker.getRegistration().then(function(registration) {
                                if (registration) {
                                    registration.update();
                                }
                                });
                            }
                        }

                        const fetchGroceriesData = async () => {
                            if (currentPageComponent.value === GroceriesPage) {
                                await currentPageRef.value.fetchData();
                                const locations = currentPageRef.value.locations;
                                if (locations.length > 0) {
                                    currentPageRef.value.selectedLocation = locations[0].id;
                                }
                            }
                        };

                        const fetchLocationsData = async () => {
                            if (currentPageComponent.value === LocationsPage) {
                                await currentPageRef.value.fetchLocations();
                            }
                        };

                        const fetchHistoryData = async () => {
                            if (currentPageComponent.value === HistoryPage) {
                                await currentPageRef.value.fetchData();
                            }
                        };

                        const fetchCurrentPageData = async () => {
                            console.log('Fetching current page data');
                            if (!currentPageRef.value) {
                                console.log('Current page component not yet mounted');
                                return;
                            }

                            if (currentPageComponent.value === GroceriesPage && currentPageRef.value.fetchData) {
                                console.log('Fetching Groceries data');
                                await currentPageRef.value.fetchData();
                            } else if (currentPageComponent.value === LocationsPage && currentPageRef.value.fetchLocations) {
                                console.log('Fetching Locations data');
                                await currentPageRef.value.fetchLocations();
                            } else if (currentPageComponent.value === HistoryPage && currentPageRef.value.fetchData) {
                                console.log('Fetching History data');
                                await currentPageRef.value.fetchData();
                            }
                        };

                        watch(() => sheetId.value, async (newSheetId) => {
                            if (newSheetId) {
                                // Reset the last checked time for this sheet
                                delete sheetLastChecked[newSheetId];

                                // Add a small delay to ensure the component has mounted
                                await new Promise(resolve => setTimeout(resolve, 0));
                                await fetchCurrentPageData();
                                setupChangeDetection(newSheetId, fetchCurrentPageData);
                            }
                        });

                        let googleAuth = null;

                        async function initializeApp() {
                            console.log("Initializing app");
                            await GoogleAuth.initGoogleAuth();
                            await loadPickerApi();
                            if (!checkSavedSession()) {
                                console.log("No saved session, initializing Google Sign-In");
                                initializeGoogleSignIn();
                            }
                        }

                        onMounted(() => {
                            console.log("App mounted hook called");
                            checkForUpdates();
                            initializeApp();
                        });

                        const currentModifiedTime = ref(null);
                        let changeDetectionInterval = null;

                        const setupChangeDetection = (sheetId, fetchLocations) => {
                            //The same function name is used for the app.
                            console.log("Setting up change detection for sheet:", sheetId);
                            
                            async function checkForChanges() {
                                if (isEditing.value) {
                                console.log("User is editing, skipping change check");
                                return;
                                }
                                
                                console.log("Checking for changes in sheet:", sheetId);
                                try {
                                const modifiedTime = await GoogleAuth.checkForChanges(sheetId);
                                console.log("Current modified time:", currentModifiedTime.value);
                                console.log("New modified time:", modifiedTime);
                                if (modifiedTime !== currentModifiedTime.value) {
                                    currentModifiedTime.value = modifiedTime;
                                    console.log('Sheet updated, refreshing data...');
                                    await fetchLocations();
                                } else {
                                    console.log('Sheet still up to date.');
                                }
                                } catch (error) {
                                console.error('Error checking for updates:', error);
                                if (error.message.includes('Authentication failed')) {
                                    // Handle authentication failure
                                    if (window.handleAuthFailure) {
                                    window.handleAuthFailure();
                                    }
                                }
                                // Don't throw the error here, just log it and continue
                                }
                            }

                            // Clear existing interval if any
                            if (changeDetectionInterval) {
                                clearInterval(changeDetectionInterval);
                            }

                            // Set up new interval
                            changeDetectionInterval = setInterval(checkForChanges, 30000); // Check every 30 seconds

                            // Perform an initial check
                            checkForChanges();
                        };

                        return {
                            isSignedIn,
                            user,
                            sheetId,
                            signOut,
                            isSidenavOpen: false,
                            toggleSidenav,
                            currentPage,
                            currentPageComponent,
                            createNewSheet,
                            handleCredentialResponse,
                            showPicker,
                            locationPageRef,
                            loading,
                            setupChangeDetection,
                            currentModifiedTime,
                            currentPageRef,
                            fetchCurrentPageData,
                            LocationsPage: defineComponent({
                                extends: LocationsPage,
                                props: ['sheetId'],
                                setup(props, context) {
                                    return LocationsPage.setup({
                                        ...props,
                                        setupChangeDetection
                                    }, context);
                                }
                            }),
                            sheetLastChecked,
                            isEditing,
                            startEditing,
                            stopEditing,
                            DashboardPage
                        };
                    }
                });

                let pendingCredentialResponse = null;

                window.handleCredentialResponse = function(response) {
                    if (app && app._instance) {
                        app._instance.proxy.handleCredentialResponse(response);
                    } else {
                        pendingCredentialResponse = response;
                    }
                };

                window.handleAuthFailure = function() {
                    // Reset the app state
                    isSignedIn.value = false;
                    user.value = null;
                    sheetId.value = null;
                    
                    // Redirect to sign-in page or show sign-in prompt
                    currentPage.value = 'signin';  // Assuming you have a 'signin' page
                    
                    // Show a message to the user
                    error.value = 'Your session has expired. Please sign in again.';
                };

                console.log("Mounting Vue app");
                app.mount('#app');
                console.log("Vue app mounted successfully");

                // Make the app visible after mounting
                document.getElementById('app').style.display = 'block';
            }).catch((error) => {
                console.error("Error loading scripts:", error);
            });
        })();
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                .then(registration => {
                    console.log('Service Worker registered successfully:', registration.scope);
                })
                .catch(error => {
                    console.log('Service Worker registration failed:', error);
                });
            });
        }
    </script>

    <script>
      // Function to add the allow attribute to any iframes created by Google Sign-In
      function addAllowAttributeToGoogleIframes() {
        const iframes = document.querySelectorAll('iframe[src^="https://accounts.google.com"]');
        iframes.forEach(iframe => {
          if (!iframe.getAttribute('allow')) {
            iframe.setAttribute('allow', 'identity-credentials-get');
          }
        });
      }

      // Run the function periodically
      setInterval(addAllowAttributeToGoogleIframes, 1000);
    </script>
</body>
</html>