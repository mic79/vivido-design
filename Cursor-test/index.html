<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Groceries</title>
    <script src="https://accounts.google.com/gsi/client" async defer onloadX="initializeGoogleSignIn()"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        html, body {
            height: 100%;
            min-height: 100%;
            margin: 0;
            overflow: hidden;
        }
        html {
            font-family: 'Lato', sans-serif;
        }
        .main-content {
            display: flex;
            height: 100vh;
        }
        
        .sidenav {
            position: fixed;
            width: 300px;
            top: 0;
            bottom: 0;
            left: -300px;
            padding: 20px;
            background-color: #f4f4f4;
            box-sizing: border-box;
            overflow-y: auto;
            transition: left 0.3s ease-in-out;
            z-index: 1000;
        }
        @media (min-width: 768px) {
            .sidenav {
                position: relative;
                left: 0;
            }
        }
        @media (max-width: 767.98px) {
            .sidenav.open {
                left: 0;
            }
        }

        .close-sidenav {
            display: block;
        }
        @media (min-width: 768px) {
            .close-sidenav {
                display: none;
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                font-size: 1.5rem;
                cursor: pointer;
            }
        }
        .hamburger-menu {
            display: inline-block;
            font-size: 1.5rem;
            cursor: pointer;
            margin-right: 1rem;
        }
        @media (min-width: 768px) {
            .hamburger-menu {
                display: none;
            }
        }
        .nav-menu {
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            background-color: #f0f0f0;
        }
        .nav-menu a {
            text-decoration: none;
            color: #333;
            padding: 5px 10px;
        }
        .nav-menu a.active {
            font-weight: bold;
            background-color: #ddd;
        }
        .page-content {
            width: 100%;
            overflow-y: auto;
        }
        .locations-page, .groceries-page {
            padding-bottom: 80px;
        }
        .responsive {
            max-width: 100%;
            overflow-x: auto;
        }
        h2, .h2 {
            display: inline-block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .filter-input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }
        .sticky-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .sticky-button:hover {
            background-color: #45a049;
        }
        .error {
            color: red;
            margin-bottom: 10px;
        }
        .loading {
            margin-top: 10px;
        }
        .controls {
            margin-bottom: 10px;
        }
        @media (max-width: 768px) {
            /* table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            } */
            
            tr { border: 1px solid #ccc; }
            
            td {
                border: none;
                position: relative;
                /* padding-left: 50%; */
            }
            
            /* td:before {
                position: absolute;
                top: 6px;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
            } */
        }

        .location-tabs {
            display: flex;
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .location-tab {
            cursor: pointer;
            padding: 10px;
            border: 1px solid #ccc;
            margin-right: 5px;
            white-space: nowrap;
        }

        .location-tab.active {
            background-color: #e0e0e0;
            font-weight: bold;
        }

        .location-total {
            font-size: 0.8em;
            color: #666;
        }

        .grocery-list table {
            width: 100%;
            border-collapse: collapse;
        }

        .grocery-list th, .grocery-list td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }

        .grocery-list input[type="text"],
        .grocery-list input[type="number"],
        .recently-checked-off input[type="text"],
        .recently-checked-off input[type="number"],
        .locations-list input[type="text"],
        .locations-list input[type="number"] {
            width: 100%;
            box-sizing: border-box;
        }

        .selected-actions {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .recently-checked-off h3 {
            background-color: #f0f0f0;
            padding: 10px;
            margin: 0;
        }

        .recently-checked-off h4 {
            cursor: pointer;
        }

        .recently-checked-off ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .recently-checked-off li {
            padding: 8px;
            border-bottom: 1px solid #ccc;
        }

        .add-grocery-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }

        .handle {
            cursor: move;
        }

        .sortable-ghost {
            opacity: 0.5;
            background: #c8ebfb;
        }
    </style>
</head>
<body>
    <div id="app" style="display: none;">
        <div v-if="!isSignedIn">
            <div id="googleSignInButton"></div>
        </div>
        <div v-if="isSignedIn" class="main-content">
            <div class="sidenav" :class="{ 'open': isSidenavOpen }">
                <span class="close-sidenav" @click="toggleSidenav">&times;</span>
                <p>{{ user.email }} <button @click="signOut">Sign Out</button></p>
                <nav class="nav-menu">
                    <a :class="{ active: currentPage === 'groceries' }" @click="currentPage = 'groceries'; toggleSidenav()" href="#">Groceries</a>
                    <a :class="{ active: currentPage === 'locations' }" @click="currentPage = 'locations'; toggleSidenav()" href="#">Locations</a>
                </nav>
                <p v-if="sheetId">Current Sheet ID: {{ sheetId }} (Share this ID with others to collaborate)</p>
                <div>
                    <button @click="createNewSheet">Create New Sheet</button>
                    <button @click="showPicker">Select GroceriesApp Sheet</button>
                </div>
            </div>
            <component v-if="sheetId" :is="currentPageComponent" :sheet-id="sheetId" ref="locationPageRef" :toggle-sidenav="toggleSidenav"></component>
        </div>
    </div>

    <script>
    function initializeGoogleSignIn() {
        console.log('Attempting to initialize Google Sign-In');
        if (typeof google === 'undefined' || typeof google.accounts === 'undefined') {
            console.error('Google API not loaded');
            return;
        }
        google.accounts.id.initialize({
            client_id: '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com',
            callback: handleCredentialResponse
        });
        Vue.nextTick(() => {
            const buttonElement = document.getElementById("googleSignInButton");
            if (buttonElement) {
                google.accounts.id.renderButton(
                    buttonElement,
                    { theme: "outline", size: "large" }
                );
                console.log('Button rendered');
                document.getElementById('app').style.display = 'block'; // Show the app after initialization
            } else {
                console.error('Google Sign-In button element not found');
            }
        });
    }

    (function() {
        const { createApp, ref, computed, onMounted, watch } = Vue;

        let app; // Declare app variable to be used later

        // Define handleCredentialResponse in the global scope
        window.handleCredentialResponse = function(response) {
            console.log("Received credential response:", response);
            if (app && typeof app.handleCredentialResponse === 'function') {
                app.handleCredentialResponse(response);
            } else {
                console.error('App or handleCredentialResponse not initialized');
            }
        };

        const GroceriesPage = {
            props: ['sheetId', 'toggleSidenav'],
            setup(props) {
                const locations = ref([]);
                const groceryItems = ref([]);
                const recentlyCheckedOff = ref([]);
                const loading = ref(false);
                const error = ref(null);
                const selectedLocation = ref(null);
                const selectedItems = ref([]);
                const selectAll = ref(false);

                function toggleSelectAll(items) {
                    if (selectedItems.value.length === items.length) {
                        selectedItems.value = [];
                    } else {
                        selectedItems.value = items.map(item => item.id);
                    }
                }

                async function performSelectedAction(action) {
                    if (selectedItems.value.length === 0) return;

                    switch (action) {
                        case 'delete':
                        if (confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                            // Implement delete logic
                            console.log('Deleting items:', selectedItems.value);
                        }
                        break;
                        case 'changeLocation':
                        // Implement change location logic
                        console.log('Changing location for items:', selectedItems.value);
                        break;
                        case 'changeDate':
                        const newDate = prompt("Enter new date (YYYY-MM-DD) or leave empty to remove date:");
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                            if (newDate) {
                                item.dateChecked = new Date(newDate).getTime();
                                item.date = new Date(newDate).toLocaleDateString();
                            } else {
                                item.dateChecked = null;
                                item.date = '';
                            }
                            await updateItemInSheet(item);
                            }
                        }
                        updateRecentlyCheckedOff();
                        updateLocationStats();
                        break;
                    }

                    selectedItems.value = []; // Clear selections after action
                }

                // Fetch locations and grocery items
                async function fetchData() {
                    console.log('fetchData');
                    loading.value = true;
                    error.value = null;
                    try {
                        // Fetch locations
                        const locationsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E'
                        });
                        
                        locations.value = locationsResponse.result.values
                            .filter(row => row[3] !== 'true') // Filter out hidden locations
                            .map(row => ({
                                id: row[2],
                                title: row[0],
                                order: parseInt(row[1]) || 0, // Parse the order value
                                itemCount: 0,
                                totalPrice: 0
                            }))
                            .sort((a, b) => a.order - b.order); // Sort locations by order

                        // Fetch grocery items
                        const itemsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Groceries!A2:H'
                        });

                        groceryItems.value = itemsResponse.result.values.map(row => ({
                            id: row[0],
                            title: row[1],
                            amount: parseInt(row[2]),
                            price: parseFloat(row[3].replace(',', '.')),
                            order: parseInt(row[4]),
                            location: row[5],
                            dateChecked: row[6] ? parseInt(row[6]) : null,
                            date: row[7],
                            checked: !!row[6]
                        }));

                        // Update location item counts and total prices
                        updateLocationStats();

                        // Set the first location as selected by default
                        if (locations.value.length > 0 && !selectedLocation.value) {
                            selectedLocation.value = locations.value[0].id;
                        }

                        // Process recently checked off items
                        updateRecentlyCheckedOff();

                    } catch (err) {
                        console.error('Error fetching data:', err);
                        error.value = 'Failed to fetch data. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                function updateLocationStats() {
                    console.log("Updating location stats");
                    const locationTotals = {};
                    groceryItems.value.forEach(item => {
                        if (!item.dateChecked) {  // Only consider unchecked items
                            if (!locationTotals[item.location]) {
                                locationTotals[item.location] = {
                                    itemCount: 0,
                                    totalPrice: 0
                                };
                            }
                            locationTotals[item.location].itemCount++;
                            
                            let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                            if (!isNaN(price)) {
                                locationTotals[item.location].totalPrice += price;
                            }
                        }
                    });

                    locations.value.forEach(location => {
                        const stats = locationTotals[location.id] || { itemCount: 0, totalPrice: 0 };
                        location.itemCount = stats.itemCount;
                        location.totalPrice = stats.totalPrice;
                        console.log(`Location: ${location.title}, Count: ${location.itemCount}, Total: ${location.totalPrice}`);
                    });
                }

                function updateRecentlyCheckedOff() {
                    const checkedItems = groceryItems.value.filter(item => 
                        item.dateChecked && item.location === selectedLocation.value
                    );
                    const groupedItems = _.groupBy(checkedItems, item => new Date(item.dateChecked).toLocaleDateString());
                    
                    recentlyCheckedOff.value = Object.entries(groupedItems).map(([date, items]) => ({
                        date,
                        items,
                        total: items.reduce((sum, item) => {
                            let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                            return sum + (price * (item.amount || 1));
                        }, 0),
                        collapsed: true
                    }));
                }

                async function toggleItemCheck(item) {
                    loading.value = true;
                    try {
                        const now = Date.now();
                        item.dateChecked = item.checked ? now : null;
                        item.date = item.checked ? new Date(now).toLocaleDateString() : '';

                        await updateItemInSheet(item);
                        updateLocationStats();
                        updateRecentlyCheckedOff();
                    } catch (err) {
                        console.error('Error toggling item check:', err);
                        error.value = 'Failed to update item. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function addGroceryItem() {
                    const newItem = {
                        id: `item_${Date.now()}`,
                        title: '',
                        amount: 1,
                        price: 0,
                        order: groceryItems.value.length,
                        location: selectedLocation.value,
                        dateChecked: null,
                        date: '',
                        checked: false
                    };

                    groceryItems.value.push(newItem);
                    await updateItemInSheet(newItem);
                    updateLocationStats();
                }

                async function updateItemInSheet(item) {
                    const itemIndex = groceryItems.value.findIndex(i => i.id === item.id);
                    if (itemIndex === -1) {
                        throw new Error('Item not found in local array');
                    }

                    const range = `Groceries!A${itemIndex + 2}:H${itemIndex + 2}`;
                    await gapi.client.sheets.spreadsheets.values.update({
                        spreadsheetId: props.sheetId,
                        range: range,
                        valueInputOption: 'RAW',
                        resource: {
                            values: [[
                                item.id,
                                item.title,
                                item.amount,
                                item.price, // Send the price as is, without formatting
                                item.order,
                                item.location,
                                item.dateChecked,
                                item.date
                            ]]
                        }
                    });
                }

                function selectLocation(locationId) {
                    selectedLocation.value = locationId;
                    updateRecentlyCheckedOff();
                    selectedItems.value = []; // Clear selections
                }

                function formatPrice(price) {
                    return price.toFixed(2).replace('.', ',');
                }

                function parsePrice(priceString) {
                    return parseFloat(priceString.replace(',', '.'));
                }

                async function updateItemField(item, field, value) {
                    if (field === 'price') {
                        item[field] = parsePrice(value);
                    } else if (field === 'amount') {
                        item[field] = parseInt(value);
                    } else {
                        item[field] = value;
                    }
                    await updateItemInSheet(item);
                    updateLocationStats();
                }

                async function deleteSelectedItems() {
                    if (selectedItems.value.length === 0) return;
                    if (confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                        loading.value = true;
                        error.value = null;
                        try {
                            const sheetId = await getSheetId('Groceries');
                            if (!sheetId) {
                                throw new Error('Groceries sheet ID not found');
                            }

                            const itemsToDelete = groceryItems.value.filter(item => selectedItems.value.includes(item.id));
                            const indicesToDelete = itemsToDelete
                                .map(item => groceryItems.value.indexOf(item) + 2)
                                .sort((a, b) => b - a);

                            // Remove from Google Sheet
                            await gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: props.sheetId,
                                resource: {
                                    requests: indicesToDelete.map(index => ({
                                        deleteDimension: {
                                            range: {
                                                sheetId: sheetId,
                                                dimension: 'ROWS',
                                                startIndex: index - 1,
                                                endIndex: index
                                            }
                                        }
                                    }))
                                }
                            });

                            // Remove from local array
                            groceryItems.value = groceryItems.value.filter(item => !selectedItems.value.includes(item.id));
                            selectedItems.value = [];

                            updateLocationStats();
                            console.log('Grocery items deleted successfully');
                        } catch (err) {
                            console.error('Error deleting grocery items:', err);
                            error.value = 'Failed to delete items. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }
                }

                async function getSheetId(sheetTitle) {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.get({
                            spreadsheetId: props.sheetId,
                            fields: 'sheets.properties'
                        });
                        const sheet = response.result.sheets.find(sheet => sheet.properties.title === sheetTitle);
                        return sheet ? sheet.properties.sheetId : null;
                    } catch (error) {
                        console.error('Error fetching sheet ID:', error);
                        return null;
                    }
                }

                async function changeLocationForSelected(newLocationId) {
                    if (selectedItems.value.length === 0 || !newLocationId) return;
                    
                    loading.value = true;
                    error.value = null;
                    
                    try {
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                                item.location = newLocationId;
                                await updateItemInSheet(item);
                            }
                        }
                        
                        // Clear selection after changing location
                        selectedItems.value = [];
                        
                        // Update location stats after changing locations
                        updateLocationStats();
                        
                        console.log('Location changed successfully for selected items');
                    } catch (err) {
                        console.error('Error changing location for items:', err);
                        error.value = 'Failed to change location for items. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function changeDateForSelected(newDate) {
                    console.log('changeDateForSelected', newDate);
                    loading.value = true;
                    try {
                        let timestamp;
                        if(newDate === '' || newDate === null){
                            timestamp = '';
                        } else {
                            timestamp = new Date(newDate).getTime();
                        }
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                                item.dateChecked = timestamp;
                                item.date = newDate;
                                await updateItemInSheet(item);
                            }
                        }
                        updateRecentlyCheckedOff();
                    } catch (err) {
                        console.error('Error changing date:', err);
                        error.value = 'Failed to change date. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                const filteredGroceryItems = computed(() => {
                    return groceryItems.value
                        .filter(item => item.location === selectedLocation.value && !item.dateChecked)
                        .sort((a, b) => a.order - b.order);
                });

                async function handlePriceInput(item, event) {
                    let value = event.target.value;
                    
                    // Replace dot with comma
                    value = value.replace('.', ',');
                    
                    // Remove any characters that are not digits or comma
                    value = value.replace(/[^\d,]/g, '');
                    
                    // Ensure only one comma
                    const parts = value.split(',');
                    if (parts.length > 2) {
                        value = parts[0] + ',' + parts.slice(1).join('');
                    }
                    
                    // Update the item's price
                    item.price = value;
                    
                    try {
                        // Update the item in the sheet
                        await updateItemInSheet(item);
                        console.log(`Price updated for item ${item.id}: ${item.price}`);
                        
                        // Update location stats
                        updateLocationStats();
                    } catch (err) {
                        console.error('Error updating item price:', err);
                        error.value = 'Failed to update item price. Please try again.';
                    }
                }

                onMounted(() => {
                    fetchData().then(() => {
                        if (locations.value.length > 0) {
                            selectLocation(locations.value[0].id);
                        }
                    });
                });

                return {
                    locations,
                    groceryItems,
                    recentlyCheckedOff,
                    loading,
                    error,
                    fetchData,
                    selectedLocation,
                    selectedItems,
                    filteredGroceryItems,
                    toggleItemCheck,
                    addGroceryItem,
                    selectLocation,
                    updateItemField,
                    formatPrice,
                    deleteSelectedItems,
                    changeLocationForSelected,
                    changeDateForSelected,
                    updateLocationStats,
                    handlePriceInput,
                    selectAll,
                    toggleSelectAll,
                    performSelectedAction,
                    updateRecentlyCheckedOff
                };
            },
            template: `
                <div class="groceries-page page-content">
                    <span class="hamburger-menu" @click="toggleSidenav">☰</span>
                    <h2>Groceries <button @click="fetchData">Reload Data</button> <small v-if="loading" class="loading">Loading...</small></h2>
                    <div v-if="error" class="error">{{ error }}</div>
                    <div v-if="loading" class="loading">Loading...</div>
                    
                    <!-- Location tabs -->
                    <div class="location-tabs">
                        <div 
                            v-for="location in locations" 
                            :key="location.id" 
                            class="location-tab"
                            :class="{ 'active': location.id === selectedLocation }"
                            @click="selectLocation(location.id)"
                        >
                            {{ location.title }} ({{ location.itemCount }})
                            <div class="location-total">{{ formatPrice(location.totalPrice) }}</div>
                        </div>
                    </div>

                    <!-- Grocery items to purchase -->
                    <div class="grocery-list">
                        <table>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                    <th>Item</th>
                                    <th>Quantity</th>
                                    <th>Price</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in filteredGroceryItems" :key="item.id">
                                    <td>
                                        <input type="checkbox" v-model="selectedItems" :value="item.id">
                                    </td>
                                    <td><input type="text" v-model="item.title" @change="updateItemField(item, 'title', $event.target.value)"></td>
                                    <td><input type="number" v-model.number="item.amount" @change="updateItemField(item, 'amount', $event.target.value)"></td>
                                    <td><input type="text" v-model="item.price" @input="handlePriceInput(item, $event)"></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Actions for selected items -->
                    <div v-if="selectedItems.length > 0" class="selected-actions">
                        <button @click="deleteSelectedItems">Delete Selected</button>
                        <select @change="changeLocationForSelected($event.target.value)">
                            <option value="">Change Location</option>
                            <option v-for="location in locations" :key="location.id" :value="location.id">
                                {{ location.title }}
                            </option>
                        </select>
                        <input type="date" @change="changeDateForSelected($event.target.value)">
                    </div>

                    <!-- Recently checked off items -->
                    <div class="recently-checked-off">
                        <h3>Recently Checked Off Items</h3>
                        <div v-for="group in recentlyCheckedOff" :key="group.date">
                        <h4 @click="group.collapsed = !group.collapsed">
                            {{ group.date }} - Total: {{ formatPrice(group.total) }}
                        </h4>
                        <table v-if="!group.collapsed">
                            <thead>
                            <tr>
                                <th><input type="checkbox" :checked="selectedItems.length === group.items.length" @change="toggleSelectAll(group.items)"></th>
                                <th>Item</th>
                                <th>Quantity</th>
                                <th>Price</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr v-for="item in group.items" :key="item.id">
                                <td><input type="checkbox" v-model="selectedItems" :value="item.id"></td>
                                <td><input type="text" v-model="item.title" @change="updateItemInSheet(item)"></td>
                                <td><input type="number" v-model.number="item.amount" @change="updateItemInSheet(item)"></td>
                                <td><input type="text" v-model="item.price" @input="handlePriceInput(item, $event)"></td>
                            </tr>
                            </tbody>
                        </table>
                        </div>
                    </div>

                    <button @click="addGroceryItem" class="add-grocery-button">Add Grocery</button>
                </div>
            `
        };

        const LocationsPage = {
            props: ['sheetId', 'toggleSidenav'],
            setup(props) {
                const locations = ref([]);
                const globalSearch = ref('');
                const sortColumn = ref('title');
                const sortDirection = ref('asc');
                const currentPage = ref(1);
                const itemsPerPage = ref(10);
                const columns = ['title', 'city', 'hidden'];
                const loading = ref(false);
                const error = ref(null);
                const selectAll = ref(false);

                const filteredLocations = computed(() => {
                    return locations.value.filter(location =>
                        Object.values(location).some(value =>
                            String(value).toLowerCase().includes(globalSearch.value.toLowerCase())
                        )
                    );
                });

                const sortedLocations = computed(() => {
                    return [...filteredLocations.value].sort((a, b) => {
                        if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                        if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                        return 0;
                    });
                });

                const paginatedLocations = computed(() => {
                    const startIndex = (currentPage.value - 1) * itemsPerPage.value;
                    return sortedLocations.value.slice(startIndex, startIndex + itemsPerPage.value);
                });

                const totalPages = computed(() => Math.ceil(sortedLocations.value.length / itemsPerPage.value));

                const selectedLocations = computed(() => 
                    locations.value.filter(location => location.selected)
                );

                function sort(column) {
                    if (sortColumn.value === column) {
                        sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn.value = column;
                        sortDirection.value = 'asc';
                    }
                }

                function changePage(page) {
                    stopChangeDetection();
                    
                    currentPage.value = page;
                }

                const debounceUpdate = _.debounce(updateLocation, 1500);

                const debounceSearch = _.debounce(() => {
                    currentPage.value = 1;
                }, 300);

                async function fetchLocations() {
                    console.log('fetchLocations');
                    loading.value = true;
                    error.value = null;
                    try {
                        const response = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E'
                        });
                        
                        locations.value = response.result.values.map((row, index) => ({
                            id: row[2] || `loc_${index}`,
                            title: row[0] || '',
                            order: row[1] || '',
                            city: row[4] || '',
                            hidden: row[3] === 'true',
                            selected: false // Add selected property for checkboxes
                        }));
                        resetPagination();
                    } catch (err) {
                        console.error('Error fetching locations:', err);
                        error.value = 'Failed to fetch locations. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function updateLocation(location) {
                    loading.value = true;
                    error.value = null;
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: `Locations!A${locations.value.indexOf(location) + 2}:F${locations.value.indexOf(location) + 2}`,
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[location.title, location.order, location.id, location.hidden.toString(), location.city]]
                            }
                        });
                    } catch (err) {
                        console.error('Error updating location:', err);
                        error.value = 'Failed to update location. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function addNewLocation() {
                    loading.value = true;
                    error.value = null;
                    const newLocation = {
                        id: `loc_${Date.now()}`,
                        title: 'New Location',
                        order: (locations.value.length + 1).toString(),
                        city: '',
                        hidden: false,
                        selected: false
                    };

                    locations.value.push(newLocation);

                    try {
                        await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A:F',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[newLocation.title, newLocation.order, newLocation.id, newLocation.hidden.toString(), newLocation.city]]
                            }
                        });
                    } catch (err) {
                        console.error('Error adding new location:', err);
                        locations.value.pop(); // Remove the new location if there was an error
                        error.value = 'Failed to add new location. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                function exportToCSV() {
                    const csv = [
                        columns.join(','),
                        ...locations.value.map(location => columns.map(column => location[column]).join(','))
                    ].join('\n');
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', 'locations.csv');
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                }

                async function importFromCSV(event) {
                    loading.value = true;
                    error.value = null;
                    const file = event.target.files[0];
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const csv = e.target.result;
                            const lines = csv.split('\n');
                            const headers = lines[0].split(',');
                            const newLocations = lines.slice(1).map(line => {
                                const values = line.split(',');
                                const location = {};
                                headers.forEach((header, index) => {
                                    location[header] = values[index];
                                });
                                return location;
                            });
                            locations.value = newLocations;
                            await updateAllLocations();
                        } catch (err) {
                            console.error('Error importing CSV:', err);
                            error.value = 'Failed to import CSV. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    };
                    reader.readAsText(file);
                }

                async function updateAllLocations() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E',
                            valueInputOption: 'RAW',
                            resource: {
                                values: locations.value.map(loc => [loc.title, loc.order, loc.id, loc.hidden.toString(), loc.city])
                            }
                        });
                    } catch (err) {
                        console.error('Error updating all locations:', err);
                        error.value = 'Failed to update all locations. Please try again.';
                    }
                }

                function toggleSelectAll() {
                    locations.value.forEach(location => location.selected = selectAll.value);
                }

                async function deleteSelected() {
                    if (selectedLocations.value.length === 0) return;
                    if (confirm(`Are you sure you want to delete ${selectedLocations.value.length} location(s)?`)) {
                        loading.value = true;
                        error.value = null;
                        try {
                            const sheetId = await getSheetId('Locations');
                            if (!sheetId) {
                                throw new Error('Locations sheet ID not found');
                            }

                            const locationsToDelete = locations.value.filter(location => location.selected);
                            const indicesToDelete = locationsToDelete
                                .map(location => locations.value.indexOf(location) + 2)
                                .sort((a, b) => b - a);

                            // Remove from Google Sheet
                            await gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: props.sheetId,
                                resource: {
                                    requests: indicesToDelete.map(index => ({
                                        deleteDimension: {
                                            range: {
                                                sheetId: sheetId,
                                                dimension: 'ROWS',
                                                startIndex: index - 1,
                                                endIndex: index
                                            }
                                        }
                                    }))
                                }
                            });

                            // Remove from local array
                            locations.value = locations.value.filter(location => !location.selected);
                            selectAll.value = false;

                            console.log('Locations deleted successfully');
                        } catch (err) {
                            console.error('Error deleting locations:', err);
                            error.value = 'Failed to delete locations. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }
                }

                async function getSheetId(sheetTitle) {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.get({
                            spreadsheetId: props.sheetId,
                            fields: 'sheets.properties'
                        });
                        const sheet = response.result.sheets.find(sheet => sheet.properties.title === sheetTitle);
                        return sheet ? sheet.properties.sheetId : null;
                    } catch (error) {
                        console.error('Error fetching sheet ID:', error);
                        return null;
                    }
                }

                function resetPagination() {
                    currentPage.value = 1;
                }

                let currentModifiedTime = null,
                changeDetectionInterval = null;

                function setupChangeDetection() {
                    // Stop any existing interval
                    stopChangeDetection();

                    // Initial fetch
                    fetchLocations();
                    
                    // Start polling for changes
                    changeDetectionInterval = setInterval(checkForChanges, 30000); // Check every 30 seconds
                }

                function stopChangeDetection() {
                    if (changeDetectionInterval) {
                        clearInterval(changeDetectionInterval);
                        changeDetectionInterval = null;
                    }
                }

                async function checkForChanges() {
                    try {
                        const response = await gapi.client.drive.files.get({
                            fileId: props.sheetId,
                            fields: 'modifiedTime'
                        });
                        const newModifiedTime = response.result.modifiedTime;
                        if (newModifiedTime !== currentModifiedTime) {
                            currentModifiedTime = newModifiedTime;
                            console.log('Sheet updated, refreshing data...');
                            await fetchLocations();
                        } else {
                            console.log('Sheet still up to date.');
                        }
                    } catch (error) {
                        console.error('Error checking for updates:', error);
                    }
                }

                onMounted(async () => {
                    await fetchLocations();
                    setupChangeDetection();
                });

                watch(globalSearch, debounceSearch);

                return {
                    locations,
                    globalSearch,
                    columns,
                    sortColumn,
                    sortDirection,
                    currentPage,
                    totalPages,
                    paginatedLocations,
                    loading,
                    error,
                    sort,
                    changePage,
                    updateLocation,
                    debounceUpdate,
                    addNewLocation,
                    exportToCSV,
                    importFromCSV,
                    fetchLocations,
                    selectAll,
                    selectedLocations,
                    toggleSelectAll,
                    deleteSelected,
                    debounceSearch,
                    resetPagination,
                    setupChangeDetection,
                    stopChangeDetection
                };
            },
            template: `
                <div class="locations-page page-content">
                    <span class="hamburger-menu" @click="toggleSidenav">☰</span>
                    <h2>Locations <button @click="fetchLocations">Reload data</button> <small v-if="loading" class="loading">Loading...</small></h2>
                    <div v-if="error" class="error">{{ error }}</div>
                    <div class="controls">
                        <input v-model="globalSearch" placeholder="Search locations..." @input="debounceSearch">
                        <!--<button @click="exportToCSV">Export to CSV</button>
                        <input type="file" @change="importFromCSV" accept=".csv">-->
                        <button @click="deleteSelected" :disabled="selectedLocations.length === 0">Delete Selected</button>
                    </div>
                    <div class="locations-list responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                    <th v-for="column in columns" :key="column" @click="sort(column)">
                                        {{ column }}
                                        <span v-if="sortColumn === column">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="location in paginatedLocations" :key="location.id">
                                    <td><input type="checkbox" v-model="location.selected"></td>
                                    <td v-for="column in columns" :key="column">
                                        <input v-if="column !== 'hidden'" type="text" v-model="location[column]" @input="debounceUpdate(location)">
                                        <input v-else type="checkbox" v-model="location.hidden" @change="updateLocation(location)">
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button @click="currentPage > 1 && currentPage--" :disabled="currentPage === 1">Previous</button>
                        <span>Page {{ currentPage }} of {{ totalPages }}</span>
                        <button @click="currentPage < totalPages && currentPage++" :disabled="currentPage === totalPages">Next</button>
                    </div>
                    <button class="sticky-button" @click="addNewLocation">Add New Location</button>
                </div>
            `
        };

        app = createApp({
            components: {
                GroceriesPage,
                LocationsPage
            },
            setup() {
                const isSignedIn = ref(false);
                const user = ref(null);
                const sheetId = ref(null);
                const tokenClient = ref(null);
                const currentPage = ref('groceries');
                const pickerApiLoaded = ref(false);
                const loading = ref(false);
                const locationPageRef = ref(null);

                const CLIENT_ID = '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com';
                const SCOPES = 'https://www.googleapis.com/auth/drive.file';

                const currentPageComponent = computed(() => {
                    return currentPage.value === 'groceries' ? GroceriesPage : LocationsPage;
                });

                function initializeGapiClient() {
                    gapi.client.init({
                        //apiKey: 'AIzaSyDjwvPH2It7i1feQRPTmQyY_yhNSG-1BmE',
                        //clientId: CLIENT_ID,
                        discoveryDocs: [
                            'https://sheets.googleapis.com/$discovery/rest?version=v4',
                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                        ],
                        scope: SCOPES
                    }).then(() => {
                        tokenClient.value = google.accounts.oauth2.initTokenClient({
                            client_id: CLIENT_ID,
                            scope: SCOPES,
                            callback: handleTokenResponse,
                            error_callback: (err) => {
                                console.error("Error during token client initialization:", err);
                            }
                        });
                    }).catch((error) => {
                        console.error("Error initializing gapi client:", error);
                    });
                }

                function handleCredentialResponse(response) {
                    console.log("Handling credential response in Vue app");
                    user.value = parseJwt(response.credential);
                    isSignedIn.value = true;
                    console.log("Signed in as: " + user.value.name);
                    if (tokenClient.value) {
                        tokenClient.value.requestAccessToken({prompt: 'consent'});
                    } else {
                        console.error('Token client not initialized');
                    }
                    checkForStoredSheet();
                }

                function handleTokenResponse(tokenResponse) {
                    if (tokenResponse && tokenResponse.access_token) {
                        gapi.client.setToken(tokenResponse);
                        checkForStoredSheet();
                    } else if (tokenResponse.error) {
                        console.error("Error during token response:", tokenResponse.error);
                    }
                }

                function parseJwt(token) {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    return JSON.parse(jsonPayload);
                }

                function checkForStoredSheet() {
                    const storedSheetId = localStorage.getItem('lastUsedSheetId');
                    if (storedSheetId) {
                        sheetId.value = storedSheetId;
                        setupChangeDetection();
                        // Proceed with loading data from the sheet
                    } else {
                        // User will need to create a new sheet or select one
                    }
                }

                async function createNewSheet() {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.create({
                            properties: {
                                title: 'GroceriesApp'
                            },
                            sheets: [
                                {
                                    properties: {
                                        title: 'Groceries'
                                    }
                                },
                                {
                                    properties: {
                                        title: 'Locations'
                                    }
                                }
                            ]
                        });
                        sheetId.value = response.result.spreadsheetId;
                        localStorage.setItem('lastUsedSheetId', sheetId.value);
                        console.log('New sheet created:', sheetId.value);
                        await initializeNewSheet();
                    } catch (err) {
                        console.error('Error creating new sheet:', err);
                    }
                }

                async function initializeNewSheet() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Groceries!A1:H1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['id', 'title', 'amount', 'price', 'order', 'location', 'date_checked', 'date']]
                            }
                        });
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Locations!A1:F1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['title', 'order', 'id', 'hide_in_groceries', 'city']]
                            }
                        });
                        console.log('New sheet initialized');
                    } catch (err) {
                        console.error('Error initializing new sheet:', err);
                    }
                }

                function signOut() {
                    const token = gapi.client.getToken();
                    if (token !== null) {
                        google.accounts.oauth2.revoke(token.access_token);
                        gapi.client.setToken('');
                    }
                    isSignedIn.value = false;
                    user.value = null;
                    sheetId.value = null;
                    localStorage.removeItem('lastUsedSheetId');
                    stopChangeDetection();
                }

                function loadPickerApi() {
                    gapi.load('picker', { callback: onPickerApiLoad });
                }

                function onPickerApiLoad() {
                    pickerApiLoaded.value = true;
                }

                async function showPicker() {
                    if (!pickerApiLoaded.value) {
                        await new Promise((resolve) => {
                            loadPickerApi();
                            const checkLoaded = setInterval(() => {
                                if (pickerApiLoaded.value) {
                                    clearInterval(checkLoaded);
                                    resolve();
                                }
                            }, 100);
                        });
                    }

                    const token = gapi.client.getToken();
                    if (!token) {
                        console.error('No access token available');
                        return;
                    }

                    const view = new google.picker.DocsView(google.picker.ViewId.SPREADSHEETS)
                        .setIncludeFolders(true)
                        .setMimeTypes("application/vnd.google-apps.spreadsheet")
                        .setQuery("GroceriesApp");

                    const picker = new google.picker.PickerBuilder()
                        .enableFeature(google.picker.Feature.NAV_HIDDEN)
                        .setAppId('778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com') // Replace with your actual App ID
                        .setOAuthToken(token.access_token)
                        .addView(view)
                        .setCallback(pickerCallback)
                        .build();

                    picker.setVisible(true);
                }

                async function pickerCallback(data) {
                    if (data.action === google.picker.Action.PICKED) {
                        const fileId = data.docs[0].id;
                        console.log('The user selected: ' + fileId);
                        
                        sheetId.value = fileId;
                        localStorage.setItem('lastUsedSheetId', fileId);
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        if (currentPageComponent.value === LocationsPage && locationPageRef.value) {
                            try {
                                await locationPageRef.value.fetchLocations();
                                setupChangeDetection();
                            } catch (error) {
                                console.error('Error fetching locations:', error);
                            }
                        }
                    }
                }

                function toggleSidenav() {
                    console.log('toggleSidenav');
                    //this.isSidenavOpen = !this.isSidenavOpen;
                    $('.sidenav').toggleClass('open');
                }

                // Load and init the gapi client
                gapi.load('client', initializeGapiClient);

                return {
                    isSignedIn,
                    user,
                    sheetId,
                    signOut,
                    isSidenavOpen: false,
                    toggleSidenav,
                    currentPage,
                    currentPageComponent,
                    createNewSheet,
                    handleCredentialResponse,
                    showPicker,
                    locationPageRef,
                    loading,
                    pickerCallback
                };
            }
        });

        // Instead of accessing app._instance.exposed, we'll set the method directly on the app
        app.handleCredentialResponse = function(response) {
            // This will call the handleCredentialResponse function inside the component
            app._instance.proxy.handleCredentialResponse(response);
        };

        // Mount your app after ensuring Google APIs are loaded
        gapi.load('client', function() {
            gapi.client.init({
                discoveryDocs: [
                    'https://sheets.googleapis.com/$discovery/rest?version=v4',
                    'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                ],
            }).then(() => {
                app.mount('#app');
                initializeGoogleSignIn();
            });
        });
    })();
    </script>
</body>
</html>