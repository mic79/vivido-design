<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Groceries</title>
    <script src="https://accounts.google.com/gsi/client" async defer onloadX="initializeGoogleSignIn()"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        * {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        :focus {
            outline: 0;
        }
        html, body {
            height: 100%;
            min-height: 100%;
            margin: 0;
            overflow: hidden;
        }
        html {
            font-family: 'Lato', sans-serif;
        }
        .main-content {
            display: flex;
            height: 100vh;
        }
        
        .sidenav {
            position: fixed;
            width: 300px;
            top: 0;
            bottom: 0;
            left: -300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background-color: #f4f4f4;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
            box-sizing: border-box;
            overflow-y: auto;
            transition: left 0.3s ease-in-out;
            z-index: 1000;
        }
        @media (min-width: 768px) {
            .sidenav {
                position: relative;
                left: 0;
            }
        }
        @media (max-width: 767.98px) {
            .sidenav.open {
                left: 0;
            }
        }

        .close-sidenav {
            display: block;
            color: #729c9c;
            font-size: 30px;
        }
        @media (min-width: 768px) {
            .close-sidenav {
                display: none;
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                font-size: 1.5rem;
                cursor: pointer;
            }
        }
        .user-info {
            margin-bottom: 51px;
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        .user-info button {
            margin-left: auto;
        }
        .sheet-info {
            font-size: 12px;
        }
        .hamburger-menu {
            margin-right: 1rem;
            display: inline-block;
            color: #729c9c;
            font-size: 1.5rem;
            line-height: 1;
            cursor: pointer;
        }
        @media (min-width: 768px) {
            .hamburger-menu {
                display: none;
            }
        }
        .nav-menu {
            padding: 10px 0;
            display: flex;
            flex-direction: column;
            flex: 1;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
        }
        .nav-menu a {
            text-decoration: none;
            color: #333;
            padding: 10px 0;
        }
        .nav-menu a.active {
            font-weight: bold;
        }
        .page-content {
            width: 100%;
            overflow-y: auto;
        }
        .locations-page, .groceries-page {
            padding-bottom: 100px;
        }
        @media (max-width: 767.98px) {
            .locations-page, .groceries-page {
                padding-bottom: 160px;
            }
        }
        .groceries-page:after, .locations-page:after {
            content: '';
            position: absolute;
            height: 100px;
            width: 100%;
            bottom: 0;
            background: linear-gradient(0deg, white 50%, transparent);
            pointer-events: none;
            z-index: 2;
        }
        .header {
            position: sticky;
            height: 112px;
            top: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            background-color: #f7f7f8;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .header-title {
            padding: 0 1rem;
            display: flex;
            align-items: center;
        }
        .responsive {
            max-width: 100%;
            overflow-x: auto;
        }
        h2, .h2 {
            display: flex;
            align-items: center;
            font-size: 20px;
            font-weight: 500;
            line-height: 1;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        @media (max-width: 768px) {
            tr {
                border: 1px solid #ccc;
            }
        }
        th, td {
            border-bottom: 1px solid #f2f2f2;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            color: rgba(0, 0, 0, .54);
            font-size: 14px;
            font-weight: 400;
        }
        td {
            color: #212121;
            font-size: 16px;
        }
        @media (max-width: 768px) {
            td {
                border: none;
                position: relative;
                /* padding-left: 50%; */
            }
        }
        td input {
            height: 30px;
            padding: 0;
            border: 0 !important;
            outline: none;
            font-size: inherit;
        }
        input[type="checkbox"] {
            height: 20px;
            width: 20px;
            accent-color: #729c9c;
        }
        button {
            height: 24px;
            margin: 2px 4px;
            padding: 4px 12px;
            background: transparent;
            border: 2px solid #729c9c;
            border-radius: 12px;
            color: #729c9c;
            font-size: 12px;
            font-weight: 400;
            line-height: 1;
            cursor: pointer;
        }
        button:hover {
            background: #729c9c;
            color: #fff;
        }
        button:disabled {
            visibility: hidden;
        }
        .item-amount input {
            color: rgba(33,33,33,0.4);
        }
        .item-amount input, .item-price input {
            width: inherit;
            text-align: right;
        }
        .item-price {
            padding-right: 16px;
        }
        .filter-input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }
        .error {
            margin: 0 8px;
            flex: 1;
            color: indianred;
            font-size: 12px;
            line-height: 1;
        }
        .loading {
            font-size: 12px;
        }
        .controls {
            margin-top: 10px;
            padding: 0 1rem;
        }
        .controls input[type="text"] {
            height: 30px;
            width: 100%;
            max-width: 200px;
            padding: 0;
            border: 0;
            outline: none;
            color: #212121;
            font-size: 14px;
            border-bottom: 1px solid rgba(0, 0, 0, .12);
        }

        .location-tabs {
            padding: 0 1rem;
            display: flex;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .location-tab {
            cursor: pointer;
            padding: 8px 10px;
            border-bottom: 2px solid transparent;
            margin-right: 5px;
            color: rgba(0, 0, 0, .54);
            font-size: 14px;
            font-weight: 400;
            text-align: center;
            white-space: nowrap;
        }

        .location-tab.active {
            border-bottom: 2px solid #4f4f4f;
        }

        .location-total {
            font-weight: 600;
        }

        .location-order, .location-hidden {
            width: 30px;
        }
        td.location-order input {
            text-align: right;
        }

        .grocery-list table {
            width: 100%;
            border-collapse: collapse;
        }

        .grocery-list input[type="text"],
        .grocery-list input[type="number"],
        .recently-checked-off input[type="text"],
        .recently-checked-off input[type="number"],
        .locations-list input[type="text"],
        .locations-list input[type="number"] {
            width: 100%;
            box-sizing: border-box;
        }

        .selected-actions {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .recently-checked-off h3 {
            margin: 0;
            padding: 10px 1rem;
            background-color: #e9e9e9;
            color: #4f4f4f;
            font-size: 16px;
            font-weight: 400;
        }

        .recently-checked-off h4 {
            position: sticky;
            top: 112px;
            margin: 0;
            padding: 1rem;
            display: flex;
            background: #f2f2f2;
            color: rgba(0, 0, 0, .54);
            font-size: 14px;
            font-weight: 400;
            cursor: pointer;
            z-index: 2;
        }

        .recently-checked-off ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .recently-checked-off li {
            padding: 8px;
            border-bottom: 1px solid #ccc;
        }

        .add-grocery-button,
        .add-location-button {
            position: fixed;
            height: 48px;
            width: 100%;
            max-width: 400px;
            bottom: 20px;
            left: 50%;
            padding: 0 8px;
            background-color: white;
            border-radius: 48px;
            font-size: 14px;
            letter-spacing: .05em;
            text-transform: uppercase;
            transform: translateX(-50%);
            cursor: pointer;
            z-index: 99;
        }

        .handle {
            cursor: move;
        }

        .sortable-ghost {
            opacity: 0.5;
            background: #c8ebfb;
        }
        .pagination {
            margin: 10px;
        }
        .pagination button:disabled {
            opacity: 0.35;
            pointer-events: none;
            visibility: visible;
        }
    </style>
</head>
<body>
    <div id="app" style="display: none;">
        <div v-if="!isSignedIn">
            <div id="googleSignInButton"></div>
        </div>
        <div v-if="isSignedIn" class="main-content">
            <div class="sidenav" :class="{ 'open': isSidenavOpen }">
                <span class="close-sidenav" @click="toggleSidenav">&times;</span>
                <p class="user-info">{{ user.email }} <button @click="signOut">Sign Out</button></p>
                <nav class="nav-menu">
                    <a :class="{ active: currentPage === 'groceries' }" @click="currentPage = 'groceries'; toggleSidenav()" href="#">Groceries</a>
                    <a :class="{ active: currentPage === 'locations' }" @click="currentPage = 'locations'; toggleSidenav()" href="#">Locations</a>
                    <a :class="{ active: currentPage === 'history' }" @click="currentPage = 'history'; toggleSidenav()" href="#">History</a>
                </nav>
                <div class="sheet-info">
                    <p v-if="sheetId"><strong>Current Sheet ID</strong><br>{{ sheetId }}</p>
                    <div>
                        <button @click="createNewSheet">New Sheet</button>
                        <button @click="showPicker">Load Sheet</button>
                    </div>
                </div>
            </div>
            <component v-if="sheetId" :is="currentPageComponent" :sheet-id="sheetId" ref="locationPageRef" :toggle-sidenav="toggleSidenav"></component>
        </div>
    </div>

    <script>
    // Add this before your Vue app definition
    window.setupChangeDetection = function(sheetId) {
      console.log('Setting up change detection for sheet:', sheetId);
      if (window.changeDetectionInterval) {
        clearInterval(window.changeDetectionInterval);
      }

      async function checkForChanges() {
        try {
          const response = await gapi.client.drive.files.get({
            fileId: sheetId,
            fields: 'modifiedTime'
          });
          const newModifiedTime = response.result.modifiedTime;
          if (newModifiedTime !== window.currentModifiedTime) {
            window.currentModifiedTime = newModifiedTime;
            console.log('Sheet updated, refreshing data...');
            // Call your data refresh function here, e.g.:
            // if (window.app) window.app.config.globalProperties.$refreshData();
          }
        } catch (error) {
          console.error('Error checking for updates:', error);
        }
      }

      window.changeDetectionInterval = setInterval(checkForChanges, 30000); // Check every 30 seconds
    };

    function initializeGoogleSignIn() {
        console.log('Attempting to initialize Google Sign-In');
        if (typeof google === 'undefined' || typeof google.accounts === 'undefined') {
            console.error('Google API not loaded');
            return;
        }
        google.accounts.id.initialize({
            client_id: '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com',
            callback: handleCredentialResponse
        });
        Vue.nextTick(() => {
            const buttonElement = document.getElementById("googleSignInButton");
            if (buttonElement) {
                google.accounts.id.renderButton(
                    buttonElement,
                    { theme: "outline", size: "large" }
                );
                console.log('Button rendered');
                document.getElementById('app').style.display = 'block'; // Show the app after initialization
            } else {
                console.error('Google Sign-In button element not found');
            }
        });
    }

    (function() {
        const { createApp, ref, computed, onMounted, watch } = Vue;

        let app; // Declare app variable to be used later

        // Define handleCredentialResponse in the global scope
        window.handleCredentialResponse = function(response) {
            console.log("Received credential response:", response);
            if (app && typeof app.handleCredentialResponse === 'function') {
                app.handleCredentialResponse(response);
            } else {
                console.error('App or handleCredentialResponse not initialized');
            }
        };

        const GroceriesPage = {
            props: ['sheetId', 'toggleSidenav'],
            setup(props) {
                const locations = ref([]);
                const groceryItems = ref([]);
                const recentlyCheckedOff = ref([]);
                const loading = ref(false);
                const error = ref(null);
                const selectedLocation = ref(null);
                const selectedItems = ref([]);
                const selectAll = ref(false);
                const inputValues = ref({});

                function toggleSelectAll(items) {
                    if (selectedItems.value.length === items.length) {
                        selectedItems.value = [];
                    } else {
                        selectedItems.value = items.map(item => item.id);
                    }
                }

                async function performSelectedAction(action) {
                    if (selectedItems.value.length === 0) return;

                    switch (action) {
                        case 'delete':
                        if (confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                            // Implement delete logic
                            console.log('Deleting items:', selectedItems.value);
                        }
                        break;
                        case 'changeLocation':
                        // Implement change location logic
                        console.log('Changing location for items:', selectedItems.value);
                        break;
                        case 'changeDate':
                        const newDate = prompt("Enter new date (YYYY-MM-DD) or leave empty to remove date:");
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                            if (newDate) {
                                item.dateChecked = new Date(newDate).getTime();
                                item.date = new Date(newDate).toLocaleDateString();
                            } else {
                                item.dateChecked = null;
                                item.date = '';
                            }
                            await updateItemInSheet(item);
                            }
                        }
                        updateRecentlyCheckedOff();
                        updateLocationStats();
                        break;
                    }

                    selectedItems.value = []; // Clear selections after action
                }

                // Fetch locations and grocery items
                async function fetchData() {
                    //console.log('fetchData');
                    loading.value = true;
                    error.value = null;
                    try {
                        // Fetch locations
                        const locationsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E'
                        });
                        
                        locations.value = locationsResponse.result.values
                            .filter(row => row[3] !== 'true') // Filter out hidden locations
                            .map(row => ({
                                id: row[2],
                                title: row[0],
                                order: parseInt(row[1]) || 0, // Parse the order value
                                itemCount: 0,
                                totalPrice: 0
                            }))
                            .sort((a, b) => a.order - b.order); // Sort locations by order

                        // Fetch grocery items
                        const itemsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Groceries!A2:H'
                        });

                        groceryItems.value = itemsResponse.result.values.map(row => ({
                            id: row[0],
                            title: row[1],
                            amount: parseInt(row[2]),
                            price: parseFloat(row[3].replace(',', '.')),
                            order: parseInt(row[4]),
                            location: row[5],
                            dateChecked: row[6] ? parseInt(row[6]) : null,
                            date: row[7],
                            checked: !!row[6]
                        }));

                        // Update location item counts and total prices
                        updateLocationStats();

                        // Set the first location as selected by default
                        if (locations.value.length > 0 && !selectedLocation.value) {
                            selectedLocation.value = locations.value[0].id;
                        }

                        // Process recently checked off items
                        updateRecentlyCheckedOff();

                    } catch (err) {
                        console.error('Error fetching data:', err);
                        error.value = 'Failed to fetch data. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                function updateLocationStats() {
                    //console.log("Updating location stats");
                    const locationTotals = {};
                    groceryItems.value.forEach(item => {
                        if (!item.dateChecked) {  // Only consider unchecked items
                            if (!locationTotals[item.location]) {
                                locationTotals[item.location] = {
                                    itemCount: 0,
                                    totalPrice: 0
                                };
                            }
                            locationTotals[item.location].itemCount++;
                            
                            let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                            if (!isNaN(price)) {
                                locationTotals[item.location].totalPrice += price;
                            }
                        }
                    });

                    locations.value.forEach(location => {
                        const stats = locationTotals[location.id] || { itemCount: 0, totalPrice: 0 };
                        location.itemCount = stats.itemCount;
                        location.totalPrice = stats.totalPrice;
                        //console.log(`Location: ${location.title}, Count: ${location.itemCount}, Total: ${location.totalPrice}`);
                    });
                }

                function updateRecentlyCheckedOff() {
                    const checkedItems = groceryItems.value.filter(item => 
                        item.dateChecked && item.location === selectedLocation.value
                    );
                    const groupedItems = _.groupBy(checkedItems, item => new Date(item.dateChecked).toLocaleDateString());
                    
                    // Create a map of existing groups with their collapsed state
                    const existingGroupsMap = new Map(
                        recentlyCheckedOff.value.map(group => [group.date, group.collapsed])
                    );

                    recentlyCheckedOff.value = Object.entries(groupedItems).map(([date, items]) => ({
                        date,
                        items,
                        total: items.reduce((sum, item) => {
                            let price = typeof item.price === 'string' ? parseFloat(item.price.replace(',', '.')) : item.price;
                            return sum + (price);
                        }, 0),
                        collapsed: existingGroupsMap.has(date) ? existingGroupsMap.get(date) : true // Preserve collapsed state or default to true
                    }));
                }

                async function toggleItemCheck(item) {
                    loading.value = true;
                    try {
                        const now = Date.now();
                        item.dateChecked = item.checked ? now : null;
                        item.date = item.checked ? new Date(now).toLocaleDateString() : '';

                        await updateItemInSheet(item);
                        updateLocationStats();
                        updateRecentlyCheckedOff();
                    } catch (err) {
                        console.error('Error toggling item check:', err);
                        error.value = 'Failed to update item. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function addGroceryItem() {
                    const newItem = {
                        id: `item_${Date.now()}`,
                        title: '',
                        amount: 0,
                        price: 0,
                        order: groceryItems.value.length,
                        location: selectedLocation.value,
                        dateChecked: null,
                        date: '',
                        checked: false
                    };

                    groceryItems.value.push(newItem);
                    await updateItemInSheet(newItem);
                    updateLocationStats();

                    // Use nextTick to ensure the DOM has updated before trying to focus
                    Vue.nextTick(() => {
                        const newItemInput = document.querySelector(`input[data-item-id="${newItem.id}"]`);
                        if (newItemInput) {
                            newItemInput.focus();
                        }
                    });
                }

                async function updateItemInSheet(item) {
                    //console.log('updateItemInSheet', item);
                    const itemIndex = groceryItems.value.findIndex(i => i.id === item.id);
                    if (itemIndex === -1) {
                        throw new Error('Item not found in local array');
                    }

                    const formattedPrice = formatPrice(item.price);

                    const range = `Groceries!A${itemIndex + 2}:H${itemIndex + 2}`;
                    await gapi.client.sheets.spreadsheets.values.update({
                        spreadsheetId: props.sheetId,
                        range: range,
                        valueInputOption: 'RAW',
                        resource: {
                            values: [[
                                item.id,
                                item.title,
                                item.amount,
                                formattedPrice, // Use the formatted price here
                                item.order,
                                item.location,
                                item.dateChecked,
                                item.date
                            ]]
                        }
                    });
                }

                function selectLocation(locationId) {
                    selectedLocation.value = locationId;
                    updateRecentlyCheckedOff();
                    selectedItems.value = []; // Clear selections
                }

                function parsePrice(value) {
                    if (typeof value === 'number') return value;
                    if (!value) return 0;
                    
                    // Remove any non-digit, non-comma, non-minus characters
                    value = value.replace(/[^\d,-]/g, '');
                    
                    // Replace comma with dot for parsing
                    value = value.replace(',', '.');
                    
                    // Parse the value, ensuring it's a number with two decimal places
                    return parseFloat(parseFloat(value).toFixed(2));
                }

                function formatPrice(price) {
                    if (price === null || price === undefined || isNaN(price)) return '0,00';
                    
                    // Convert to string, replace dot with comma, and ensure two decimal places
                    let formattedPrice = Math.abs(price).toFixed(2).replace('.', ',');
                    
                    // Add minus sign if negative
                    if (price < 0) formattedPrice = '-' + formattedPrice;
                    
                    return formattedPrice;
                }

                function formatPriceForDisplay(item) {
                    const storedInput = inputValues.value[item.id];
                    if (storedInput !== undefined) {
                        return storedInput;
                    }
                    return formatPrice(item.price);
                }

                async function handlePriceBlur(item, event) {
                    // Get the stored input value or use the current item price
                    const inputValue = inputValues.value[item.id] || formatPrice(item.price);
                    
                    // Parse and format the price
                    const newPrice = parsePrice(inputValue);
                    const formattedPrice = formatPrice(newPrice);
                    
                    // Update the item price and input value
                    item.price = newPrice;
                    event.target.value = formattedPrice;
                    
                    // Clear the temporary input value
                    delete inputValues.value[item.id];
                    
                    await updateItemInSheet(item);
                    updateLocationStats();
                    updateRecentlyCheckedOff();
                }

                async function updateItemField(item, field, value) {
                    if (typeof value === 'string') {
                        // For text inputs: capitalize first letter and remove trailing spaces
                        value = value.charAt(0).toUpperCase() + value.slice(1).trimEnd();
                    }

                    if (field === 'price') {
                        value = parsePrice(value);
                    } else if (field === 'amount') {
                        value = parseInt(value) || null;  // Convert to integer or null if invalid
                    }

                    item[field] = value;
                    await updateItemInSheet(item);
                    updateLocationStats();
                }

                async function deleteSelectedItems() {
                    if (selectedItems.value.length === 0) return;
                    if (confirm(`Are you sure you want to delete ${selectedItems.value.length} item(s)?`)) {
                        loading.value = true;
                        error.value = null;
                        try {
                            const sheetId = await getSheetId('Groceries');
                            if (!sheetId) {
                                throw new Error('Groceries sheet ID not found');
                            }

                            const itemsToDelete = groceryItems.value.filter(item => selectedItems.value.includes(item.id));
                            const indicesToDelete = itemsToDelete
                                .map(item => groceryItems.value.indexOf(item) + 2)
                                .sort((a, b) => b - a);

                            // Remove from Google Sheet
                            await gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: props.sheetId,
                                resource: {
                                    requests: indicesToDelete.map(index => ({
                                        deleteDimension: {
                                            range: {
                                                sheetId: sheetId,
                                                dimension: 'ROWS',
                                                startIndex: index - 1,
                                                endIndex: index
                                            }
                                        }
                                    }))
                                }
                            });

                            // Remove from local array
                            groceryItems.value = groceryItems.value.filter(item => !selectedItems.value.includes(item.id));
                            selectedItems.value = [];

                            updateLocationStats();
                            console.log('Grocery items deleted successfully');
                        } catch (err) {
                            console.error('Error deleting grocery items:', err);
                            error.value = 'Failed to delete items. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }
                }

                async function getSheetId(sheetTitle) {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.get({
                            spreadsheetId: props.sheetId,
                            fields: 'sheets.properties'
                        });
                        const sheet = response.result.sheets.find(sheet => sheet.properties.title === sheetTitle);
                        return sheet ? sheet.properties.sheetId : null;
                    } catch (error) {
                        console.error('Error fetching sheet ID:', error);
                        return null;
                    }
                }

                async function changeLocationForSelected(newLocationId) {
                    if (selectedItems.value.length === 0 || !newLocationId) return;
                    
                    loading.value = true;
                    error.value = null;
                    
                    try {
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                                item.location = newLocationId;
                                await updateItemInSheet(item);
                            }
                        }
                        
                        // Clear selection after changing location
                        selectedItems.value = [];
                        
                        // Update location stats after changing locations
                        updateLocationStats();
                        
                        console.log('Location changed successfully for selected items');
                    } catch (err) {
                        console.error('Error changing location for items:', err);
                        error.value = 'Failed to change location for items. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function changeDateForSelected(newDate) {
                    console.log('changeDateForSelected', newDate);
                    loading.value = true;
                    try {
                        let timestamp;
                        if(newDate === '' || newDate === null){
                            timestamp = '';
                        } else {
                            timestamp = new Date(newDate).getTime();
                        }
                        for (const itemId of selectedItems.value) {
                            const item = groceryItems.value.find(i => i.id === itemId);
                            if (item) {
                                item.dateChecked = timestamp;
                                item.date = newDate;
                                await updateItemInSheet(item);
                            }
                        }
                        updateRecentlyCheckedOff();
                    } catch (err) {
                        console.error('Error changing date:', err);
                        error.value = 'Failed to change date. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                const filteredGroceryItems = computed(() => {
                    return groceryItems.value
                        .filter(item => item.location === selectedLocation.value && !item.dateChecked)
                        .sort((a, b) => a.order - b.order);
                });

                function handlePriceInput(item, event) {
                    //console.log('handlePriceInput', item, event);
                    let inputValue = event.target.value;
                    
                    // Allow minus sign, digits, and at most one comma
                    inputValue = inputValue.replace(/[^-\d,]/g, '');
                    
                    // Ensure only one minus sign at the start
                    if (inputValue.startsWith('-')) {
                        inputValue = '-' + inputValue.substring(1).replace(/-/g, '');
                    }
                    
                    // Ensure only one comma
                    const commaIndex = inputValue.indexOf(',');
                    if (commaIndex !== -1) {
                        inputValue = inputValue.slice(0, commaIndex + 1) + inputValue.slice(commaIndex + 1).replace(',', '');
                    }
                    
                    // Limit to two decimal places if comma is present
                    /*const parts = inputValue.split(',');
                    if (parts.length > 1) {
                        parts[1] = parts[1].slice(0, 2);
                        inputValue = parts.join(',');
                    }*/
                    
                    // Update the input value without full formatting
                    event.target.value = inputValue;
                    
                    // Update the item price
                    //item.price = parsePrice(inputValue);

                    // Store the input value temporarily
                    inputValues.value[item.id] = inputValue;
                }

                function handleAmountFocus(item, event) {
                    if (event.target.value === '' || event.target.value === '0') {
                        event.target.value = '';
                        item.amount = null;  // or '' if you prefer
                    }
                }

                function handlePriceFocus(item, event) {
                    if (event.target.value === '' || event.target.value === '0' || event.target.value === '0,00') {
                        event.target.value = '';
                        inputValues.value[item.id] = '';
                    }
                }

                async function handlePriceBlur(item, event) {
                    //console.log('handlePriceBlur', item, event);
                    // Get the stored input value or use the current item price
                    const inputValue = inputValues.value[item.id] || formatPrice(item.price);
                    
                    // Parse and format the price
                    const newPrice = parsePrice(inputValue);
                    const formattedPrice = formatPrice(newPrice);
                    
                    // Update the item price and input value
                    item.price = newPrice;
                    event.target.value = formattedPrice;
                    
                    // Clear the temporary input value
                    delete inputValues.value[item.id];
                    
                    await updateItemInSheet(item);
                    updateLocationStats();
                    updateRecentlyCheckedOff();

                    /*// Format the price when the input loses focus
                    const formattedPrice = formatPrice(item.price);
                    event.target.value = formattedPrice;
                    item.price = parsePrice(formattedPrice);
                    await updateItemInSheet(item);*/
                }

                function handleKeyPress(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        // Perform your "done" action here, e.g., blur the input
                        event.target.blur();
                    }
                }

                onMounted(() => {
                    fetchData().then(() => {
                        if (locations.value.length > 0) {
                            selectLocation(locations.value[0].id);
                        }

                        function force_scroll_sideways(element) {
                            element.addEventListener("wheel", (event) => {
                                event.preventDefault();

                                let [x, y] = [event.deltaX, event.deltaY];
                                let magnitude;

                                if (x === 0) {
                                magnitude = y > 0 ? 30 : -30;
                                } else {
                                magnitude = x;
                                }

                                //console.log({ x, y, magnitude });
                                element.scrollBy({
                                left: magnitude
                                });
                            });
                        }
                        
                        const element = document.querySelector(".location-tabs");
                        force_scroll_sideways(element);
                    });
                });

                return {
                    locations,
                    groceryItems,
                    recentlyCheckedOff,
                    loading,
                    error,
                    fetchData,
                    selectedLocation,
                    selectedItems,
                    filteredGroceryItems,
                    toggleItemCheck,
                    addGroceryItem,
                    selectLocation,
                    updateItemField,
                    formatPriceForDisplay,
                    formatPrice,
                    deleteSelectedItems,
                    changeLocationForSelected,
                    changeDateForSelected,
                    updateLocationStats,
                    selectAll,
                    toggleSelectAll,
                    performSelectedAction,
                    updateRecentlyCheckedOff,
                    handlePriceInput,
                    handlePriceBlur,
                    handlePriceFocus,
                    handleAmountFocus,
                    inputValues,
                    handleKeyPress
                };
            },
            template: `
                <div class="groceries-page page-content">
                    <div class="header">
                        <div class="header-title">
                            <span class="hamburger-menu" @click="toggleSidenav">☰</span>
                            <h2>Groceries <button @click="fetchData">Reload Data</button> <small v-if="loading" class="loading">Loading...</small></h2>
                            <div v-if="error" class="error">{{ error }}</div>
                        </div>
                        
                        <!-- Location tabs -->
                        <div class="location-tabs">
                            <div 
                                v-for="location in locations" 
                                :key="location.id" 
                                class="location-tab"
                                :class="{ 'active': location.id === selectedLocation }"
                                @click="selectLocation(location.id)"
                            >
                                {{ location.title }} ({{ location.itemCount }})
                                <div class="location-total">{{ formatPrice(location.totalPrice) }}</div>
                            </div>
                        </div>
                    </div>
                    <!-- Grocery items to purchase -->
                    <div class="grocery-list">
                        <table>
                            <thead>
                                <tr>
                                    <th width="30"><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                    <th>Item</th>
                                    <th width="60">Quantity</th>
                                    <th width="60">Price</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="item in filteredGroceryItems" :key="item.id">
                                    <td class="select-checkbox" width="30">
                                        <input type="checkbox" v-model="selectedItems" :value="item.id">
                                    </td>
                                    <td class="item-title"><input type="text" v-model="item.title" :data-item-id="item.id" @change="updateItemField(item, 'title', $event.target.value)"></td>
                                    <td class="item-amount" width="60"><input type="number" v-model.number="item.amount" :data-item-id="item.id" @focus="handleAmountFocus(item, $event)" @change="updateItemField(item, 'amount', $event.target.value)"></td>
                                    <td class="item-price" width="60">
                                        <input 
                                            :value="formatPriceForDisplay(item, $event)"
                                            @input="handlePriceInput(item, $event)"
                                            @focus="handlePriceFocus(item, $event)"
                                            @blur="handlePriceBlur(item, $event)"
                                            @keypress="handleKeyPress"
                                            inputmode="decimal"
                                            enterkeyhint="done"
                                        >
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Actions for selected items -->
                    <div v-if="selectedItems.length > 0" class="selected-actions">
                        <button @click="deleteSelectedItems">Delete Selected</button>
                        <select @change="changeLocationForSelected($event.target.value)">
                            <option value="">Change Location</option>
                            <option v-for="location in locations" :key="location.id" :value="location.id">
                                {{ location.title }}
                            </option>
                        </select>
                        <input type="date" @change="changeDateForSelected($event.target.value)">
                    </div>

                    <!-- Recently checked off items -->
                    <div class="recently-checked-off">
                        <h3>Recently Checked Off Items</h3>
                        <div v-for="group in recentlyCheckedOff" :key="group.date" class="recently-checked-off-group">
                        <h4 @click="group.collapsed = !group.collapsed">
                            {{ group.date }}<span style="margin-left: auto;">{{ formatPrice(group.total) }}</span>
                        </h4>
                        <table v-if="!group.collapsed">
                            <thead>
                            <tr>
                                <th width="30"><input type="checkbox" :checked="selectedItems.length === group.items.length" @change="toggleSelectAll(group.items)"></th>
                                <th>Item</th>
                                <th width="60">Quantity</th>
                                <th width="60">Price</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr v-for="item in group.items" :key="item.id">
                                <td class="select-checkbox" width="30"><input type="checkbox" v-model="selectedItems" :value="item.id"></td>
                                <td class="item-title"><input type="text" v-model="item.title" @change="updateItemInSheet(item)"></td>
                                <td class="item-amount" width="60"><input type="number" v-model.number="item.amount" @focus="handleAmountFocus(item, $event)" @change="updateItemInSheet(item)"></td>
                                <td class="item-price" width="60">
                                    <input  
                                            :value="formatPriceForDisplay(item, $event)"
                                            @input="handlePriceInput(item, $event)"
                                            @blur="handlePriceBlur(item, $event)"
                                            @keypress="handleKeyPress"
                                            inputmode="decimal"
                                            enterkeyhint="done"
                                        >
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        </div>
                    </div>

                    <button @click="addGroceryItem" class="add-grocery-button">Add Grocery</button>
                </div>
            `
        };

        const LocationsPage = {
            props: ['sheetId', 'toggleSidenav'],
            setup(props) {
                const locations = ref([]);
                const stableLocations = ref([]);
                const globalSearch = ref('');
                const sortColumn = ref('title');
                const sortDirection = ref('asc');
                const currentLocationsPage = ref(1);
                const itemsPerPage = ref(10);
                const columns = ['title', 'city', 'order', 'hidden'];
                const loading = ref(false);
                const error = ref(null);
                const selectAll = ref(false);
                const editingLocationId = ref(null);
                const focusNextId = ref(null);

                function applySort() {
                    //console.log('applySort', sortColumn.value, sortDirection.value);
                    stableLocations.value = [...stableLocations.value].sort((a, b) => {
                        if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                        if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                        // If values are equal, maintain current order
                        return stableLocations.value.indexOf(a) - stableLocations.value.indexOf(b);
                    });
                }

                /*const filteredLocations = computed(() => {
                    return locations.value.filter(location =>
                        Object.values(location).some(value =>
                        String(value).toLowerCase().includes(globalSearch.value.toLowerCase())
                        )
                    );
                });

                watch(filteredLocations, (newValue) => {
                    stableLocations.value = newValue;
                    applySort();
                }, { immediate: true });*/

                /*const sortedLocations = computed(() => {
                    console.log('sortedLocations', filteredLocations.value);
                    return [...filteredLocations.value].sort((a, b) => {
                        if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                        if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                        return 0;
                    });
                });*/

                const paginatedLocations = computed(() => {
                    const startIndex = (currentLocationsPage.value - 1) * itemsPerPage.value;
                    return stableLocations.value.slice(startIndex, startIndex + itemsPerPage.value);
                });

                const totalPages = computed(() => Math.ceil(stableLocations.value.length / itemsPerPage.value));

                const selectedLocations = computed(() => 
                    locations.value.filter(location => location.selected)
                );

                function sort(column) {
                    //console.log('sort', column);
                    if (sortColumn.value === column) {
                        sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn.value = column;
                        sortDirection.value = 'asc';
                    }
                    applyFilterAndSort();
                }

                function applyFilterAndSort() {
                    const filtered = locations.value.filter(location =>
                        Object.values(location).some(value =>
                        String(value).toLowerCase().includes(globalSearch.value.toLowerCase())
                        )
                    );

                    stableLocations.value = filtered.sort((a, b) => {
                        if (sortColumn.value === 'order') {
                            return sortDirection.value === 'asc' ? a.order - b.order : b.order - a.order;
                        }
                        if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                        if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                        return 0;
                    });
                }

                function changePage(page) {
                    stopChangeDetection();
                    
                    currentLocationsPage.value = page;
                }

                const debounceUpdate = _.debounce(updateLocation, 1500);

                const debounceSearch = _.debounce(() => {
                    currentLocationsPage.value = 1;
                    applyFilterAndSort();
                }, 300);

                watch(globalSearch, debounceSearch);

                async function fetchLocations() {
                    //console.log('fetchLocations');
                    loading.value = true;
                    error.value = null;
                    try {
                        const response = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E'
                        });
                        
                        locations.value = response.result.values.map((row, index) => ({
                            id: row[2] || `loc_${index}`,
                            title: row[0] || '',
                            order: row[1] || '',
                            city: row[4] || '',
                            hidden: row[3] === 'true',
                            selected: false // Add selected property for checkboxes
                        }));
                        //resetPagination();
                    } catch (err) {
                        console.error('Error fetching data:', err);
                        error.value = 'Failed to fetch data. Please try again.';
                    } finally {
                        loading.value = false;
                        applyFilterAndSort();
                    }
                }

                function formatCapitalizeFirst(value) {
                    return value.charAt(0).toUpperCase() + value.slice(1);
                }
                function formatTextInput(value) {
                    return value.charAt(0).toUpperCase() + value.slice(1).trimEnd();
                }

                async function updateLocation(location) {
                    //console.log('updateLocation', location);
                    loading.value = true;
                    error.value = null;

                    // Apply formatting to title and city
                    if (typeof location.title === 'string') {
                        location.title = formatTextInput(location.title);
                    }
                    if (typeof location.city === 'string') {
                        location.city = formatTextInput(location.city);
                    }

                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: `Locations!A${locations.value.indexOf(location) + 2}:F${locations.value.indexOf(location) + 2}`,
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[location.title, location.order, location.id, location.hidden.toString(), location.city]]
                            }
                        });
                    } catch (err) {
                        console.error('Error updating location:', err);
                        error.value = 'Failed to update location. Please try again.';
                    } finally {
                        loading.value = false;
                        if (editingLocationId.value !== location.id) {
                            applyFilterAndSort();
                        }
                    }
                }

                function handleLocationInput(location, field, event) {
                    editingLocationId.value = location.id;
                    if (field === 'title' || field === 'city') {
                        location[field] = formatCapitalizeFirst(event.target.value);
                    } else if (field === 'order') {
                        // Ensure order is always a number
                        location[field] = event.target.value ? parseInt(event.target.value, 10) : 0;
                    } else {
                        location[field] = event.target.value;
                    }
                }
                function handleLocationBlur(location) {
                    updateLocation(location);
                    editingLocationId.value = null;
                }

                function handleKeyDown(location, field, event) {
                    if (event.key === 'Tab') {
                        //console.log('handleKeyDown', location, field, event);
                        //event.preventDefault(); // Prevent default tab behavior
                        const currentIndex = stableLocations.value.findIndex(loc => loc.id === location.id);
                        //const currentLocationsPage = Math.floor(currentIndex / itemsPerPage.value) + 1;
                        
                        let nextField, nextLocation;
                        if (field === 'title') {
                            nextField = 'city';
                            nextLocation = location;
                        } else if (field === 'city') {
                            const nextIndex = currentIndex + 1;
                            nextLocation = stableLocations.value[nextIndex];
                            nextField = nextLocation ? 'title' : null;
                        }

                        setTimeout(function() {
                            if (nextLocation) {
                                const nextIndex = stableLocations.value.findIndex(loc => loc.id === nextLocation.id);
                                const nextPage = Math.floor(nextIndex / itemsPerPage.value) + 1;

                                //console.log('nextIndex', nextIndex);
                                //console.log('nextPage', nextPage);
                                //console.log('currentLocationsPage', currentLocationsPage.value);
                                if (nextPage !== currentLocationsPage.value) {
                                    // We need to change pages
                                    currentLocationsPage.value = nextPage;
                                    focusNextId.value = `${nextLocation.id}-${nextField}`;
                                } else {
                                    // Focus the next field immediately
                                    Vue.nextTick(() => {
                                        const nextInput = document.querySelector(`input[data-location-id="${nextLocation.id}"][data-field="${nextField}"]`);
                                        //console.log('nextInput', nextInput);
                                        if (nextInput) nextInput.focus();
                                    });
                                }
                            }
                        }, 300);
                    }
                }

                watch(currentLocationsPage, () => {
                    //console.log('Watch currentLocationsPage', currentLocationsPage.value);
                    if (focusNextId.value) {
                        Vue.nextTick(() => {
                            const [locationId, field] = focusNextId.value.split('-');
                            const nextInput = document.querySelector(`input[data-location-id="${locationId}"][data-field="${field}"]`);
                            if (nextInput) nextInput.focus();
                            focusNextId.value = null;
                        });
                    }
                });

                async function addNewLocation() {
                    loading.value = true;
                    error.value = null;
                    const newLocation = {
                        id: `loc_${Date.now()}`,
                        title: '',
                        order: (locations.value.length + 1).toString(),
                        city: '',
                        hidden: false,
                        selected: false
                    };

                    locations.value.push(newLocation);

                    try {
                        await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A:F',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[newLocation.title, newLocation.order, newLocation.id, newLocation.hidden.toString(), newLocation.city]]
                            }
                        });

                        applyFilterAndSort();

                        // Calculate which page the new location is on
                        const newLocationIndex = stableLocations.value.findIndex(loc => loc.id === newLocation.id);
                        //console.log('newLocationIndex', newLocationIndex);
                        if (newLocationIndex !== -1) {
                            const newPage = Math.floor(newLocationIndex / itemsPerPage.value) + 1;
                            currentLocationsPage.value = newPage;
                        }

                        // Use nextTick to ensure the DOM has updated before trying to focus
                        Vue.nextTick(() => {
                            const newLocationInput = document.querySelector(`input[data-location-id="${newLocation.id}"]`);
                            if (newLocationInput) {
                                newLocationInput.focus();
                            }
                        });
                    } catch (err) {
                        console.error('Error adding new location:', err);
                        locations.value.pop(); // Remove the new location if there was an error
                        error.value = 'Failed to add new location. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                function exportToCSV() {
                    const csv = [
                        columns.join(','),
                        ...locations.value.map(location => columns.map(column => location[column]).join(','))
                    ].join('\n');
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', 'locations.csv');
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                }

                async function importFromCSV(event) {
                    loading.value = true;
                    error.value = null;
                    const file = event.target.files[0];
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const csv = e.target.result;
                            const lines = csv.split('\n');
                            const headers = lines[0].split(',');
                            const newLocations = lines.slice(1).map(line => {
                                const values = line.split(',');
                                const location = {};
                                headers.forEach((header, index) => {
                                    location[header] = values[index];
                                });
                                return location;
                            });
                            locations.value = newLocations;
                            await updateAllLocations();
                        } catch (err) {
                            console.error('Error importing CSV:', err);
                            error.value = 'Failed to import CSV. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    };
                    reader.readAsText(file);
                }

                async function updateAllLocations() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:E',
                            valueInputOption: 'RAW',
                            resource: {
                                values: locations.value.map(loc => [loc.title, loc.order, loc.id, loc.hidden.toString(), loc.city])
                            }
                        });
                    } catch (err) {
                        console.error('Error updating all locations:', err);
                        error.value = 'Failed to update all locations. Please try again.';
                    }
                }

                function toggleSelectAll() {
                    locations.value.forEach(location => location.selected = selectAll.value);
                }

                async function deleteSelected() {
                    if (selectedLocations.value.length === 0) return;
                    if (confirm(`Are you sure you want to delete ${selectedLocations.value.length} location(s)?`)) {
                        loading.value = true;
                        error.value = null;
                        try {
                            const sheetId = await getSheetId('Locations');
                            if (!sheetId) {
                                throw new Error('Locations sheet ID not found');
                            }

                            const locationsToDelete = locations.value.filter(location => location.selected);
                            const indicesToDelete = locationsToDelete
                                .map(location => locations.value.indexOf(location) + 2)
                                .sort((a, b) => b - a);

                            // Remove from Google Sheet
                            await gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: props.sheetId,
                                resource: {
                                    requests: indicesToDelete.map(index => ({
                                        deleteDimension: {
                                            range: {
                                                sheetId: sheetId,
                                                dimension: 'ROWS',
                                                startIndex: index - 1,
                                                endIndex: index
                                            }
                                        }
                                    }))
                                }
                            });

                            // Remove from local array
                            locations.value = locations.value.filter(location => !location.selected);
                            // Update stableLocations
                            stableLocations.value = stableLocations.value.filter(location => !location.selected);
                            selectAll.value = false;

                            console.log('Locations deleted successfully');
                            // Reapply filter and sort
                            applyFilterAndSort();
                        } catch (err) {
                            console.error('Error deleting locations:', err);
                            error.value = 'Failed to delete locations. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }
                }

                async function getSheetId(sheetTitle) {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.get({
                            spreadsheetId: props.sheetId,
                            fields: 'sheets.properties'
                        });
                        const sheet = response.result.sheets.find(sheet => sheet.properties.title === sheetTitle);
                        return sheet ? sheet.properties.sheetId : null;
                    } catch (error) {
                        console.error('Error fetching sheet ID:', error);
                        return null;
                    }
                }

                function resetPagination() {
                    currentLocationsPage.value = 1;
                }

                let currentModifiedTime = null;
                let changeDetectionInterval = null;

                function setupChangeDetection(sheetId) {
                    // Stop any existing interval
                    stopChangeDetection();

                    // Initial fetch
                    fetchLocations();
                    
                    // Start polling for changes
                    changeDetectionInterval = setInterval(checkForChanges, 30000); // Check every 30 seconds
                }

                function stopChangeDetection() {
                    if (changeDetectionInterval) {
                        clearInterval(changeDetectionInterval);
                        changeDetectionInterval = null;
                    }
                }

                async function checkForChanges() {
                    try {
                        const response = await gapi.client.drive.files.get({
                            fileId: props.sheetId,
                            fields: 'modifiedTime'
                        });
                        const newModifiedTime = response.result.modifiedTime;
                        if (newModifiedTime !== currentModifiedTime) {
                            currentModifiedTime = newModifiedTime;
                            console.log('Sheet updated, refreshing data...');
                            await fetchLocations();
                        } else {
                            console.log('Sheet still up to date.');
                        }
                    } catch (error) {
                        console.error('Error checking for updates:', error);
                    }
                }

                function getLocationColumnClass(column) {
                    return `location-${column.toLowerCase()}`;
                }

                window.setupChangeDetection = setupChangeDetection;

                onMounted(async () => {
                    await fetchLocations();
                    setupChangeDetection();
                });

                watch(globalSearch, debounceSearch);

                return {
                    locations,
                    globalSearch,
                    columns,
                    sortColumn,
                    sortDirection,
                    currentLocationsPage,
                    totalPages,
                    paginatedLocations,
                    loading,
                    error,
                    sort,
                    changePage,
                    updateLocation,
                    debounceUpdate,
                    addNewLocation,
                    exportToCSV,
                    importFromCSV,
                    fetchLocations,
                    selectAll,
                    selectedLocations,
                    toggleSelectAll,
                    deleteSelected,
                    debounceSearch,
                    resetPagination,
                    setupChangeDetection,
                    stopChangeDetection,
                    getLocationColumnClass,
                    handleLocationInput,
                    handleLocationBlur,
                    handleKeyDown
                };
            },
            template: `
                <div class="locations-page page-content">
                    <div class="header">
                        <div class="header-title">
                            <span class="hamburger-menu" @click="toggleSidenav">☰</span>
                            <h2>Locations <button @click="fetchLocations">Reload data</button> <small v-if="loading" class="loading">Loading...</small></h2>
                            <div v-if="error" class="error">{{ error }}</div>
                        </div>
                        <div class="controls">
                            <input type="text" v-model="globalSearch" placeholder="Search locations..." @input="debounceSearch">
                            <!--<button @click="exportToCSV">Export to CSV</button>
                            <input type="file" @change="importFromCSV" accept=".csv">-->
                            <button @click="deleteSelected" :disabled="selectedLocations.length === 0">Delete Selected</button>
                        </div>
                    </div>
                    <div class="locations-list responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th width="30" class="location-checkbox"><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                    <th v-for="column in columns" :key="column" @click="sort(column)" :class="getLocationColumnClass(column)">
                                        {{ column }}
                                        <span v-if="sortColumn === column">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="location in paginatedLocations" :key="location.id">
                                    <td><input type="checkbox" v-model="location.selected"></td>
                                    <td v-for="column in columns" :key="column" :class="getLocationColumnClass(column)">
                                        <input v-if="column !== 'hidden'" type="text" v-model="location[column]" :data-location-id="location.id" :data-field="column" @input="handleLocationInput(location, column, $event)" @blur="handleLocationBlur(location)" @keydown="handleKeyDown(location, column, $event)">
                                        <input v-else type="checkbox" v-model="location.hidden" @change="updateLocation(location)">
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button @click="currentLocationsPage > 1 && currentLocationsPage--" :disabled="currentLocationsPage === 1">Previous</button>
                        <span>Page {{ currentLocationsPage }} of {{ totalPages }}</span>
                        <button @click="currentLocationsPage < totalPages && currentLocationsPage++" :disabled="currentLocationsPage === totalPages">Next</button>
                    </div>
                    <button class="add-location-button" @click="addNewLocation">Add Location</button>
                </div>
            `
        };

        const HistoryPage = {
            props: ['sheetId', 'toggleSidenav'],
            setup(props) {
                const historyItems = ref([]);
                const locations = ref([]);
                const loading = ref(false);
                const error = ref(null);

                const filters = ref({
                title: '',
                amount: '',
                price: '',
                date: '',
                location: ''
                });

                const columns = ['title', 'amount', 'price', 'date', 'location'];

                async function fetchData() {
                    loading.value = true;
                    error.value = null;
                    try {
                        // Fetch locations
                        const locationsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:C'
                        });
                        
                        locations.value = locationsResponse.result.values.reduce((acc, [title, , id]) => {
                            acc[id] = title;
                            return acc;
                        }, {});

                        // Fetch grocery items
                        const itemsResponse = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Groceries!A2:H'
                        });

                        historyItems.value = itemsResponse.result.values
                        .map(row => ({
                            id: row[0],
                            title: row[1],
                            amount: parseInt(row[2]),
                            price: parseFloat(row[3].replace(',', '.')),
                            location: locations.value[row[5]] || row[5],
                            date: row[7] ? new Date(parseInt(row[6])).toISOString().split('T')[0] : '',
                        }))
                        .sort((a, b) => new Date(b.date) - new Date(a.date));

                    } catch (err) {
                        console.error('Error fetching data:', err);
                        error.value = 'Failed to fetch data. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                const filteredItems = computed(() => {
                    return historyItems.value.filter(item => 
                        columns.every(column => 
                            !filters.value[column] || 
                            String(item[column]).toLowerCase().includes(filters.value[column].toLowerCase())
                        )
                    );
                });

                onMounted(fetchData);

                return {
                    historyItems,
                    loading,
                    error,
                    filters,
                    columns,
                    filteredItems,
                    fetchData
                };
            },
            template: `
                <div class="history-page page-content">
                    <div class="header">
                        <div class="header-title">
                            <span class="hamburger-menu" @click="toggleSidenav">☰</span>
                            <h2>History <button @click="fetchData">Reload Data</button> <small v-if="loading" class="loading">Loading...</small></h2>
                            <div v-if="error" class="error">{{ error }}</div>
                        </div>
                    </div>
                    <div v-else class="history-list responsive">
                        <table>
                        <thead>
                            <tr>
                            <th v-for="column in columns" :key="column">
                                {{ column.charAt(0).toUpperCase() + column.slice(1) }}
                                <input 
                                :placeholder="'Filter ' + column"
                                v-model="filters[column]"
                                @input="filters = {...filters}"
                                >
                            </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="item in filteredItems" :key="item.id">
                            <td>{{ item.title }}</td>
                            <td>{{ item.amount }}</td>
                            <td>{{ item.price.toFixed(2).replace('.', ',') }}</td>
                            <td>{{ item.date }}</td>
                            <td>{{ item.location }}</td>
                            </tr>
                        </tbody>
                        </table>
                    </div>
                </div>
            `
        };

        app = createApp({
            components: {
                GroceriesPage,
                LocationsPage,
                HistoryPage
            },
            setup() {
                const isSignedIn = ref(false);
                const user = ref(null);
                const sheetId = ref(null);
                const tokenClient = ref(null);
                const currentPage = ref('groceries');
                const pickerApiLoaded = ref(false);
                const loading = ref(false);
                const locationPageRef = ref(null);

                const CLIENT_ID = '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com';
                const SCOPES = 'https://www.googleapis.com/auth/drive.file';

                const currentPageComponent = computed(() => {
                    switch (currentPage.value) {
                        case 'groceries':
                            return GroceriesPage;
                        case 'locations':
                            return LocationsPage;
                        case 'history':
                            return HistoryPage;
                        default:
                            return null;
                    }
                });

                function initializeGapiClient() {
                    gapi.client.init({
                        //apiKey: 'AIzaSyDjwvPH2It7i1feQRPTmQyY_yhNSG-1BmE',
                        //clientId: CLIENT_ID,
                        discoveryDocs: [
                            'https://sheets.googleapis.com/$discovery/rest?version=v4',
                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                        ],
                        scope: SCOPES
                    }).then(() => {
                        tokenClient.value = google.accounts.oauth2.initTokenClient({
                            client_id: CLIENT_ID,
                            scope: SCOPES,
                            callback: handleTokenResponse,
                            error_callback: (err) => {
                                console.error("Error during token client initialization:", err);
                            }
                        });
                    }).catch((error) => {
                        console.error("Error initializing gapi client:", error);
                    });
                }

                function handleCredentialResponse(response) {
                    console.log("Handling credential response in Vue app");
                    user.value = parseJwt(response.credential);
                    isSignedIn.value = true;
                    console.log("Signed in as: " + user.value.name);

                    if (tokenClient.value) {
                        tokenClient.value.requestAccessToken({prompt: 'consent'});
                    } else {
                        console.error('Token client not initialized');
                    }

                    if (sheetId.value) {
                        window.setupChangeDetection(sheetId.value);
                    }

                    checkForStoredSheet();
                }

                function handleTokenResponse(tokenResponse) {
                    if (tokenResponse && tokenResponse.access_token) {
                        gapi.client.setToken(tokenResponse);
                        checkForStoredSheet();
                    } else if (tokenResponse.error) {
                        console.error("Error during token response:", tokenResponse.error);
                    }
                }

                function parseJwt(token) {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    return JSON.parse(jsonPayload);
                }

                function checkForStoredSheet() {
                    console.log('Checking for stored sheet');
                    const storedSheetId = localStorage.getItem('lastUsedSheetId');
                    if (storedSheetId) {
                        console.log('Found stored sheet ID:', storedSheetId);

                        sheetId.value = storedSheetId;
                        //setupChangeDetection();
                        if (typeof window.setupChangeDetection === 'function') {
                            console.log('Calling setupChangeDetection');
                            window.setupChangeDetection(storedSheetId);
                        } else {
                            console.error('setupChangeDetection is not a function');
                        }
                        // Proceed with loading data from the sheet
                    } else {
                        // User will need to create a new sheet or select one
                    }
                }

                async function createNewSheet() {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.create({
                            properties: {
                                title: 'GroceriesApp'
                            },
                            sheets: [
                                {
                                    properties: {
                                        title: 'Groceries'
                                    }
                                },
                                {
                                    properties: {
                                        title: 'Locations'
                                    }
                                }
                            ]
                        });
                        sheetId.value = response.result.spreadsheetId;
                        localStorage.setItem('lastUsedSheetId', sheetId.value);
                        console.log('New sheet created:', sheetId.value);
                        await initializeNewSheet();
                    } catch (err) {
                        console.error('Error creating new sheet:', err);
                    }
                }

                async function initializeNewSheet() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Groceries!A1:H1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['id', 'title', 'amount', 'price', 'order', 'location', 'date_checked', 'date']]
                            }
                        });
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Locations!A1:F1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['title', 'order', 'id', 'hide_in_groceries', 'city']]
                            }
                        });
                        console.log('New sheet initialized');
                    } catch (err) {
                        console.error('Error initializing new sheet:', err);
                    }
                }

                function signOut() {
                    const token = gapi.client.getToken();
                    if (token !== null) {
                        google.accounts.oauth2.revoke(token.access_token);
                        gapi.client.setToken('');
                    }
                    isSignedIn.value = false;
                    user.value = null;
                    sheetId.value = null;
                    localStorage.removeItem('lastUsedSheetId');
                    stopChangeDetection();
                }

                function loadPickerApi() {
                    gapi.load('picker', { callback: onPickerApiLoad });
                }

                function onPickerApiLoad() {
                    pickerApiLoaded.value = true;
                }

                async function showPicker() {
                    if (!pickerApiLoaded.value) {
                        await new Promise((resolve) => {
                            loadPickerApi();
                            const checkLoaded = setInterval(() => {
                                if (pickerApiLoaded.value) {
                                    clearInterval(checkLoaded);
                                    resolve();
                                }
                            }, 100);
                        });
                    }

                    const token = gapi.client.getToken();
                    if (!token) {
                        console.error('No access token available');
                        return;
                    }

                    const view = new google.picker.DocsView(google.picker.ViewId.SPREADSHEETS)
                        .setIncludeFolders(true)
                        .setMimeTypes("application/vnd.google-apps.spreadsheet")
                        .setQuery("GroceriesApp");

                    const picker = new google.picker.PickerBuilder()
                        .enableFeature(google.picker.Feature.NAV_HIDDEN)
                        .setAppId('778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com') // Replace with your actual App ID
                        .setOAuthToken(token.access_token)
                        .addView(view)
                        .setCallback(pickerCallback)
                        .build();

                    picker.setVisible(true);
                }

                async function pickerCallback(data) {
                    if (data.action === google.picker.Action.PICKED) {
                        const fileId = data.docs[0].id;
                        console.log('The user selected: ' + fileId);
                        
                        sheetId.value = fileId;
                        localStorage.setItem('lastUsedSheetId', fileId);
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        if (currentPageComponent.value === LocationsPage && locationPageRef.value) {
                            try {
                                await locationPageRef.value.fetchLocations();
                                setupChangeDetection();
                            } catch (error) {
                                console.error('Error fetching locations:', error);
                            }
                        }
                    }
                }

                function toggleSidenav() {
                    //console.log('toggleSidenav');
                    //this.isSidenavOpen = !this.isSidenavOpen;
                    $('.sidenav').toggleClass('open');
                }

                // Load and init the gapi client
                gapi.load('client', initializeGapiClient);

                return {
                    isSignedIn,
                    user,
                    sheetId,
                    signOut,
                    isSidenavOpen: false,
                    toggleSidenav,
                    currentPage,
                    currentPageComponent,
                    createNewSheet,
                    handleCredentialResponse,
                    showPicker,
                    locationPageRef,
                    loading,
                    pickerCallback
                };
            }
        });

        // Instead of accessing app._instance.exposed, we'll set the method directly on the app
        app.handleCredentialResponse = function(response) {
            // This will call the handleCredentialResponse function inside the component
            app._instance.proxy.handleCredentialResponse(response);
        };

        // Mount your app after ensuring Google APIs are loaded
        gapi.load('client', function() {
            gapi.client.init({
                discoveryDocs: [
                    'https://sheets.googleapis.com/$discovery/rest?version=v4',
                    'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                ],
            }).then(() => {
                app.mount('#app');
                initializeGoogleSignIn();
            });
        });
    })();
    </script>
</body>
</html>