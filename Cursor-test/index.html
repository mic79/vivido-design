<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Groceries</title>
    <script src="https://accounts.google.com/gsi/client" async defer onloadX="initializeGoogleSignIn()"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
        .nav-menu {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: #f0f0f0;
        }
        .nav-menu a {
            text-decoration: none;
            color: #333;
            padding: 5px 10px;
        }
        .nav-menu a.active {
            font-weight: bold;
            background-color: #ddd;
        }
        .responsive {
            max-width: 100%;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .filter-input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }
        .sticky-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .sticky-button:hover {
            background-color: #45a049;
        }
        .error {
            color: red;
            margin-bottom: 10px;
        }
        .loading {
            margin-top: 10px;
        }
        .controls {
            margin-bottom: 10px;
        }
        @media (max-width: 768px) {
            /* table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            } */
            
            tr { border: 1px solid #ccc; }
            
            td {
                border: none;
                position: relative;
                /* padding-left: 50%; */
            }
            
            /* td:before {
                position: absolute;
                top: 6px;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
            } */
        }
    </style>
</head>
<body>
    <div id="app" style="display: none;">
        <div v-if="!isSignedIn">
            <div id="googleSignInButton"></div>
        </div>
        <div v-if="isSignedIn">
            <p>{{ user.email }} <button @click="signOut">Sign Out</button></p>
            <nav class="nav-menu">
                <a :class="{ active: currentPage === 'groceries' }" @click="currentPage = 'groceries'" href="#">Groceries</a>
                <a :class="{ active: currentPage === 'locations' }" @click="currentPage = 'locations'" href="#">Locations</a>
            </nav>
            <p v-if="sheetId">Current Sheet ID: {{ sheetId }} (Share this ID with others to collaborate)</p>
            <div>
                <button @click="createNewSheet">Create New Sheet</button>
                <button @click="showPicker">Select GroceriesApp Sheet</button>
            </div>
            <component v-if="sheetId" :is="currentPageComponent" :sheet-id="sheetId" ref="locationPageRef"></component>
        </div>
    </div>

    <script>
    function initializeGoogleSignIn() {
        console.log('Attempting to initialize Google Sign-In');
        if (typeof google === 'undefined' || typeof google.accounts === 'undefined') {
            console.error('Google API not loaded');
            return;
        }
        google.accounts.id.initialize({
            client_id: '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com',
            callback: handleCredentialResponse
        });
        Vue.nextTick(() => {
            const buttonElement = document.getElementById("googleSignInButton");
            if (buttonElement) {
                google.accounts.id.renderButton(
                    buttonElement,
                    { theme: "outline", size: "large" }
                );
                console.log('Button rendered');
                document.getElementById('app').style.display = 'block'; // Show the app after initialization
            } else {
                console.error('Google Sign-In button element not found');
            }
        });
    }

    (function() {
        const { createApp, ref, computed, onMounted, watch } = Vue;

        let app; // Declare app variable to be used later

        // Define handleCredentialResponse in the global scope
        window.handleCredentialResponse = function(response) {
            console.log("Received credential response:", response);
            if (app && typeof app.handleCredentialResponse === 'function') {
                app.handleCredentialResponse(response);
            } else {
                console.error('App or handleCredentialResponse not initialized');
            }
        };

        const GroceriesPage = {
            template: '<div><h2>Groceries</h2><p>Groceries content goes here</p></div>'
        };

        const LocationsPage = {
            props: ['sheetId'],
            setup(props) {
                const locations = ref([]);
                const globalSearch = ref('');
                const sortColumn = ref('title');
                const sortDirection = ref('asc');
                const currentPage = ref(1);
                const itemsPerPage = ref(10);
                const columns = ['title', 'city', 'country', 'hidden'];
                const loading = ref(false);
                const error = ref(null);
                const selectAll = ref(false);

                const filteredLocations = computed(() => {
                    return locations.value.filter(location =>
                        Object.values(location).some(value =>
                            String(value).toLowerCase().includes(globalSearch.value.toLowerCase())
                        )
                    );
                });

                const sortedLocations = computed(() => {
                    return [...filteredLocations.value].sort((a, b) => {
                        if (a[sortColumn.value] < b[sortColumn.value]) return sortDirection.value === 'asc' ? -1 : 1;
                        if (a[sortColumn.value] > b[sortColumn.value]) return sortDirection.value === 'asc' ? 1 : -1;
                        return 0;
                    });
                });

                const paginatedLocations = computed(() => {
                    const startIndex = (currentPage.value - 1) * itemsPerPage.value;
                    return sortedLocations.value.slice(startIndex, startIndex + itemsPerPage.value);
                });

                const totalPages = computed(() => Math.ceil(sortedLocations.value.length / itemsPerPage.value));

                const selectedLocations = computed(() => 
                    locations.value.filter(location => location.selected)
                );

                function sort(column) {
                    if (sortColumn.value === column) {
                        sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn.value = column;
                        sortDirection.value = 'asc';
                    }
                }

                function changePage(page) {
                    stopChangeDetection();
                    
                    currentPage.value = page;
                }

                const debounceUpdate = _.debounce(updateLocation, 1500);

                const debounceSearch = _.debounce(() => {
                    currentPage.value = 1;
                }, 300);

                async function fetchLocations() {
                    loading.value = true;
                    error.value = null;
                    try {
                        const response = await gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:F'
                        });
                        
                        locations.value = response.result.values.map((row, index) => ({
                            id: row[2] || `loc_${index}`,
                            title: row[0] || '',
                            order: row[1] || '',
                            city: row[4] || '',
                            country: row[5] || '',
                            hidden: row[3] === 'true'
                        }));
                        resetPagination();
                    } catch (err) {
                        console.error('Error fetching locations:', err);
                        error.value = 'Failed to fetch locations. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function updateLocation(location) {
                    loading.value = true;
                    error.value = null;
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: `Locations!A${locations.value.indexOf(location) + 2}:F${locations.value.indexOf(location) + 2}`,
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[location.title, location.order, location.id, location.hidden.toString(), location.city, location.country]]
                            }
                        });
                    } catch (err) {
                        console.error('Error updating location:', err);
                        error.value = 'Failed to update location. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                async function addNewLocation() {
                    loading.value = true;
                    error.value = null;
                    const newLocation = {
                        id: `loc_${Date.now()}`,
                        title: 'New Location',
                        order: (locations.value.length + 1).toString(),
                        city: '',
                        country: '',
                        hidden: false
                    };

                    locations.value.push(newLocation);

                    try {
                        await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A:F',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [[newLocation.title, newLocation.order, newLocation.id, newLocation.hidden.toString(), newLocation.city, newLocation.country]]
                            }
                        });
                    } catch (err) {
                        console.error('Error adding new location:', err);
                        locations.value.pop(); // Remove the new location if there was an error
                        error.value = 'Failed to add new location. Please try again.';
                    } finally {
                        loading.value = false;
                    }
                }

                function exportToCSV() {
                    const csv = [
                        columns.join(','),
                        ...locations.value.map(location => columns.map(column => location[column]).join(','))
                    ].join('\n');
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', 'locations.csv');
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                }

                async function importFromCSV(event) {
                    loading.value = true;
                    error.value = null;
                    const file = event.target.files[0];
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const csv = e.target.result;
                            const lines = csv.split('\n');
                            const headers = lines[0].split(',');
                            const newLocations = lines.slice(1).map(line => {
                                const values = line.split(',');
                                const location = {};
                                headers.forEach((header, index) => {
                                    location[header] = values[index];
                                });
                                return location;
                            });
                            locations.value = newLocations;
                            await updateAllLocations();
                        } catch (err) {
                            console.error('Error importing CSV:', err);
                            error.value = 'Failed to import CSV. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    };
                    reader.readAsText(file);
                }

                async function updateAllLocations() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: props.sheetId,
                            range: 'Locations!A2:F',
                            valueInputOption: 'RAW',
                            resource: {
                                values: locations.value.map(loc => [loc.title, loc.order, loc.id, loc.hidden.toString(), loc.city, loc.country])
                            }
                        });
                    } catch (err) {
                        console.error('Error updating all locations:', err);
                        error.value = 'Failed to update all locations. Please try again.';
                    }
                }

                function toggleSelectAll() {
                    locations.value.forEach(location => location.selected = selectAll.value);
                }

                async function deleteSelected() {
                    if (selectedLocations.value.length === 0) return;
                    if (confirm(`Are you sure you want to delete ${selectedLocations.value.length} location(s)?`)) {
                        loading.value = true;
                        error.value = null;
                        try {
                            // First, get the sheet ID for the "Locations" sheet
                            const sheetsResponse = await gapi.client.sheets.spreadsheets.get({
                                spreadsheetId: props.sheetId
                            });
                            const locationsSheet = sheetsResponse.result.sheets.find(sheet => sheet.properties.title === "Locations");
                            if (!locationsSheet) {
                                throw new Error("Locations sheet not found");
                            }
                            const locationsSheetId = locationsSheet.properties.sheetId;

                            // Get the indices of selected locations
                            const indicesToDelete = locations.value
                                .map((loc, index) => loc.selected ? index + 2 : -1) // +2 because sheet is 1-indexed and has a header row
                                .filter(index => index !== -1)
                                .sort((a, b) => b - a); // Sort in descending order

                            // Remove from Google Sheet
                            await gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: props.sheetId,
                                resource: {
                                    requests: indicesToDelete.map(index => ({
                                        deleteDimension: {
                                            range: {
                                                sheetId: locationsSheetId,
                                                dimension: 'ROWS',
                                                startIndex: index - 1,
                                                endIndex: index
                                            }
                                        }
                                    }))
                                }
                            });

                            // Remove from local array
                            locations.value = locations.value.filter(location => !location.selected);
                            selectAll.value = false;

                            console.log('Locations deleted successfully');
                        } catch (err) {
                            console.error('Error deleting locations:', err);
                            error.value = 'Failed to delete locations. Please try again.';
                        } finally {
                            loading.value = false;
                        }
                    }
                }

                function resetPagination() {
                    currentPage.value = 1;
                }

                let currentModifiedTime = null,
                changeDetectionInterval = null;

                function setupChangeDetection() {
                    // Stop any existing interval
                    stopChangeDetection();

                    // Initial fetch
                    fetchLocations();
                    
                    // Start polling for changes
                    changeDetectionInterval = setInterval(checkForChanges, 5000); // Check every 30 seconds
                }

                function stopChangeDetection() {
                    if (changeDetectionInterval) {
                        clearInterval(changeDetectionInterval);
                        changeDetectionInterval = null;
                    }
                }

                async function checkForChanges() {
                    try {
                        const response = await gapi.client.drive.files.get({
                            fileId: props.sheetId,
                            fields: 'modifiedTime'
                        });
                        const newModifiedTime = response.result.modifiedTime;
                        if (newModifiedTime !== currentModifiedTime) {
                            currentModifiedTime = newModifiedTime;
                            console.log('Sheet updated, refreshing data...');
                            await fetchLocations();
                        } else {
                            console.log('Sheet still up to date.');
                        }
                    } catch (error) {
                        console.error('Error checking for updates:', error);
                    }
                }

                onMounted(async () => {
                    await fetchLocations();
                    setupChangeDetection();
                });

                watch(globalSearch, debounceSearch);

                return {
                    locations,
                    globalSearch,
                    columns,
                    sortColumn,
                    sortDirection,
                    currentPage,
                    totalPages,
                    paginatedLocations,
                    loading,
                    error,
                    sort,
                    changePage,
                    updateLocation,
                    debounceUpdate,
                    addNewLocation,
                    exportToCSV,
                    importFromCSV,
                    fetchLocations,
                    selectAll,
                    selectedLocations,
                    toggleSelectAll,
                    deleteSelected,
                    debounceSearch,
                    resetPagination,
                    setupChangeDetection,
                    stopChangeDetection
                };
            },
            template: `
                <div>
                    <h2>Locations <button @click="fetchLocations">Reload Locations</button></h2>
                    <div v-if="error" class="error">{{ error }}</div>
                    <div class="controls">
                        <input v-model="globalSearch" placeholder="Search locations..." @input="debounceSearch">
                        <!--<button @click="exportToCSV">Export to CSV</button>
                        <input type="file" @change="importFromCSV" accept=".csv">-->
                        <button @click="deleteSelected" :disabled="selectedLocations.length === 0">Delete Selected</button>
                    </div>
                    <div class="responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" v-model="selectAll" @change="toggleSelectAll"></th>
                                    <th v-for="column in columns" :key="column" @click="sort(column)">
                                        {{ column }}
                                        <span v-if="sortColumn === column">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="location in paginatedLocations" :key="location.id">
                                    <td><input type="checkbox" v-model="location.selected"></td>
                                    <td v-for="column in columns" :key="column">
                                        <input v-if="column !== 'hidden'" v-model="location[column]" @input="debounceUpdate(location)">
                                        <input v-else type="checkbox" v-model="location.hidden" @change="updateLocation(location)">
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button @click="currentPage > 1 && currentPage--" :disabled="currentPage === 1">Previous</button>
                        <span>Page {{ currentPage }} of {{ totalPages }}</span>
                        <button @click="currentPage < totalPages && currentPage++" :disabled="currentPage === totalPages">Next</button>
                    </div>
                    <button class="sticky-button" @click="addNewLocation">Add New Location</button>
                    <div v-if="loading" class="loading">Loading...</div>
                </div>
            `
        };

        app = createApp({
            components: {
                GroceriesPage,
                LocationsPage
            },
            setup() {
                const isSignedIn = ref(false);
                const user = ref(null);
                const sheetId = ref(null);
                const tokenClient = ref(null);
                const currentPage = ref('groceries');
                const pickerApiLoaded = ref(false);
                const loading = ref(false);
                const locationPageRef = ref(null);

                const CLIENT_ID = '778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com';
                const SCOPES = 'https://www.googleapis.com/auth/drive.file';

                const currentPageComponent = computed(() => {
                    return currentPage.value === 'groceries' ? GroceriesPage : LocationsPage;
                });

                function initializeGapiClient() {
                    gapi.client.init({
                        //apiKey: 'AIzaSyDjwvPH2It7i1feQRPTmQyY_yhNSG-1BmE',
                        //clientId: CLIENT_ID,
                        discoveryDocs: [
                            'https://sheets.googleapis.com/$discovery/rest?version=v4',
                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                        ],
                        scope: SCOPES
                    }).then(() => {
                        tokenClient.value = google.accounts.oauth2.initTokenClient({
                            client_id: CLIENT_ID,
                            scope: SCOPES,
                            callback: handleTokenResponse,
                            error_callback: (err) => {
                                console.error("Error during token client initialization:", err);
                            }
                        });
                    }).catch((error) => {
                        console.error("Error initializing gapi client:", error);
                    });
                }

                function handleCredentialResponse(response) {
                    console.log("Handling credential response in Vue app");
                    user.value = parseJwt(response.credential);
                    isSignedIn.value = true;
                    console.log("Signed in as: " + user.value.name);
                    if (tokenClient.value) {
                        tokenClient.value.requestAccessToken({prompt: 'consent'});
                    } else {
                        console.error('Token client not initialized');
                    }
                    checkForStoredSheet();
                }

                function handleTokenResponse(tokenResponse) {
                    if (tokenResponse && tokenResponse.access_token) {
                        gapi.client.setToken(tokenResponse);
                        checkForStoredSheet();
                    } else if (tokenResponse.error) {
                        console.error("Error during token response:", tokenResponse.error);
                    }
                }

                function parseJwt(token) {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    return JSON.parse(jsonPayload);
                }

                function checkForStoredSheet() {
                    const storedSheetId = localStorage.getItem('lastUsedSheetId');
                    if (storedSheetId) {
                        sheetId.value = storedSheetId;
                        setupChangeDetection();
                        // Proceed with loading data from the sheet
                    } else {
                        // User will need to create a new sheet or select one
                    }
                }

                async function createNewSheet() {
                    try {
                        const response = await gapi.client.sheets.spreadsheets.create({
                            properties: {
                                title: 'GroceriesApp'
                            },
                            sheets: [
                                {
                                    properties: {
                                        title: 'Groceries'
                                    }
                                },
                                {
                                    properties: {
                                        title: 'Locations'
                                    }
                                }
                            ]
                        });
                        sheetId.value = response.result.spreadsheetId;
                        localStorage.setItem('lastUsedSheetId', sheetId.value);
                        console.log('New sheet created:', sheetId.value);
                        await initializeNewSheet();
                    } catch (err) {
                        console.error('Error creating new sheet:', err);
                    }
                }

                async function initializeNewSheet() {
                    try {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Groceries!A1:H1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['id', 'title', 'amount', 'price', 'order', 'location', 'date_checked', 'date']]
                            }
                        });
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: sheetId.value,
                            range: 'Locations!A1:F1',
                            valueInputOption: 'RAW',
                            resource: {
                                values: [['title', 'order', 'id', 'hide_in_groceries', 'city', 'country']]
                            }
                        });
                        console.log('New sheet initialized');
                    } catch (err) {
                        console.error('Error initializing new sheet:', err);
                    }
                }

                function signOut() {
                    const token = gapi.client.getToken();
                    if (token !== null) {
                        google.accounts.oauth2.revoke(token.access_token);
                        gapi.client.setToken('');
                    }
                    isSignedIn.value = false;
                    user.value = null;
                    sheetId.value = null;
                    localStorage.removeItem('lastUsedSheetId');
                    stopChangeDetection();
                }

                function loadPickerApi() {
                    gapi.load('picker', { callback: onPickerApiLoad });
                }

                function onPickerApiLoad() {
                    pickerApiLoaded.value = true;
                }

                async function showPicker() {
                    if (!pickerApiLoaded.value) {
                        await new Promise((resolve) => {
                            loadPickerApi();
                            const checkLoaded = setInterval(() => {
                                if (pickerApiLoaded.value) {
                                    clearInterval(checkLoaded);
                                    resolve();
                                }
                            }, 100);
                        });
                    }

                    const token = gapi.client.getToken();
                    if (!token) {
                        console.error('No access token available');
                        return;
                    }

                    const view = new google.picker.DocsView(google.picker.ViewId.SPREADSHEETS)
                        .setIncludeFolders(true)
                        .setMimeTypes("application/vnd.google-apps.spreadsheet")
                        .setQuery("GroceriesApp");

                    const picker = new google.picker.PickerBuilder()
                        .enableFeature(google.picker.Feature.NAV_HIDDEN)
                        .setAppId('778093944102-hs9c9949mulivlrd17nh9vnbveblgc9v.apps.googleusercontent.com') // Replace with your actual App ID
                        .setOAuthToken(token.access_token)
                        .addView(view)
                        .setCallback(pickerCallback)
                        .build();

                    picker.setVisible(true);
                }

                async function pickerCallback(data) {
                    if (data.action === google.picker.Action.PICKED) {
                        const fileId = data.docs[0].id;
                        console.log('The user selected: ' + fileId);
                        
                        sheetId.value = fileId;
                        localStorage.setItem('lastUsedSheetId', fileId);
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        if (currentPageComponent.value === LocationsPage && locationPageRef.value) {
                            try {
                                await locationPageRef.value.fetchLocations();
                                setupChangeDetection();
                            } catch (error) {
                                console.error('Error fetching locations:', error);
                            }
                        }
                    }
                }

                // Load and init the gapi client
                gapi.load('client', initializeGapiClient);

                return {
                    isSignedIn,
                    user,
                    sheetId,
                    signOut,
                    currentPage,
                    currentPageComponent,
                    createNewSheet,
                    handleCredentialResponse,
                    showPicker,
                    locationPageRef,
                    loading,
                    pickerCallback
                };
            }
        });

        // Instead of accessing app._instance.exposed, we'll set the method directly on the app
        app.handleCredentialResponse = function(response) {
            // This will call the handleCredentialResponse function inside the component
            app._instance.proxy.handleCredentialResponse(response);
        };

        // Mount your app after ensuring Google APIs are loaded
        gapi.load('client', function() {
            gapi.client.init({
                discoveryDocs: [
                    'https://sheets.googleapis.com/$discovery/rest?version=v4',
                    'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                ],
            }).then(() => {
                app.mount('#app');
                initializeGoogleSignIn();
            });
        });
    })();
    </script>
</body>
</html>
