<!DOCTYPE html>
<html>
<head>
    <title>WebXR Multiplayer Driving Game</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }

        #speedometer {
            color: #ffffff;
            background-color: #990000;
            position: absolute;
            bottom: 0px;
            padding: 5px;
            z-index: 1000;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
            z-index: 1000;
        }

        #vrButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: #333;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
            font-size: 14px;
        }

        a {
            color: #a06851;
        }

        /* Desktop HUD Styles */
        #desktopHUD {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            min-width: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        #desktopHUD .hud-line {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        #desktopHUD .hud-label {
            color: #aaa;
            margin-right: 15px;
        }
        
        #desktopHUD .hud-value {
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
        /* Hide desktop HUD in VR */
        .vr-mode #desktopHUD {
            display: none;
        }
    </style>
</head>

<body>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>
    <div id="speedometer">0.0 km/h</div>
    
    <!-- Desktop HUD for non-VR users -->
    <div id="desktopHUD">
        <div class="hud-line">
            <span class="hud-label">LAP:</span>
            <span class="hud-value" id="desktopLapNumber">1</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">TIME:</span>
            <span class="hud-value" id="desktopCurrentTime">0:00.000</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">BEST:</span>
            <span class="hud-value" id="desktopBestTime">--:--.---</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">CHECKPOINT:</span>
            <span class="hud-value" id="desktopCheckpoint">0/0</span>
        </div>
    </div>
    <div id="info">WebXR Multiplayer Driving Game<br>WASD/VR Controllers to drive<br>C = Camera, Y = Reset</div>
    <button id="vrButton" style="display: none;">Enter VR</button>
    
    <!-- Background Music -->
    <audio id="backgroundMusic" loop preload="auto">
        <source src="audio/machina-tobias-voigt-main-version-19314-02-39.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://kripken.github.io/ammo.js/builds/ammo.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/Detector.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/OrbitControls.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/stats.min.js"></script>

    <script>
        Ammo().then(function (Ammo) {

            // Detects webgl
            if (!Detector.webgl) {
                Detector.addGetWebGLMessage();
                document.getElementById('container').innerHTML = "";
            }

            // - Global variables -
            var DISABLE_DEACTIVATION = 4;
            var TRANSFORM_AUX = new Ammo.btTransform();
            var ZERO_QUATERNION = new THREE.Quaternion(0, 0, 0, 1);

            // Graphics variables
            var container, stats, speedometer;
            var camera, controls, scene, renderer;
            var clock = new THREE.Clock();
            var materialDynamic, materialStatic, materialInteractive;

            // Physics variables
            var collisionConfiguration;
            var dispatcher;
            var broadphase;
            var solver;
            var physicsWorld;

            var syncList = [];
            var time = 0;
            var vehicleRef = null; // For reset functionality
            var raycastLines = []; // Visual debug lines for raycasting
            
            // Checkpoint system
            var playerCurrentCheckpoint = 1; // Next checkpoint to reach (1-based)
            var playerLastPassedCheckpoint = 0; // Last checkpoint passed (0-based)
            var nextCheckpointMarker = null;
            var checkpointMarkers = [];
            
            // Lap timing system
            var currentLapNumber = 1;
            var currentLapStartTime = 0;
            var currentLapTime = 0;
            var bestLapTime = null;
            var lapTimes = [];
            
            // LocalStorage key for best time
            var BEST_TIME_KEY = 'webxr-drive-best-time';
            
            // LOCALSTORAGE FUNCTIONS: Save and load best time
            function loadBestTime() {
                try {
                    var savedTime = localStorage.getItem(BEST_TIME_KEY);
                    if (savedTime !== null) {
                        bestLapTime = parseFloat(savedTime);
                        console.log('üíæ Loaded best time from storage:', formatLapTime(bestLapTime));
                        return bestLapTime;
                    }
                } catch (error) {
                    console.warn('Failed to load best time from localStorage:', error);
                }
                return null;
            }
            
            function saveBestTime(time) {
                try {
                    localStorage.setItem(BEST_TIME_KEY, time.toString());
                    console.log('üíæ Saved new best time to storage:', formatLapTime(time));
                } catch (error) {
                    console.warn('Failed to save best time to localStorage:', error);
                }
            }
            
            function clearBestTime() {
                try {
                    localStorage.removeItem(BEST_TIME_KEY);
                    bestLapTime = null;
                    console.log('üóëÔ∏è Cleared best time from storage');
                } catch (error) {
                    console.warn('Failed to clear best time from localStorage:', error);
                }
            }
            
            function formatLapTime(seconds) {
                if (seconds === null || seconds === undefined) return '--:--.---';
                var minutes = Math.floor(seconds / 60);
                var secs = (seconds % 60).toFixed(3);
                return minutes + ':' + (secs < 10 ? '0' : '') + secs;
            }
            
            // VR HUD elements
            var vrHUD = null;
            var lapNumberText = null;
            var currentTimeText = null;
            var bestTimeText = null;
            
            // Engine sound system
            var audioContext = null;
            var playerEngineSound = null;
            var botEngineSound = null;
            var backgroundMusic = null;
            var vrAudioStarted = false; // Track if VR audio has been started
            
            // Road and path system
            var racingPath = null;
            var roadMesh = null;
            var roadPhysicsBody = null; // Physics body for the road surface
            var pathPoints = [];
            var denseWaypoints = []; // Dense waypoints every 1-2m for bot navigation
            
            // Bot car system
            var botCar = null;
            var botVehicleRef = null;
            var botTargetMarker = null; // Visual marker for bot's current target

            // Keyboard actions
            var actions = {};
            var keysActions = {
                "KeyW": 'acceleration',
                "KeyS": 'braking',
                "KeyA": 'left',
                "KeyD": 'right'
            };

            // Camera modes
            var cameraMode = 'firstperson'; // Start in first person for VR
            var firstPersonCamera = null;
            var orbitCamera = null;
            var cameraRig = null; // Container for VR camera positioning
            
            // VR fly camera variables
            var vrFlySpeed = 10; // meters per second
            var vrFlyPosition = new THREE.Vector3(0, 5, -20); // Starting fly position
            var vrFlyRotation = new THREE.Euler(0, 0, 0); // Camera rotation in fly mode

            // - Functions -

            function initGraphics() {

                container = document.getElementById('container');
                speedometer = document.getElementById('speedometer');

                scene = new THREE.Scene();

                // Create camera rig for VR positioning
                cameraRig = new THREE.Group();
                scene.add(cameraRig);

                // Orbit camera (backup)
                orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
                orbitCamera.position.x = -4.84;
                orbitCamera.position.y = 4.39;
                orbitCamera.position.z = -35.11;
                orbitCamera.lookAt(new THREE.Vector3(0.33, -0.40, 0.85));
                
                // First person camera
                firstPersonCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Add first person camera to the rig for VR
                cameraRig.add(firstPersonCamera);
                
                // Start with first person camera for VR
                camera = firstPersonCamera;
                controls = new THREE.OrbitControls(orbitCamera);
                controls.enabled = false; // Disabled by default

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setClearColor(0xbfd1e5);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Enable WebXR
                renderer.xr.enabled = true;

                var ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(10, 10, 5);
                scene.add(dirLight);

                materialDynamic = new THREE.MeshPhongMaterial({ color: 0xfca400 });
                materialStatic = new THREE.MeshPhongMaterial({ color: 0x999999 });
                materialInteractive = new THREE.MeshPhongMaterial({ color: 0x990000 });

                container.innerHTML = "";
                container.appendChild(renderer.domElement);

                // VR Button setup
                setupVRButton();

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = '1000';
                container.appendChild(stats.domElement);

                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', keydown);
                window.addEventListener('keyup', keyup);
            }

            function setupVRButton() {
                const vrButton = document.getElementById('vrButton');
                
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            vrButton.style.display = 'block';
                            vrButton.style.background = '#006600';
                            console.log('VR supported');
                        }
                    });
                }
                
                vrButton.addEventListener('click', async () => {
                    if (renderer.xr.isPresenting) {
                        renderer.xr.getSession().end();
                    } else {
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', {
                                optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                            });
                            renderer.xr.setSession(session);
                            console.log('VR session started');
                            // Set up VR HUD when VR starts
                            setupVRHUD();
                            // Hide desktop HUD in VR mode
                            document.body.classList.add('vr-mode');
                            
                            // Start audio in VR session (VR counts as user interaction)
                            // Add a small delay to ensure audio system is ready
                            setTimeout(() => {
                                startEngineAudio();
                                console.log('üéµ VR audio started');
                            }, 100);
                            
                            // Listen for VR session end to restore desktop HUD
                            session.addEventListener('end', () => {
                                console.log('VR session ended');
                                document.body.classList.remove('vr-mode');
                                vrAudioStarted = false; // Reset for next VR session
                            });
                        } catch (error) {
                            console.error('VR not supported:', error);
                        }
                    }
                });
            }

            function onWindowResize() {
                // Update both cameras
                orbitCamera.aspect = window.innerWidth / window.innerHeight;
                orbitCamera.updateProjectionMatrix();
                
                firstPersonCamera.aspect = window.innerWidth / window.innerHeight;
                firstPersonCamera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function initPhysics() {
                // Physics configuration
                collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                broadphase = new Ammo.btDbvtBroadphase();
                solver = new Ammo.btSequentialImpulseConstraintSolver();
                physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0));
            }

            function tick() {
                // Use WebXR-compatible animation loop
                renderer.setAnimationLoop(() => {
                    var dt = clock.getDelta();
                    for (var i = 0; i < syncList.length; i++)
                        syncList[i](dt);
                    physicsWorld.stepSimulation(dt, 10);
                    
                    // Only update orbit controls when in orbit mode
                    if (cameraMode === 'orbit') {
                        controls.update(dt);
                    }
                    
                    renderer.render(scene, camera);
                    time += dt;
                    stats.update();
                });
            }

            function keyup(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = false;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }
            
            function keydown(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = true;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Camera switching with 'C' key
                if (e.code === 'KeyC') {
                    switchCamera();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Reset car with 'Y' key
                if (e.code === 'KeyY') {
                    resetCar();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }
            
            function setupVRHUD() {
                if (vrHUD) return; // Already created
                
                // Create HUD group
                vrHUD = new THREE.Group();
                
                // Position HUD in front of player (relative to camera rig)
                vrHUD.position.set(0, 0.3, -1.5); // Above and in front
                
                // Create canvas for text rendering
                var canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                var context = canvas.getContext('2d');
                
                // Create texture from canvas
                var hudTexture = new THREE.CanvasTexture(canvas);
                hudTexture.needsUpdate = true;
                
                // Create HUD plane
                var hudGeometry = new THREE.PlaneGeometry(1, 0.5);
                var hudMaterial = new THREE.MeshBasicMaterial({
                    map: hudTexture,
                    transparent: true,
                    opacity: 0.8
                });
                
                var hudMesh = new THREE.Mesh(hudGeometry, hudMaterial);
                vrHUD.add(hudMesh);
                
                // Store references for updating
                vrHUD.userData = {
                    canvas: canvas,
                    context: context,
                    texture: hudTexture
                };
                
                // Add HUD to camera rig so it follows the player
                cameraRig.add(vrHUD);
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                
                console.log('ü•Ω VR HUD created');
            }
            
            // ENGINE SOUND SYSTEM: Procedural engine sound generation
            class EngineSound {
                constructor(audioContext, baseFrequency = 80, volume = 0.3) {
                    this.audioContext = audioContext;
                    this.baseFrequency = baseFrequency;
                    this.volume = volume;
                    
                    // Create audio nodes
                    this.oscillator1 = null;
                    this.oscillator2 = null;
                    this.oscillator3 = null;
                    this.noiseBuffer = null;
                    this.noiseSource = null;
                    this.gainNode = null;
                    this.filterNode = null;
                    
                    this.isPlaying = false;
                    this.currentRPM = 800; // Idle RPM
                    
                    this.setupAudioNodes();
                }
                
                setupAudioNodes() {
                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    // Create filter for engine character
                    this.filterNode = this.audioContext.createBiquadFilter();
                    this.filterNode.type = 'lowpass';
                    this.filterNode.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    this.filterNode.Q.setValueAtTime(1, this.audioContext.currentTime);
                    
                    // Connect filter to gain to output
                    this.filterNode.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                    
                    // Create noise buffer for engine texture
                    this.createNoiseBuffer();
                }
                
                createNoiseBuffer() {
                    var bufferSize = this.audioContext.sampleRate * 2; // 2 seconds of noise
                    this.noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    var output = this.noiseBuffer.getChannelData(0);
                    
                    // Generate pink noise for engine texture
                    for (var i = 0; i < bufferSize; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.1;
                    }
                }
                
                start() {
                    if (this.isPlaying) return;
                    
                    // Create oscillators for engine harmonics
                    this.oscillator1 = this.audioContext.createOscillator();
                    this.oscillator2 = this.audioContext.createOscillator();
                    this.oscillator3 = this.audioContext.createOscillator();
                    
                    // Set oscillator types and frequencies
                    this.oscillator1.type = 'sawtooth';
                    this.oscillator2.type = 'square';
                    this.oscillator3.type = 'triangle';
                    
                    // Create gain nodes for each oscillator
                    var gain1 = this.audioContext.createGain();
                    var gain2 = this.audioContext.createGain();
                    var gain3 = this.audioContext.createGain();
                    
                    gain1.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gain2.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gain3.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    
                    // Connect oscillators
                    this.oscillator1.connect(gain1);
                    this.oscillator2.connect(gain2);
                    this.oscillator3.connect(gain3);
                    
                    gain1.connect(this.filterNode);
                    gain2.connect(this.filterNode);
                    gain3.connect(this.filterNode);
                    
                    // Add noise source
                    this.noiseSource = this.audioContext.createBufferSource();
                    this.noiseSource.buffer = this.noiseBuffer;
                    this.noiseSource.loop = true;
                    
                    var noiseGain = this.audioContext.createGain();
                    noiseGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    
                    this.noiseSource.connect(noiseGain);
                    noiseGain.connect(this.filterNode);
                    
                    // Start all sources
                    this.oscillator1.start();
                    this.oscillator2.start();
                    this.oscillator3.start();
                    this.noiseSource.start();
                    
                    // Fade in
                    this.gainNode.gain.setTargetAtTime(this.volume, this.audioContext.currentTime, 0.1);
                    
                    this.isPlaying = true;
                    this.updateFrequencies();
                }
                
                stop() {
                    if (!this.isPlaying) return;
                    
                    // Fade out
                    this.gainNode.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
                    
                    // Stop sources after fade out
                    setTimeout(() => {
                        if (this.oscillator1) {
                            this.oscillator1.stop();
                            this.oscillator2.stop();
                            this.oscillator3.stop();
                            this.noiseSource.stop();
                        }
                        this.isPlaying = false;
                    }, 200);
                }
                
                updateEngine(speed, throttle, rpm) {
                    if (!this.isPlaying) return;
                    
                    // Calculate RPM based on speed and throttle
                    var targetRPM = 800 + (speed * 50) + (throttle * 2000); // Idle + speed + throttle
                    targetRPM = Math.min(targetRPM, 6000); // Max RPM
                    
                    // Smooth RPM changes
                    this.currentRPM += (targetRPM - this.currentRPM) * 0.1;
                    
                    this.updateFrequencies();
                    this.updateVolume(throttle);
                }
                
                updateFrequencies() {
                    if (!this.isPlaying || !this.oscillator1) return;
                    
                    var baseFreq = this.baseFrequency * (this.currentRPM / 1000);
                    
                    // Set frequencies for harmonics
                    this.oscillator1.frequency.setTargetAtTime(baseFreq, this.audioContext.currentTime, 0.01);
                    this.oscillator2.frequency.setTargetAtTime(baseFreq * 2, this.audioContext.currentTime, 0.01);
                    this.oscillator3.frequency.setTargetAtTime(baseFreq * 0.5, this.audioContext.currentTime, 0.01);
                    
                    // Update filter frequency based on RPM
                    var filterFreq = 400 + (this.currentRPM / 10);
                    this.filterNode.frequency.setTargetAtTime(filterFreq, this.audioContext.currentTime, 0.01);
                }
                
                updateVolume(throttle) {
                    if (!this.isPlaying) return;
                    
                    var targetVolume = this.volume * (0.3 + throttle * 0.7); // Idle + throttle volume
                    this.gainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.05);
                }
            }
            
            function initAudioSystem() {
                try {
                    // Create audio context
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create engine sounds (lowered pitch and volume for music prominence)
                    playerEngineSound = new EngineSound(audioContext, 55, 0.15); // Player car (reduced volume from 0.4 to 0.15)
                    botEngineSound = new EngineSound(audioContext, 60, 0.08);    // Bot car (reduced volume from 0.2 to 0.08)
                    
                    // Initialize background music
                    backgroundMusic = document.getElementById('backgroundMusic');
                    if (backgroundMusic) {
                        backgroundMusic.volume = 0.6; // Set to 60% volume to be more prominent than engine sounds
                        
                        // Add error handling for audio loading
                        backgroundMusic.addEventListener('error', function(e) {
                            console.warn('üéµ Background music failed to load:', e);
                        });
                        
                        backgroundMusic.addEventListener('canplaythrough', function() {
                            console.log('üéµ Background music loaded successfully');
                        });
                        
                        console.log('üéµ Background music initialized');
                    }
                    
                    console.log('üîä Audio system initialized');
                    
                    // Start audio on first user interaction
                    var startAudioOnInteraction = function() {
                        startEngineAudio();
                        document.removeEventListener('click', startAudioOnInteraction);
                        document.removeEventListener('keydown', startAudioOnInteraction);
                        document.removeEventListener('touchstart', startAudioOnInteraction);
                    };
                    
                    document.addEventListener('click', startAudioOnInteraction);
                    document.addEventListener('keydown', startAudioOnInteraction);
                    document.addEventListener('touchstart', startAudioOnInteraction);
                    
                } catch (error) {
                    console.warn('Audio system not available:', error);
                }
            }

            // GLOBAL AUDIO CONTROL: Resume audio context and start engine sounds (requires user interaction)
            function startEngineAudio() {
                if (!audioContext || !playerEngineSound || !botEngineSound) {
                    console.warn('Audio system not initialized yet');
                    return;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playerEngineSound.start();
                        botEngineSound.start();
                        console.log('üîä Engine sounds started (resumed context)');
                        // Start background music
                        if (backgroundMusic) {
                            backgroundMusic.play().then(() => {
                                console.log('üéµ Background music started');
                            }).catch(error => {
                                console.warn('Background music failed to start:', error);
                            });
                        }
                    }).catch(error => {
                        console.warn('Failed to resume audio context:', error);
                    });
                } else {
                    playerEngineSound.start();
                    botEngineSound.start();
                    console.log('üîä Engine sounds started');
                    // Start background music
                    if (backgroundMusic) {
                        backgroundMusic.play().then(() => {
                            console.log('üéµ Background music started');
                        }).catch(error => {
                            console.warn('Background music failed to start:', error);
                        });
                    }
                }
            }

            function updateVRHUD() {
                if (!vrHUD || !vrHUD.userData) return;
                
                var canvas = vrHUD.userData.canvas;
                var context = vrHUD.userData.context;
                var texture = vrHUD.userData.texture;
                
                // Clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set up text styling
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = '#ffffff';
                context.font = 'bold 32px Arial';
                context.textAlign = 'left';
                
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Draw lap information
                var yPos = 50;
                var lineHeight = 40;
                
                // Lap number
                context.fillText('LAP: ' + currentLapNumber, 20, yPos);
                yPos += lineHeight;
                
                // Current lap time
                context.fillText('TIME: ' + formatTime(currentLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Best lap time
                context.fillText('BEST: ' + formatTime(bestLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Checkpoint progress
                var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                context.fillText('CHECKPOINT: ' + currentCheckpoint + '/' + totalCheckpoints, 20, yPos);
                yPos += lineHeight;
                
                // Update texture
                texture.needsUpdate = true;
            }

            // DESKTOP HUD UPDATE: Update desktop HUD with same info as VR HUD
            function updateDesktopHUD() {
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                } else {
                    console.warn('‚ö†Ô∏è Desktop HUD: currentLapStartTime not initialized:', currentLapStartTime);
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Update desktop HUD elements
                var lapElement = document.getElementById('desktopLapNumber');
                var timeElement = document.getElementById('desktopCurrentTime');
                var bestElement = document.getElementById('desktopBestTime');
                var checkpointElement = document.getElementById('desktopCheckpoint');
                
                if (lapElement) lapElement.textContent = currentLapNumber;
                if (timeElement) timeElement.textContent = formatTime(currentLapTime);
                if (bestElement) bestElement.textContent = formatTime(bestLapTime);
                
                // Update checkpoint progress
                if (checkpointElement) {
                    var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                    var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                    if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                    checkpointElement.textContent = currentCheckpoint + '/' + totalCheckpoints;
                }
            }

            function switchCamera() {
                if (renderer.xr.isPresenting) {
                    // VR mode: cycle through firstperson -> fly -> firstperson
                    if (cameraMode === 'firstperson') {
                        cameraMode = 'fly';
                        // Initialize fly camera position if not set
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            vrFlyPosition.copy(vehicleRef.chassisMesh.position);
                            vrFlyPosition.y += 10; // Start 10m above the car
                        } else {
                            // Fallback position if car not ready yet
                            vrFlyPosition.set(0, 15, -20);
                        }
                        // Reset rotation when entering fly mode
                        vrFlyRotation.set(0, 0, 0);
                        console.log('Switched to VR fly camera');
                    } else if (cameraMode === 'fly') {
                        cameraMode = 'firstperson';
                        console.log('Switched to VR first-person camera');
                    } else {
                        // From orbit to firstperson in VR
                        cameraMode = 'firstperson';
                        cameraRig.remove(orbitCamera);
                        cameraRig.add(firstPersonCamera);
                        console.log('Switched to VR first-person camera');
                    }
                } else {
                    // Desktop mode: cycle through firstperson -> orbit -> firstperson
                    if (cameraMode === 'orbit') {
                        cameraMode = 'firstperson';
                        camera = firstPersonCamera;
                        controls.enabled = false; // Disable orbit controls in first person
                        
                        console.log('Switched to first-person camera');
                    } else {
                        cameraMode = 'orbit';
                        camera = orbitCamera;
                        controls.enabled = true; // Re-enable orbit controls
                        
                        console.log('Switched to orbit camera');
                    }
                }
            }

            function resetCar() {
                if (vehicleRef && vehicleRef.vehicle && vehicleRef.vehicleBody) {
                    try {
                        // Reset to last passed checkpoint
                        var resetPosition;
                        console.log('üîç Reset Debug - Checkpoints:', checkpointMarkers ? checkpointMarkers.length : 'null', 'LastPassed:', playerLastPassedCheckpoint, 'Current:', playerCurrentCheckpoint);
                        
                        if (checkpointMarkers && checkpointMarkers.length > 0 && playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) {
                            var checkpoint = checkpointMarkers[playerLastPassedCheckpoint];
                            if (checkpoint && checkpoint.position) {
                                resetPosition = checkpoint.position.clone();
                                // Get the actual road surface elevation at this X,Z position
                                var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                
                                // Safety check: if calculated elevation is much lower than checkpoint, use checkpoint + extra height
                                var checkpointY = checkpoint.position.y;
                                if (actualRoadElevation < checkpointY - 10) {
                                    console.warn('‚ö†Ô∏è Calculated road elevation seems too low, using checkpoint elevation + safety margin');
                                    resetPosition.y = checkpointY + 2; // 2m above checkpoint position for safety
                                } else {
                                    resetPosition.y = actualRoadElevation + 1; // 1m above calculated road surface
                                }
                                console.log('üöó Resetting to checkpoint', playerLastPassedCheckpoint);
                                console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                console.log('   Calculated road elevation:', actualRoadElevation.toFixed(1));
                                console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                            } else {
                                console.warn('Checkpoint', playerLastPassedCheckpoint, 'has no position data, using default');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        } else {
                            // If checkpoints exist but playerLastPassedCheckpoint is invalid, use checkpoint 0
                            if (checkpointMarkers && checkpointMarkers.length > 0) {
                                console.warn('Invalid playerLastPassedCheckpoint, using checkpoint 0');
                                var checkpoint = checkpointMarkers[0];
                                if (checkpoint && checkpoint.position) {
                                    resetPosition = checkpoint.position.clone();
                                    var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                    var checkpointY = checkpoint.position.y;
                                    if (actualRoadElevation < checkpointY - 10) {
                                        resetPosition.y = checkpointY + 2;
                                    } else {
                                        resetPosition.y = actualRoadElevation + 1;
                                    }
                                    console.log('üöó Resetting to checkpoint 0 (fallback)');
                                    console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                    console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                                } else {
                                    console.warn('Checkpoint 0 has no position data, using default position');
                                    resetPosition = new THREE.Vector3(0, 0, -20);
                                    var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                    resetPosition.y = defaultRoadElevation + 1;
                                }
                            } else {
                                console.warn('No valid checkpoints available, using default position');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        }
                        
                        // Calculate orientation toward next checkpoint
                        var resetRotation = new THREE.Quaternion(0, 0, 0, 1); // Default rotation
                        if (checkpointMarkers && checkpointMarkers.length > 0) {
                            // Use valid checkpoint index for orientation calculation
                            var currentCheckpointIndex = (playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) ? playerLastPassedCheckpoint : 0;
                            var nextCheckpointIndex = (currentCheckpointIndex + 1) % checkpointMarkers.length;
                            var nextCheckpoint = checkpointMarkers[nextCheckpointIndex];
                            if (nextCheckpoint && nextCheckpoint.position) {
                                // Calculate direction to next checkpoint
                                var direction = new THREE.Vector3().subVectors(nextCheckpoint.position, resetPosition);
                                direction.y = 0; // Keep horizontal
                                direction.normalize();
                                
                                // Calculate rotation to face that direction
                                var angle = Math.atan2(direction.x, direction.z);
                                resetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                                
                                console.log('üß≠ Player respawn facing toward checkpoint', nextCheckpointIndex, 'from current', currentCheckpointIndex);
                            }
                        }
                        
                        var resetTransform = new Ammo.btTransform();
                        resetTransform.setIdentity();
                        resetTransform.setOrigin(new Ammo.btVector3(resetPosition.x, resetPosition.y, resetPosition.z));
                        resetTransform.setRotation(new Ammo.btQuaternion(resetRotation.x, resetRotation.y, resetRotation.z, resetRotation.w));
                        
                        vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                        vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                        vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                        
                        console.log('‚úÖ Car reset successfully to position:', resetPosition);
                    } catch (error) {
                        console.error('‚ùå Error during car reset:', error);
                        // Fallback to default position
                        try {
                            var fallbackPosition = new THREE.Vector3(0, 0, -20);
                            var fallbackRoadElevation = getRoadSurfaceElevation(0, -20);
                            fallbackPosition.y = fallbackRoadElevation + 1; // 1m above road surface
                            var resetTransform = new Ammo.btTransform();
                            resetTransform.setIdentity();
                            resetTransform.setOrigin(new Ammo.btVector3(fallbackPosition.x, fallbackPosition.y, fallbackPosition.z));
                            // Use default forward orientation for fallback
                            resetTransform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));
                            
                            vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                            vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                            vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                            
                            console.log('üîÑ Fallback reset to default position successful');
                        } catch (fallbackError) {
                            console.error('‚ùå Fallback reset also failed:', fallbackError);
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è Cannot reset car: vehicle reference not available');
                }
            }
            
            function checkCheckpointProgress(carPosition) {
                if (!checkpointMarkers || checkpointMarkers.length === 0) return;
                
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                // Check if player is close enough to the next checkpoint
                var distance = carPosition.distanceTo(checkpoint.position);
                if (distance < 15) { // 15 meter detection radius
                    // Checkpoint passed!
                    playerLastPassedCheckpoint = playerCurrentCheckpoint;
                    playerCurrentCheckpoint++;
                    
                    console.log('‚úÖ Checkpoint', nextIndex, 'passed! Last:', playerLastPassedCheckpoint, 'Next:', playerCurrentCheckpoint);
                    
                    // Update visual indicator
                    updateNextCheckpointMarker();
                    
                    // Check for lap completion (when we've passed all checkpoints)
                    if (playerCurrentCheckpoint >= checkpointMarkers.length) {
                        // Lap completed!
                        var lapTime = (Date.now() - currentLapStartTime) / 1000;
                        lapTimes.push(lapTime);
                        
                        // Check if it's a new best time
                        if (bestLapTime === null || lapTime < bestLapTime) {
                            bestLapTime = lapTime;
                            saveBestTime(lapTime); // Save to localStorage
                            console.log('üèÜ NEW BEST LAP TIME!', formatLapTime(lapTime));
                        } else {
                            console.log('üèÅ LAP COMPLETED!', formatLapTime(lapTime));
                        }
                        
                        // Start new lap
                        currentLapNumber++;
                        currentLapStartTime = Date.now();
                        playerLastPassedCheckpoint = 0; // Reset checkpoint progress for new lap
                        playerCurrentCheckpoint = 1; // Reset current checkpoint to 1 (next checkpoint to reach)
                        
                        console.log('Starting lap', currentLapNumber, '- checkpoint progress reset to 0, next checkpoint: 1');
                    }
                }
                
                // Update pulsing animation for next checkpoint marker
                if (nextCheckpointMarker && nextCheckpointMarker.userData) {
                    nextCheckpointMarker.userData.pulseTime += 0.1;
                    var scale = 1 + 0.3 * Math.sin(nextCheckpointMarker.userData.pulseTime);
                    nextCheckpointMarker.scale.setScalar(scale);
                }
                
                // Update HUD displays
                if (renderer.xr.isPresenting) {
                    updateVRHUD(); // VR users see 3D HUD
                } else {
                    updateDesktopHUD(); // Desktop users see HTML HUD
                }
            }

            function createBox(pos, quat, w, l, h, mass, friction) {
                var material = mass > 0 ? materialDynamic : materialStatic;
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5));

                if (!mass) mass = 0;
                if (!friction) friction = 1;

                var mesh = new THREE.Mesh(shape, material);
                mesh.position.copy(pos);
                mesh.quaternion.copy(quat);
                scene.add(mesh);

                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);

                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(mass, localInertia);

                var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, geometry, localInertia);
                var body = new Ammo.btRigidBody(rbInfo);

                body.setFriction(friction);
                physicsWorld.addRigidBody(body);

                if (mass > 0) {
                    body.setActivationState(DISABLE_DEACTIVATION);
                    // Sync physics and graphics
                    function sync(dt) {
                        var ms = body.getMotionState();
                        if (ms) {
                            ms.getWorldTransform(TRANSFORM_AUX);
                            var p = TRANSFORM_AUX.getOrigin();
                            var q = TRANSFORM_AUX.getRotation();
                            mesh.position.set(p.x(), p.y(), p.z());
                            mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                        }
                    }
                    syncList.push(sync);
                }
            }

            function createWheelMesh(radius, width) {
                var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                t.rotateZ(Math.PI / 2);
                var mesh = new THREE.Mesh(t, materialInteractive);
                mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), materialInteractive));
                scene.add(mesh);
                return mesh;
            }

            function createChassisMesh(w, l, h) {
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var mesh = new THREE.Mesh(shape, materialInteractive);
                scene.add(mesh);
                return mesh;
            }

            function createBotVehicle(pos, quat, color) {
                // Vehicle constants (same as player car)
                var chassisWidth = 1.8;
                var chassisHeight = .6;
                var chassisLength = 4;
                var massVehicle = 800;

                var wheelAxisPositionBack = -1;
                var wheelRadiusBack = .4;
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1;
                var wheelAxisHeightBack = .3;

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1;
                var wheelAxisHeightFront = .3;
                var wheelRadiusFront = .35;
                var wheelWidthFront = .2;

                var friction = 1000;
                var suspensionStiffness = 20.0;
                var suspensionDamping = 2.3;
                var suspensionCompression = 4.4;
                var suspensionRestLength = 0.6;
                var rollInfluence = 0.2;

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2000;
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Ensure the bot body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                
                // Create bot chassis mesh with different color
                var botMaterial = new THREE.MeshPhongMaterial({ color: color || 0x0066ff });
                var chassisShape = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                var chassisMesh = new THREE.Mesh(chassisShape, botMaterial);
                scene.add(chassisMesh);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store bot vehicle reference
                var botRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh,
                    currentWaypointIndex: 0,
                    targetSpeed: 60, // km/h
                    waypointReachDistance: 8.0, // Distance to consider waypoint "reached" (increased)
                    debugCounter: 0,
                    // Predictive steering parameters
                    lookAheadWaypoints: 5, // Number of waypoints to look ahead
                    steeringSmoothing: 0.15, // Steering smoothing factor (0-1)
                    previousSteering: 0, // For smooth steering transitions
                    // Dynamic speed parameters
                    maxCornerSpeed: 80, // km/h - maximum speed through corners
                    brakingDistance: 25, // meters - distance to start braking before corners
                    cornerSpeedFactor: 0.6, // Speed reduction factor for tight corners
                    // Stuck detection parameters
                    lastPosition: new THREE.Vector3(-5, 0, -45), // Track last position
                    lastWaypointReached: 0, // Last successfully reached waypoint
                    stuckCheckInterval: 180, // Check every 3 seconds (60fps * 3)
                    stuckDistanceThreshold: 2.0, // If moved less than 2m in 3 seconds
                    stuckSpeedThreshold: 5.0, // If speed is below 5 km/h for too long
                    lowSpeedCounter: 0, // Counter for low speed duration
                    stuckCounter: 0, // Counter for stuck detection
                    lastRespawnTime: 0, // Prevent rapid respawning
                    // Obstacle avoidance parameters
                    avoidanceRayLength: 15, // meters - how far ahead to look for obstacles
                    avoidanceForce: 0.8, // Steering force when avoiding obstacles
                    sideRayAngle: 30, // degrees - angle for side detection rays
                    obstacleAvoidanceActive: false // Track if currently avoiding
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                
                var wheelMeshes = [];
                
                // Create visual target marker (10m high green column)
                var markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 8);
                var markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, // Bright green
                    transparent: true,
                    opacity: 0.8
                });
                botTargetMarker = new THREE.Mesh(markerGeometry, markerMaterial);
                botTargetMarker.position.set(0, 5, 0); // 5m high (half of 10m cylinder)
                scene.add(botTargetMarker);
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    // Create wheel mesh with bot color
                    var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                    t.rotateZ(Math.PI / 2);
                    var mesh = new THREE.Mesh(t, botMaterial);
                    mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), botMaterial));
                    scene.add(mesh);
                    wheelMeshes[index] = mesh;
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Bot AI sync function
                function botSync(dt) {
                    botRef.debugCounter++;
                    var speed = vehicle.getCurrentSpeedKmHour();

                    // Get current car position
                    var tm = vehicle.getChassisWorldTransform();
                    var p = tm.getOrigin();
                    var q = tm.getRotation();
                    var carPos = new THREE.Vector3(p.x(), p.y(), p.z());
                    var carQuat = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());

                    // Update chassis mesh
                    chassisMesh.position.set(p.x(), p.y(), p.z());
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());

                    // Update wheel meshes
                    var n = vehicle.getNumWheels();
                    for (var i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        var wheelTm = vehicle.getWheelTransformWS(i);
                        var wheelP = wheelTm.getOrigin();
                        var wheelQ = wheelTm.getRotation();
                        wheelMeshes[i].position.set(wheelP.x(), wheelP.y(), wheelP.z());
                        wheelMeshes[i].quaternion.set(wheelQ.x(), wheelQ.y(), wheelQ.z(), wheelQ.w());
                    }


                    // Initialize forces
                    breakingForce = 0;
                    engineForce = 0;

                    // AI Navigation Logic - Advanced Predictive System
                    if (denseWaypoints.length > 0) {
                        // Get current target waypoint
                        var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                        var targetPoint = targetWaypoint.position;
                        
                        // Check if we've reached the current waypoint
                        var distanceToWaypoint = carPos.distanceTo(targetPoint);
                        
                        if (distanceToWaypoint < botRef.waypointReachDistance) {
                            // Move to next waypoint
                            var oldIndex = botRef.currentWaypointIndex;
                            botRef.lastWaypointReached = oldIndex; // Track last successful waypoint
                            botRef.currentWaypointIndex = (botRef.currentWaypointIndex + 1) % denseWaypoints.length;
                            // Only log lap completion (when reaching waypoint 0 again)
                            if (botRef.currentWaypointIndex === 0) {
                                console.log('üèÅ Bot completed a lap!');
                            }
                            targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                            targetPoint = targetWaypoint.position;
                            distanceToWaypoint = carPos.distanceTo(targetPoint);
                            
                            // Reset stuck detection counters on successful waypoint reach
                            botRef.stuckCounter = 0;
                            botRef.lowSpeedCounter = 0;
                        }

                        // Get car's forward direction (positive Z is forward in our coordinate system)
                        var carForward = new THREE.Vector3(0, 0, 1);
                        carForward.applyQuaternion(carQuat);

                        // OBSTACLE AVOIDANCE: Check for obstacles and calculate avoidance steering
                        var avoidanceResult = checkObstacles(carPos, carQuat, carForward, speed, botRef);
                        
                        var finalSteerAmount;
                        if (avoidanceResult.shouldAvoid) {
                            // SMART OBSTACLE AVOIDANCE: Check if we should reverse or steer around
                            var distanceFromPath = findDistanceFromPath(carPos, botRef);
                            var maxPathDeviation = 15.0; // Maximum distance allowed from racing line
                            var obstacleDistance = avoidanceResult.closestDistance;
                            
                            // If obstacle is very close and we're already far from path, consider reversing
                            if (obstacleDistance < 8.0 && distanceFromPath > maxPathDeviation) {
                                console.log('üîÑ OBSTACLE TOO CLOSE & FAR FROM PATH! Reversing to find alternate route');
                                finalSteerAmount = 0; // Don't steer while reversing
                                targetSpeedKmh = -20; // Reverse at 20 km/h
                                shouldBrake = false; // Don't brake while reversing
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If obstacle is blocking and we have multiple hits (surrounded), reverse
                            else if (avoidanceResult.multipleHits && obstacleDistance < 10.0) {
                                console.log('üö´ SURROUNDED BY OBSTACLES! Reversing to escape');
                                finalSteerAmount = avoidanceResult.avoidanceSteer * 0.5; // Gentle steering while reversing
                                targetSpeedKmh = -15; // Reverse slower when surrounded
                                shouldBrake = false;
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If we're close to path, try normal steering avoidance
                            else if (distanceFromPath < maxPathDeviation) {
                                console.log('üöß STEERING AROUND OBSTACLE! Steer:', avoidanceResult.avoidanceSteer.toFixed(2), 'Distance:', obstacleDistance.toFixed(1) + 'm');
                                finalSteerAmount = avoidanceResult.avoidanceSteer;
                                targetSpeedKmh = Math.min(targetSpeedKmh, 25); // Slow down while avoiding
                                botRef.obstacleAvoidanceActive = true;
                            }
            // If too far from path, return to path first
            else {
                console.log('üìç TOO FAR FROM PATH! Returning to racing line first');
                try {
                    // Calculate direction back to nearest path point
                    var nearestPathPoint = findNearestPathPoint(carPos);
                    if (nearestPathPoint && nearestPathPoint.point) {
                        var backToPath = new THREE.Vector3().subVectors(nearestPathPoint.point, carPos).normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, backToPath);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 1.5));
                        targetSpeedKmh = Math.min(targetSpeedKmh, 30); // Moderate speed returning to path
                        botRef.obstacleAvoidanceActive = true;
                    } else {
                        // Fallback: use normal path following if nearest point not found
                        var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                        var toTarget = new THREE.Vector3().subVectors(lookAheadPoint, carPos);
                        var toTargetNormalized = toTarget.clone().normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 2.0));
                        botRef.obstacleAvoidanceActive = false;
                    }
                } catch (e) {
                    console.warn('Error calculating return to path:', e);
                    // Fallback to normal navigation
                    finalSteerAmount = 0;
                    botRef.obstacleAvoidanceActive = false;
                }
            }
                        } else {
                            // PREDICTIVE STEERING: Look ahead multiple waypoints
                            var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                            
                            // Calculate steering toward look-ahead point
                            var toTarget = new THREE.Vector3()
                                .subVectors(lookAheadPoint, carPos);
                            
                            var toTargetNormalized = toTarget.clone().normalize();

                            // Calculate raw steering using cross product
                            var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                            var rawSteerAmount = cross.y; // Raw steering direction (fixed with correct forward vector)
                            
                            finalSteerAmount = Math.max(-1.0, Math.min(1.0, rawSteerAmount * 2.0));
                            botRef.obstacleAvoidanceActive = false;
                        }
                        
                        // STEERING SMOOTHING: Blend with previous steering for realistic transitions
                        var steerAmount = botRef.previousSteering + (finalSteerAmount - botRef.previousSteering) * botRef.steeringSmoothing;
                        botRef.previousSteering = steerAmount;

                        // Apply smoothed steering
                        vehicleSteering = steerAmount;
                        
                        // Update visual target marker to show where bot is heading
                        if (botTargetMarker) {
                            botTargetMarker.position.set(targetPoint.x, 5, targetPoint.z);
                        }

                        // DYNAMIC SPEED CONTROL: Analyze upcoming corners and adjust speed
                        var speedAnalysis = calculateOptimalSpeed(carPos, speed, botRef);
                        var targetSpeedKmh = speedAnalysis.targetSpeed;
                        var shouldBrake = speedAnalysis.shouldBrake;

                        // Apply throttle/brake - always try to move forward
                        breakingForce = 0;
                        engineForce = 0;

                        var absSpeed = Math.abs(speed);
                        
                        // REALISTIC BRAKING AND ACCELERATION
                        if (shouldBrake || absSpeed > targetSpeedKmh + 3) {
                            // Brake for corners or overspeed
                            var brakeIntensity = shouldBrake ? 0.8 : 0.6;
                            breakingForce = maxBreakingForce * brakeIntensity;
                            engineForce = 0;
                        } else if (absSpeed < targetSpeedKmh - 3) {
                            // Accelerate when under target speed
                            var accelIntensity = (targetSpeedKmh - absSpeed) / targetSpeedKmh;
                            engineForce = maxEngineForce * Math.min(0.9, accelIntensity + 0.3);
                            breakingForce = 0;
                        } else if (absSpeed < 5) {
                            // If moving very slowly, give it a push
                            engineForce = maxEngineForce * 0.5;
                            breakingForce = 0;
                        } else {
                            // Maintain speed - slight throttle
                            engineForce = maxEngineForce * 0.2;
                            breakingForce = 0;
                        }

                        // STUCK DETECTION AND RECOVERY SYSTEM
                        var stuckDetected = checkIfStuck(carPos, speed, botRef);
                        if (stuckDetected) {
                            respawnBot(botRef);
                        }

                        // Minimal debug output - only show important events
                        if (botRef.debugCounter % 600 === 0) { // Every 10 seconds instead of 5
                            var status = 'üèéÔ∏è Bot: ' + speed.toFixed(0) + 'km/h | WP:' + botRef.currentWaypointIndex + '/' + denseWaypoints.length;
                            if (botRef.stuckCounter > 0) status += ' ‚ö†Ô∏è STUCK:' + botRef.stuckCounter;
                            console.log(status);
                        }
                    } else {
                        // No racing path - simple forward movement for testing
                        if (botRef.debugCounter % 180 === 0) {
                            console.log('Bot: No racing path found, applying basic forward movement');
                        }
                        engineForce = maxEngineForce * 0.8; // More throttle
                        vehicleSteering = 0; // Straight
                    }

                    // Apply forces to vehicle
                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);
                    
                    // Update bot engine sound
                    if (botEngineSound) {
                        var throttle = Math.abs(engineForce) / maxEngineForce; // Normalize throttle (0-1)
                        var speedKmh = Math.abs(speed);
                        botEngineSound.updateEngine(speedKmh, throttle);
                    }
                    
                }

                // PREDICTIVE STEERING: Calculate look-ahead point based on speed and upcoming corners
                function calculateLookAheadPoint(carPos, speed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(speed);
                    
                    // Dynamic look-ahead distance based on speed (faster = look further ahead)
                    var baseLookAhead = Math.max(2, Math.min(8, absSpeed / 10)); // 2-8 waypoints
                    var lookAheadCount = Math.floor(baseLookAhead);
                    
                    // Find the look-ahead waypoint
                    var lookAheadIndex = (currentIndex + lookAheadCount) % denseWaypoints.length;
                    var lookAheadWaypoint = denseWaypoints[lookAheadIndex];
                    
                    // RACING LINE OPTIMIZATION: Adjust target point for optimal cornering
                    var optimizedPoint = calculateRacingLine(lookAheadWaypoint, lookAheadIndex, botRef);
                    
                    return optimizedPoint;
                }
                
                // RACING LINE: Calculate optimal path through corners
                function calculateRacingLine(waypoint, waypointIndex, botRef) {
                    var basePoint = waypoint.position.clone();
                    
                    // Analyze corner by looking at surrounding waypoints
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner direction and sharpness
                    var inVector = new THREE.Vector3().subVectors(basePoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, basePoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // If it's a corner (angle > threshold), optimize the racing line
                    if (cornerAngle > 0.3) { // ~17 degrees
                        // Calculate corner center and radius
                        var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                        var offsetDistance = Math.min(4, cornerSharpness * 6); // Max 4m offset
                        
                        // Determine if it's a left or right corner
                        var cross = new THREE.Vector3().crossVectors(inVector, outVector);
                        var isLeftCorner = cross.y > 0;
                        
                        // Calculate perpendicular offset for racing line
                        var perpendicular = new THREE.Vector3(-inVector.z, 0, inVector.x);
                        if (!isLeftCorner) perpendicular.multiplyScalar(-1);
                        
                        // Apply racing line offset (late apex)
                        basePoint.add(perpendicular.multiplyScalar(offsetDistance * 0.7));
                    }
                    
                    return basePoint;
                }
                
                // DYNAMIC SPEED CONTROL: Calculate optimal speed based on upcoming corners
                function calculateOptimalSpeed(carPos, currentSpeed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(currentSpeed);
                    var maxSpeed = botRef.targetSpeed;
                    var shouldBrake = false;
                    
                    // Look ahead for corners within braking distance
                    var lookAheadDistance = 0;
                    var minCornerSpeed = maxSpeed;
                    
                    for (var i = 0; i < 15; i++) { // Check next 15 waypoints (~30m ahead)
                        var checkIndex = (currentIndex + i) % denseWaypoints.length;
                        var waypoint = denseWaypoints[checkIndex];
                        
                        if (i > 0) {
                            var prevWaypoint = denseWaypoints[(currentIndex + i - 1) % denseWaypoints.length];
                            lookAheadDistance += waypoint.position.distanceTo(prevWaypoint.position);
                        }
                        
                        // Analyze corner sharpness
                        var cornerSpeed = analyzeCornerSpeed(checkIndex, botRef);
                        
                        if (cornerSpeed < minCornerSpeed) {
                            minCornerSpeed = cornerSpeed;
                            
                            // If we need to slow down significantly and we're within braking distance
                            if (absSpeed > cornerSpeed + 10 && lookAheadDistance < botRef.brakingDistance) {
                                shouldBrake = true;
                            }
                        }
                        
                        // Stop looking if we're far enough ahead
                        if (lookAheadDistance > botRef.brakingDistance) break;
                    }
                    
                    // Calculate target speed
                    var targetSpeed = Math.max(minCornerSpeed, maxSpeed * 0.4); // Minimum 40% of max speed
                    
                    // Smooth speed transitions
                    if (targetSpeed < absSpeed) {
                        targetSpeed = Math.max(targetSpeed, absSpeed - 15); // Don't brake too hard
                    }
                    
                    return {
                        targetSpeed: targetSpeed,
                        shouldBrake: shouldBrake,
                        cornerSpeed: minCornerSpeed
                    };
                }
                
                // Analyze corner speed based on turn radius and sharpness
                function analyzeCornerSpeed(waypointIndex, botRef) {
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var currentPoint = denseWaypoints[waypointIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner angle
                    var inVector = new THREE.Vector3().subVectors(currentPoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, currentPoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // Calculate safe corner speed based on angle
                    var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                    var baseCornerSpeed = botRef.maxCornerSpeed;
                    
                    if (cornerSharpness > 0.1) { // If it's actually a corner
                        // Sharper corners = slower speeds
                        var speedReduction = Math.pow(cornerSharpness, 0.7); // Smooth curve
                        baseCornerSpeed *= (1.0 - speedReduction * botRef.cornerSpeedFactor);
                    }
                    
                    return Math.max(baseCornerSpeed, 20); // Minimum 20 km/h
                }
                
                // STUCK DETECTION: Check if bot is stuck and needs respawning
                function checkIfStuck(currentPos, currentSpeed, botRef) {
                    var absSpeed = Math.abs(currentSpeed);
                    var currentTime = botRef.debugCounter;
                    
                    // Prevent rapid respawning (minimum 10 seconds between respawns)
                    if (currentTime - botRef.lastRespawnTime < 600) {
                        return false;
                    }
                    
                    // Get target waypoint for vertical position checking
                    var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                    var stuckByElevation = false;
                    
                    if (targetWaypoint) {
                        // Check if bot is at significantly wrong elevation
                        var targetY = targetWaypoint.position.y;
                        var currentY = currentPos.y;
                        var verticalDistance = Math.abs(currentY - targetY);
                        
                        // If bot is more than 8 meters above or below target elevation
                        if (verticalDistance > 8) {
                            botRef.verticalStuckCounter = (botRef.verticalStuckCounter || 0) + 1;
                            
                            // If stuck at wrong elevation for 5 seconds
                            if (botRef.verticalStuckCounter > 300) {
                                console.log('üèîÔ∏è Bot stuck at wrong elevation! Current Y:', currentY.toFixed(1), 'Target Y:', targetY.toFixed(1), 'Diff:', verticalDistance.toFixed(1) + 'm');
                                stuckByElevation = true;
                            }
                        } else {
                            botRef.verticalStuckCounter = 0; // Reset if elevation is good
                        }
                    }
                    
                    // Check if speed is too low for too long
                    if (absSpeed < botRef.stuckSpeedThreshold) {
                        botRef.lowSpeedCounter++;
                    } else {
                        botRef.lowSpeedCounter = 0; // Reset if speed is good
                    }
                    
                    // Check position movement every interval
                    if (botRef.debugCounter % botRef.stuckCheckInterval === 0) {
                        var distanceMoved = currentPos.distanceTo(botRef.lastPosition);
                        
                        // If bot hasn't moved much in the check interval
                        if (distanceMoved < botRef.stuckDistanceThreshold) {
                            botRef.stuckCounter++;
                            // Reduced stuck detection logging
                        } else {
                            botRef.stuckCounter = 0; // Reset if moving well
                        }
                        
                        // Update last position for next check
                        botRef.lastPosition.copy(currentPos);
                    }
                    
                    // Declare stuck if:
                    // 1. Low speed for more than 5 seconds (300 frames)
                    // 2. OR not moving for 2 consecutive checks (6 seconds)
                    // 3. OR wrong elevation for more than 5 seconds
                    var stuckBySpeed = botRef.lowSpeedCounter > 300;
                    var stuckByPosition = botRef.stuckCounter >= 2;
                    
                    if (stuckBySpeed || stuckByPosition || stuckByElevation) {
                        var reason = stuckByElevation ? 'WRONG ELEVATION' : 
                                   stuckBySpeed ? 'LOW SPEED' : 'NO MOVEMENT';
                        console.log('üö® Bot STUCK (' + reason + ') - Respawning...');
                        return true;
                    }
                    
                    return false;
                }
                
                // RESPAWN BOT: Teleport bot to last reached waypoint with correct orientation
                function respawnBot(botRef) {
                    // Get respawn waypoint (last successfully reached waypoint)
                    var respawnWaypoint = denseWaypoints[botRef.lastWaypointReached];
                    var respawnPos = respawnWaypoint.position.clone();
                    
                    // Get the actual road surface elevation at this position
                    var actualRoadElevation = getRoadSurfaceElevation(respawnPos.x, respawnPos.z);
                    
                    // Safety check: if calculated elevation is much lower than waypoint, use waypoint + extra height
                    var waypointY = respawnWaypoint.position.y;
                    if (actualRoadElevation < waypointY - 10) {
                        console.warn('‚ö†Ô∏è Bot: Calculated road elevation seems too low, using waypoint elevation + safety margin');
                        respawnPos.y = waypointY + 2; // 2m above waypoint position for safety
                    } else {
                        respawnPos.y = actualRoadElevation + 1; // 1m above calculated road surface
                    }
                    
                    // Calculate orientation toward next waypoint
                    var nextWaypointIndex = (botRef.lastWaypointReached + 1) % denseWaypoints.length;
                    var nextWaypoint = denseWaypoints[nextWaypointIndex];
                    var directionToNext = new THREE.Vector3()
                        .subVectors(nextWaypoint.position, respawnPos)
                        .normalize();
                    
                    // Calculate rotation quaternion to face next waypoint
                    // Use Y-axis rotation (yaw) to face the target direction
                    var targetAngle = Math.atan2(directionToNext.x, directionToNext.z);
                    var quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    
                    console.log('üß≠ Bot respawn facing toward waypoint', nextWaypointIndex);
                    
                    // Apply respawn transform to physics body
                    var transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin(new Ammo.btVector3(respawnPos.x, respawnPos.y, respawnPos.z));
                    transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
                    
                    // Reset physics body
                    botRef.vehicleBody.setWorldTransform(transform);
                    botRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.activate(); // Wake up the physics body
                    
                    // Reset bot state
                    botRef.currentWaypointIndex = nextWaypointIndex;
                    botRef.stuckCounter = 0;
                    botRef.lowSpeedCounter = 0;
                    botRef.lastRespawnTime = botRef.debugCounter;
                    botRef.previousSteering = 0; // Reset steering smoothing
                    
                    console.log('üîÑ Bot respawned at waypoint', nextWaypointIndex);
                }
                
                // HELPER FUNCTION: Calculate distance from racing path
                function findDistanceFromPath(carPos, botRef) {
                    if (!denseWaypoints || denseWaypoints.length === 0) return 0;
                    
                    try {
                        var nearestPoint = findNearestPathPoint(carPos);
                        if (!nearestPoint || !nearestPoint.point) return 0;
                        return carPos.distanceTo(nearestPoint.point);
                    } catch (e) {
                        console.warn('Error calculating distance from path:', e);
                        return 0;
                    }
                }
                
                // VISUAL RAYCAST DEBUG: Create visible lines to show raycast directions
                function createRaycastVisuals() {
                    // Clear existing raycast lines
                    raycastLines.forEach(line => {
                        scene.remove(line);
                    });
                    raycastLines = [];
                }
                
                function addRaycastLine(start, end, color, hit) {
                    var geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                    var material = new THREE.LineBasicMaterial({ 
                        color: color,
                        linewidth: hit ? 3 : 1,
                        transparent: true,
                        opacity: hit ? 0.9 : 0.5
                    });
                    var line = new THREE.Line(geometry, material);
                    scene.add(line);
                    raycastLines.push(line);
                    
                    // Add a small sphere at hit point if there's a hit
                    if (hit) {
                        var sphereGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        var sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
                        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        sphere.position.copy(end);
                        scene.add(sphere);
                        raycastLines.push(sphere);
                    }
                }

                // OBSTACLE AVOIDANCE: Raycast-based obstacle detection
                function checkObstacles(carPos, carQuat, carForward, speed, botRef) {
                    var rayLength = botRef.avoidanceRayLength;
                    var shouldAvoid = false;
                    var avoidanceSteer = 0;
                    var closestDistance = rayLength;
                    
                    // Clear previous raycast visuals
                    createRaycastVisuals();
                    
                    // Create rays: forward, left, right
                    var rays = [
                        { direction: carForward.clone(), weight: 1.0, name: 'forward' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'left' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'right' }
                    ];
                    
                    var obstacleDetected = false;
                    var avoidanceDirection = 0; // -1 = left, +1 = right
                    var debugInfo = [];
                    var totalHits = 0;
                    
                    // Cast rays and check for collisions
                    for (var i = 0; i < rays.length; i++) {
                        var ray = rays[i];
                        var rayStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                        var rayEnd = new Ammo.btVector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayCallback = new Ammo.ClosestRayResultCallback(rayStart, rayEnd);
                        physicsWorld.rayTest(rayStart, rayEnd, rayCallback);
                        
                        var hitDetected = rayCallback.hasHit();
                        
                        // Visual debugging - create lines for each ray
                        var startPos = new THREE.Vector3(carPos.x, carPos.y, carPos.z);
                        var endPos = new THREE.Vector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayColor = 0x00ff00; // Green for no hit
                        var actualHitPos = endPos;
                        
                        if (hitDetected) {
                            // Check if the hit object is the road surface
                            var hitBody = rayCallback.get_m_collisionObject();
                            var isRoadHit = (roadPhysicsBody && hitBody.a === roadPhysicsBody.a);
                            
                            var hitPoint = rayCallback.get_m_hitPointWorld();
                            var hitDistance = Math.sqrt(
                                Math.pow(hitPoint.x() - carPos.x, 2) + 
                                Math.pow(hitPoint.y() - carPos.y, 2) + 
                                Math.pow(hitPoint.z() - carPos.z, 2)
                            );
                            
                            // Update visual end position to hit point
                            actualHitPos = new THREE.Vector3(hitPoint.x(), hitPoint.y(), hitPoint.z());
                            
                            if (isRoadHit) {
                                // Road hit - ignore for obstacle avoidance but show in debug
                                debugInfo.push(ray.name + ':ROAD-' + hitDistance.toFixed(1) + 'm');
                                rayColor = 0x888888; // Gray for road hits
                            } else {
                                totalHits++;
                                debugInfo.push(ray.name + ':' + hitDistance.toFixed(1) + 'm');
                                
                                // Ignore hits that are too close (probably the car itself) or road surface
                                if (hitDistance > 1.5 && hitDistance < rayLength) {
                                obstacleDetected = true;
                                shouldAvoid = true;
                                rayColor = 0xff0000; // Red for obstacle hit
                                
                                // Calculate avoidance based on which ray hit
                                if (ray.name === 'forward') {
                                    avoidanceDirection += (Math.random() > 0.5) ? 1 : -1;
                                } else if (ray.name === 'left') {
                                    avoidanceDirection += 1.0;
                                } else if (ray.name === 'right') {
                                    avoidanceDirection -= 1.0;
                                }
                                
                                if (hitDistance < closestDistance) {
                                    closestDistance = hitDistance;
                                }
                                } else {
                                    rayColor = 0xffff00; // Yellow for hit but ignored (too close/far)
                                }
                            }
                        }
                        
                        // Add visual ray line
                        addRaycastLine(startPos, actualHitPos, rayColor, hitDetected);
                        
                        // Clean up Ammo objects
                        Ammo.destroy(rayStart);
                        Ammo.destroy(rayEnd);
                        Ammo.destroy(rayCallback);
                    }
                    
                    // Debug raycast hits every 300 frames
                    if (botRef.debugCounter % 300 === 0) {
                        if (totalHits > 0) {
                            console.log('üéØ Raycast hits detected:', debugInfo.join(', '));
                        } else {
                            console.log('üîç No raycast hits detected - all rays clear');
                        }
                        
                        // Check if player car is nearby but not detected
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            var playerPos = vehicleRef.chassisMesh.position;
                            var distanceToPlayer = carPos.distanceTo(playerPos);
                            if (distanceToPlayer < rayLength) {
                                console.log('‚ö†Ô∏è Player car nearby at', distanceToPlayer.toFixed(1) + 'm but not detected by raycast!');
                                
                                // Test if we can raycast directly to player
                                var dirToPlayer = new THREE.Vector3().subVectors(playerPos, carPos).normalize();
                                var testStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                                var testEnd = new Ammo.btVector3(
                                    carPos.x + dirToPlayer.x * distanceToPlayer,
                                    carPos.y,
                                    carPos.z + dirToPlayer.z * distanceToPlayer
                                );
                                
                                var testCallback = new Ammo.ClosestRayResultCallback(testStart, testEnd);
                                physicsWorld.rayTest(testStart, testEnd, testCallback);
                                
                                if (testCallback.hasHit()) {
                                    console.log('‚úÖ Direct raycast TO player: HIT detected');
                                } else {
                                    console.log('‚ùå Direct raycast TO player: NO HIT - player car has no physics body for raycast!');
                                }
                                
                                Ammo.destroy(testStart);
                                Ammo.destroy(testEnd);
                                Ammo.destroy(testCallback);
                            }
                        }
                    }
                    
                    // Calculate final avoidance steering
                    if (shouldAvoid) {
                        var urgency = Math.max(0.3, 1.0 - (closestDistance / rayLength));
                        avoidanceSteer = Math.sign(avoidanceDirection) * botRef.avoidanceForce * urgency;
                        avoidanceSteer = Math.max(-1.0, Math.min(1.0, avoidanceSteer));
                        
                        console.log('üöß OBSTACLE DETECTED! Distance:', closestDistance.toFixed(1) + 'm, Steer:', avoidanceSteer.toFixed(2), '|', debugInfo.join(', '));
                    }
                    
                    return {
                        shouldAvoid: shouldAvoid,
                        avoidanceSteer: avoidanceSteer,
                        closestDistance: closestDistance,
                        obstacleDetected: obstacleDetected,
                        multipleHits: totalHits >= 2 // True if multiple rays hit obstacles
                    };
                }
                

                syncList.push(botSync);
                return botRef;
            }

            function createVehicle(pos, quat) {
                // Vehicle constants
                var chassisWidth = 1.8;
                var chassisHeight = .6;
                var chassisLength = 4;
                var massVehicle = 800;

                var wheelAxisPositionBack = -1;
                var wheelRadiusBack = .4;
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1;
                var wheelAxisHeightBack = .3;

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1;
                var wheelAxisHeightFront = .3;
                var wheelRadiusFront = .35;
                var wheelWidthFront = .2;

                var friction = 1000;
                var suspensionStiffness = 20.0;
                var suspensionDamping = 2.3;
                var suspensionCompression = 4.4;
                var suspensionRestLength = 0.6;
                var rollInfluence = 0.2;

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2000;
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Ensure the player body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                var chassisMesh = createChassisMesh(chassisWidth, chassisHeight, chassisLength);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store vehicle reference for reset
                vehicleRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                var wheelMeshes = [];
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    wheelMeshes[index] = createWheelMesh(radius, width);
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Sync keyboard/VR actions and physics and graphics
                function sync(dt) {
                    var speed = vehicle.getCurrentSpeedKmHour();
                    speedometer.innerHTML = (speed < 0 ? '(R) ' : '') + Math.abs(speed).toFixed(1) + ' km/h';
                    
                    // Check for checkpoint progress
                    if (chassisMesh) {
                        checkCheckpointProgress(chassisMesh.position);
                    }
                    
                    // Update player engine sound
                    if (playerEngineSound) {
                        var throttle = Math.abs(engineForce) / 1500; // Normalize throttle (0-1)
                        var speedKmh = Math.abs(speed);
                        playerEngineSound.updateEngine(speedKmh, throttle);
                    }

                    breakingForce = 0;
                    engineForce = 0;

                    // Get VR controller input
                    var vrSteering = 0;
                    var vrAcceleration = 0;
                    var vrBraking = 0;
                    
                    if (renderer.xr.isPresenting) {
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                            for (let i = 0; i < session.inputSources.length; i++) {
                                const inputSource = session.inputSources[i];
                                const gamepad = inputSource.gamepad;
                                
                                if (gamepad && inputSource.handedness === 'right') {
                                    // Start audio on first VR controller interaction
                                    if (!vrAudioStarted && gamepad.buttons) {
                                        for (let j = 0; j < gamepad.buttons.length; j++) {
                                            if (gamepad.buttons[j] && gamepad.buttons[j].pressed) {
                                                startEngineAudio();
                                                vrAudioStarted = true;
                                                console.log('üéµ VR audio started via controller button press');
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Thumbstick for steering
                                    if (gamepad.axes && gamepad.axes.length >= 4) {
                                        vrSteering = gamepad.axes[2] || 0;
                                    }
                                    
                                    // Trigger for acceleration
                                    if (gamepad.buttons && gamepad.buttons[0]) {
                                        vrAcceleration = gamepad.buttons[0].value || 0;
                                    }
                                    
                                    // Grip for braking
                                    if (gamepad.buttons && gamepad.buttons[1]) {
                                        vrBraking = gamepad.buttons[1].value || 0;
                                    }
                                    
                                    // A button (index 4) for camera switching
                                    if (gamepad.buttons && gamepad.buttons[4] && gamepad.buttons[4].pressed) {
                                        // Prevent rapid switching with a simple debounce
                                        if (!this.lastCameraSwitchTime || (Date.now() - this.lastCameraSwitchTime) > 500) {
                                            switchCamera();
                                            this.lastCameraSwitchTime = Date.now();
                                        }
                                    }
                                    
                                    // Y button (index 3) for car reset
                                    if (gamepad.buttons && gamepad.buttons[3] && gamepad.buttons[3].pressed) {
                                        if (!this.lastResetTime || (Date.now() - this.lastResetTime) > 500) {
                                            resetCar();
                                            this.lastResetTime = Date.now();
                                        }
                                    }
                                    
                                    // VR Fly Camera Controls (when in fly mode)
                                    if (cameraMode === 'fly') {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Right thumbstick: X = strafe left/right, Y = forward/back movement (KEEP WORKING)
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var moveX = gamepad.axes[2] || 0; // Right thumbstick X = strafe
                                            var moveZ = gamepad.axes[3] || 0; // Right thumbstick Y = forward/back
                                            
                                            // Create movement vectors relative to current rotation
                                            var forward = new THREE.Vector3(0, 0, -1);
                                            var right = new THREE.Vector3(1, 0, 0);
                                            
                                            // Apply current Y rotation to movement vectors
                                            forward.applyEuler(vrFlyRotation);
                                            right.applyEuler(vrFlyRotation);
                                            
                                            // Apply movement
                                            vrFlyPosition.add(right.multiplyScalar(moveX * flyDelta));
                                            vrFlyPosition.add(forward.multiplyScalar(-moveZ * flyDelta));
                                        }
                                        
                                        // Trigger buttons for up/down movement
                                        if (gamepad.buttons && gamepad.buttons[0]) {
                                            var upMovement = gamepad.buttons[0].value || 0;
                                            vrFlyPosition.y += upMovement * flyDelta;
                                        }
                                        
                                        if (gamepad.buttons && gamepad.buttons[1]) {
                                            var downMovement = gamepad.buttons[1].value || 0;
                                            vrFlyPosition.y -= downMovement * flyDelta;
                                        }
                                        
                                        // Apply bounds to prevent flying too far
                                        vrFlyPosition.x = Math.max(-200, Math.min(200, vrFlyPosition.x));
                                        vrFlyPosition.y = Math.max(1, Math.min(100, vrFlyPosition.y)); // 1m to 100m height
                                        vrFlyPosition.z = Math.max(-200, Math.min(200, vrFlyPosition.z));
                                    }
                                }
                                
                                if (gamepad && inputSource.handedness === 'left') {
                                    // LEFT CONTROLLER - VR Fly Camera Controls (rotation and up/down)
                                    console.log('üéÆ Left controller detected in fly mode');
                                    if (cameraMode === 'fly') {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Left controller thumbstick: X = rotation, Y = up/down movement
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var rotateY = gamepad.axes[2] || 0; // Left thumbstick X = Y rotation
                                            var moveY = gamepad.axes[3] || 0;   // Left thumbstick Y = vertical movement
                                            
                                            // Debug logging
                                            if (Math.abs(rotateY) > 0.1 || Math.abs(moveY) > 0.1) {
                                                console.log('üéÆ Left controller - Rotate:', rotateY.toFixed(2), 'MoveY:', moveY.toFixed(2));
                                            }
                                            
                                            // Apply Y rotation (turning left/right) - inverted for natural feel
                                            vrFlyRotation.y -= rotateY * rotationSpeed * dt;
                                            
                                            // Apply vertical movement (up/down)
                                            vrFlyPosition.y -= moveY * flyDelta; // Inverted for natural feel
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Combine keyboard and VR input
                    var acceleration = actions.acceleration || (vrAcceleration > 0.1);
                    var braking = actions.braking || (vrBraking > 0.1);
                    var left = actions.left || (vrSteering < -0.1);
                    var right = actions.right || (vrSteering > 0.1);

                    // Calculate speed-dependent steering - less responsive at high speeds
                    var absSpeed = Math.abs(speed);
                    var speedFactor = Math.max(0.2, 1.0 - (absSpeed / 80)); // Reduce steering at speeds above 80 km/h
                    var steeringIncrement = baseSteeringIncrement * speedFactor;
                    
                    // Also reduce steering clamp at high speeds for more realistic handling
                    var dynamicSteeringClamp = steeringClamp * speedFactor;

                    if (acceleration) {
                        if (speed < -1)
                            breakingForce = maxBreakingForce;
                        else engineForce = maxEngineForce;
                    }
                    if (braking) {
                        if (speed > 1)
                            breakingForce = maxBreakingForce;
                        else engineForce = -maxEngineForce / 2;
                    }
                    
                    // Improved steering logic with speed-dependent response
                    if (left) {
                        if (vehicleSteering < dynamicSteeringClamp)
                            vehicleSteering += steeringIncrement;
                    }
                    else if (right) {
                        if (vehicleSteering > -dynamicSteeringClamp)
                            vehicleSteering -= steeringIncrement;
                    }
                    else {
                        // Return to center more gradually for better control
                        var returnRate = steeringIncrement * 1.5; // Slightly faster return to center
                        if (vehicleSteering < -returnRate) {
                            vehicleSteering += returnRate;
                        } else if (vehicleSteering > returnRate) {
                            vehicleSteering -= returnRate;
                        } else {
                            vehicleSteering = 0;
                        }
                    }

                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);

                    var tm, p, q, i;
                    var n = vehicle.getNumWheels();
                    for (i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        tm = vehicle.getWheelTransformWS(i);
                        p = tm.getOrigin();
                        q = tm.getRotation();
                        wheelMeshes[i].position.set(p.x(), p.y(), p.z());
                        wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }

                    tm = vehicle.getChassisWorldTransform();
                    p = tm.getOrigin();
                    q = tm.getRotation();
                    chassisMesh.position.set(p.x(), p.y(), p.z());
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());

                    // Update camera position (works for both desktop and VR)
                    if (cameraMode === 'firstperson') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Move the camera rig (which contains the VR camera)
                            var cameraOffset = new THREE.Vector3(0, 1.4, 1.2); // x, y(up), z(forward)
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            
                            // Rotate 180 degrees around Y axis to face forward
                            var forwardRotation = new THREE.Quaternion();
                            forwardRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                            carQuaternion.multiply(forwardRotation);
                            
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            cameraRig.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            cameraRig.quaternion.copy(carQuaternion);
                        } else {
                            // In Desktop: Move the first person camera directly
                            var cameraOffset = new THREE.Vector3(0, 1.4, 1.2); // x, y(up), z(forward)
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            firstPersonCamera.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            
                            // Make camera look forward relative to car
                            var lookDirection = new THREE.Vector3(0, 0, 5); // Look forward
                            lookDirection.applyQuaternion(carQuaternion);
                            var lookTarget = firstPersonCamera.position.clone().add(lookDirection);
                            firstPersonCamera.lookAt(lookTarget);
                        }
                    } else if (cameraMode === 'fly') {
                        if (renderer.xr.isPresenting) {
                            // VR Fly Camera: Position camera rig at fly position
                            cameraRig.position.copy(vrFlyPosition);
                            // Apply fly camera rotation (Y-axis rotation from thumbstick)
                            cameraRig.rotation.copy(vrFlyRotation);
                        }
                        // Fly mode is VR-only
                    } else if (cameraMode === 'orbit') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Position orbit camera in the rig
                            cameraRig.position.set(p.x() - 4.84, p.y() + 4.39, p.z() - 35.11);
                            var lookTarget = new THREE.Vector3(p.x(), p.y(), p.z());
                            cameraRig.lookAt(lookTarget);
                        }
                        // Desktop orbit camera is handled by OrbitControls
                    }
                }

                syncList.push(sync);
            }

            function createRacingPath() {
                // Define control points using the reference track layout
                const curvePoints = [
                    -6, 0, 10,
                    -1, 0, 10,
                     3, 0,  4,
                     6, 0,  1,
                    11, 0,  2,
                    13, 0,  6,
                     9, 1,  9,
                     4, 1,  7,
                     1, 1,  1,
                     0, 1, -5,
                     2, 0, -9,
                     8, 0,-10,
                    13, 0, -5,
                    14, 1,  2,
                    10, 3,  7,
                     2, 1,  8,
                    -4, 3,  7,
                    -8, 1,  1,
                    -9, 1, -4,
                    -6, 1, -9,
                     0, 1,-10,
                     7, 1, -7,
                     5, 2,  0,
                     0, 2,  2,
                    -5, 1,  0,
                    -7, 2, -5,
                    -8, 2, -9,
                   -11, 2,-10,
                   -14, 1, -7,
                   -13, 1, -2,
                   -14, 0,  3,
                   -11, 0, 10,
                    -6, 0, 10
                ];
                
                // Convert curvePoints array to Vector3 points with elevation smoothing
                var rawPoints = [];
                for (let i = 0; i < curvePoints.length; i += 3) {
                    rawPoints.push(new THREE.Vector3(
                        curvePoints[i] * 4,     // Scale up X by 4x
                        curvePoints[i + 1] * 6, // 6x Y for dramatic but manageable elevation
                        curvePoints[i + 2] * 4  // Scale up Z by 4x
                    ));
                }
                
                // Apply elevation smoothing to prevent overly steep sections
                pathPoints = [];
                for (let i = 0; i < rawPoints.length; i++) {
                    var point = rawPoints[i].clone();
                    
                    // Smooth elevation using weighted average with neighbors
                    if (i > 0 && i < rawPoints.length - 1) {
                        var prevY = rawPoints[i - 1].y;
                        var currentY = rawPoints[i].y;
                        var nextY = rawPoints[i + 1].y;
                        
                        // Calculate maximum allowed slope (in meters per horizontal unit)
                        var maxSlope = 0.3; // 30% grade maximum
                        var prevDist = rawPoints[i].distanceTo(rawPoints[i - 1]);
                        var nextDist = rawPoints[i].distanceTo(rawPoints[i + 1]);
                        
                        // Limit elevation change based on horizontal distance
                        var maxPrevChange = prevDist * maxSlope;
                        var maxNextChange = nextDist * maxSlope;
                        
                        // Clamp elevation changes
                        if (Math.abs(currentY - prevY) > maxPrevChange) {
                            currentY = prevY + Math.sign(currentY - prevY) * maxPrevChange;
                        }
                        if (Math.abs(nextY - currentY) > maxNextChange) {
                            currentY = nextY - Math.sign(nextY - currentY) * maxNextChange;
                        }
                        
                        // Apply additional smoothing (weighted average)
                        point.y = currentY * 0.6 + (prevY + nextY) * 0.2;
                    }
                    
                    pathPoints.push(point);
                }

                // Create smooth racing path using CatmullRom curve
                racingPath = new THREE.CatmullRomCurve3(pathPoints, true); // true = closed loop

                // Generate dense waypoints for bot navigation
                createDenseWaypoints();

                // Create visual road mesh
                createRoadMesh();
                
                // Create path markers for debugging/visualization (HIDDEN)
                // createPathMarkers();
                
                // Create checkpoint system (HIDDEN VISUALS, DATA ONLY)
                createCheckpointData();
                
                console.log('Racing path created with', pathPoints.length, 'control points and', denseWaypoints.length, 'dense waypoints');
            }

            function createDenseWaypoints() {
                denseWaypoints = [];
                
                // Calculate total path length
                var pathLength = racingPath.getLength();
                var waypointSpacing = 2.0; // 2 meters between waypoints
                var numWaypoints = Math.floor(pathLength / waypointSpacing);
                
                console.log('Creating', numWaypoints, 'waypoints with', waypointSpacing, 'm spacing along', pathLength.toFixed(1), 'm track');
                
                // Generate waypoints at regular intervals
                for (var i = 0; i < numWaypoints; i++) {
                    var t = i / numWaypoints; // Parameter from 0 to 1
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    denseWaypoints.push({
                        position: point,
                        direction: tangent,
                        index: i,
                        t: t
                    });
                }
                
                // Add visual markers for waypoints (every 10th waypoint to avoid clutter) - HIDDEN
                /*
                for (var i = 0; i < denseWaypoints.length; i += 10) {
                    var waypoint = denseWaypoints[i];
                    var markerGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                    var markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff // Cyan for waypoints
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(waypoint.position);
                    marker.position.y = 1; // Above ground
                    scene.add(marker);
                }
                */
                
                // Debug first few waypoints
                console.log('First 5 waypoints:');
                for (var i = 0; i < Math.min(5, denseWaypoints.length); i++) {
                    var wp = denseWaypoints[i];
                    console.log('Waypoint', i + ':', 
                        '(' + wp.position.x.toFixed(1) + ', ' + wp.position.z.toFixed(1) + ')',
                        'direction:', '(' + wp.direction.x.toFixed(2) + ', ' + wp.direction.z.toFixed(2) + ')'
                    );
                }
            }

            function createRoadMesh() {
                var roadWidth = 14; // 14 meter wide road as requested
                var borderWidth = 0.4; // 40cm white borders on each side
                var totalWidth = roadWidth + (borderWidth * 2); // Road + borders
                var segments = 800; // Very high resolution for maximum smoothness
                
                // Get points along the curve
                var pathPoints = [];
                var pathDirections = [];
                
                for (var i = 0; i <= segments; i++) {
                    var t = i / segments;
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    pathPoints.push(point);
                    pathDirections.push(tangent);
                }
                
                // Create road geometry as a flat surface
                var roadGeometry = new THREE.BufferGeometry();
                var vertices = [];
                var indices = [];
                var uvs = [];
                
                // Generate vertices for road surface with corner smoothing
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    
                    // Apply aggressive direction smoothing with wider window
                    var smoothDirection = direction.clone();
                    if (i > 1 && i < pathPoints.length - 2) {
                        var prevDir2 = pathDirections[i - 2];
                        var prevDir1 = pathDirections[i - 1];
                        var nextDir1 = pathDirections[i + 1];
                        var nextDir2 = pathDirections[i + 2];
                        
                        // 5-point weighted average for ultra-smooth transitions
                        smoothDirection = prevDir2.clone().multiplyScalar(0.1)
                            .add(prevDir1.clone().multiplyScalar(0.2))
                            .add(direction.clone().multiplyScalar(0.4))
                            .add(nextDir1.clone().multiplyScalar(0.2))
                            .add(nextDir2.clone().multiplyScalar(0.1));
                        smoothDirection.normalize();
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point average for edge cases
                        var prevDir = pathDirections[i - 1];
                        var nextDir = pathDirections[i + 1];
                        smoothDirection.add(prevDir).add(nextDir).divideScalar(3);
                        smoothDirection.normalize();
                    }
                    
                    // Calculate perpendicular vector (road width direction)
                    var perpendicular = new THREE.Vector3(-smoothDirection.z, 0, smoothDirection.x).normalize();
                    
                    // Create points for road with borders
                    var halfTotalWidth = totalWidth / 2;
                    var halfRoadWidth = roadWidth / 2;
                    
                    // Outer edges (including borders)
                    var leftBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(halfTotalWidth));
                    var leftBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(halfRoadWidth));
                    var rightBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(-halfRoadWidth));
                    var rightBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(-halfTotalWidth));
                    
                    // Apply aggressive elevation smoothing to eliminate bumps
                    var smoothY = point.y;
                    if (i > 2 && i < pathPoints.length - 3) {
                        // 7-point smoothing for ultra-smooth elevation transitions
                        var y_m3 = pathPoints[i - 3].y;
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        var y_p3 = pathPoints[i + 3].y;
                        
                        // Gaussian-like weighted average for maximum smoothness
                        smoothY = y_m3 * 0.05 + y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.3 + y_p1 * 0.2 + y_p2 * 0.1 + y_p3 * 0.05;
                    } else if (i > 1 && i < pathPoints.length - 2) {
                        // 5-point smoothing for edge areas
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        
                        smoothY = y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.4 + y_p1 * 0.2 + y_p2 * 0.1;
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point smoothing for corners
                        var prevY = pathPoints[i - 1].y;
                        var nextY = pathPoints[i + 1].y;
                        smoothY = prevY * 0.25 + point.y * 0.5 + nextY * 0.25;
                    }
                    
                    var roadThickness = 0.2; // 20cm thickness
                    
                    // Add TOP vertices (from left to right: outer border, inner border, inner border, outer border)
                    vertices.push(leftBorderOuter.x, smoothY + 0.05, leftBorderOuter.z);   // Left border outer
                    vertices.push(leftBorderInner.x, smoothY + 0.05, leftBorderInner.z);   // Left border inner (road edge)
                    vertices.push(rightBorderInner.x, smoothY + 0.05, rightBorderInner.z); // Right border inner (road edge)
                    vertices.push(rightBorderOuter.x, smoothY + 0.05, rightBorderOuter.z); // Right border outer
                    
                    // Add BOTTOM vertices (same order) - 20cm below top
                    vertices.push(leftBorderOuter.x, smoothY + 0.05 - roadThickness, leftBorderOuter.z);
                    vertices.push(leftBorderInner.x, smoothY + 0.05 - roadThickness, leftBorderInner.z);
                    vertices.push(rightBorderInner.x, smoothY + 0.05 - roadThickness, rightBorderInner.z);
                    vertices.push(rightBorderOuter.x, smoothY + 0.05 - roadThickness, rightBorderOuter.z);
                    
                    // Add UV coordinates for all 8 vertices per segment
                    // Top vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                    // Bottom vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                }
                
                // Create triangular faces for thick road with borders
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 8; // 8 vertices per segment now
                    
                    // TOP SURFACE - Left Border (2 triangles)
                    indices.push(base, base + 1, base + 8);      // Triangle 1
                    indices.push(base + 1, base + 9, base + 8);  // Triangle 2
                    
                    // TOP SURFACE - Main Road (2 triangles)
                    indices.push(base + 1, base + 2, base + 9);   // Triangle 1
                    indices.push(base + 2, base + 10, base + 9);  // Triangle 2
                    
                    // TOP SURFACE - Right Border (2 triangles)
                    indices.push(base + 2, base + 3, base + 10);  // Triangle 1
                    indices.push(base + 3, base + 11, base + 10); // Triangle 2
                    
                    // BOTTOM SURFACE - Left Border (2 triangles)
                    indices.push(base + 4, base + 12, base + 5);  // Triangle 1
                    indices.push(base + 5, base + 12, base + 13); // Triangle 2
                    
                    // BOTTOM SURFACE - Main Road (2 triangles)
                    indices.push(base + 5, base + 13, base + 6);  // Triangle 1
                    indices.push(base + 6, base + 13, base + 14); // Triangle 2
                    
                    // BOTTOM SURFACE - Right Border (2 triangles)
                    indices.push(base + 6, base + 14, base + 7);  // Triangle 1
                    indices.push(base + 7, base + 14, base + 15); // Triangle 2
                    
                    // SIDE FACES
                    // Left outer edge
                    indices.push(base, base + 8, base + 4);       // Triangle 1
                    indices.push(base + 8, base + 12, base + 4);  // Triangle 2
                    
                    // Right outer edge
                    indices.push(base + 3, base + 7, base + 11);  // Triangle 1
                    indices.push(base + 7, base + 15, base + 11); // Triangle 2
                }
                
                // Set geometry attributes
                roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                roadGeometry.setIndex(indices);
                roadGeometry.computeVertexNormals();
                
                // Create texture for road with white borders
                var canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 1;
                var ctx = canvas.getContext('2d');
                
                // Create gradient: white borders, gray road
                var gradient = ctx.createLinearGradient(0, 0, 256, 0);
                gradient.addColorStop(0, '#ffffff');    // Left border - white
                gradient.addColorStop(0.2, '#ffffff');  // Left border - white
                gradient.addColorStop(0.2, '#333333');  // Road start - gray
                gradient.addColorStop(0.8, '#333333');  // Road end - gray
                gradient.addColorStop(0.8, '#ffffff');  // Right border - white
                gradient.addColorStop(1, '#ffffff');    // Right border - white
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 256, 1);
                
                var roadTexture = new THREE.CanvasTexture(canvas);
                roadTexture.wrapS = THREE.ClampToEdgeWrapping;
                roadTexture.wrapT = THREE.RepeatWrapping;
                
                // Create road material with border texture
                var roadMaterial = new THREE.MeshLambertMaterial({ 
                    map: roadTexture,
                    side: THREE.DoubleSide,
                    transparent: false,
                    wireframe: false
                });
                
                // Create road mesh and add to scene
                roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                scene.add(roadMesh);
                
                // Create physics collision for the road surface
                createRoadPhysics(roadGeometry);
                
                console.log('üõ£Ô∏è Ultra-smooth road mesh created with', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles, and', segments, 'segments');
                console.log('Road width:', roadWidth + 'm, Road segments:', segments);
                
                // Create center line as a thin strip
                var centerLineGeometry = new THREE.BufferGeometry();
                var centerVertices = [];
                var centerIndices = [];
                var centerUvs = [];
                
                var lineWidth = 0.3; // 30cm wide center line
                
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    var perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                    
                    var leftPoint = point.clone().add(perpendicular.clone().multiplyScalar(lineWidth / 2));
                    var rightPoint = point.clone().add(perpendicular.clone().multiplyScalar(-lineWidth / 2));
                    
                    centerVertices.push(leftPoint.x, leftPoint.y + 0.02, leftPoint.z);
                    centerVertices.push(rightPoint.x, rightPoint.y + 0.02, rightPoint.z);
                    
                    centerUvs.push(0, i / (pathPoints.length - 1));
                    centerUvs.push(1, i / (pathPoints.length - 1));
                }
                
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 2;
                    centerIndices.push(base, base + 1, base + 2);
                    centerIndices.push(base + 1, base + 3, base + 2);
                }
                
                centerLineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(centerVertices, 3));
                centerLineGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(centerUvs, 2));
                centerLineGeometry.setIndex(centerIndices);
                centerLineGeometry.computeVertexNormals();
                
                var centerLineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    side: THREE.DoubleSide
                });
                var centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
                scene.add(centerLine);
                
                console.log('Created flat road surface with', roadWidth + 'm width');
                
                // DEBUG: Create a simple test rectangle to verify road positioning
                var testGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                var testMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                var testPlane = new THREE.Mesh(testGeometry, testMaterial);
                testPlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
                testPlane.position.set(0, 0.1, 0); // Position at origin, slightly above ground
                scene.add(testPlane);
                console.log('Added red test plane for road visibility debugging');
            }
            
            // CREATE ROAD PHYSICS: Add collision mesh for elevated road surface
            function createRoadPhysics(roadGeometry) {
                // Get vertices and indices from the road geometry
                var vertices = roadGeometry.attributes.position.array;
                var indices = roadGeometry.index.array;
                
                // Create Ammo triangle mesh
                var mesh = new Ammo.btTriangleMesh(true, true);
                
                // Add triangles to the mesh
                for (var i = 0; i < indices.length; i += 3) {
                    var i1 = indices[i] * 3;
                    var i2 = indices[i + 1] * 3;
                    var i3 = indices[i + 2] * 3;
                    
                    var v1 = new Ammo.btVector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                    var v2 = new Ammo.btVector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                    var v3 = new Ammo.btVector3(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                    
                    mesh.addTriangle(v1, v2, v3, false);
                    
                    // Clean up vectors
                    Ammo.destroy(v1);
                    Ammo.destroy(v2);
                    Ammo.destroy(v3);
                }
                
                // Create collision shape from triangle mesh
                var roadShape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
                
                // Create rigid body (static, mass = 0)
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(0, 0, 0));
                
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                
                var rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, roadShape, localInertia);
                var roadBody = new Ammo.btRigidBody(rbInfo);
                
                // Set friction for good driving feel
                roadBody.setFriction(0.8);
                roadBody.setRestitution(0.1);
                
                // Store globally for obstacle detection filtering
                roadPhysicsBody = roadBody;
                
                // Add to physics world
                physicsWorld.addRigidBody(roadBody);
                
                console.log('Road physics collision mesh created with', indices.length / 3, 'triangles');
            }

            function createPathMarkers() {
                // Create visual markers at each control point
                for (var i = 0; i < pathPoints.length; i++) {
                    var markerGeometry = new THREE.SphereGeometry(2, 8, 8);
                    var markerMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xff0000 // Green for start, red for others
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(pathPoints[i]);
                    marker.position.y = pathPoints[i].y + 3; // Above road surface
                    scene.add(marker);
                }
            }
            
            function createCheckpoints() {
                // Create checkpoint markers at each path point
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    // Create checkpoint ring/gate
                    var ringGeometry = new THREE.RingGeometry(8, 12, 16);
                    var ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    var ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Position at path point
                    ring.position.copy(pathPoints[i]);
                    ring.position.y += 5; // Above the road
                    
                    // Rotate to face along the path
                    if (i < pathPoints.length - 2) {
                        var direction = new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]);
                        ring.lookAt(ring.position.clone().add(direction));
                    }
                    
                    // Add checkpoint number
                    var numberGeometry = new THREE.SphereGeometry(3, 8, 8);
                    var numberMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xffffff
                    });
                    var numberSphere = new THREE.Mesh(numberGeometry, numberMaterial);
                    numberSphere.position.copy(ring.position);
                    numberSphere.position.y += 2;
                    
                    scene.add(ring);
                    scene.add(numberSphere);
                    
                    checkpointMarkers.push({
                        ring: ring,
                        sphere: numberSphere,
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Create next checkpoint indicator
                updateNextCheckpointMarker();
                
                console.log('Created', checkpointMarkers.length, 'checkpoints');
            }
            
            function createCheckpointData() {
                // Create checkpoint data without visual elements
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    checkpointMarkers.push({
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Initialize the next checkpoint marker (yellow pulsing sphere)
                updateNextCheckpointMarker();
                
                // Log checkpoint elevations for debugging
                console.log('Created', checkpointMarkers.length, 'checkpoint data points with next checkpoint marker');
                if (checkpointMarkers.length > 0) {
                    var minY = Math.min(...checkpointMarkers.map(cp => cp.position.y));
                    var maxY = Math.max(...checkpointMarkers.map(cp => cp.position.y));
                    console.log('üèîÔ∏è Track elevation range: Min:', minY.toFixed(1) + 'm, Max:', maxY.toFixed(1) + 'm, Difference:', (maxY - minY).toFixed(1) + 'm');
                }
            }
            
            function updateNextCheckpointMarker() {
                // Remove old marker
                if (nextCheckpointMarker) {
                    scene.remove(nextCheckpointMarker);
                }
                
                // Create glowing marker for next checkpoint
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                if (checkpoint && checkpoint.position) {
                    var glowGeometry = new THREE.SphereGeometry(4, 16, 16);
                    var glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    });
                    nextCheckpointMarker = new THREE.Mesh(glowGeometry, glowMaterial);
                    nextCheckpointMarker.position.copy(checkpoint.position);
                    // Position marker relative to track elevation at this point
                    var trackElevation = checkpoint.position.y;
                    nextCheckpointMarker.position.y = trackElevation + 8; // 8m above track for visibility
                    
                    scene.add(nextCheckpointMarker);
                    
                    // Make it pulse
                    nextCheckpointMarker.userData = { pulseTime: 0 };
                    
                    console.log('üìç Next checkpoint marker updated at:', checkpoint.position);
                }
            }

            // ROAD SURFACE UTILITIES: Get actual road elevation at any point
            function getRoadSurfaceElevation(x, z) {
                if (!racingPath) {
                    console.warn('‚ö†Ô∏è No racing path available for elevation detection');
                    return 0;
                }
                
                // Find the closest point on the racing path with higher resolution
                var closestT = 0;
                var minDistance = Infinity;
                var samples = 200; // Increased samples for better accuracy
                
                for (var i = 0; i <= samples; i++) {
                    var t = i / samples;
                    var pathPoint = racingPath.getPoint(t);
                    var distance = Math.sqrt(Math.pow(pathPoint.x - x, 2) + Math.pow(pathPoint.z - z, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestT = t;
                    }
                }
                
                // Get the elevation at this point and apply the same smoothing used in road mesh
                var pathPoint = racingPath.getPoint(closestT);
                
                // Apply the same elevation smoothing algorithm used in createRoadMesh
                var segments = 800; // Same as road mesh
                var segmentIndex = Math.floor(closestT * segments);
                
                // Get neighboring points for smoothing (same as road mesh algorithm)
                var smoothY = pathPoint.y;
                if (segmentIndex > 2 && segmentIndex < segments - 3) {
                    // Sample points around this segment
                    var points = [];
                    for (var i = -3; i <= 3; i++) {
                        var sampleT = Math.max(0, Math.min(1, (segmentIndex + i) / segments));
                        points.push(racingPath.getPoint(sampleT));
                    }
                    
                    // Apply 7-point Gaussian smoothing (same as road mesh)
                    smoothY = points[0].y * 0.05 + points[1].y * 0.1 + points[2].y * 0.2 + 
                             points[3].y * 0.3 + points[4].y * 0.2 + points[5].y * 0.1 + points[6].y * 0.05;
                }
                
                // Add safety margin - if the calculated elevation seems too low, use the original path point
                var originalY = pathPoint.y;
                var finalY = Math.max(smoothY, originalY - 5); // Don't go more than 5m below original
                
                console.log('üõ£Ô∏è Elevation at (' + x.toFixed(1) + ',' + z.toFixed(1) + '): original=' + originalY.toFixed(1) + ', smoothed=' + smoothY.toFixed(1) + ', final=' + finalY.toFixed(1));
                
                return finalY;
            }

            // Bot pathfinding utilities
            function getPathPosition(t) {
                // Get position along path (t = 0 to 1)
                return racingPath.getPoint(t);
            }

            function getPathDirection(t) {
                // Get direction vector at position t
                return racingPath.getTangent(t);
            }

            function findNearestPathPoint(position) {
                // Find closest point on path to given position
                var closestT = 0;
                var closestDistance = Infinity;
                
                // Sample path at regular intervals
                for (var t = 0; t <= 1; t += 0.01) {
                    var pathPoint = racingPath.getPoint(t);
                    var distance = position.distanceTo(pathPoint);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestT = t;
                    }
                }
                
                return {
                    t: closestT,
                    point: racingPath.getPoint(closestT),
                    distance: closestDistance,
                    direction: racingPath.getTangent(closestT)
                };
            }

            function createObjects() {
                // Create racing path first
                console.log('Creating racing path...');
                createRacingPath();
                console.log('Racing path created:', !!racingPath, 'Points:', pathPoints.length);
                
                // Ground (4x bigger) - lowered by 75cm total (raised by 25cm from -1.0m)
                createBox(new THREE.Vector3(0, -0.75, 0), ZERO_QUATERNION, 300, 1, 300, 0, 2);

                // Walls around the driving area
                createBox(new THREE.Vector3(0, 5, -150), ZERO_QUATERNION, 300, 10, 2, 0, 2);
                createBox(new THREE.Vector3(0, 5, 150), ZERO_QUATERNION, 300, 10, 2, 0, 2);
                createBox(new THREE.Vector3(150, 5, 0), ZERO_QUATERNION, 2, 10, 300, 0, 2);
                createBox(new THREE.Vector3(-150, 5, 0), ZERO_QUATERNION, 2, 10, 300, 0, 2);

                // Ramp
                var quaternion = new THREE.Quaternion(0, 0, 0, 1);
                quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 18);
                createBox(new THREE.Vector3(0, -1.5, 0), quaternion, 8, 4, 10, 0);

                // Stack of boxes (moved away from track)
                var size = .75;
                var nw = 8;
                var nh = 6;
                for (var j = 0; j < nw; j++)
                    for (var i = 0; i < nh; i++)
                        createBox(new THREE.Vector3(size * j - (size * (nw - 1)) / 2 + 120, size * i, 10), ZERO_QUATERNION, size, size, size, 10);

                // Random cones - fewer and away from track
                for (var c = 0; c < 25; c++) {
                    var x, z;
                    do {
                        x = (Math.random() - 0.5) * 280;
                        z = (Math.random() - 0.5) * 280;
                        
                        // Check if too close to racing path (only if path exists)
                        var testPos = new THREE.Vector3(x, 0, z);
                        var pathInfo = racingPath ? findNearestPathPoint(testPos) : {distance: 100};
                        
                    } while ((Math.abs(x) < 30 && Math.abs(z) < 30) || pathInfo.distance < 20);
                    
                    createBox(new THREE.Vector3(x, 2, z), ZERO_QUATERNION, 1, 4, 1, 10, 1);
                }

                // Create player and bot cars at the first checkpoint (start line)
                var playerStartPosition = new THREE.Vector3(0, 0, -50); // Default X,Z fallback
                var botStartPosition = new THREE.Vector3(-5, 0, -45); // Default X,Z fallback
                
                // Calculate proper Y positions for fallback
                var playerFallbackElevation = getRoadSurfaceElevation(0, -50);
                var botFallbackElevation = getRoadSurfaceElevation(-5, -45);
                playerStartPosition.y = playerFallbackElevation + 1; // 1m above road
                botStartPosition.y = botFallbackElevation + 1; // 1m above road
                
                if (checkpointMarkers && checkpointMarkers.length > 0) {
                    var firstCheckpoint = checkpointMarkers[0];
                    
                    // Player car at first checkpoint
                    playerStartPosition = firstCheckpoint.position.clone();
                    playerStartPosition.x += 2; // Slightly to the right
                    var playerRoadElevation = getRoadSurfaceElevation(playerStartPosition.x, playerStartPosition.z);
                    if (playerRoadElevation < firstCheckpoint.position.y - 10) {
                        playerStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        playerStartPosition.y = playerRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    // Bot car slightly behind and to the left
                    botStartPosition = firstCheckpoint.position.clone();
                    botStartPosition.x -= 2; // Slightly to the left
                    botStartPosition.z -= 5; // 5m behind
                    var botRoadElevation = getRoadSurfaceElevation(botStartPosition.x, botStartPosition.z);
                    if (botRoadElevation < firstCheckpoint.position.y - 10) {
                        botStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        botStartPosition.y = botRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    console.log('üèÅ Starting positions at first checkpoint:');
                    console.log('üöó Player:', playerStartPosition.x.toFixed(1), playerStartPosition.y.toFixed(1), playerStartPosition.z.toFixed(1));
                    console.log('ü§ñ Bot:', botStartPosition.x.toFixed(1), botStartPosition.y.toFixed(1), botStartPosition.z.toFixed(1));
                } else {
                    console.warn('‚ö†Ô∏è No checkpoints available, using default start positions');
                }
                
                // Create rotation quaternion for 90 degrees left (counter-clockwise around Y-axis)
                var leftRotation = new THREE.Quaternion();
                leftRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); // 90 degrees in radians
                console.log('üîÑ Cars will be rotated 90¬∞ left at spawn');
                
                console.log('Creating player car...');
                createVehicle(playerStartPosition, leftRotation);
                
                console.log('Creating bot car...');
                botVehicleRef = createBotVehicle(botStartPosition, leftRotation, 0x0066ff);
                console.log('Bot car created, racing path available:', !!racingPath);
                
                // Confirm both cars are starting at the correct positions
                console.log('‚úÖ Both cars positioned at first checkpoint (start line)');
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                loadBestTime(); // Load saved best time from localStorage
                console.log('üèÅ Lap timing started');
                
                // Initialize audio system
                initAudioSystem();
            }

            // - Init -
            initGraphics();
            initPhysics();
            createObjects();
            tick();

        });
    </script>
</body>
</html>
