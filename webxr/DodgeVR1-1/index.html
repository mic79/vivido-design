<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Zero-G Environment</title>
    <meta name="description" content="Zero-gravity WebXR environment using A-Frame with Lone Echo-style locomotion">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/aframe-glow-component@1.0.0/dist/aframe-glow-component.min.js"></script>
  </head>
  <body>
    <script>
      // Physics world setup for zero-gravity
      const world = new CANNON.World();
      world.gravity.set(0, 0, 0); // Zero gravity for space environment
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // Global error handler to suppress Meta Touch Controls errors
      window.addEventListener('error', (event) => {
        if (event.error && event.error.message && 
            event.error.message.includes('thumbstick') && 
            event.error.message.includes('Cannot read properties of undefined')) {
          // Suppress Meta Touch Controls thumbstick errors
          event.preventDefault();
          return false;
        }
      });

      // Multiplayer state for 1-4 players
      let isMultiplayer = false;
      let isHost = false;
      let peer = null;
      let connections = new Map();
      let connectionToPlayer = new Map(); // Track which player ID is assigned to each connection
      let players = new Map();
      let activePlayers = new Set();
      let botPlayers = new Set();
      let playerSlots = [
        { name: 'Player 0', color: '#ff0000', position: '-2 0 -2', rotation: '0 45 0' },
        { name: 'Player 1', color: '#00ff00', position: '2 0 -2', rotation: '0 -45 0' },
        { name: 'Player 2', color: '#ff00ff', position: '-2 0 2', rotation: '0 135 0' },
        { name: 'Player 3', color: '#ffff00', position: '2 0 2', rotation: '0 -135 0' }
      ];
      let sessionID = null;
      let multiplayerSlot = null;
      let myPlayerId = null;
      let myReadyState = false;
      let readyStates = [false, false, false, false];
      let lastMultiplayerToggle = 0;
      let MAX_LOBBIES = 10;
      let multiplayerStartType = 'dodgevr';
      let connectionState = 'disconnected';
      let selectedLobby = 1;
      let isSearchingForMatch = false;

      // Multiplayer score state
      let multiplayerScore = { local: 0, remote: 0 };
      // Multiplayer ready state
      let multiplayerReady = { local: false, remote: false };

      // Menu state tracking
      let isMenuVisible = false;

      // Team system
      let playerTeams = new Map(); // playerId -> 'red' or 'blue'
      let teamScores = { red: 0, blue: 0 };
      let gameMode = 'dodgeball'; // 'dodgeball' or 'capture'

      // Helper: check if menu is currently visible
      function getMenuVisibility() {
        return isMenuVisible;
      }

      // Initialize players map
      for (let i = 0; i < 4; i++) {
        players.set(`player_${i}`, {
          id: `player_${i}`,
          name: playerSlots[i].name,
          color: playerSlots[i].color,
          position: playerSlots[i].position,
          rotation: playerSlots[i].rotation,
          isConnected: false,
          isBot: false,
          isReady: false
        });
      }

      // Helper: update HUD status display
      function updateMultiplayerStatus(text) {
        const hudStatus = document.getElementById('hud-status');
        if (hudStatus) {
          hudStatus.setAttribute('text', 'value', text);
        }

      }

      // Helper: update menu display
      function updateMenuDisplay() {
        const menuCurrentMode = document.getElementById('menu-current-mode');
        if (menuCurrentMode) {
          const mode = isMultiplayer ? `Multiplayer (Lobby ${selectedLobby})` : 'Singleplayer';
          const playerCount = activePlayers.size;
          menuCurrentMode.setAttribute('text', 'value', `Mode: ${mode} (${playerCount}/4 players)`);
        }
        
        // CRITICAL FIX: Disable game mode buttons for clients in multiplayer
        const dodgeButton = document.querySelector('#menu-mode-dodge');
        const captureButton = document.querySelector('#menu-mode-capture');
        
        if (dodgeButton && captureButton) {
          const canChangeMode = !isMultiplayer || isHost;
          const opacity = canChangeMode ? 1.0 : 0.3;
          const color = canChangeMode ? '#ffffff' : '#666666';
          
          dodgeButton.setAttribute('material', `opacity: ${opacity}; color: ${color}`);
          captureButton.setAttribute('material', `opacity: ${opacity}; color: ${color}`);
          
          // Add visual indicator for clients
          if (isMultiplayer && !isHost) {
            const statusText = document.getElementById('menu-mode-status');
            if (statusText) {
              statusText.setAttribute('text', 'value', '(Host controls game mode)');
              statusText.setAttribute('visible', true);
            }
          } else {
            const statusText = document.getElementById('menu-mode-status');
            if (statusText) {
              statusText.setAttribute('visible', false);
            }
          }
        }
      }

      // Helper: switch game mode
      function switchGameMode(mode) {
        // CRITICAL FIX: Only host can change game mode in multiplayer
        if (isMultiplayer && !isHost) {
          return; // Clients cannot change game mode
        }
        
        gameMode = mode;
        
        // Host syncs game mode change to all clients
        if (isMultiplayer && isHost && activePlayers.size > 1) {
          sendGameModeUpdate(mode);
        }
        
        // Update local UI and game state
        updateGameModeUI(mode);
      }

      // Helper: check if two players are on the same team
      function areTeammates(playerId1, playerId2) {
        if (gameMode !== 'capture') return false; // No teams in dodge mode
        
        const team1 = playerTeams.get(playerId1);
        const team2 = playerTeams.get(playerId2);
        
        // Both players must have teams assigned and be on the same team
        return team1 && team2 && team1 === team2;
      }

      // Helper: get ball assignment based on team and role in capture mode
      function getBallForPlayer(playerId) {
        if (gameMode !== 'capture') {
          // Dodgeball mode: use original assignments
          if (playerId === 'player_0') return 2;
          if (playerId === 'player_1') return 4;
          if (playerId === 'player_2') return 1; // FIXED: player_2 gets ball 1
          if (playerId === 'player_3') return 3; // FIXED: player_3 gets ball 3
          return 2; // default
        }
        
        // CRITICAL FIX: In capture mode, all 4 players get unique balls
        // Ball assignments are fixed regardless of team - only colors change
        
        if (playerId === 'player_0') return 2; // Host always uses ball 2
        if (playerId === 'player_1') return 4; // Client 1 always uses ball 4
        if (playerId === 'player_2') return 1; // FIXED: Client 2 gets ball 1 (was bot-red)
        if (playerId === 'player_3') return 3; // FIXED: Client 3 gets ball 3 (was bot-blue)
        if (playerId === 'bot-red') return 1;  // Red bot uses ball 1 (only when no player_2)
        if (playerId === 'bot-blue') return 3; // Blue bot uses ball 3 (only when no player_3)
        
        return 2; // fallback
      }

      // Helper: update ball colors based on team assignments
      function updateBallColors() {
        if (gameMode !== 'capture') return;
        
        // Update ball colors to match team assignments
        const balls = [
          { index: 1, element: document.querySelector('[zerog-ball*="player: player1"]') }, // Red bot ball
          { index: 2, element: document.querySelector('[zerog-ball*="player: player2"]') }, // Human ball
          { index: 3, element: document.querySelector('[zerog-ball*="player: player3"]') }, // Blue bot ball  
          { index: 4, element: document.querySelector('[zerog-ball*="player: player4"]') }  // Human ball
        ];
        
        balls.forEach(ball => {
          if (!ball.element) return;
          
          let targetColor = '#ffffff'; // default white
          
          // CRITICAL FIX: Dynamic color assignment based on current ball ownership
          const ballOwnerId = getBallOwnerId(ball.index);
          
          if (ballOwnerId) {
            if (ballOwnerId === 'bot-red') {
              targetColor = '#ff0000'; // Red bot -> always red
            } else if (ballOwnerId === 'bot-blue') {
              targetColor = '#0000ff'; // Blue bot -> always blue
            } else {
              // Human player - color based on their team
              const playerTeam = playerTeams.get(ballOwnerId);
              targetColor = playerTeam === 'red' ? '#ff0000' : '#0000ff';
            }
          }
          
          // Update ball color
          ball.element.setAttribute('color', targetColor);
          ball.element.setAttribute('glow', `color: ${targetColor}; intensity: 1.5`);
          
          // Update light color
          const light = ball.element.querySelector('[light]');
          if (light) {
            light.setAttribute('light', `color: ${targetColor}; intensity: 1.5; distance: 5; decay: 2`);
          }
          
          // Update wireframe color
          const wireframe = ball.element.querySelector('[material*="wireframe"]');
          if (wireframe) {
            wireframe.setAttribute('material', `wireframe: true; color: ${targetColor}; opacity: 0.5`);
            wireframe.setAttribute('color', targetColor);
          }
        });
      }

      // Helper: check if ball should affect target based on team rules
      function shouldBallAffectTarget(ballPlayerIndex, targetId) {
        if (gameMode !== 'capture') return true; // No team restrictions in dodgeball
        
        // Get the owner of the ball
        const ballOwnerId = getBallOwnerId(ballPlayerIndex);
        if (!ballOwnerId) return false; // Unknown ball owner
        
        // Get teams of ball owner and target
        const ballOwnerTeam = playerTeams.get(ballOwnerId);
        const targetTeam = playerTeams.get(targetId);
        
        // Ball should only affect opponents (different team)
        return ballOwnerTeam && targetTeam && ballOwnerTeam !== targetTeam;
      }
      
      // Helper: get the owner ID of a ball based on its player index
      function getBallOwnerId(ballPlayerIndex) {
        // CRITICAL FIX: Handle all 4 players + bots dynamically
        // Check if human players are using these balls first
        
        if (ballPlayerIndex === 1) {
          // Ball 1: player_2 takes priority, otherwise bot-red
          return activePlayers.has('player_2') ? 'player_2' : 'bot-red';
        }
        if (ballPlayerIndex === 2) return 'player_0';   // Host always owns ball 2
        if (ballPlayerIndex === 3) {
          // Ball 3: player_3 takes priority, otherwise bot-blue  
          return activePlayers.has('player_3') ? 'player_3' : 'bot-blue';
        }
        if (ballPlayerIndex === 4) return 'player_1';   // Client 1 always owns ball 4
        return null;
      }
      
      // Helper: get player ID from ball index
      function getPlayerIdFromBallIndex(ballPlayerIndex) {
        // CRITICAL FIX: Use the same dynamic logic as getBallOwnerId
        return getBallOwnerId(ballPlayerIndex) || 'player_0'; // fallback
      }
      
      // Helper: update player color based on team
      function updatePlayerTeamColor(playerId, team) {
        const teamColors = {
          red: '#ff0000',
          blue: '#0000ff'
        };
        
        const color = teamColors[team];
        if (!color) return;
        
        
        // Update player target color
        const playerTarget = document.querySelector('#player-target');
        const playerImpact = document.querySelector('#player-impact');
        
        if (playerTarget) {
          playerTarget.setAttribute('color', color);
          playerTarget.setAttribute('material', `shader: standard; emissive: ${color}; emissiveIntensity: 0.5; transparent: true; opacity: 0.7`);
          playerTarget.setAttribute('impact-effect', `color: ${color}`);
          
          // Update the light color
          const playerLight = playerTarget.querySelector('a-entity[light]');
          if (playerLight) {
            playerLight.setAttribute('light', `type: point; color: ${color}; intensity: 1; distance: 3`);
          }
          
          // Update impact sphere color
          if (playerImpact) {
            playerImpact.setAttribute('color', color);
          }
          
        }
        
        // Also update remote player colors if this is for a remote player
        if (playerId !== myPlayerId) {
          const playerIndex = parseInt(playerId.split('_')[1]);
          const remoteTarget = document.querySelector(`#remote-target-${playerIndex}`);
          const remoteImpact = document.querySelector(`#remote-impact-${playerIndex}`);
          
          if (remoteTarget) {
            remoteTarget.setAttribute('color', color);
            remoteTarget.setAttribute('material', `shader: standard; emissive: ${color}; emissiveIntensity: 0.5; transparent: true; opacity: 0.7`);
            remoteTarget.setAttribute('impact-effect', `color: ${color}`);
            
            // Update remote light color
            const remoteLight = remoteTarget.querySelector('a-entity[light]');
            if (remoteLight) {
              remoteLight.setAttribute('light', `type: point; color: ${color}; intensity: 1; distance: 3`);
            }
            
            // Update remote impact sphere color
            if (remoteImpact) {
              remoteImpact.setAttribute('color', color);
            }
            
          }
        }
      }

      // Multiplayer connection functions
      async function initMultiplayer() {
        updateMenuDisplay();
      }

      async function setupHost(lobbyNumber) {
        return new Promise((resolve, reject) => {
          isMultiplayer = true;
          isHost = true;
          selectedLobby = lobbyNumber;
          sessionID = `dodgevr-host-${multiplayerStartType}-${lobbyNumber}`;
          
          let iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
          
          const config = iceServersConfig;
          
          peer = new Peer(sessionID, {
            host: "0.peerjs.com",
            port: 443,
            secure: true,
            config: { 'iceServers': config }
          });
          
          peer.on("open", function() {
            updateMultiplayerStatus(`Host - Lobby ${lobbyNumber} (1/4)`);
            updateMenuDisplay();
            
            // Mark self as connected
            myPlayerId = 'player_0';
            activePlayers.add('player_0');
            const player = players.get('player_0');
            if (player) {
              player.isConnected = true;
              player.isBot = false;
            }
            
                      // CRITICAL FIX: Assign host to default team (red) for capture mode
          if (gameMode === 'capture') {
            playerTeams.set('player_0', 'red');
            // Update ball colors and visibility for host
            updateBallColors();
            manageActivePlayersAndBots();
            // Send team assignments to all clients
            sendTeamAssignments();
          }
            
            // Position host at corner
            const rig = document.querySelector('#rig');
            if (rig) {
              rig.setAttribute('position', playerSlots[0].position);
              rig.setAttribute('rotation', playerSlots[0].rotation);
            }
            
            // Update player target color to match host's assigned color (player_0 = red)
            const playerTarget = document.querySelector('#player-target');
            const playerImpact = document.querySelector('#player-impact');
            if (playerTarget) {
              const playerColor = playerSlots[0].color; // Red for player_0
              playerTarget.setAttribute('color', playerColor);
              playerTarget.setAttribute('material', 'emissive: ' + playerColor + '; emissiveIntensity: 0.5; transparent: true; opacity: 0.7');
              playerTarget.setAttribute('impact-effect', 'color: ' + playerColor);
              
              // Update the light color
              const playerLight = playerTarget.querySelector('a-entity[light]');
              if (playerLight) {
                playerLight.setAttribute('light', 'color: ' + playerColor + '; intensity: 1; distance: 3');
              }
              
              // Update impact sphere color
              if (playerImpact) {
                playerImpact.setAttribute('color', playerColor);
              }
              
            }
            
            // Make all remote players visible for host
            setTimeout(() => {
              makeAllRemotePlayersVisible();
            }, 100);
            
            resolve();
          });
          
          peer.on("connection", function(conn) {
            
            // Store the connection with a unique key based on peer ID
            const clientKey = `client_${conn.peer}`;
            connections.set(clientKey, conn);
            
            setupConnectionHandlers(conn, clientKey);
            
            conn.on("open", function() {
              
                          // Mark client as connected and send player count update
            // Don't add 'client' to activePlayers - we'll add the actual player ID when assigned
            // Only count actual players, not connection IDs
            const actualPlayerCount = activePlayers.size;
            const maxPlayers = gameMode === 'capture' ? 2 : 4;
            updateMultiplayerStatus(`Host - Lobby ${lobbyNumber} (${actualPlayerCount}/${maxPlayers})`);
            updateMenuDisplay();
              
              // Send player count update to all clients
              sendPlayerCountUpdate();
              
              // Make all remote players visible
              setTimeout(() => {
                makeAllRemotePlayersVisible();
              }, 200);
              
                        // Automatically assign player slot to the new client (only if not already assigned)
          setTimeout(() => {
            // Check if this connection already has a player assigned
            const existingPlayer = Array.from(activePlayers).find(id => id !== 'player_0' && id !== 'client');
            if (!existingPlayer) {
              handlePlayerAssignmentRequest(conn);
            } else {
            }
          }, 100);
            });
          });
          
          peer.on("error", function(err) {
            updateMultiplayerStatus(`Host error: ${err.type}`);
            if (err.type === 'unavailable-id') {
              reject(new Error('unavailable-id'));
            }
          });
        });
      }

      async function setupPeer(lobbyNumber) {
        return new Promise((resolve, reject) => {
          isMultiplayer = true;
          isHost = false;
          selectedLobby = lobbyNumber;
          const timestamp = Date.now();
          const randomId = Math.random().toString(36).substr(2, 9);
          sessionID = `dodgevr-peer-${multiplayerStartType}-${lobbyNumber}-${timestamp}-${randomId}`;
          
          let iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
          
          const config = iceServersConfig;
          
          peer = new Peer(sessionID, {
            host: "0.peerjs.com",
            port: 443,
            secure: true,
            config: { 'iceServers': config }
          });
          
          peer.on("open", function() {
            updateMultiplayerStatus('Connecting to host...');
            const hostID = `dodgevr-host-${multiplayerStartType}-${lobbyNumber}`;
            const conn = peer.connect(hostID);
            connections.set('host', conn);
            
            conn.on("open", function() {
              setupConnectionHandlers(conn, 'client');
              updateMultiplayerStatus(`Connected - Lobby ${lobbyNumber} (connecting...)`);
              updateMenuDisplay();
              resolve();
            });
            
            conn.on("error", function(err) {
              reject(new Error('connection-failed'));
            });
          });
          
          peer.on("error", function(err) {
            updateMultiplayerStatus(`Peer error: ${err.type}`);
            reject(new Error(err.type));
          });
        });
      }

      function setupConnectionHandlers(conn, playerId) {
        conn.on('data', (data) => {
          // Throttle data reception logging to prevent spam
          if (!this.lastDataReceiveTime || Date.now() - this.lastDataReceiveTime > 30000) {
            this.lastDataReceiveTime = Date.now();
          }
          switch(data.type) {
            case 'player-count-update':
              handlePlayerCountUpdate(data);
              break;
            case 'player-assignment':
              handlePlayerAssignment(data);
              break;
            case 'ready-update':
              handleReadyUpdate(data);
              break;
            case 'game-state':
              handleGameState(data);
              break;
            case 'player-update':
              handlePlayerUpdate(data);
              break;
            case 'request-player-assignment':
              handlePlayerAssignmentRequest(conn);
              break;
            case 'player-info-update':
              handlePlayerInfoUpdate(data);
              break;
            case 'score-update':
              handleScoreUpdate(data);
              break;
            case 'player-state':
              handlePlayerState(data);
              break;
            case 'ball-state':
              handleBallState(data);
              break;
            case 'bot-state':
              handleBotState(data);
              break;
            case 'game-mode-update':
              handleGameModeUpdate(data);
              break;
            case 'request-game-mode':
              handleGameModeRequest(conn);
              break;
            case 'team-assignments':
              handleTeamAssignments(data);
              break;
            case 'capture-ball-grabbed':
              handleCaptureBallGrabbed(data);
              break;
          }
        });
        
        conn.on('close', () => {
          handlePlayerDisconnection(conn, playerId);
        });
        
        conn.on('error', (err) => {
          handlePlayerDisconnection(conn, playerId);
        });
      }

      function handlePlayerCountUpdate(data) {
        updateMenuDisplay();
        
        // Update status for clients to show player count from host
        if (!isHost) {
          const maxPlayers = gameMode === 'capture' ? 2 : 4;
          updateMultiplayerStatus(`Connected - Lobby ${selectedLobby} (${data.playerCount}/${maxPlayers})`);
        }
        
        // Update local activePlayers set with the host's data
        if (data.activePlayers) {
          activePlayers.clear();
          data.activePlayers.forEach(playerId => {
            activePlayers.add(playerId);
          });
        }
        
        // If client doesn't have a player ID yet, request assignment
        if (!isHost && !myPlayerId) {
          const hostConn = connections.get('host');
          if (hostConn && hostConn.open) {
            hostConn.send({
              type: 'request-player-assignment'
            });
          }
        }
        
        // Make remote players visible when player count updates
        setTimeout(() => {
          makeAllRemotePlayersVisible();
        }, 100);
      }

      function handlePlayerAssignment(data) {
        // Only accept assignment if we don't already have a player ID
        if (myPlayerId) {
          return;
        }
        
        myPlayerId = data.playerId;
        
        // Add self to active players
        activePlayers.add(myPlayerId);
        
        // Track this connection for the client side
        const hostConn = connections.get('host');
        if (hostConn) {
          connectionToPlayer.set(hostConn, myPlayerId);
        }
        
        // Position player at their assigned corner
        const playerIndex = parseInt(myPlayerId.split('_')[1]);
        const rig = document.querySelector('#rig');
        if (rig && playerSlots[playerIndex]) {
          rig.setAttribute('position', playerSlots[playerIndex].position);
          rig.setAttribute('rotation', playerSlots[playerIndex].rotation);
        } else {
        }
        
        // CRITICAL FIX: Don't set hardcoded player colors here - let team colors take precedence
        // Player colors will be set by updatePlayerTeamColor when teams are assigned
        // Just ensure the target exists for now
        const playerTarget = document.querySelector('#player-target');
        if (playerTarget) {
          // Set a default neutral color that will be overridden by team selection
          playerTarget.setAttribute('color', '#888888');
          playerTarget.setAttribute('material', 'emissive: #888888; emissiveIntensity: 0.5; transparent: true; opacity: 0.7');
        }
        
        // Update status to show player count - use the count from the host
        updateMultiplayerStatus(`Connected - Lobby ${selectedLobby} (connecting...)`);
        
        // Make all other remote players visible
        makeAllRemotePlayersVisible();
        
        // Update ball colors and visibility for new player
        updateBallColors();
        manageActivePlayersAndBots();
        
        // CRITICAL FIX: Request current game mode from host
        const hostConnection = connections.get('host');
        if (hostConnection && hostConnection.open) {
          hostConnection.send({
            type: 'request-game-mode'
          });
        }
        
        updateMenuDisplay();
      }

      function makeAllRemotePlayersVisible() {
        
        // Get current player's position and rotation
        const rig = document.querySelector('#rig');
        const playerPos = rig ? rig.getAttribute('position') : { x: 0, y: 0, z: 0 };
        const playerRot = rig ? rig.getAttribute('rotation') : { x: 0, y: 0, z: 0 };
        
        
        for (let i = 0; i < 4; i++) {
          const remotePlayer = document.querySelector(`#remote-player-${i}`);
          if (remotePlayer) {
            // Skip if this is the current player's slot
            if (myPlayerId === `player_${i}`) {
              remotePlayer.setAttribute('visible', false);
              continue;
            }
            
            // Show remote players if they exist in remotePlayerStates (meaning we received data from them)
            // or if they're in activePlayers (for host-side visibility)
            const playerId = `player_${i}`;
            const hasReceivedData = remotePlayerStates.has(playerId);
            const isInActivePlayers = activePlayers.has(playerId);
            
            if (hasReceivedData || isInActivePlayers) {
              // Position remote player at their absolute world position
              const slot = playerSlots[i];
              if (slot) {
                // Set position and make visible
                remotePlayer.setAttribute('position', slot.position);
                remotePlayer.setAttribute('rotation', slot.rotation);
                remotePlayer.setAttribute('visible', true);
                
                // Keep the sphere at the same size as singleplayer
                const sphere = remotePlayer.querySelector(`#remote-target-${i}`);
                if (sphere) {
                  sphere.setAttribute('radius', '0.2');
                  sphere.setAttribute('material', 'emissiveIntensity: 0.5; opacity: 0.7');
                }
                
              } else {
              }
            } else {
              // Hide if not connected
              remotePlayer.setAttribute('visible', false);
            }
          } else {
          }
        }
      }

      function handlePlayerAssignmentRequest(conn) {
        if (!isHost) return;
        
        
        let assignedSlot = null;
        for (let slotNumber = 1; slotNumber < 4; slotNumber++) {
          const playerId = `player_${slotNumber}`;
          const player = players.get(playerId);
          if (!player || !player.isConnected || player.isBot) {
            assignedSlot = slotNumber;
            break;
          }
        }
        
        if (assignedSlot !== null) {
          const playerId = `player_${assignedSlot}`;
          
          conn.send({
            type: 'player-assignment',
            playerId: playerId
          });
          
          const player = players.get(playerId);
          if (player) {
            player.isConnected = true;
            player.isBot = false;
            activePlayers.add(playerId);
          }
          
          // Track which connection this player is assigned to
          connectionToPlayer.set(conn, playerId);
          
          updateMenuDisplay();
          sendPlayerCountUpdate();
          
          // Send current team assignments to new client
          setTimeout(() => {
            sendTeamAssignments();
          }, 100);
        } else {
        }
      }

      function handlePlayerUpdate(data) {
        // Handle remote player position/state updates
        const remotePlayer = document.querySelector(`#remote-player-${data.playerId}`);
        if (remotePlayer) {
          remotePlayer.setAttribute('position', data.position);
          // Add more state updates as needed
        }
      }

      function handleGameState(data) {
        // Handle game state updates from host
      }

      function handleReadyUpdate(data) {
        readyStates[data.playerIndex] = data.ready;
        
        // Update the game manager's ready states
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].playerReadyStates[data.playerIndex] = data.ready;
          gameManager.components['game-manager'].updateReadyState();
        }
        
        updateMenuDisplay();
      }

      function handlePlayerInfoUpdate(data) {
        // Update local player info from host
      }

      function handleScoreUpdate(data) {
        // Handle score updates from host
        if (data.scores) {
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            gameManager.components['game-manager'].playerScores = data.scores;
            gameManager.components['game-manager'].updateMultiplayerScore();
            
            // Check for overtime win condition on clients
            if (gameManager.components['game-manager'].matchState === 'OVERTIME') {
              gameManager.components['game-manager'].checkOvertimeWin();
            }
          }
        }
      }
      
      function handlePlayerState(data) {
        // Handle remote player position/rotation updates (throttled logging)
        if (!this.lastPlayerStateReceiveTime || Date.now() - this.lastPlayerStateReceiveTime > 30000) {
          this.lastPlayerStateReceiveTime = Date.now();
        }
        remotePlayerStates.set(data.playerId, data.state);
        
        // CRITICAL: Host forwards player states to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          // Forward this player state to all other clients
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open) {
              // Forward to all connections (the sender will ignore their own data)
              conn.send({
                type: 'player-state',
                state: data.state,
                playerId: data.playerId
              });
            }
          });
        }
        
        // Update the corresponding remote player entity
        const playerIndex = parseInt(data.playerId.split('_')[1]);
        const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
        if (remotePlayer) {
          remotePlayer.setAttribute('position', `${data.state.x} ${data.state.y} ${data.state.z}`);
          remotePlayer.setAttribute('rotation', `${data.state.rx} ${data.state.ry} ${data.state.rz}`);
          remotePlayer.setAttribute('visible', true);
          if (!this.lastRemotePlayerUpdateTime || Date.now() - this.lastRemotePlayerUpdateTime > 30000) {
            this.lastRemotePlayerUpdateTime = Date.now();
          }
        } else {
          if (!this.lastRemotePlayerErrorTime || Date.now() - this.lastRemotePlayerErrorTime > 30000) {
            this.lastRemotePlayerErrorTime = Date.now();
          }
        }
      }
      
      function handleGameModeUpdate(data) {
        // CRITICAL FIX: Only clients should receive game mode updates from host
        if (isHost) {
          return; // Host doesn't receive game mode updates, only sends them
        }
        
        const newMode = data.gameMode;
        
        // Only apply if different from current mode
        if (newMode !== gameMode) {
          // Apply the game mode change locally (clients receive only)
          gameMode = newMode;
          
          // Update local UI and game state
          updateGameModeUI(newMode);
        }
      }
      
      function handleCaptureBallGrabbed(data) {
        // Force release capture ball if another player grabbed it
        if (data.grabberId !== myPlayerId) {
          const captureBall = document.querySelector('#capture-ball');
          if (captureBall && captureBall.components['zerog-ball']) {
            const ballComponent = captureBall.components['zerog-ball'];
            if (ballComponent.isGrabbed) {
              // Force release the ball locally
              ballComponent.onRelease();
              
              // Also release from player component
              const zerogPlayer = document.querySelector('[zerog-player]');
              if (zerogPlayer && zerogPlayer.components['zerog-player']) {
                const playerComponent = zerogPlayer.components['zerog-player'];
                ['left', 'right'].forEach(handKey => {
                  if (playerComponent.grabInfo[handKey] && 
                      playerComponent.grabInfo[handKey].surface === captureBall) {
                    playerComponent.grabInfo[handKey] = null;
                    playerComponent.isGrabbing[handKey] = false;
                  }
                });
              }
            }
          }
        }
      }
      
      function handleGameModeRequest(conn) {
        // CRITICAL FIX: Host responds to game mode requests from clients
        if (!isHost) {
          return; // Only host can respond to game mode requests
        }
        
        // Send current game mode to requesting client
        if (conn && conn.open) {
          conn.send({
            type: 'game-mode-update',
            gameMode: gameMode
          });
        }
      }
      
      function updateGameModeUI(mode) {
        // Update HUD based on game mode
        const hudStatus = document.getElementById('hud-status');
        if (hudStatus) {
          if (mode === 'capture') {
            hudStatus.setAttribute('text', 'value', 'Capture Mode - Get the white ball to the goal!');
          } else {
            hudStatus.setAttribute('text', 'value', 'Dodge Mode - Hit opponents with balls!');
          }
        }
        
        // Show/hide capture ball and goals based on mode
        const captureBall = document.querySelector('#capture-ball');
        const redGoal = document.querySelector('#red-goal');
        const blueGoal = document.querySelector('#blue-goal');
        
        if (captureBall) {
          captureBall.setAttribute('visible', mode === 'capture');
        }
        if (redGoal) {
          redGoal.setAttribute('visible', mode === 'capture');
        }
        if (blueGoal) {
          blueGoal.setAttribute('visible', mode === 'capture');
        }
        
        // Assign bot teams in capture mode
        if (mode === 'capture') {
          playerTeams.set('bot-red', 'red');
          playerTeams.set('bot-blue', 'blue');
          
          // Ensure player team colors are maintained
          const currentPlayerId = myPlayerId || 'player_0';
          let playerTeam = playerTeams.get(currentPlayerId);
          
          // CRITICAL FIX: Assign default team if player doesn't have one
          if (!playerTeam) {
            playerTeam = 'red'; // Default to red team
            playerTeams.set(currentPlayerId, playerTeam);
          }
          
          updatePlayerTeamColor(currentPlayerId, playerTeam);
        }
        
        // Update player and bot management
        manageActivePlayersAndBots();
        
        // Update ball colors for team assignments
        updateBallColors();
        
        // Send team assignments to clients if host
        if (isHost) {
          sendTeamAssignments();
        }
        
        // Update bot ball assignments for new game mode
        const redBot = document.querySelector('#zerog-bot-red');
        const blueBot = document.querySelector('#zerog-bot-blue');
        if (redBot && redBot.components['zerog-bot']) {
          redBot.components['zerog-bot'].updateBallAssignment();
        }
        if (blueBot && blueBot.components['zerog-bot']) {
          blueBot.components['zerog-bot'].updateBallAssignment();
        }
        
        // Update score display for team mode
        if (mode === 'capture') {
          const hudScore = document.querySelector('#hud-score');
          if (hudScore) {
            hudScore.setAttribute('visible', true);
            const leftScore = hudScore.children[0];
            const rightScore = hudScore.children[1];
            if (leftScore) leftScore.setAttribute('text', 'value', `${teamScores.blue}`);
            if (rightScore) rightScore.setAttribute('text', 'value', `${teamScores.red}`);
          }
        }
      }
      
      function handleBotState(data) {
        // Handle remote bot position/velocity updates from host
        const botId = data.botState.botId;
        const botElement = document.querySelector(`#zerog-${botId}`);
        
        if (botElement && botElement.components['zerog-bot']) {
          const botComponent = botElement.components['zerog-bot'];
          
          // Only update bot position on clients (not on host)
          if (!isHost && botComponent.body) {
            // Update bot physics body position and velocity
            botComponent.body.position.set(data.botState.x, data.botState.y, data.botState.z);
            botComponent.body.velocity.set(data.botState.vx, data.botState.vy, data.botState.vz);
            
            // Update visual position
            botElement.object3D.position.set(data.botState.x, data.botState.y, data.botState.z);
          }
        }
        
        // Host forwards bot states to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open) {
              conn.send({
                type: 'bot-state',
                botState: data.botState,
                playerId: data.playerId
              });
            }
          });
        }
      }
      
      function handleBallState(data) {
        // Handle remote ball position/velocity updates (throttled logging)
        if (!this.lastBallStateReceiveTime || Date.now() - this.lastBallStateReceiveTime > 30000) {
          this.lastBallStateReceiveTime = Date.now();
        }
        remoteBallStates.set(data.playerId, data.ballState);
        
        // CRITICAL: Host forwards ball states to other clients (but NOT back to sender)
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          // Forward this ball state to all other clients EXCEPT the sender
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.playerId) {
              // Only forward to connections that are NOT the original sender
              conn.send({
                type: 'ball-state',
                ballState: data.ballState,
                playerId: data.playerId
              });
            }
          });
        }
        
        // CRITICAL FIX: Apply ball updates from other players
        const ballNumber = data.ballState.playerId;
        
        // CRITICAL FIX: Handle capture ball with dynamic ownership
        if (ballNumber === 'capture') {
          const captureBall = document.querySelector('#capture-ball');
          if (captureBall && captureBall.components['zerog-ball']) {
            const ballComponent = captureBall.components['zerog-ball'];
            
            // Don't update capture ball if it's currently being controlled locally
            if (ballComponent.isGrabbed || ballComponent.tractorBeamActive) {
              return;
            }
            
            // Apply network update to capture ball from any player
            captureBall.object3D.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
            if (ballComponent.body) {
              ballComponent.body.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
              ballComponent.body.velocity.set(data.ballState.vx, data.ballState.vy, data.ballState.vz);
            }
          }
          return;
        }
        
        // CRITICAL FIX: Use dynamic ball assignment instead of hardcoded logic
        const currentPlayerBallNumber = getBallForPlayer(myPlayerId || 'player_0');
        
        // CRITICAL FIX: NEVER apply network updates to our own ball
        if (ballNumber === currentPlayerBallNumber) {
          // This is our own ball - we have full authority over it
          // Don't apply any network updates regardless of control state
          return;
        }
        
        // Also check if this ball is currently being controlled by the local player
        const ball = document.querySelector(`[zerog-ball*="player: player${ballNumber}"]`);
        if (ball && ball.components['zerog-ball']) {
          const ballComponent = ball.components['zerog-ball'];
          
          // Skip network updates if ball is being grabbed OR if tractor beam is active for this ball OR if auto-return is active
          const isGrabbed = ballComponent.isGrabbed;
          const isTractorBeamActive = ballComponent.tractorBeamActive;
          const isAutoReturnActive = ballComponent.autoReturnActive;
          const isLocallyControlled = isGrabbed || isTractorBeamActive || isAutoReturnActive;
          
          if (isLocallyControlled) {
            // Ball is being controlled locally - don't apply network updates
            if (!this.lastGrabbedBallSkipTime || Date.now() - this.lastGrabbedBallSkipTime > 30000) {
              this.lastGrabbedBallSkipTime = Date.now();
            }
            return;
          }
        }
        
        // Apply network updates to OTHER players' balls
        if (ball && ball.components['zerog-ball']) {
          const ballComponent = ball.components['zerog-ball'];
          
          // CRITICAL: Check if ball is locally controlled BEFORE applying any network updates
          const isLocallyControlled = ballComponent.isGrabbed || ballComponent.tractorBeamActive || ballComponent.autoReturnActive;
          
          // DEBUG: Log every network update attempt for locally controlled balls
          if (isLocallyControlled) {
            return; // Exit early - don't apply any network updates
          }
          
          // Only apply network updates if ball is NOT locally controlled
          
          
          // Force immediate visual update
          ball.object3D.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
          
          if (ballComponent.body) {
            ballComponent.body.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
            ballComponent.body.velocity.set(data.ballState.vx, data.ballState.vy, data.ballState.vz);
            
            // Also sync the quaternion to ensure visual representation is fully updated
            ball.object3D.quaternion.copy(ballComponent.body.quaternion);
            
            // Force a visual update by marking the ball as needing update
            ball.object3D.updateMatrix();
            ball.object3D.updateMatrixWorld(true);
            
            // Mark this ball as remotely updated to prevent physics tick from overriding
            ball.setAttribute('data-remote-update', 'true');
            
            // Clear the remote update flag after a short delay
            setTimeout(() => {
              ball.removeAttribute('data-remote-update');
            }, 100); // 100ms delay
          }
          
          if (!this.lastBallUpdateTime || Date.now() - this.lastBallUpdateTime > 30000) {
            this.lastBallUpdateTime = Date.now();
          }
          
          // Debug: Log significant ball movement
          const ballSpeed = Math.sqrt(data.ballState.vx * data.ballState.vx + data.ballState.vy * data.ballState.vy + data.ballState.vz * data.ballState.vz);
          if (ballSpeed > 0.1) {
            
          }
          
          // Debug: Log ball update confirmation (throttled)
          if (!this.lastBallUpdateDebugTime || Date.now() - this.lastBallUpdateDebugTime > 30000) {
            this.lastBallUpdateDebugTime = Date.now();
          }
        } else {
          if (!this.lastBallErrorTime || Date.now() - this.lastBallErrorTime > 30000) {
            // Debug: list all balls to see what's available
            const allBalls = document.querySelectorAll('[zerog-ball]');
            allBalls.forEach((ball, index) => {
              const player = ball.getAttribute('zerog-ball')?.player;
            });
            this.lastBallErrorTime = Date.now();
          }
        }
      }

      function handlePlayerDisconnection(conn, playerId) {
        
        // Find the actual player ID assigned to this connection
        const actualPlayerId = connectionToPlayer.get(conn);
        
        // Remove the connection from the connections map
        let connectionKeyToRemove = null;
        connections.forEach((connection, key) => {
          if (connection === conn) {
            connectionKeyToRemove = key;
          }
        });
        
        if (connectionKeyToRemove) {
          connections.delete(connectionKeyToRemove);
        }
        
        // Remove the connection-to-player mapping
        connectionToPlayer.delete(conn);
        
        // Remove player from active players (use actual player ID if available)
        const playerToRemove = actualPlayerId || playerId;
        if (playerToRemove) {
          activePlayers.delete(playerToRemove);
          
          // If this was a client disconnecting, also remove them from the players map
          if (playerToRemove && playerToRemove.startsWith('player_')) {
            const player = players.get(playerToRemove);
            if (player) {
              player.isConnected = false;
              player.isBot = false;
            }
          }
        }
        
        // Handle client-side disconnection
        if (!isHost) {
          updateMultiplayerStatus('Connection lost - attempting to reconnect...');
          
          // Clear current state but keep multiplayer flag
          myPlayerId = null;
          activePlayers.clear();
          
          // Set a flag to prevent manual mode switches during reconnection
          window.isReconnecting = true;
          
          // Attempt to reconnect after a short delay
          setTimeout(() => {
            if (isMultiplayer && !isHost && window.isReconnecting) {
              
              // Add a timeout to the reconnection attempt
              const reconnectionTimeout = setTimeout(() => {
                if (window.isReconnecting) {
                  window.isReconnecting = false;
                  
                  // Switch to singleplayer mode
                  isMultiplayer = false;
                  isHost = false;
                  myPlayerId = null;
                  activePlayers.clear();
                  connections.clear();
                  connectionToPlayer.clear();
                  
                  // Reset to singleplayer state
                  const rig = document.querySelector('#rig');
                  if (rig) {
                    rig.setAttribute('position', '0 0 0');
                    rig.setAttribute('rotation', '0 0 0');
                  }
                  
                  // Reset player target color to default
                  const playerTarget = document.querySelector('#player-target');
                  if (playerTarget) {
                    playerTarget.setAttribute('color', '#ff0000');
                    playerTarget.setAttribute('material', 'emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7');
                    playerTarget.setAttribute('impact-effect', 'color: #ff0000');
                  }
                  
                  updateMultiplayerStatus('Singleplayer Mode');
                  updateMenuDisplay();
                }
              }, 10000); // 10 second timeout
              
              connectToLobby(selectedLobby).then(() => {
                clearTimeout(reconnectionTimeout);
                updateMultiplayerStatus(`Reconnected - Lobby ${selectedLobby}`);
                window.isReconnecting = false;
              }).catch((error) => {
                updateMultiplayerStatus('Reconnection failed - switching to singleplayer');
                
                // Switch to singleplayer mode if reconnection fails
                setTimeout(() => {
                  if (isMultiplayer && window.isReconnecting) {
                    isMultiplayer = false;
                    isHost = false;
                    myPlayerId = null;
                    activePlayers.clear();
                    connections.clear();
                    connectionToPlayer.clear();
                    window.isReconnecting = false;
                    
                    // Reset to singleplayer state
                    const rig = document.querySelector('#rig');
                    if (rig) {
                      rig.setAttribute('position', '0 0 0');
                      rig.setAttribute('rotation', '0 0 0');
                    }
                    
                    // Reset player target color to default
                    const playerTarget = document.querySelector('#player-target');
                    if (playerTarget) {
                      playerTarget.setAttribute('color', '#ff0000');
                      playerTarget.setAttribute('material', 'emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7');
                      playerTarget.setAttribute('impact-effect', 'color: #ff0000');
                    }
                    
                    updateMultiplayerStatus('Singleplayer Mode');
                    updateMenuDisplay();
                  } else {
                    window.isReconnecting = false;
                  }
                }, 2000); // Wait 2 seconds before switching to singleplayer
              });
            } else {
              window.isReconnecting = false;
            }
          }, 1000); // Wait 1 second before attempting reconnection
        }
        
        // Update displays
        updateMenuDisplay();
        
        // Send updated player count to remaining clients
        if (isHost) {
          sendPlayerCountUpdate();
        }
        
        // Make remote players visible again (in case some were hidden)
        setTimeout(() => {
          makeAllRemotePlayersVisible();
        }, 100);
        
      }

      function sendPlayerCountUpdate() {
        // Calculate actual player count (excluding connection IDs)
        const actualPlayerCount = Array.from(activePlayers).filter(id => id.startsWith('player_')).length;
        
        
        // Update host's own status display
        if (isHost) {
          const maxPlayers = gameMode === 'capture' ? 2 : 4;
          updateMultiplayerStatus(`Host - Lobby ${selectedLobby} (${actualPlayerCount}/${maxPlayers})`);
        }
        
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send({
              type: 'player-count-update',
              activePlayers: Array.from(activePlayers),
              playerCount: actualPlayerCount
            });
          }
        });
      }

      function connectToLobby(lobbyNumber) {
        return new Promise((resolve, reject) => {
          if (isMultiplayer) {
            // Disconnect from current session
            if (peer) {
              peer.destroy();
            }
            connections.clear();
            connectionToPlayer.clear();
            activePlayers.clear();
            myPlayerId = null;
          }
          
          // Try to connect as host first, then as peer
          setupHost(lobbyNumber).then(() => {
            resolve();
          }).catch((error) => {
            setupPeer(lobbyNumber).then(() => {
              resolve();
            }).catch((peerError) => {
              updateMultiplayerStatus(`Lobby ${lobbyNumber} unavailable. Try another lobby.`);
              reject(peerError);
            });
          });
        });
      }

      function autoConnect() {
        // Try to find an available lobby
        for (let lobby = 1; lobby <= MAX_LOBBIES; lobby++) {
          connectToLobby(lobby);
          break; // For now, just try lobby 1
        }
      }

      // Update HUD score display
      function updateHUDScore(playerScore, opponentScore, isMultiplayer = false) {
        const hudScore = document.querySelector('#hud-score');
        
        if (hudScore) {
          const playerScoreEl = hudScore.children[0];
          const opponentScoreEl = hudScore.children[1];
          
          if (playerScoreEl && opponentScoreEl) {
            if (isMultiplayer && myPlayerId) {
              // Get player names from player slots
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              const myPlayerName = `P${playerIndex}`;
              const myPlayerColor = playerSlots[playerIndex].color;
              
              // Find the opponent (other active player)
              let opponentName = 'Opponent';
              let opponentIndex = -1;
              let opponentColor = '#ff4444'; // Default red
              for (let i = 0; i < 4; i++) {
                if (i !== playerIndex && activePlayers.has(`player_${i}`)) {
                  opponentIndex = i;
                  opponentName = `P${i}`;
                  opponentColor = playerSlots[i].color;
                  break;
                }
              }
              
              playerScoreEl.setAttribute('text', 'value', `${myPlayerName}: ${playerScore}`);
              playerScoreEl.setAttribute('text', 'color', myPlayerColor);
              opponentScoreEl.setAttribute('text', 'value', `${opponentName}: ${opponentScore}`);
              opponentScoreEl.setAttribute('text', 'color', opponentColor);
            } else {
              // Singleplayer mode
              playerScoreEl.setAttribute('text', 'value', `You: ${playerScore}`);
              opponentScoreEl.setAttribute('text', 'value', `Bot: ${opponentScore}`);
              // Singleplayer HUD updated silently
            }
          }
        } else {
        }
      }

      // Show/hide HUD elements during gameplay
function setGameplayHUD(isPlaying) {
  // Don't change HUD visibility if menu is open
  if (isMenuVisible) {
    return;
  }
  
  const hudStatus = document.querySelector('#hud-status');
  const hudScore = document.querySelector('#hud-score');
  const hudTimer = document.querySelector('#hud-timer');
  const hudMessage = document.querySelector('#hud-message');
  
  if (hudStatus) {
    hudStatus.setAttribute('visible', !isPlaying);
  }
  if (hudScore) {
    // Only show score during active matches (not just when gameplay is enabled)
    const gameManager = document.querySelector('#game-manager');
    const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                         gameManager.components['game-manager'].gameStarted;
    hudScore.setAttribute('visible', isPlaying && isMatchActive);
  }
  if (hudTimer) {
    // Only show timer during active matches (not just when gameplay is enabled)
    const gameManager = document.querySelector('#game-manager');
    const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                         gameManager.components['game-manager'].gameStarted;
    hudTimer.setAttribute('visible', isPlaying && isMatchActive);
  }
  if (hudMessage) {
    // Show "Press A to Start" when not playing, hide during active gameplay
    if (isPlaying) {
      hudMessage.setAttribute('visible', false); // Hide during active gameplay
    } else {
      hudMessage.setAttribute('visible', true); // Show in default state
      hudMessage.setAttribute('text', 'value', 'Press A to Start');
    }
  }
  
  // HUD updated silently
}

      // Create materials for zero-g environment
      const defaultMaterial = new CANNON.Material('default');
      const playerMaterial = new CANNON.Material('player');
      const surfaceMaterial = new CANNON.Material('surface');
      const ballMaterial = new CANNON.Material('ball');
      
      /* 
       * COLLISION FILTERING SYSTEM:
       * Group 1: Player (can grab surfaces, ignores balls when held)
       * Group 2: Balls (can hit walls/surfaces, pass through player body)  
       * Group 4: Walls/Surfaces (interact with both player and balls)
       * 
       * This prevents physics reactions when holding balls near your body!
       */

      // Create contact materials for realistic surface interaction
      const playerSurfaceContact = new CANNON.ContactMaterial(
        playerMaterial,
        surfaceMaterial,
        {
          friction: 0.8,
          restitution: 0.3
        }
      );
      world.addContactMaterial(playerSurfaceContact);

      const ballSurfaceContact = new CANNON.ContactMaterial(
        ballMaterial,
        surfaceMaterial,
        {
          friction: 0.1,
          restitution: 0.9
        }
      );
      world.addContactMaterial(ballSurfaceContact);

      // Zero-G Player Controller - Physics-based movement
      AFRAME.registerComponent('zerog-player', {
        schema: {
          mass: { type: 'number', default: 70 }, // kg
          linearDamping: { type: 'number', default: 0.05 },
          angularDamping: { type: 'number', default: 0.1 },
          thrusterForce: { type: 'number', default: 0.8 },
          maxSpeed: { type: 'number', default: 8 },
          rotationSpeed: { type: 'number', default: 2 }
        },
        
        init: function() {
          
          // Option B: No physics body - use visual collision detection instead
          
          // Create collision visualization (this IS our collision system now)
          this.createCollisionVisualization();
          
          // Option B: Custom physics simulation state
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.angularVelocity = new THREE.Vector3(0, 0, 0);
          this.lastPosition = new THREE.Vector3(0, 0, 0);
          this.collisionMargin = 0.02; // 2cm safety margin
          this.damping = 0.996; // 0.4% velocity loss per frame (much gentler)
          this.minVelocity = 0.01; // Stop very slow movement
          
          // Movement state
          this.isGrabbing = { left: false, right: false };
          this.grabbedSurface = { left: null, right: null };
          this.grabInfo = { left: null, right: null };
          this.thrusterActive = { left: false, right: false };
          
          // Stunning state
          this.isStunned = false;
          this.stunEndTime = 0;
          this.stunImmunityEndTime = 0; // 10-second immunity after being stunned
          
          // NEW: Track grip state for continuous ball grabbing
          this.gripHeld = { left: false, right: false };
          
          // Rotation state
          this.rotationY = 0;
          this.thumbstickRotation = { left: 0, right: 0 };
          
          // Braking state
          this.isBraking = { left: false, right: false };
          this.brakingForce = 0.9; // Stronger braking for immediate effect
          
          // Get hand references
          this.leftHand = null;
          this.rightHand = null;
          this.rig = null;
          
          // Debug mode (for optional console output)
          this.debugMode = this.data.debug || false;
          
          // Wait for scene to load to get hand references
          this.el.sceneEl.addEventListener('loaded', () => {
            this.leftHand = document.querySelector('#leftHand');
            this.rightHand = document.querySelector('#rightHand');
            this.rig = document.querySelector('#rig');
            
            
            this.setupHandEvents();
            
            // Add keyboard listener for toggling collision visualization
            this.keydownListener = (evt) => {
              if (evt.key === 'c' || evt.key === 'C') {
                this.toggleCollisionVisualization();
              }
            };
            document.addEventListener('keydown', this.keydownListener);

          });
        },
        
        setupHandEvents: function() {
          // Grip controls for grabbing surfaces AND balls (EchoVR style)
          this.el.sceneEl.addEventListener('gripdown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            
            // Track grip state for continuous ball grabbing
            this.gripHeld[handKey] = true;
            
            // Try to grab balls first (priority), then static surfaces
            this.tryGrabBall(hand);
            
            // If no ball was grabbed, try static surfaces
            if (!this.isGrabbing[handKey]) {
              this.handleGrab(hand, true);
            }
          });
          
          this.el.sceneEl.addEventListener('gripup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            
            // Track grip state
            this.gripHeld[handKey] = false;
            
            // Release whatever is being grabbed (ball or surface)
            this.releaseGrabbedBall(hand);
            this.handleGrab(hand, false);
          });
          
          // Trigger controls for thrusters ONLY when menu is not visible
          this.el.sceneEl.addEventListener('triggerdown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't activate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, true);
          });
          
          this.el.sceneEl.addEventListener('triggerup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't deactivate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, false);
          });
          
          // Thumbstick controls for rotation
          this.el.sceneEl.addEventListener('thumbstickmoved', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return; // Skip silently for thumbstick to avoid spam
            }
            
            const hand = evt.target;
            this.handleThumbstick(hand, evt.detail);
          });
          
          // B button assigned to menu toggle (see menu-toggle component)
          
          // Thumbstick click for braking (Echo VR style)
          this.el.sceneEl.addEventListener('thumbstickdown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            this.startBraking(hand);
          });
          
          this.el.sceneEl.addEventListener('thumbstickup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            this.stopBraking(hand);
          });
        },
        
        // Debug arrows removed - not useful for this system
        
        handleThumbstick: function(hand, detail) {
          const isLeft = hand.id === 'leftHand';
          
          // Use right thumbstick for rotation (common VR convention)
          // Flip the direction to match expected behavior
          if (!isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.right = -detail.x;
            if (this.debugMode) {
            }
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
          
          // Left thumbstick could be used for other things in the future
          if (isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.left = -detail.x;
            if (this.debugMode) {
            }
          } else if (isLeft) {
            this.thumbstickRotation.left = 0;
          }
        },
        
        handleGrab: function(hand, isDown) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          

          
          if (isDown) {
            // Check for nearby surfaces to grab
            const surface = this.findNearestGrabbableSurface(hand);
            
            if (surface) {
              this.grabbedSurface[handKey] = surface;
              this.attachToSurface(hand, surface);
              
              // Haptic feedback
              this.playHapticFeedback(hand, 0.5, 100);
            }
          } else {
            if (this.isGrabbing[handKey]) {
              this.releaseFromSurface(hand);
              this.grabbedSurface[handKey] = null;
            }
          }
        },
        
        handleThruster: function(hand, isActive) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          this.thrusterActive[handKey] = isActive;
          
          if (isActive) {
            // Visual thruster effect
            this.showThrusterEffect(hand);
          } else {
            this.hideThrusterEffect(hand);
          }
        },
        
        findNearestGrabbableSurface: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
                  // Look for elements with grab-surface component OR zerog-ball attribute
        const allElements = document.querySelectorAll('[grab-surface], [zerog-ball]');
          let nearestSurface = null;
          let minDistance = Infinity;
          
          allElements.forEach(element => {
            const distance = this.getDistanceToSurface(handPos, handRadius, element);
            
            // If hand is touching or very close to surface (within 5cm)
            if (distance <= 0.05) {
              if (distance < minDistance) {
                minDistance = distance;
                nearestSurface = element;
              }
            }
          });
          
          // Only log when something is found
          if (nearestSurface) {
            const distanceCm = minDistance > 0 ? (minDistance * 100).toFixed(1) : "touching";

          }
          
          return nearestSurface;
        },
        
        getDistanceToSurface: function(handPos, handRadius, element) {
          const elementPos = new THREE.Vector3();
          element.object3D.getWorldPosition(elementPos);
          const geometry = element.getAttribute('geometry');
          
          if (!geometry) {
            // Fallback to simple distance for elements without geometry
            return handPos.distanceTo(elementPos) - handRadius;
          }
          
          // Check collision based on geometry type
          if (geometry.primitive === 'box') {
            return this.distanceToBox(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'sphere') {
            return this.distanceToSphere(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'cylinder') {
            return this.distanceToCylinder(handPos, handRadius, elementPos, geometry);
          } else {
            // Fallback
            return handPos.distanceTo(elementPos) - handRadius;
          }
        },
        
        distanceToBox: function(handPos, handRadius, boxPos, geometry) {
          // Calculate distance from hand sphere to box surface
          const halfWidth = geometry.width / 2;
          const halfHeight = geometry.height / 2;
          const halfDepth = geometry.depth / 2;
          
          // Get relative position of hand to box center
          const relativePos = new THREE.Vector3().subVectors(handPos, boxPos);
          
          // Calculate closest point on box to hand
          const closestPoint = new THREE.Vector3(
            Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
            Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
            Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
          );
          
          // Distance from hand to closest point on box surface
          const distance = relativePos.distanceTo(closestPoint);
          
          // Subtract hand radius to get surface distance
          return Math.max(0, distance - handRadius);
        },
        
        distanceToSphere: function(handPos, handRadius, spherePos, geometry) {
          const sphereRadius = geometry.radius;
          const centerDistance = handPos.distanceTo(spherePos);
          
          // Distance to sphere surface minus hand radius
          return Math.max(0, centerDistance - sphereRadius - handRadius);
        },
        
        distanceToCylinder: function(handPos, handRadius, cylinderPos, geometry) {
          const cylinderRadius = geometry.radius;
          const cylinderHeight = geometry.height;
          
          // Get relative position
          const relativePos = new THREE.Vector3().subVectors(handPos, cylinderPos);
          
          // Distance to cylinder axis (ignoring Y)
          const radialDistance = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
          
          // Clamp Y to cylinder height
          const clampedY = Math.max(-cylinderHeight/2, Math.min(cylinderHeight/2, relativePos.y));
          
          // Calculate distance to cylinder surface
          let distance;
          if (Math.abs(relativePos.y) <= cylinderHeight/2) {
            // Hand is within cylinder height, check radial distance
            distance = Math.max(0, radialDistance - cylinderRadius);
          } else {
            // Hand is above/below cylinder, check distance to circular ends
            const endDistance = Math.abs(relativePos.y) - cylinderHeight/2;
            if (radialDistance <= cylinderRadius) {
              distance = endDistance;
            } else {
              distance = Math.sqrt(endDistance * endDistance + Math.pow(radialDistance - cylinderRadius, 2));
            }
          }
          
          // Subtract hand radius
          return Math.max(0, distance - handRadius);
        },
        
        attachToSurface: function(hand, surface) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          
          const surfacePos = new THREE.Vector3();
          surface.object3D.getWorldPosition(surfacePos);
          
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Check if this is a ball and handle differently
          if (surface.hasAttribute('zerog-ball') && surface.components['zerog-ball']) {
            // For balls, call the ball's onGrab method
            surface.components['zerog-ball'].onGrab(hand);
            
            this.grabInfo[handKey] = {
              surface: surface,
              isBall: true,
              initialHandPos: handPos.clone(),
              lastHandPos: handPos.clone()
            };
            

          } else {
            // For static surfaces, use normal grab behavior
            // Option B: Use VR rig position instead of physics body
            const rigPos = new THREE.Vector3();
            this.rig.object3D.getWorldPosition(rigPos);
            
            this.grabInfo[handKey] = {
              surface: surface,
              isBall: false,
              initialHandPos: handPos.clone(),
              lastHandPos: handPos.clone(),
              initialSurfacePos: surfacePos.clone(),
              initialPlayerPos: rigPos.clone(),
              grabPoint: surfacePos.clone()
            };
            

          }
          
          // Set grabbing flag
          this.isGrabbing[handKey] = true;
          

        },
        
        releaseFromSurface: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabInfo = this.grabInfo[handKey];
          if (grabInfo) {
            // If releasing a ball, call the ball's onRelease method
            if (grabInfo.isBall && grabInfo.surface.components['zerog-ball']) {
              grabInfo.surface.components['zerog-ball'].onRelease();
            }
          }
          
          // Clear grab info
          this.grabInfo[handKey] = null;
          this.isGrabbing[handKey] = false;
          

        },
        
        showThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', true);
            thrusterVFX.setAttribute('material', 'opacity', 0.8);
          }
        },
        
        hideThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', false);
          }
        },
        
        // Debug arrow functions removed - not useful for this system
        
        playHapticFeedback: function(hand, intensity, duration) {
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(intensity, duration).catch(() => {});
          }
                },

        createCollisionVisualization: function() {
          // Create wireframe visualization of the collision capsule
          const radius = 0.25;
          const height = 1.6;
          
          // Option A: Add wireframes as camera children so they follow VR headset automatically
          const camera = document.querySelector('[camera]');
          if (!camera) {
            console.warn('Camera not found - cannot create collision visualization');
            return;
          }
          
          // Main cylinder (body center) - positioned relative to camera
          const cylinderWireframe = document.createElement('a-cylinder');
          cylinderWireframe.setAttribute('radius', radius);
          cylinderWireframe.setAttribute('height', height);
          cylinderWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          cylinderWireframe.setAttribute('position', '0 -0.4 0'); // 0.4m below camera (body center)
          camera.appendChild(cylinderWireframe);
          
          // Top sphere (head level) - positioned at camera position
          const topSphereWireframe = document.createElement('a-sphere');
          topSphereWireframe.setAttribute('radius', radius);
          topSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          topSphereWireframe.setAttribute('position', '0 0 0'); // At camera position (head level)
          camera.appendChild(topSphereWireframe);
          
          // Bottom sphere (feet level) - positioned 1.6m below camera
          const bottomSphereWireframe = document.createElement('a-sphere');
          bottomSphereWireframe.setAttribute('radius', radius);
          bottomSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          bottomSphereWireframe.setAttribute('position', '0 -0.8 0'); // 0.8m below camera (feet level)
          camera.appendChild(bottomSphereWireframe);
          
          // Store references and hide by default
          this.collisionVisualization = {
            cylinder: cylinderWireframe,
            topSphere: topSphereWireframe,
            bottomSphere: bottomSphereWireframe,
            visible: false
          };
          
          // Hide by default
          this.setCollisionVisualizationVisible(false);
          
        },

        toggleCollisionVisualization: function() {
          if (this.collisionVisualization) {
            this.collisionVisualization.visible = !this.collisionVisualization.visible;
            this.setCollisionVisualizationVisible(this.collisionVisualization.visible);
          }
        },

        setCollisionVisualizationVisible: function(visible) {
          if (this.collisionVisualization) {
            this.collisionVisualization.cylinder.setAttribute('visible', visible);
            this.collisionVisualization.topSphere.setAttribute('visible', visible);
            this.collisionVisualization.bottomSphere.setAttribute('visible', visible);
          }
        },

        tick: function(time, deltaTime) {
          // Option B: Custom physics simulation with visual collision detection
          if (!this.rig) return;
          
          const dt = Math.min(deltaTime / 1000, 0.033); // Cap at 30fps for stability
          
          // Check if stunned and disable controls
          if (this.isStunned) {
            if (Date.now() > this.stunEndTime) {
              this.isStunned = false;
            } else {
              // While stunned, disable movement but allow rotation
              this.velocity.set(0, 0, 0);
              this.thrusterActive.left = false;
              this.thrusterActive.right = false;
              this.isBraking.left = false;
              this.isBraking.right = false;
              
              // Release any grabbed objects
              ['left', 'right'].forEach(handKey => {
                if (this.isGrabbing[handKey]) {
                  const hand = handKey === 'left' ? this.leftHand : this.rightHand;
                  this.releaseFromSurface(hand);
                }
              });
              
              // Continue processing for rotation (don't return early)
              // Only skip movement-related processing below
            }
          }
          
          // Apply thumbstick rotation (allowed when stunned)
          this.applyRotation(dt);
          
          // Skip movement processing if stunned
          if (!this.isStunned) {
            // Apply thruster forces to velocity
            this.applyThrusterForces(dt);
            
            // Apply movement from grabbed surfaces
            this.applyGrabMovement(dt);
            
            // Apply gradual braking if active
            this.applyGradualBraking(dt);
            
            // Apply damping to velocity
            this.applyDamping(dt);
            
            // Check for collisions and apply responses
            this.checkAndResolveCollisions(dt);
            
            // Apply velocity to move VR rig
            this.applyVelocityToRig(dt);
            
            // Update grab visual feedback
            this.updateGrabFeedback();
            
            // NEW: Continuous ball grabbing while grip is held
            this.updateGripBallGrabbing();
          }
        },

        // Option B: Apply damping to velocity
        applyDamping: function(dt) {
          const dampingFactor = Math.pow(this.damping, dt * 60); // Frame-rate independent
          this.velocity.multiplyScalar(dampingFactor);
          
          // Stop very slow movement to prevent infinite drift
          if (this.velocity.length() < this.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
        },
        
        // Option B: Apply velocity to move VR rig
        applyVelocityToRig: function(dt) {
          if (this.velocity.length() > 0) {
            const movement = this.velocity.clone().multiplyScalar(dt);
            this.rig.object3D.position.add(movement);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
            }
          }
        },
        
        // Option B: Check for collisions using visual wireframes and resolve them
        checkAndResolveCollisions: function(dt) {
          if (!this.collisionVisualization) {
            return; // No collision checking if wireframes not created yet
          }
          
          // Get current camera position (this is our collision center)
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          const cameraWorldPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraWorldPos);
          
          // Check collision points (head, body center, feet)
          const collisionPoints = [
            { pos: cameraWorldPos.clone(), radius: 0.25, name: 'head' }, // Head level
            { pos: cameraWorldPos.clone().add(new THREE.Vector3(0, -0.4, 0)), radius: 0.25, name: 'body' }, // Body center
            { pos: cameraWorldPos.clone().add(new THREE.Vector3(0, -0.8, 0)), radius: 0.25, name: 'feet' } // Feet level
          ];
          
          let totalCollisionResponse = new THREE.Vector3(0, 0, 0);
          
          // Check each collision point against all collidable surfaces
          collisionPoints.forEach(point => {
            const response = this.checkPointCollision(point.pos, point.radius, point.name);
            if (response.length() > 0) {
              totalCollisionResponse.add(response);
            }
          });
          
          // Check for ball hits on player target (separate from wall collisions)
          this.checkBallHits(cameraWorldPos);
          
          // Check for melee hits (player holding ball and hitting opponent)
          this.checkMeleeHits(cameraWorldPos);
          
          // Apply collision response by moving rig and dampening velocity
          if (totalCollisionResponse.length() > 0) {
            // Move rig away from collision
            this.rig.object3D.position.add(totalCollisionResponse);
            
            // Dampen velocity in collision direction
            const collisionNormal = totalCollisionResponse.clone().normalize();
            const velocityInCollisionDirection = this.velocity.clone().projectOnVector(collisionNormal);
            this.velocity.sub(velocityInCollisionDirection.multiplyScalar(1.2)); // Remove + a bit extra
            
            if (this.debugMode) {
            }
          }
        },
        
        // Option B: Check a single point for collision with surfaces
        checkPointCollision: function(point, radius, pointName) {
          const response = new THREE.Vector3(0, 0, 0);
          
          // Check against all grab-surface objects
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            const surfacePos = new THREE.Vector3();
            surface.object3D.getWorldPosition(surfacePos);
            const geometry = surface.getAttribute('geometry');
            
            if (!geometry) return;
            
            const collision = this.getCollisionResponse(point, radius, surfacePos, geometry);
            if (collision.length() > 0) {
              response.add(collision);
              if (this.debugMode) {
              }
            }
          });
          
          return response;
        },
        
        // Option B: Calculate collision response for point vs geometry
        getCollisionResponse: function(point, radius, surfacePos, geometry) {
          const response = new THREE.Vector3(0, 0, 0);
          
          if (geometry.primitive === 'box') {
            // Box collision
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            const penetration = radius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              // Calculate push-out direction
              const direction = relativePos.clone().sub(closestPoint).normalize();
              if (direction.length() === 0) {
                // Point is exactly on surface, push up
                direction.set(0, 1, 0);
              }
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision
            const sphereRadius = geometry.radius;
            const distance = point.distanceTo(surfacePos);
            const penetration = radius + sphereRadius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              const direction = point.clone().sub(surfacePos).normalize();
              response.copy(direction.multiplyScalar(penetration));
            }
          }
          
          return response;
        },
        
        // Check for ball hits on player target sphere
        checkBallHits: function(playerPos) {
          // Get all balls
          const balls = document.querySelectorAll('[zerog-ball]');
          
          balls.forEach(ball => {
            if (!ball.body) return; // Skip if no physics body
            
            const ballPos = new THREE.Vector3();
            ballPos.copy(ball.body.position);
            const ballVelocity = ball.body.velocity.length();
            
            // Check distance to player target (camera position)
            const distance = ballPos.distanceTo(playerPos);
            const hitDistance = 0.3; // 0.2m target radius + 0.1m ball radius
            
            // Only trigger if ball is moving and close to player target
            if (distance <= hitDistance && ballVelocity > 0.5) {
              // Check which player owns this ball
              const ballPlayer = ball.getAttribute('zerog-ball').player;
              
              // Only opponent balls (player1) can hit the player target
              if (ballPlayer === 'player1') {
                // Play impact effect
                const playerTarget = document.querySelector('#player-target');
                if (playerTarget && playerTarget.components['impact-effect']) {
                  playerTarget.components['impact-effect'].playEffect();
                  
                  // Reset ball after hit
                  if (ball.components['zerog-ball']) {
                    ball.components['zerog-ball'].resetPosition();
                  }
                  
                  if (this.debugMode) {
                  }
                }
              }
            }
          });
        },
        
        // Check for melee hits (player holding ball and hitting opponent)
        checkMeleeHits: function(playerPos) {
          if (gameMode !== 'capture') return; // Only in capture mode
          if (this.isStunned) return; // Can't melee while stunned
          
          // Check if player is holding any ball
          let heldBall = null;
          const balls = document.querySelectorAll('[zerog-ball]');
          
          balls.forEach(ball => {
            if (ball.components['zerog-ball'] && ball.components['zerog-ball'].isGrabbed) {
              heldBall = ball;
            }
          });
          
          if (!heldBall) return; // No ball held
          
          // Check if player is moving fast enough for melee hit
          const playerVelocity = this.velocity.length();
          if (playerVelocity < 2.0) return; // Need to be moving at least 2 m/s
          
          // Add cooldown to prevent spam
          const now = Date.now();
          this.lastMeleeTime = this.lastMeleeTime || 0;
          if (now - this.lastMeleeTime < 1000) return; // 1 second cooldown
          
          // Check collision with bot target (singleplayer)
          if (!isMultiplayer || activePlayers.size <= 1) {
            const botTarget = document.querySelector('#bot-target');
            if (botTarget) {
              const targetPos = new THREE.Vector3();
              botTarget.object3D.getWorldPosition(targetPos);
              const distance = playerPos.distanceTo(targetPos);
              
              if (distance < 0.5) { // Close enough for melee hit
                const playerId = myPlayerId || 'player_0';
                if (areTeammates(playerId, 'bot-red') || areTeammates(playerId, 'bot-blue')) {
                  return;
                }
                
                // Stun the bot
                const impactEffect = botTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                
                // Find the ball component and call stunBot
                if (heldBall.components['zerog-ball']) {
                  heldBall.components['zerog-ball'].stunBot();
                }
                
                // Add cooldown to prevent spam
                this.lastMeleeTime = Date.now();
                return;
              }
            }
          }
          
          // Check collision with other players (multiplayer)
          for (let i = 0; i < 4; i++) {
            const targetId = `player_${i}`;
            if (!activePlayers.has(targetId)) continue;
            
            let targetEntity = null;
            const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
            
            if (i === myPlayerIndex) continue; // Can't hit yourself
            
            if (myPlayerId && i === myPlayerIndex) {
              continue; // Skip self
            } else {
              targetEntity = document.querySelector(`#remote-target-${i}`);
            }
            
            if (!targetEntity) continue;
            
            const targetPos = new THREE.Vector3();
            targetEntity.object3D.getWorldPosition(targetPos);
            const distance = playerPos.distanceTo(targetPos);
            
            if (distance < 0.5) { // Close enough for melee hit
              const playerId = myPlayerId || 'player_0';
              if (areTeammates(playerId, targetId)) {
                continue;
              }
              
              // Stun the target player
              const impactEffect = targetEntity.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              
              // Find the ball component and call stunPlayer
              if (heldBall.components['zerog-ball']) {
                heldBall.components['zerog-ball'].stunPlayer();
              }
              
              // Add cooldown to prevent spam
              this.lastMeleeTime = Date.now();
              return;
            }
          }
        },
        
        updateGrabFeedback: function() {
          // Show visual feedback for grabbable objects in range
          if (!this.leftHand || !this.rightHand) return;
          
          const leftNearby = this.findNearestGrabbableSurface(this.leftHand);
          const rightNearby = this.findNearestGrabbableSurface(this.rightHand);
          
          // Reset all grabbable objects to normal color first
          document.querySelectorAll('.grabbable-surface, [zerog-ball]').forEach(el => {
            if (el.hasAttribute('material')) {
              const currentColor = el.getAttribute('material').color;
              if (currentColor === '#00ff00') { // Reset if it was highlighted
                el.setAttribute('material', 'color', '#888888');
              }
            }
          });
          
          // Highlight objects in grab range
          if (leftNearby && !this.isGrabbing.left) {
            leftNearby.setAttribute('material', 'color', '#00ff00');
          }
          if (rightNearby && !this.isGrabbing.right && rightNearby !== leftNearby) {
            rightNearby.setAttribute('material', 'color', '#00ff00');
          }
        },
        
        // Option B: Apply rotation to VR rig only (no physics body)
        applyRotation: function(deltaTime) {
          if (!this.rig) {
            return;
          }
          
          // Apply rotation from right thumbstick
          const rotationInput = this.thumbstickRotation.right;
          if (Math.abs(rotationInput) > 0.1) {
            const rotationSpeed = this.data.rotationSpeed * deltaTime; // deltaTime is already in seconds
            this.rotationY += rotationInput * rotationSpeed;
            
            // Apply rotation to the rig only (Option B: no physics body)
            this.rig.object3D.rotation.y = this.rotationY;
            
            // Debug output
            if (this.debugMode) {
            }
          }
        },
        
        // Option B: Apply thruster forces to velocity
        applyThrusterForces: function(dt) {
          if (!this.leftHand || !this.rightHand) return;
          
          let totalThrust = new THREE.Vector3(0, 0, 0);
          
          // Left hand thruster
          if (this.thrusterActive.left) {
            // Get thrust direction from controller orientation
            const leftDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.leftHand.object3D.getWorldQuaternion(worldQuat);
            leftDir.applyQuaternion(worldQuat);
            leftDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(leftDir);
            
            if (this.debugMode) {
            }
          }
          
          // Right hand thruster
          if (this.thrusterActive.right) {
            // Get thrust direction from controller orientation
            const rightDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.rightHand.object3D.getWorldQuaternion(worldQuat);
            rightDir.applyQuaternion(worldQuat);
            rightDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(rightDir);
            
            if (this.debugMode) {
            }
          }
          
          // Apply thrust to velocity (Option B approach)
          if (totalThrust.length() > 0) {
            this.velocity.add(totalThrust);
            
            // Cap maximum velocity
            if (this.velocity.length() > this.data.maxSpeed) {
              this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
            }
            
            if (this.debugMode) {
            }
          }
        },
        
        // Option B: Apply grab movement to velocity
        applyGrabMovement: function(dt) {
          // Handle pulling/pushing when grabbing STATIC surfaces (not balls)
          ['left', 'right'].forEach(handKey => {
            if (this.isGrabbing[handKey] && this.grabInfo[handKey]) {
              const grabInfo = this.grabInfo[handKey];
              
              // CRITICAL: Only apply player movement for static surfaces, NEVER for balls
              if (grabInfo.isBall) {
                return; // Balls handle their own movement, do NOT affect player
              }
              
              // Double-check: Ensure surface is not a ball by checking for zerog-ball attribute
              if (grabInfo.surface && grabInfo.surface.hasAttribute('zerog-ball')) {
                return; // Additional safety check
              }
              
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              if (!hand) return;
              
              const currentHandPos = new THREE.Vector3();
              hand.object3D.getWorldPosition(currentHandPos);
              
              // Calculate how much the hand has moved since last frame
              const handMovement = new THREE.Vector3()
                .subVectors(currentHandPos, grabInfo.lastHandPos);
              
              const movementMagnitude = handMovement.length();
              
              // Only apply movement if hand has moved significantly
              if (movementMagnitude > 0.001) { // 0.1cm minimum movement
                
                // Apply hand movement as velocity change in opposite direction
                // This creates the "pulling yourself toward/away from object" effect
                const movementStrength = 80.0; // Scale factor for responsiveness
                const velocityChange = handMovement.clone().negate().multiplyScalar(movementStrength / dt);
                
                // Add to velocity (Option B approach)
                this.velocity.add(velocityChange.multiplyScalar(dt));
                
                // Cap maximum velocity
                if (this.velocity.length() > this.data.maxSpeed) {
                  this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
                }
                
                if (this.debugMode) {
                }
              }
              
              // Update last hand position for next frame
              grabInfo.lastHandPos.copy(currentHandPos);
            }
          });
        },
        
        startBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Start braking for this hand
          this.isBraking[handKey] = true;
          
          // Haptic feedback when starting braking
          this.playHapticFeedback(hand, 0.2, 100);
        },
        
        stopBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Stop braking for this hand
          this.isBraking[handKey] = false;
          
          // Haptic feedback when stopping braking
          this.playHapticFeedback(hand, 0.1, 50);
        },
        
        // Option B: Apply braking to velocity
        applyGradualBraking: function(dt) {
          // Check if either hand is braking
          const isBrakingActive = this.isBraking.left || this.isBraking.right;
          
          if (isBrakingActive) {
            // Apply stronger braking to velocity
            const brakingFactor = Math.pow(this.brakingForce, dt * 60); // Frame-rate independent
            this.velocity.multiplyScalar(brakingFactor);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
            }
          }
        },

        // NEW: Try to grab a ball with the specified hand
        tryGrabBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Don't grab if already grabbing something
          if (this.isGrabbing[handKey]) return;
          
          // Look for nearby balls only (not static surfaces)
          const ball = this.findNearestBall(hand);
          
          if (ball) {
            // Only grab player's own ball or capture ball
            const ballPlayer = ball.getAttribute('zerog-ball')?.player;
            
            // Determine which ball this player should grab
            let shouldGrabThisBall = false;
            
            // Always allow grabbing the capture ball
            if (ballPlayer === 'capture') {
              shouldGrabThisBall = true;
            } else {
              // Use dynamic ball assignment based on current team and game mode
              const currentPlayerId = myPlayerId || 'player_0';
              const myBallIndex = getBallForPlayer(currentPlayerId);
              const expectedBallPlayer = `player${myBallIndex}`;
              shouldGrabThisBall = (ballPlayer === expectedBallPlayer);
            }
            
            if (shouldGrabThisBall) {
              this.grabbedSurface[handKey] = ball;
              this.attachToSurface(hand, ball);
              
              // Haptic feedback
              this.playHapticFeedback(hand, 0.5, 100);
            }
          }
        },
        
        // NEW: Release grabbed ball  
        releaseGrabbedBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabInfo = this.grabInfo[handKey];
          if (grabInfo && grabInfo.isBall) {
            this.releaseFromSurface(hand);
            this.grabbedSurface[handKey] = null;
            
          }
        },
        
        // NEW: Find nearest ball (not static surfaces)
        findNearestBall: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
          // Look for balls only
          const balls = document.querySelectorAll('[zerog-ball]');
          let nearestBall = null;
          let minDistance = Infinity;
          
          balls.forEach(ball => {
            const distance = this.getDistanceToSurface(handPos, handRadius, ball);
            
            // If hand is touching or very close to ball (within 10cm for easier grabbing)
            if (distance <= 0.10) {
              if (distance < minDistance) {
                minDistance = distance;
                nearestBall = ball;
              }
            }
          });
          
          return nearestBall;
        },
        
        // NEW: Continuous ball grabbing while grip is held
        updateGripBallGrabbing: function() {
          // Check each hand
          ['left', 'right'].forEach(handKey => {
            const hand = handKey === 'left' ? this.leftHand : this.rightHand;
            if (!hand) return;
            
            // If grip is held but not currently grabbing anything
            if (this.gripHeld[handKey] && !this.isGrabbing[handKey]) {
              // Continuously try to grab nearby balls
              this.tryGrabBall(hand);
            }
          });
        },

        remove: function() {
          // Option B: No physics body to remove
          
          // Clean up event listener
          if (this.keydownListener) {
            document.removeEventListener('keydown', this.keydownListener);
          }
          
          // Clean up collision visualization elements from camera
          if (this.collisionVisualization) {
            if (this.collisionVisualization.cylinder && this.collisionVisualization.cylinder.parentNode) {
              this.collisionVisualization.cylinder.parentNode.removeChild(this.collisionVisualization.cylinder);
            }
            if (this.collisionVisualization.topSphere && this.collisionVisualization.topSphere.parentNode) {
              this.collisionVisualization.topSphere.parentNode.removeChild(this.collisionVisualization.topSphere);
            }
            if (this.collisionVisualization.bottomSphere && this.collisionVisualization.bottomSphere.parentNode) {
              this.collisionVisualization.bottomSphere.parentNode.removeChild(this.collisionVisualization.bottomSphere);
            }
          }
        }
      });

      // Surface Grab Points - Interactive surfaces for grabbing
      AFRAME.registerComponent('grab-surface', {
        schema: {
          type: { type: 'string', default: 'static' }, // static, dynamic
          strength: { type: 'number', default: 1.0 }
        },
        
        init: function() {
          // Add grabbable class
          this.el.classList.add('grabbable-surface');
          
          // Create physics body for surface
          const geometry = this.el.getAttribute('geometry');
          let shape;
          
          if (geometry && geometry.primitive === 'box') {
            shape = new CANNON.Box(new CANNON.Vec3(
              geometry.width / 2,
              geometry.height / 2,
              geometry.depth / 2
            ));
          } else if (geometry && geometry.primitive === 'sphere') {
            shape = new CANNON.Sphere(geometry.radius);
          } else {
            // Fallback for unknown geometry
            shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
          }
          
          this.body = new CANNON.Body({
            mass: this.data.type === 'static' ? 0 : 1,
            shape: shape,
            material: surfaceMaterial,
            type: this.data.type === 'static' ? CANNON.Body.STATIC : CANNON.Body.DYNAMIC,
            collisionFilterGroup: 4, // Surfaces are in group 4
            collisionFilterMask: 3   // Surfaces collide with groups 1 (player) + 2 (balls) = 3
          });
          
          const position = this.el.getAttribute('position');
          const rotation = this.el.getAttribute('rotation');
          this.body.position.set(position.x, position.y, position.z);
          
          // Apply rotation if present
          if (rotation) {
            const rad = Math.PI / 180;
            this.body.quaternion.setFromEuler(
              rotation.x * rad,
              rotation.y * rad,
              rotation.z * rad
            );
          }
          
          world.addBody(this.body);
          
          // Store body reference for grabbing
          this.el.body = this.body;
          

          
          // Visual feedback for grabbable surfaces
          this.el.addEventListener('mouseenter', () => {
            this.el.setAttribute('material', 'color', '#00ff00');
          });
          
          this.el.addEventListener('mouseleave', () => {
            this.el.setAttribute('material', 'color', '#ffffff');
          });
        }
      });



      // Zero-G Bot Component - AI opponent for singleplayer
      AFRAME.registerComponent('zerog-bot', {
        schema: {
          enabled: { type: 'boolean', default: true },
          difficulty: { type: 'string', default: 'medium' },
          throwInterval: { type: 'number', default: 4000 }, // 4 seconds between throws
          minThrowForce: { type: 'number', default: 3 },
          maxThrowForce: { type: 'number', default: 8 },
          movementSpeed: { type: 'number', default: 1.5 },
          accuracy: { type: 'number', default: 0.7 },
          team: { type: 'string', default: 'red' } // 'red' or 'blue'
        },
        
        init: function() {
          this.ball = null;
          this.lastThrowTime = 0;
          this.lastMoveTime = 0;
          this.moveInterval = 6000; // Move every 6 seconds
          this.targetPosition = new THREE.Vector3();
          this.isMoving = false;
          this.moveStartTime = 0;
          this.moveStartPos = new THREE.Vector3();
          this.moveDuration = 2000; // 2 second movement duration
          
          // Player tracking for predictive aiming
          this.playerPos = new THREE.Vector3();
          this.playerLastPos = new THREE.Vector3();
          this.playerVelocity = new THREE.Vector3();
          this.lastPlayerUpdate = 0;
          
          // Stunning state
          this.isStunned = false;
          this.stunEndTime = 0;
          this.stunImmunityEndTime = 0; // 10-second immunity after being stunned
          
          // Create physics body for the bot
          const shape = new CANNON.Sphere(0.2);
          // Position based on team: red bot at negative Z, blue bot at positive Z
          const startZ = this.data.team === 'red' ? -12 : 12;
          this.body = new CANNON.Body({
            mass: 50, // 50kg bot
            shape: shape,
            material: defaultMaterial,
            position: new CANNON.Vec3(0, 2, startZ), // Team-based starting position
            linearDamping: 0.8,
            angularDamping: 0.8,
            collisionFilterGroup: 1,
            collisionFilterMask: 6 // Collide with balls (group 2) and surfaces (group 4)
          });
          
          this.body.gravity = new CANNON.Vec3(0, 0, 0); // Zero gravity
          world.addBody(this.body);
          
          // Store reference
          this.body.el = this.el;
          
          // Initialize position
          this.generateNewTargetPosition();
          
          // Initialize ball assignment - will be updated when game mode changes
          this.updateBallAssignment();
          
          // Add collision detection for bot being hit
          this.body.addEventListener('collide', (evt) => {
            this.checkPlayerBallHit(evt);
          });
          
          // Update difficulty settings
          if (this.data.difficulty === 'easy') {
            this.data.throwInterval = 6000;  // 6 seconds between throws
            this.data.accuracy = 0.5;        // 50% accuracy
          } else if (this.data.difficulty === 'medium') {
            this.data.throwInterval = 4000;  // 4 seconds between throws  
            this.data.accuracy = 0.7;        // 70% accuracy
          } else if (this.data.difficulty === 'hard') {
            this.data.throwInterval = 3000;  // 3 seconds between throws
            this.data.accuracy = 0.9;        // 90% accuracy
          }
        },
        
        updateBallAssignment: function() {
          // Get ball assignment based on current game mode and team
          const botId = this.data.team === 'red' ? 'bot-red' : 'bot-blue';
          const ballIndex = getBallForPlayer(botId);
          const ballPlayer = `player${ballIndex}`;
          this.ball = this.el.sceneEl.querySelector(`[zerog-ball*="player: ${ballPlayer}"]`);
        },
        
                 checkPlayerBallHit: function(evt) {
           if (!this.data.enabled) return;
           
           const otherBody = evt.target === this.body ? evt.body : evt.target;
           
           // Check if hit by player's ball
           if (otherBody.el && otherBody.el.hasAttribute('zerog-ball')) {
             const ballPlayer = otherBody.el.getAttribute('zerog-ball').player;
             const ballNumber = parseInt(ballPlayer.replace('player', ''));
             let currentPlayerBallNumber = 2; // Default for singleplayer
             if (isMultiplayer && myPlayerId) {
               currentPlayerBallNumber = getBallForPlayer(myPlayerId);
             }
             
             if (ballNumber === currentPlayerBallNumber) {
               // Bot was hit - only trigger impact effect (scoring handled by zerog-ball component)
               const impactEffect = this.el.components['impact-effect'];
               if (impactEffect) {
                 impactEffect.playEffect();
               }
               
             }
           }
         },
        
        generateNewTargetPosition: function() {
          // Generate a random position near team's goal

          if (this.data.team === 'red') {
            // Red team: stay near red goal (Z: -14.8), move in 4x4 area around -12.8
            this.targetPosition.set(
              (Math.random() - 0.5) * 4,  // X: -2 to 2 (4m wide)
              Math.random() * 2 + 1.5,    // Y: 1.5 to 3.5 (2m high)
              -12.8 + (Math.random() - 0.5) * 4  // Z: -14.8 to -10.8 (4m deep, centered on -12.8)
            );

          } else {
            // Blue team: stay near blue goal (Z: 14.8), move in 4x4 area around 12.8
            this.targetPosition.set(
              (Math.random() - 0.5) * 4,  // X: -2 to 2 (4m wide)
              Math.random() * 2 + 1.5,    // Y: 1.5 to 3.5 (2m high)
              12.8 + (Math.random() - 0.5) * 4   // Z: 10.8 to 14.8 (4m deep, centered on 12.8)
            );

          }
        },
        
        updatePlayerTracking: function(time) {
          // Get player TARGET position (the actual sphere that needs to be hit)
          const playerTarget = document.querySelector('#player-target');
          if (!playerTarget) return;
          
          // Store previous position
          this.playerLastPos.copy(this.playerPos);
          
          // Get current world position of the target sphere
          playerTarget.object3D.getWorldPosition(this.playerPos);
          
          // Calculate velocity if we have a previous frame
          if (this.lastPlayerUpdate > 0) {
            const deltaTime = (time - this.lastPlayerUpdate) / 1000; // Convert to seconds
            if (deltaTime > 0.001) { // Avoid division by zero
              this.playerVelocity.subVectors(this.playerPos, this.playerLastPos).divideScalar(deltaTime);
            }
          }
          
          this.lastPlayerUpdate = time;
        },
        
        startMovementToTarget: function(currentTime) {
          this.isMoving = true;
          this.moveStartTime = currentTime; // Use A-Frame time consistently
          this.moveStartPos.copy(this.body.position);
          
          // Calculate velocity needed to reach target
          const direction = new THREE.Vector3()
            .subVectors(this.targetPosition, this.moveStartPos)
            .normalize();
          
          const velocity = direction.multiplyScalar(this.data.movementSpeed);
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          
        },
        
        stopMovement: function() {
          this.isMoving = false;
          // Apply damping to slow down
          this.body.velocity.scale(0.1, this.body.velocity);
          this.generateNewTargetPosition();
        },
        
        findBestTarget: function() {
          const botPos = new THREE.Vector3().copy(this.body.position);
          const botId = this.data.team === 'red' ? 'bot-red' : 'bot-blue';
          let targets = [];
          
          // Add human player as potential target
          const playerTarget = document.querySelector('#player-target');
          if (playerTarget) {
            const playerId = myPlayerId || 'player_0';
            if (!areTeammates(botId, playerId)) {
              const targetPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(targetPos);
              const distance = botPos.distanceTo(targetPos);
              
              // Get player velocity (simplified)
              const playerVelocity = new THREE.Vector3(); // Could be enhanced with actual tracking
              
              targets.push({
                type: 'human player',
                position: targetPos,
                velocity: playerVelocity,
                distance: distance
              });
            }
          }
          
          // Add other bot as potential target
          const otherBotId = this.data.team === 'red' ? '#zerog-bot-blue' : '#zerog-bot-red';
          const otherBot = document.querySelector(otherBotId);
          if (otherBot && otherBot.getAttribute('visible')) {
            const otherBotTarget = otherBot.querySelector('[id*="target"]');
            if (otherBotTarget) {
              const targetPos = new THREE.Vector3();
              otherBotTarget.object3D.getWorldPosition(targetPos);
              const distance = botPos.distanceTo(targetPos);
              
              // Get other bot's velocity
              const otherBotVelocity = otherBot.components['zerog-bot'] && otherBot.components['zerog-bot'].body 
                ? new THREE.Vector3().copy(otherBot.components['zerog-bot'].body.velocity)
                : new THREE.Vector3();
              
              targets.push({
                type: `${this.data.team === 'red' ? 'blue' : 'red'} bot`,
                position: targetPos,
                velocity: otherBotVelocity,
                distance: distance
              });
            }
          }
          
          // Return target with switching logic
          if (targets.length === 0) return null;
          
          // If only one target, use it
          if (targets.length === 1) return targets[0];
          
          // Multiple targets: switch between them periodically
          if (!this.lastTargetSwitchTime) this.lastTargetSwitchTime = 0;
          if (!this.currentTargetIndex) this.currentTargetIndex = 0;
          
          const now = Date.now();
          const switchInterval = 3000; // Switch target every 3 seconds
          
          if (now - this.lastTargetSwitchTime > switchInterval) {
            this.currentTargetIndex = (this.currentTargetIndex + 1) % targets.length;
            this.lastTargetSwitchTime = now;

          }
          
          // Sort by distance but use the selected target
          targets.sort((a, b) => a.distance - b.distance);
          
          // If current target index is valid, use it, otherwise use closest
          if (this.currentTargetIndex < targets.length) {
            return targets[this.currentTargetIndex];
          } else {
            this.currentTargetIndex = 0;
            return targets[0];
          }
        },
        
        throwBallAtPlayer: function() {
          if (!this.ball || !this.ball.components['zerog-ball']) {
            return;
          }
          
          // Find the best target (closest opponent)
          const bestTarget = this.findBestTarget();
          if (!bestTarget) {

            return;
          }
          
          // Reset ball to bot position
          this.ball.components['zerog-ball'].resetPosition();
          const ballBody = this.ball.components['zerog-ball'].body;
          
          // Position ball slightly in front of bot
          const botPos = new THREE.Vector3().copy(this.body.position);
          botPos.z += 0.5; // Slightly forward
          ballBody.position.set(botPos.x, botPos.y, botPos.z);
          
          // Calculate throw force
          const throwForce = this.data.minThrowForce + 
            Math.random() * (this.data.maxThrowForce - this.data.minThrowForce);
          
          // SIMPLIFIED AIMING: Direct aim at target with minimal prediction
          let targetPos = bestTarget.position.clone();
          const velocityMagnitude = bestTarget.velocity.length();
          

          
          // Only use light prediction for fast-moving targets (> 2 m/s)
          if (velocityMagnitude > 2.0) {
            const currentDistance = botPos.distanceTo(bestTarget.position);
            const estimatedTravelTime = currentDistance / throwForce;
            const predictedMovement = bestTarget.velocity.clone().multiplyScalar(estimatedTravelTime * 0.3); // Only 30% prediction
            targetPos.add(predictedMovement);
            // Light prediction applied
          } else {
            // Direct aim at target
          }
          
          // Calculate throw direction
          let direction = new THREE.Vector3().subVectors(targetPos, botPos).normalize();
          
          // Bot accuracy - set to 100% accurate (no inaccuracy)
          let inaccuracy = 0; // 100% accurate - no spread
          
          // No inaccuracy applied - bot is perfectly accurate
          // direction.x += (Math.random() - 0.5) * inaccuracy;
          // direction.y += (Math.random() - 0.5) * inaccuracy;
          // direction.z += (Math.random() - 0.5) * inaccuracy;
          // direction.normalize(); // Already normalized above
          
          // Apply velocity to ball
          ballBody.velocity.set(
            direction.x * throwForce,
            direction.y * throwForce,
            direction.z * throwForce
          );
          
          // Add some spin
          ballBody.angularVelocity.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          
          // Bot aiming calculation complete

        },
        
        tick: function(time) {
          if (!this.data.enabled) return;
          
          // CRITICAL: In multiplayer, only the host should run bot AI
          // Clients should only receive bot position updates
          if (isMultiplayer && activePlayers.size > 1 && !isHost) {
            return; // Clients don't run bot AI
          }
          
          // Check if stunned and disable AI
          if (this.isStunned) {
            if (Date.now() > this.stunEndTime) {
              this.isStunned = false;

            } else {
              // While stunned, stop all movement and AI
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              this.isMoving = false;

              return; // Skip all AI processing while stunned
            }
          }
          
          // Update visual position from physics
          this.el.object3D.position.copy(this.body.position);
          this.el.object3D.quaternion.copy(this.body.quaternion);
          
          // Keep zero gravity
          this.body.gravity.set(0, 0, 0);
          
          // Track player movement for predictive aiming
          this.updatePlayerTracking(time);
          
          // Movement logic
          if (!this.isMoving && time - this.lastMoveTime > this.moveInterval) {
            this.startMovementToTarget(time); // Pass current time
            this.lastMoveTime = time;
          }
          
          // Stop movement after duration
          if (this.isMoving && time - this.moveStartTime > this.moveDuration) {
            this.stopMovement();
          }
          
          // Throwing logic - only when match is active
          const gameManager = this.el.sceneEl.querySelector('#game-manager');
          const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                               (gameManager.components['game-manager'].matchState === 'PLAYING' || 
                                gameManager.components['game-manager'].matchState === 'OVERTIME');
          

          
          if (isMatchActive && time - this.lastThrowTime > this.data.throwInterval) {

            
            // In capture mode, only throw at opponents
            if (gameMode === 'capture') {
              const playerId = myPlayerId || 'player_0';
              const botId = this.data.team === 'red' ? 'bot-red' : 'bot-blue';
              if (areTeammates(botId, playerId)) {
                this.lastThrowTime = time;
                return;
              }
            }
            
            this.throwBallAtPlayer();
            this.lastThrowTime = time;
          }
        },
        
        remove: function() {
          if (this.body) {
            world.removeBody(this.body);
          }
        }
      });

      // Goal component for team-based gameplay
      AFRAME.registerComponent('goal', {
        schema: {
          team: { type: 'string', default: 'red' }
        },
        
        init: function() {
          
          // Wait for the scene to be fully loaded before creating physics
          if (this.el.sceneEl.hasLoaded) {
            this.createPhysicsBody();
          } else {
            this.el.sceneEl.addEventListener('loaded', () => {
              this.createPhysicsBody();
            });
          }
        },
        
        createPhysicsBody: function() {
          
          // Add collision detection for the capture ball
          this.el.addEventListener('collide', (evt) => {
            this.checkGoalScore(evt);
          });
          
          // Create physics body for goal detection (rotated to match visual)
          const shape = new CANNON.Cylinder(1, 1, 0.1, 8); // radius, radius, height, segments
          this.body = new CANNON.Body({
            mass: 0, // Static body
            shape: shape,
            position: new CANNON.Vec3(
              this.el.getAttribute('position').x,
              this.el.getAttribute('position').y,
              this.el.getAttribute('position').z
            ),
            collisionFilterGroup: 8, // Goals are in group 8
            collisionFilterMask: 2   // Goals only detect balls (group 2)
          });
          
          
          // Rotate the physics body to match the visual (90 degrees around X-axis)
          this.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
          
          world.addBody(this.body);
          this.el.body = this.body;
          
          // Listen for ball collisions
          this.body.addEventListener('collide', (evt) => {
            this.checkGoalScore(evt);
          });
          
        },
        
        checkGoalScore: function(evt) {
          
          // Only score in capture mode
          if (gameMode !== 'capture') {
            return;
          }
          
          const otherBody = evt.target === this.body ? evt.body : evt.target;
          
          // Check if the colliding object is the capture ball
          // Method 1: Check by element ID
          const isCaptureBallById = otherBody.el && otherBody.el.id === 'capture-ball';
          // Method 2: Check by physics properties (capture ball has radius 0.2, others have 0.1)
          const isCaptureBallBySize = otherBody.shape && otherBody.shape.radius === 0.2;
          
          
          if (isCaptureBallById || isCaptureBallBySize) {
            
            // Score for the OPPOSING team (the one that scored in this goal)
            const opposingTeam = this.data.team === 'red' ? 'blue' : 'red';
            teamScores[opposingTeam] += 1;
            
            // Update score display
            this.updateTeamScores();
            
            // Check for overtime win in capture mode
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].checkOvertimeWin();
            }
            
            // Reset capture ball to center
            const captureBall = document.querySelector('#capture-ball');
            if (captureBall && captureBall.components['zerog-ball']) {
              captureBall.components['zerog-ball'].resetPosition();
            }
            
            // Play goal sound/effect
            this.playGoalEffect();
          } else {
          }
        },
        
        updateTeamScores: function() {
          const hudScore = document.querySelector('#hud-score');
          if (hudScore) {
            hudScore.setAttribute('visible', true);
            const leftScore = hudScore.children[0];
            const rightScore = hudScore.children[1];
            if (leftScore) leftScore.setAttribute('text', 'value', `${teamScores.blue}`);
            if (rightScore) rightScore.setAttribute('text', 'value', `${teamScores.red}`);
          }
        },
        
        playGoalEffect: function() {
          // Flash the goal
          const originalColor = this.el.getAttribute('material').color;
          this.el.setAttribute('material', 'color', '#ffffff');
          setTimeout(() => {
            this.el.setAttribute('material', 'color', originalColor);
          }, 200);
          
          // Play impact sound (same as when ball hits opponent)
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            // Position sound at goal location
            const goalPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(goalPos);
            impactSound.object3D.position.copy(goalPos);
            impactSound.components.sound.playSound();
          }
          
          // Create impact animation similar to player hit
          this.createImpactAnimation();
        },
        
        createImpactAnimation: function() {
          // Create temporary impact sphere for animation
          const impactSphere = document.createElement('a-sphere');
          impactSphere.setAttribute('radius', 0.1);
          impactSphere.setAttribute('color', '#ffffff');
          impactSphere.setAttribute('material', 'opacity: 0.5; transparent: true; side: double');
          impactSphere.setAttribute('position', '0 0 0');
          
          // Add animations
          impactSphere.setAttribute('animation__grow', 
            'property: radius; from: 0.1; to: 2.0; dur: 1000; easing: easeOutQuad; autoplay: true');
          impactSphere.setAttribute('animation__fade', 
            'property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; autoplay: true');
          
          // Add to goal
          this.el.appendChild(impactSphere);
          
          // Remove after animation
          setTimeout(() => {
            if (impactSphere.parentNode) {
              impactSphere.parentNode.removeChild(impactSphere);
            }
          }, 1000);
        },
        
        remove: function() {
          if (this.body) {
            world.removeBody(this.body);
          }
        }
      });

      // Game manager component for zero-g multiplayer
      // Add glow component (copied from index.html)
      AFRAME.registerComponent('glow', {
        schema: {
          color: {default: '#ffffff', type: 'color'},
          intensity: {default: 1.0}
        },
        init: function () {
          this.el.addEventListener('object3dset', this.update.bind(this));
          this.el.addEventListener('material-loaded', this.update.bind(this));
        },
        update: function () {
          const data = this.data;
          if (!this.el.object3D) return;
          
          this.el.object3D.traverse(function (node) {
            if (node.isMesh && node.material) {
              if (!node.material.emissive) {
                node.material.emissive = new THREE.Color(data.color);
              } else {
                node.material.emissive.copy(new THREE.Color(data.color));
              }
              node.material.emissiveIntensity = data.intensity;
            }
          });
        }
      });

      // Add sound manager component
      AFRAME.registerComponent('sound-manager', {
        init: function() {
          this.ballSounds = [];
          this.soundsInitialized = false;
          
          // Get all ball sounds
          this.el.sceneEl.querySelectorAll('[zerog-ball]').forEach(ball => {
            const sound = ball.querySelector('[sound]');
            if (sound) {
              this.ballSounds.push(sound);
              // Initially pause all sounds
              sound.components.sound.pauseSound();
            }
          });
          
          // Get bounce sound
          this.bounceSound = this.el.sceneEl.querySelector('#bounce-sound');
          if (this.bounceSound) {
            this.bounceSound.components.sound.pauseSound();
          }
          
          // Listen for game start
          this.el.sceneEl.addEventListener('gameStarted', () => {
            this.initializeSounds();
          });
          
          // Try to start sounds on first user interaction (helps with autoplay restrictions)
          this.el.sceneEl.addEventListener('abuttondown', () => {
            this.tryStartSounds();
          });
        },
        
        initializeSounds: function() {
          if (this.soundsInitialized) return;
          
          
          // Resume AudioContext
          const audioContext = this.el.sceneEl.audioContext;
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          // Start all ball hum sounds
          this.ballSounds.forEach((sound, index) => {
            if (sound.id && (sound.id === 'red-ball-hum' || sound.id === 'blue-ball-hum')) {
              try {
                sound.components.sound.playSound();
              } catch (e) {
              }
            }
          });
          
          // Initialize bounce sound
          if (this.bounceSound) {
            try {
              this.bounceSound.components.sound.playSound();
              this.bounceSound.components.sound.pauseSound();
            } catch (e) {
            }
          }
          
          this.soundsInitialized = true;
        },
        
        // Add method to try starting sounds immediately on user interaction
        tryStartSounds: function() {
          this.initializeSounds();
        }
      });

      AFRAME.registerComponent('game-manager', {
        schema: {
          playerScore: { type: 'number', default: 0 },
          opponentScore: { type: 'number', default: 0 },
          gameStarted: { type: 'boolean', default: false }
        },
        init: function() {
          this.playerScore = 0;
          this.opponentScore = 0;
          this.gameStarted = false;
          
          // Match states: WAITING, COUNTDOWN, PLAYING, OVERTIME, ENDED
          this.matchState = 'WAITING';
          this.matchDuration = 180; // 3 minutes in seconds
          this.matchStartTime = 0;
          this.countdownTime = 3;
          this.countdownStartTime = 0;
          
          // Multiplayer scores for up to 4 players
          this.playerScores = [0, 0, 0, 0];
          this.playerReadyStates = [false, false, false, false];
          
          // Get references to the HUD displays
          this.scoreDisplay = this.el.querySelector('#score-display');
          this.startMessage = document.querySelector('#hud-message');
          this.timerDisplay = document.querySelector('#hud-timer');
          
          // Show initial message in HUD
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          
          // Hide score and timer displays initially
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
          // Listen for A button press on both controllers
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            if (this.matchState === 'WAITING') {
              if (isMultiplayer && activePlayers.size > 1) {
                this.handleMultiplayerReady();
              } else {
                this.startCountdown();
              }
            } else if (this.matchState === 'ENDED') {
              this.resetMatch();
            }
          });
        },

        tick: function() {
          const currentTime = Date.now();
          
          if (this.matchState === 'COUNTDOWN') {
            const elapsed = (currentTime - this.countdownStartTime) / 1000;
            const remaining = Math.ceil(this.countdownTime - elapsed);
            
            if (remaining > 0) {
              this.startMessage.setAttribute('text', 'value', remaining.toString());
            } else {
              this.startMessage.setAttribute('text', 'value', 'GO!');
              setTimeout(() => {
                this.startMatch();
              }, 500);
            }
          } else if (this.matchState === 'PLAYING') {
            this.updateTimer();
          }
        },

        handleMultiplayerReady: function() {
          // Mark local player as ready
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            this.playerReadyStates[playerIndex] = true;
            readyStates[playerIndex] = true;
            
            // Send ready update to all connected players
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({
                  type: 'ready-update',
                  playerIndex: playerIndex,
                  ready: true
                });
              }
            });
          }
          this.updateReadyState();
        },

        updateReadyState: function() {
          const minPlayers = gameMode === 'capture' ? 2 : 2; // Both modes need at least 2 players
          const maxPlayers = gameMode === 'capture' ? 2 : 4;
          
          if (!isMultiplayer || activePlayers.size < minPlayers) {
            const needed = minPlayers - activePlayers.size;
            this.startMessage.setAttribute('text', 'value', `Waiting for ${needed} more player(s)...`);
            return;
          }
          
          // CRITICAL FIX: Only count ready states for active players
          let readyCount = 0;
          activePlayers.forEach(playerId => {
            const playerIndex = parseInt(playerId.split('_')[1]);
            if (this.playerReadyStates[playerIndex]) {
              readyCount++;
            }
          });
          
          const totalPlayers = activePlayers.size;
          
          if (readyCount < totalPlayers) {
            this.startMessage.setAttribute('text', 'value', `Waiting for ${totalPlayers - readyCount} more player(s)...`);
          } else if (readyCount === totalPlayers) {
            // All players ready - start countdown
            const startTime = Date.now();
            this.syncedStartCountdown(startTime);
            // Send countdown sync to all players
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'countdown-start', startTime: startTime });
              }
            });
          }
        },

        setMultiplayerWaiting: function() {
          this.matchState = 'WAITING';
          this.gameStarted = false;
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Show start message
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
        },

        syncedStartCountdown: function(startTime) {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = startTime;
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset ready states
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Reset and respawn balls
          this.respawnBalls();
          
        },

        startCountdown: function() {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = Date.now();
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset and respawn balls
          this.respawnBalls();
          
          // Match countdown started
        },

        startMatch: function() {
          this.matchState = 'PLAYING';
          this.matchStartTime = Date.now();
          this.gameStarted = true;
          
          // Hide start message, show game UI
          if (this.startMessage) this.startMessage.setAttribute('visible', false);
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', true);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', true);
          
          // Show HUD score display, hide controls
          setGameplayHUD(true);
          
          // Reset scores
          this.playerScore = 0;
          this.opponentScore = 0;
          
          // Reset team scores for capture mode
          teamScores.red = 0;
          teamScores.blue = 0;
          
          // Reset multiplayer scores
          if (isMultiplayer) {
            this.playerScores = [0, 0, 0, 0];
          }
          
          this.updateScore();
          
          // NEW: Activate tractor beam for 2 seconds at start
          this.activateStartTractorBeam();
          
          // Dispatch game started event to trigger sound initialization
          this.el.sceneEl.emit('gameStarted');
          
          // Zero-G match started
        },
        
        // NEW: Activate tractor beam for player's ball at start
        activateStartTractorBeam: function() {
          // Get the current player's ball number
          let playerBallNumber = 2; // Default for singleplayer
          if (isMultiplayer && myPlayerId) {
            playerBallNumber = getBallForPlayer(myPlayerId);
          }
          
          const playerBall = document.querySelector(`[zerog-ball*="player: player${playerBallNumber}"]`);
          if (playerBall && playerBall.components['zerog-ball']) {
            playerBall.components['zerog-ball'].startAutoReturn();
            // Start tractor beam activated
          }
        },

        updateTimer: function() {
          if (!this.timerDisplay) return;
          
          const currentTime = Date.now();
          const elapsed = (currentTime - this.matchStartTime) / 1000;
          const remaining = Math.max(0, this.matchDuration - elapsed);
          
          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.timerDisplay.setAttribute('text', 'value', `Time: ${timeString}`);
          
          // Check if time is up
          if (remaining <= 0 && this.matchState === 'PLAYING') {
            // Use correct scores based on game mode
            let score1, score2;
            if (gameMode === 'capture') {
              // In capture mode, use team scores
              score1 = teamScores.red;
              score2 = teamScores.blue;
            } else {
              // In dodge mode, use player scores
              if (isMultiplayer && activePlayers.size > 1) {
                score1 = this.playerScores[0];
                score2 = this.playerScores[1];
              } else {
                score1 = this.playerScore;
                score2 = this.opponentScore;
              }
            }
            
            if (score1 === score2) {
              this.startOvertime();
            } else {
              this.endMatch();
            }
          }
        },

        startOvertime: function() {
          this.matchState = 'OVERTIME';
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next hit wins!');
          }
          
          // Sync overtime state in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'game-state', state: 'OVERTIME' });
              }
            });
          }
        },

        endMatch: function() {
          this.matchState = 'ENDED';
          this.gameStarted = false;
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Determine winner
          let winner;
          if (gameMode === 'capture') {
            // In capture mode, determine winner by team scores
            if (teamScores.red > teamScores.blue) {
              winner = 'Red Team wins!';
            } else if (teamScores.blue > teamScores.red) {
              winner = 'Blue Team wins!';
            } else {
              winner = 'Tie game!';
            }
          } else {
            // In dodge mode, use original logic
            if (isMultiplayer && activePlayers.size > 1) {
              if (myPlayerId) {
                const playerIndex = parseInt(myPlayerId.split('_')[1]);
                const myScore = this.playerScores[playerIndex];
                const otherScores = this.playerScores.filter((score, index) => index !== playerIndex);
                const maxOtherScore = Math.max(...otherScores);
                winner = myScore > maxOtherScore ? 'You win!' : 'Opponent wins!';
              } else {
                winner = 'Game ended';
              }
            } else {
              winner = this.playerScore > this.opponentScore ? 'Player wins!' : 'Opponent wins!';
            }
          }
          
          // Show end message
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', `${winner}\nPress A to play again`);
          }
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'Match ended');
          }
          
          // Sync end state in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'game-state', state: 'ENDED', winner: winner });
              }
            });
          }
          
        },

        resetMatch: function() {
          this.matchState = 'WAITING';
          this.playerScore = 0;
          this.opponentScore = 0;
          
          // Reset team scores for capture mode
          teamScores.red = 0;
          teamScores.blue = 0;
          
          // Update score display
          if (gameMode === 'capture') {
            // Find a goal component to call updateTeamScores
            const redGoal = document.querySelector('[goal="team: red"]');
            if (redGoal && redGoal.components.goal) {
              redGoal.components.goal.updateTeamScores();
            }
          }
          this.gameStarted = false;
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Reset multiplayer scores and ready states
          if (isMultiplayer) {
            this.playerScores = [0, 0, 0, 0];
            this.playerReadyStates = [false, false, false, false];
            readyStates = [false, false, false, false];
          }
          
          // Hide game UI, show start message
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          
        },

        respawnBalls: function() {
          // Reset all balls to their spawn positions
          for (let i = 1; i <= 4; i++) {
            const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
            if (ball && ball.components['zerog-ball']) {
              ball.components['zerog-ball'].resetPosition();
            }
          }
          
          // Zero-G balls respawned
        },

        updateMultiplayerScore: function() {
          // Update score display for multiplayer
          if (this.scoreDisplay) {
            const scoreText = this.playerScores.join(' - ');
            this.scoreDisplay.setAttribute('text', 'value', scoreText);
          }
          
          // Update HUD score display
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            const myScore = this.playerScores[playerIndex];
            const otherScores = this.playerScores.filter((score, index) => index !== playerIndex);
            const maxOtherScore = Math.max(...otherScores);
            updateHUDScore(myScore, maxOtherScore, true);
          }
        },

        sendScoreUpdate: function() {
          // Send score update to all connected players
          connections.forEach((conn, playerId) => {
            if (conn && conn.open) {
              conn.send({
                type: 'score-update',
                scores: this.playerScores
              });
            }
          });
        },

        onPlayerHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastPlayerHitTime = this.lastPlayerHitTime || 0;
          this.playerHitCooldown = this.playerHitCooldown || 1000; // 1 second cooldown
          
          if (now - this.lastPlayerHitTime < this.playerHitCooldown) {
            return;
          }
          
          this.lastPlayerHitTime = now;
          this._playerHitCount = (this._playerHitCount || 0) + 1;
          
          if (isMultiplayer && activePlayers.size > 1) {
            // HOST-AUTHORITATIVE SCORING: Only host handles scoring logic
            if (isHost && myPlayerId) {
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              this.playerScores[playerIndex] += 1;
              this.updateMultiplayerScore();
              this.sendScoreUpdate();
            } else {
            }
          } else {
            this.playerScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.checkOvertimeWin();
          }
        },

        onOpponentHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastOpponentHitTime = this.lastOpponentHitTime || 0;
          this.opponentHitCooldown = this.opponentHitCooldown || 1000; // 1 second cooldown
          
          if (now - this.lastOpponentHitTime < this.opponentHitCooldown) {
            return;
          }
          
          this.lastOpponentHitTime = now;
          this._opponentHitCount = (this._opponentHitCount || 0) + 1;
          
          if (isMultiplayer && activePlayers.size > 1) {
            // HOST-AUTHORITATIVE SCORING: Only host handles scoring logic
            if (isHost && myPlayerId) {
              // Find the opponent player index (not the current player)
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              const opponentIndex = (playerIndex + 1) % 4; // Simple opponent assignment
              this.playerScores[opponentIndex] += 1;
              this.updateMultiplayerScore();
              this.sendScoreUpdate();
            } else {
            }
          } else {
            this.opponentScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.checkOvertimeWin();
          }
        },

        updateScore: function() {
          if (isMultiplayer && activePlayers.size > 1) {
            // Use the new player-based scoring system
            this.updateMultiplayerScore();
          } else {
            // In singleplayer, player is blue, opponent is red
            const blueScore = document.getElementById('blue-score');
            const redScore = document.getElementById('red-score');
            if (blueScore && redScore) {
              blueScore.setAttribute('text', 'value', this.playerScore.toString());
              redScore.setAttribute('text', 'value', this.opponentScore.toString());
            }
            // Update HUD score display
            updateHUDScore(this.playerScore, this.opponentScore, false);
          }
        },

        checkOvertimeWin: function() {
          // Only check in overtime
          if (this.matchState !== 'OVERTIME') return;

          if (gameMode === 'capture') {
            // In capture mode, check team scores
            if (teamScores.red !== teamScores.blue) {
              this.endMatch();
            }
          } else {
            // In dodge mode, check player scores (multiplayer only)
            if (!isMultiplayer || activePlayers.size < 2) return;

            // Find the highest score and how many players have it
            const maxScore = Math.max(...this.playerScores);
            const winners = this.playerScores.filter(score => score === maxScore).length;

            // If only one player has the highest score, end the match
            if (winners === 1) {
              this.endMatch();
            }
          }
        }
      });

      // Physics update loop - Anti-tunneling optimized for zero-gravity
      AFRAME.registerComponent('physics-world', {
        init: function() {
          this.lastTime = 0;
        },
        tick: function(time) {
          const deltaTime = (time - this.lastTime) / 1000;
          if (deltaTime > 0) {
            // Use smaller timesteps to prevent tunneling at high speeds in zero-g
            const maxStep = 1/240; // 240Hz timestep for better collision detection
            const steps = Math.ceil(deltaTime / maxStep);
            
            // Clamp to reasonable step count to prevent performance issues
            const clampedSteps = Math.min(steps, 8);
            const clampedStepSize = deltaTime / clampedSteps;
            
            for (let i = 0; i < clampedSteps; i++) {
              world.step(clampedStepSize);
            }
          }
          this.lastTime = time;
        }
      });

      // Impact effect component
      AFRAME.registerComponent('impact-effect', {
        schema: {
          color: { type: 'color', default: '#ffffff' }
        },
        init: function() {
          // Find the impact sphere within this entity
          this.impactSphere = this.el.querySelector('a-sphere[id$="-impact"]');
          if (!this.impactSphere) {
            console.warn('Impact sphere not found for:', this.el.id);
            return;
          }
        },
        
        playEffect: function() {
          if (!this.impactSphere) {
            console.warn('Cannot play effect - impact sphere not found');
            return;
          }
          
          // Play impact sound at the world position of the hit target
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            const worldPosition = new THREE.Vector3();
            this.el.object3D.getWorldPosition(worldPosition);
            impactSound.object3D.position.copy(worldPosition);
            impactSound.components.sound.playSound();
          }
          
          // Reset impact sphere state
          this.impactSphere.setAttribute('radius', 0.1);
          this.impactSphere.setAttribute('material', 'opacity', 0.5);
          this.impactSphere.setAttribute('visible', true);
          
          // Trigger the animations
          this.impactSphere.emit('impact');
          
          // Note: Scoring is handled by the zerog-ball component collision detection
          
          // Reset after animation completes
          setTimeout(() => {
            this.impactSphere.setAttribute('visible', false);
            this.impactSphere.setAttribute('material', 'opacity', 0);
            this.impactSphere.setAttribute('radius', 0.1);
          }, 1000);
        }
      });

      // B button for menu system
      AFRAME.registerComponent('menu-toggle', {
        init: function() {
          this.menuVisible = false;
          this.lastBButtonPress = 0;
          
          // B button to toggle menu with debouncing
          this.el.sceneEl.addEventListener('bbuttondown', () => {
            const now = Date.now();
            if (now - this.lastBButtonPress < 500) return; // 500ms debounce
            this.lastBButtonPress = now;
            this.toggleMenu();
          });
        },

        toggleMenu: function() {
          this.menuVisible = !this.menuVisible;
          isMenuVisible = this.menuVisible; // Update global state
          
          const menu = document.querySelector('#game-menu');
          const leftHand = document.querySelector('#leftHand');
          const rightHand = document.querySelector('#rightHand');
          
          // Toggle menu visibility
          if (menu) {
            menu.setAttribute('visible', this.menuVisible);
          }
          
          // Toggle HUD layers - only show one at a time
          this.toggleHUDLayers(this.menuVisible);
          
          // Show/hide laser pointers based on menu visibility
          const leftRaycastSettings = `objects: .clickable; lineColor: #ffffff; lineOpacity: ${this.menuVisible ? 1 : 0}; far: 10`;
          const rightRaycastSettings = `objects: .clickable; lineColor: #ffffff; lineOpacity: ${this.menuVisible ? 1 : 0}; far: 10`;
          
          if (leftHand) {
            leftHand.setAttribute('raycaster', leftRaycastSettings);
            // Left hand raycaster updated
            
            // If opening menu, force disable any active thrusters
            if (this.menuVisible) {
              const leftThruster = leftHand.querySelector('.thruster-vfx');
              if (leftThruster) leftThruster.setAttribute('visible', false);
            }
          }
          if (rightHand) {
            rightHand.setAttribute('raycaster', rightRaycastSettings);
            // Right hand raycaster updated
            
            // If opening menu, force disable any active thrusters
            if (this.menuVisible) {
              const rightThruster = rightHand.querySelector('.thruster-vfx');
              if (rightThruster) rightThruster.setAttribute('visible', false);
            }
          }
          
          // Reset thruster states when menu opens
          if (this.menuVisible) {
            const zerogPlayer = document.querySelector('[zerog-player]');
            if (zerogPlayer && zerogPlayer.components['zerog-player']) {
              const player = zerogPlayer.components['zerog-player'];
              player.thrusterActive.left = false;
              player.thrusterActive.right = false;
            }
          }
          
          // Update menu display when opening
          if (this.menuVisible) {
            this.updateMenuDisplay();
          }
          
          // Menu toggled
          
          // When menu closes, refresh HUD to apply any changes made during menu interaction
          if (!this.menuVisible) {
            this.refreshGameHUD();
          }
        },

        updateMenuDisplay: function() {
          // Update lobby section visibility
          const lobbySection = document.querySelector('#menu-lobby-section');
          const autoConnect = document.querySelector('#menu-auto-connect');
          
          if (lobbySection) {
            lobbySection.setAttribute('visible', isMultiplayer);
          }
          if (autoConnect) {
            autoConnect.setAttribute('visible', isMultiplayer);
          }
          
          // Update lobby number display
          const lobbyNumber = document.querySelector('#menu-lobby-number');
          if (lobbyNumber) {
            lobbyNumber.setAttribute('text', 'value', selectedLobby.toString());
          }
          
          // Update player slot indicators
          for (let i = 0; i < 4; i++) {
            const slot = document.querySelector(`#menu-slot-${i}`);
            if (slot) {
              const player = players.get(`player_${i}`);
              const isOccupied = player && player.isConnected;
              const sphere = slot.querySelector('a-sphere');
              if (sphere) {
                sphere.setAttribute('material', 'opacity', isOccupied ? 1 : 0.3);
                sphere.setAttribute('color', isOccupied ? playerSlots[i].color : '#666666');
              }
            }
          }
          
          // Update current mode display
          updateMenuDisplay();
        },

        toggleHUDLayers: function(showMenu) {
          // Game HUD elements (hidden when menu is shown)
          const gameHudElements = [
            '#version-display',
            '#hud-status', 
            '#hud-score',
            '#hud-timer',
            '#hud-message'
          ];
          
          // Toggle game HUD visibility
          gameHudElements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
              element.setAttribute('visible', !showMenu);
            }
          });
          
          // Menu HUD (the menu itself) is handled in the main toggleMenu function
          
          // HUD visibility updated
        },

        refreshGameHUD: function() {
          // Refresh the game HUD based on current game state
          setTimeout(() => {
            const gameManager = document.querySelector('#game-manager');
            const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                                 gameManager.components['game-manager'].gameStarted;
            
            // Refreshing HUD
            
            if (isMatchActive) {
              // Match is active - show gameplay HUD
              setGameplayHUD(true);
            } else if (isMultiplayer && activePlayers.size > 1) {
              // Multiplayer connected but no match - set waiting state
              setGameplayHUD(false);
              if (gameManager && gameManager.components['game-manager']) {
                gameManager.components['game-manager'].setMultiplayerWaiting();
              }
            } else {
              // Singleplayer or no connection - show default state
              setGameplayHUD(false);
              
              // Ensure "Press A to Start" message is visible in default state
              const hudMessage = document.querySelector('#hud-message');
              if (hudMessage) {
                hudMessage.setAttribute('visible', true);
                hudMessage.setAttribute('text', 'value', 'Press A to Start');
              }
            }
            
            // Game HUD refreshed
          }, 100); // Small delay to ensure menu state is fully updated
        }
      });

      // Multiplayer connection logic (slot-based, PeerJS, TURN support)
      async function startMultiplayerConnection() {
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        isMultiplayer = false;
        try {
          const slot = await findAvailableSlot(multiplayerStartType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupHost(multiplayerSlot);
          } else {
            await setupPeer(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      async function checkPeerAvailability(id) {
        return new Promise((resolve) => {
          const tempPeer = new Peer(id, { host: "0.peerjs.com", port: 443, secure: true });
          const timeout = setTimeout(() => {
            tempPeer.destroy();
            resolve(false);
          }, 2000);
          tempPeer.on("open", () => {
            clearTimeout(timeout);
            tempPeer.destroy();
            resolve(true);
          });
          tempPeer.on("error", (err) => {
            clearTimeout(timeout);
            tempPeer.destroy();
            if (err.type === 'unavailable-id') {
              resolve(false);
            } else {
              resolve(true);
            }
          });
        });
      }

      async function findAvailableSlot(desiredStartType) {
        for (let i = 1; i <= MAX_LOBBIES; i++) {
          const hostId = `zerog-host-${desiredStartType}-${i}`;
          const peerId = `zerog-peer-${desiredStartType}-${i}`;
          const hostAvailable = await checkPeerAvailability(hostId);
          if (hostAvailable) {
            return { slotNumber: i, role: 'host' };
          } else {
            const peerAvailable = await checkPeerAvailability(peerId);
            if (peerAvailable) {
              return { slotNumber: i, role: 'peer' };
            }
          }
        }
        return null;
      }



      function sendPlayerState(state) {
        if (isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, playerId) => {
            if (conn && conn.open) {
              conn.send({ type: 'player-state', state });
            }
          });
        }
      }





      
      // Removed complex patching system - scoring is now handled directly in the game-manager component

      // Attach menu-toggle to scene
      document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene && !scene.hasAttribute('menu-toggle')) {
          scene.setAttribute('menu-toggle', '');
        }
        
        // Initialize visibility - but don't call manageActivePlayersAndBots yet
        // It will be called when multiplayer is properly initialized
        
        // Hide all remote players initially
        for (let i = 1; i < 4; i++) {
          const remotePlayer = document.querySelector(`#remote-player-${i}`);
          if (remotePlayer) {
            remotePlayer.setAttribute('visible', false);
          }
        }
        
        // Initialize status display
        updateMultiplayerStatus('Singleplayer');
        
        // Scoring is now handled directly in the game-manager component - no patching needed
      });

      // --- MULTIPLAYER SYNC COMPONENT ---
      AFRAME.registerComponent('multiplayer-sync', {
        tick: function() {
          // In multiplayer, send the local camera's world position/rotation as player state
          if (isMultiplayer && activePlayers.size > 1) {
            const camera = document.querySelector('[camera]');
            if (camera) {
              const worldPos = new THREE.Vector3();
              camera.object3D.getWorldPosition(worldPos);
              const worldQuat = new THREE.Quaternion();
              camera.object3D.getWorldQuaternion(worldQuat);
              const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
              const playerState = {
                x: worldPos.x, y: worldPos.y, z: worldPos.z,
                rx: worldRot.x, ry: worldRot.y, rz: worldRot.z
              };
              sendPlayerState(playerState);
              
              // Debug: Log when client sends data (throttled to once per 30 seconds)
              if (!isHost) {
                if (!this.lastClientSendTime || Date.now() - this.lastClientSendTime > 30000) {
                  this.lastClientSendTime = Date.now();
                }
              }
            }
          }
          
          // Debug: Log sync component activity (only once per 30 seconds)
          if (isMultiplayer && activePlayers.size > 1) {
            if (!this.lastDebugTime || Date.now() - this.lastDebugTime > 30000) {
              this.lastDebugTime = Date.now();
            }
          }
          
          // Send ball states for all players
          if (isMultiplayer && activePlayers.size > 1 && myPlayerId) {
            // CRITICAL FIX: Use dynamic ball assignment instead of hardcoded logic
            const myBallNumber = getBallForPlayer(myPlayerId);
            
            const ball = document.querySelector(`[zerog-ball*="player: player${myBallNumber}"]`);
            if (ball) {
              const pos = ball.object3D.position;
              const ballComponent = ball.components['zerog-ball'];
              const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
              

              
              sendBallState({ 
                playerId: myBallNumber,
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            }
            
            // CRITICAL FIX: Dynamic capture ball ownership for multiplayer
            if (gameMode === 'capture') {
              const captureBall = document.querySelector('#capture-ball');
              if (captureBall && captureBall.components['zerog-ball']) {
                const ballComponent = captureBall.components['zerog-ball'];
                
                // Check if local player is controlling the capture ball
                const isLocallyControlled = ballComponent.isGrabbed || ballComponent.tractorBeamActive;
                
                if (isLocallyControlled) {
                  // LOCAL PLAYER controls capture ball - send updates to everyone
                  const pos = captureBall.object3D.position;
                  const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
                  
                  sendBallState({ 
                    playerId: 'capture',
                    x: pos.x, y: pos.y, z: pos.z, 
                    vx: velocity.x, vy: velocity.y, vz: velocity.z 
                  });
                } else if (isHost) {
                  // HOST controls uncontrolled capture ball - send updates to clients
                  const pos = captureBall.object3D.position;
                  const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
                  
                  sendBallState({ 
                    playerId: 'capture',
                    x: pos.x, y: pos.y, z: pos.z, 
                    vx: velocity.x, vy: velocity.y, vz: velocity.z 
                  });
                }
              }
            }
            
            // CRITICAL: Host syncs bot positions to all clients
            if (isHost) {
              const redBot = document.querySelector('#zerog-bot-red');
              const blueBot = document.querySelector('#zerog-bot-blue');
              
              if (redBot && redBot.components['zerog-bot'] && redBot.components['zerog-bot'].body) {
                const botBody = redBot.components['zerog-bot'].body;
                sendBotState({
                  botId: 'bot-red',
                  x: botBody.position.x, y: botBody.position.y, z: botBody.position.z,
                  vx: botBody.velocity.x, vy: botBody.velocity.y, vz: botBody.velocity.z
                });
              }
              
              if (blueBot && blueBot.components['zerog-bot'] && blueBot.components['zerog-bot'].body) {
                const botBody = blueBot.components['zerog-bot'].body;
                sendBotState({
                  botId: 'bot-blue',
                  x: botBody.position.x, y: botBody.position.y, z: botBody.position.z,
                  vx: botBody.velocity.x, vy: botBody.velocity.y, vz: botBody.velocity.z
                });
              }
            }
          }
          
          // Debug: Check if client is sending data (throttled)
          if (!isHost && myPlayerId && connections.size > 0) {
            if (!this.lastClientDebugTime || Date.now() - this.lastClientDebugTime > 30000) {
              this.lastClientDebugTime = Date.now();
            }
          }
          
          // Apply remote player states
          if (isMultiplayer && activePlayers.size > 1) {
            // Show remote players and hide bot
            for (let i = 1; i < 4; i++) {
              const remotePlayer = document.querySelector(`#remote-player-${i}`);
              if (remotePlayer && activePlayers.has(`player_${i}`)) {
                remotePlayer.setAttribute('visible', true);
              } else if (remotePlayer) {
                remotePlayer.setAttribute('visible', false);
              }
            }
            
            // Hide both bots in multiplayer
            const redBot = document.querySelector('#zerog-bot-red');
            const blueBot = document.querySelector('#zerog-bot-blue');
            if (redBot) {
              redBot.setAttribute('visible', false);
              if (redBot.components['zerog-bot']) redBot.setAttribute('zerog-bot', 'enabled', false);
            }
            if (blueBot) {
              blueBot.setAttribute('visible', false);
              if (blueBot.components['zerog-bot']) blueBot.setAttribute('zerog-bot', 'enabled', false);
            }
          } else if (!isMultiplayer) {
            // CRITICAL: Ensure bot is enabled and visible in singleplayer mode
            for (let i = 1; i < 4; i++) {
              const remotePlayer = document.querySelector(`#remote-player-${i}`);
              if (remotePlayer) {
                remotePlayer.setAttribute('visible', false);
              }
            }
            // Use the new player management system
            manageActivePlayersAndBots();
          }
          
          // Prevent local input from affecting other players' balls in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            for (let i = 0; i < 4; i++) {
              // Calculate which ball this player should control
              const ballPlayerIndex = i + 1; // player_0 controls player1, player_1 controls player2, etc.
              const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
              // Use dynamic ball assignment
              const myBallIndex = getBallForPlayer(myPlayerId || 'player_0');
              
              // Only reset isGrabbed for balls that don't belong to the current player
              if (ballPlayerIndex !== myBallIndex) {
                const ball = document.querySelector(`[zerog-ball*="player: player${ballPlayerIndex}"]`);
                if (ball && ball.components['zerog-ball']) {
                  ball.components['zerog-ball'].isGrabbed = false;
                }
              }
            }
          }
          
          // REMOVED: Test ball movement code that was interfering with physics
        }
      });

      // Dynamic ball physics for zero-g - can be grabbed and thrown

      AFRAME.registerComponent('zerog-ball', {
        schema: {
          player: { type: 'string', default: 'player1' },
          maxVelocity: { type: 'number', default: 8 },
          owner: { type: 'string', default: 'human' } // 'bot' or 'human'
        },
        
        init: function() {
          
          // Make balls grabbable
          this.el.classList.add('grabbable-surface');
          
          // Track if ball is being grabbed
          this.isGrabbed = false;
          this.grabbingHand = null;
          

          
          // Check if this is the special capture ball
          this.isCaptureBall = (this.data.player === 'capture');
          
          // Capture ball has special collision properties
          
          // Set initial position based on player
          const ballPlayerIndex = this.isCaptureBall ? 0 : parseInt(this.data.player.replace('player', ''));
          let spawnPos;
          
          // Position balls based on their player assignment
          if (this.isCaptureBall) {
            // Capture ball always spawns at center
            spawnPos = { x: 0, y: 2, z: 0 };
          } else if (isMultiplayer) {
            // Multiplayer: Position balls at their assigned player positions
            const playerIndex = ballPlayerIndex - 1; // player1 -> index 0, player2 -> index 1, etc.
            if (playerIndex >= 0 && playerIndex < playerSlots.length) {
              const slot = playerSlots[playerIndex];
              const positionParts = slot.position.split(' ');
              spawnPos = {
                x: parseFloat(positionParts[0]),
                y: parseFloat(positionParts[1]) + 2, // Add 2m height for ball spawn
                z: parseFloat(positionParts[2])
              };
            } else {
              // Fallback to center position
              spawnPos = { x: 0, y: 2, z: 0 };
            }
          } else {
            // Singleplayer: Position balls at their traditional positions
            if (ballPlayerIndex === 1) {
              // Bot's ball (red) - position near bot
              spawnPos = { x: 0, y: 2, z: -8 };
            } else if (ballPlayerIndex === 2) {
              // Player's ball (green) - position near player
              spawnPos = { x: 0, y: 2, z: 8 };
            } else {
              // Fallback
              spawnPos = { x: 0, y: 2, z: 0 };
            }
          }
          
          // Update the ball's visual position
          this.el.setAttribute('position', `${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);
          
          this.initialPosition = new CANNON.Vec3(spawnPos.x, spawnPos.y, spawnPos.z);
          
          // Different properties for capture ball vs regular balls
          const radius = this.isCaptureBall ? 0.2 : 0.1;
          const mass = this.isCaptureBall ? 2 : 1; // Heavier capture ball
          
          const shape = new CANNON.Sphere(radius);
          this.body = new CANNON.Body({
            mass: mass,
            shape: shape,
            material: ballMaterial,
            linearDamping: 0.02, // Slight damping for realistic movement
            angularDamping: 0.02,
            position: this.initialPosition,
            collisionFilterGroup: 2, // Balls are in group 2
            collisionFilterMask: 4 | 8   // Balls collide with group 4 (walls/surfaces) and group 8 (goals)
          });
          
          if (this.isCaptureBall) {
          }
          
          // Zero gravity
          this.body.gravity = new CANNON.Vec3(0, 0, 0);
          
          world.addBody(this.body);
          
          // Store body reference for grabbing
          this.el.body = this.body;
          
          // CRITICAL: Store element reference in physics body for collision detection
          this.body.el = this.el;
          
          if (this.isCaptureBall) {
          }
          
          // Add collision detection for bounce sounds and target hits
          this.body.addEventListener('collide', (evt) => {
            const contact = evt.contact;
            const otherBody = evt.target === this.body ? evt.body : evt.target;
            
            // Capture ball collision detection
            
            // Check for target hits first
            this.checkTargetHit();
            
            // Only play bounce sound if not grabbed and moving fast enough
            if (!this.isGrabbed && this.body.velocity.length() > 0.5) {
              const bounceSound = document.querySelector('#bounce-sound');
              if (bounceSound) {
                // Position sound at collision point
                const collisionPoint = new THREE.Vector3();
                collisionPoint.copy(this.body.position);
                bounceSound.object3D.position.copy(collisionPoint);
                
                // Stop any currently playing sound and play new one
                bounceSound.components.sound.stopSound();
                bounceSound.components.sound.playSound();
              }
            }
          });
          
          // Velocity tracking for smooth throwing
          this.velocityHistory = [];
          this.maxHistorySize = 5;
          this.lastPosition = new THREE.Vector3();
          this.lastPositionTime = 0;
          
          // Tractor beam with A button - only for player's own ball
          this.tractorBeamActive = false;
          this.targetPosition = new THREE.Vector3();
          
          // NEW: Auto-return mode (for 2 seconds after hitting target)
          this.autoReturnActive = false;
          this.autoReturnStartTime = 0;
          this.autoReturnDuration = 2000; // 2 seconds
          
          // NEW: Hit cooldown to prevent multiple hits during auto-return
          this.lastHitTime = 0;
          this.hitCooldown = 2000; // 2 seconds cooldown
          
          this.el.sceneEl.addEventListener('abuttondown', () => {
            // Check if player is stunned
            const player = document.querySelector('[zerog-player]');
            if (player && player.components['zerog-player'] && player.components['zerog-player'].isStunned) {
              return;
            }
            
            // CRITICAL FIX: Use dynamic ownership check instead of hardcoded ball indices
            const currentPlayerId = myPlayerId || 'player_0';
            const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
            const ballOwnerId = getBallOwnerId(ballPlayerIndex);
            
            // Allow any player to control the capture ball
            if (this.isCaptureBall) {
              this.tractorBeamActive = true;
            } 
            // Check if this ball is owned by the current player
            else if (this.data.owner === 'human' && ballOwnerId === currentPlayerId) {
              this.tractorBeamActive = true;
            }
            // Bots cannot be controlled by humans
          });
          
          this.el.sceneEl.addEventListener('abuttonup', () => {
            // CRITICAL FIX: Use dynamic ownership check instead of hardcoded ball indices
            const currentPlayerId = myPlayerId || 'player_0';
            const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
            const ballOwnerId = getBallOwnerId(ballPlayerIndex);
            
            // Allow any player to control the capture ball
            if (this.isCaptureBall) {
              this.tractorBeamActive = false;
            }
            // Check if this ball is owned by the current player
            else if (this.data.owner === 'human' && ballOwnerId === currentPlayerId) {
              this.tractorBeamActive = false;
            }
          });
        },
        
        resetPosition: function() {
          // Capture ball always resets to center
          if (this.isCaptureBall) {
            const resetPos = { x: 0, y: 2, z: 0 };
            this.body.position.set(resetPos.x, resetPos.y, resetPos.z);
            this.el.object3D.position.set(resetPos.x, resetPos.y, resetPos.z);
            this.body.velocity.set(0, 0, 0);
            this.body.angularVelocity.set(0, 0, 0);
            this.body.gravity.set(0, 0, 0);
            this.isGrabbed = false;
            this.grabbingHand = null;
            this.velocityHistory = [];
            return;
          }
          
          // Recalculate the correct reset position based on current game mode
          const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
          let resetPos;
          
          if (isMultiplayer) {
            // Multiplayer: Reset to assigned player position
            const playerIndex = ballPlayerIndex - 1; // player1 -> index 0, player2 -> index 1, etc.
            if (playerIndex >= 0 && playerIndex < playerSlots.length) {
              const slot = playerSlots[playerIndex];
              const positionParts = slot.position.split(' ');
              resetPos = {
                x: parseFloat(positionParts[0]),
                y: parseFloat(positionParts[1]) + 2, // Add 2m height for ball spawn
                z: parseFloat(positionParts[2])
              };
            } else {
              resetPos = this.initialPosition;
            }
          } else {
            // Singleplayer: Use traditional positions
            if (ballPlayerIndex === 1) {
              // Bot's ball (red) - reset near bot
              resetPos = { x: 0, y: 2, z: -8 };
            } else if (ballPlayerIndex === 2) {
              // Player's ball (green) - reset near player
              resetPos = { x: 0, y: 2, z: 8 };
            } else {
              resetPos = this.initialPosition;
            }
          }
          
          // Update both physics body and visual position
          this.body.position.set(resetPos.x, resetPos.y, resetPos.z);
          this.el.object3D.position.set(resetPos.x, resetPos.y, resetPos.z);
          
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          this.body.gravity.set(0, 0, 0);
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
          
          // Clear hit cooldown and auto-return when manually resetting
          this.lastHitTime = 0;
          this.autoReturnActive = false;
          
          // Ball reset to position
        },
        
        checkTargetHit: function() {
          if (this.isGrabbed || !this.body) return;

          // Per-ball cooldown to prevent double hits
          const now = Date.now();
          if (now - this.lastHitTime < this.hitCooldown) return;
          if (this.autoReturnActive) return;

          const ballPos = new THREE.Vector3().copy(this.body.position);
          const ballVelocity = this.body.velocity.length();
          if (ballVelocity < 0.5) return;
          
          // Skip capture ball from hitting players
          if (this.isCaptureBall) return;

          const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
          const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
          // Dynamic ball assignment based on team in capture mode
          const myBallIndex = getBallForPlayer(myPlayerId || 'player_0');

                    // --- SINGLEPLAYER LOGIC ---
          if (!isMultiplayer || activePlayers.size <= 1) {
            // Player2's ball hits bot target
            if (ballPlayerIndex === 2) {
              // CRITICAL FIX: Check both red and blue bot targets
              const redBotTarget = document.querySelector('#bot-target');
              const blueBotTarget = document.querySelector('#bot-blue-target');
              
              // Check red bot target
              if (redBotTarget) {
                const targetPos = new THREE.Vector3();
                redBotTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  // Play explosion/sound on red bot
                  const impactEffect = redBotTarget.components['impact-effect'];
                  if (impactEffect) impactEffect.playEffect();
                  
                  if (gameMode === 'capture') {
                    // Check if ball should affect red bot based on team rules
                    if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-red')) {
                      return; // Same team - no effect
                    }
                    // In capture mode: stun the red bot
                    this.stunBot('bot-red');
                  } else {
                    // In dodge mode: score for player
                    const gameManager = this.el.sceneEl.querySelector('#game-manager');
                    if (gameManager && gameManager.components['game-manager']) {
                      gameManager.components['game-manager'].onPlayerHit();
                    }
                  }
                  
                  this.lastHitTime = now;
                  this.startAutoReturn();
                  return;
                }
              }
              
              // Check blue bot target
              if (blueBotTarget) {
                const targetPos = new THREE.Vector3();
                blueBotTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  // Play explosion/sound on blue bot
                  const impactEffect = blueBotTarget.components['impact-effect'];
                  if (impactEffect) impactEffect.playEffect();
                  
                  if (gameMode === 'capture') {
                    // Check if ball should affect blue bot based on team rules
                    if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-blue')) {
                      return; // Same team - no effect
                    }
                    // In capture mode: stun the blue bot
                    this.stunBot('bot-blue');
                  } else {
                    // In dodge mode: score for player
                    const gameManager = this.el.sceneEl.querySelector('#game-manager');
                    if (gameManager && gameManager.components['game-manager']) {
                      gameManager.components['game-manager'].onPlayerHit();
                    }
                  }
                  
                  this.lastHitTime = now;
                  this.startAutoReturn();
                  return;
                }
              }
            }
            // Player1's ball hits player target
            if (ballPlayerIndex === 1) {
              const playerTarget = document.querySelector('#player-target');
              if (playerTarget) {
                const targetPos = new THREE.Vector3();
                playerTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  // Play explosion/sound on player
                  const impactEffect = playerTarget.components['impact-effect'];
                  if (impactEffect) impactEffect.playEffect();
                  
                  if (gameMode === 'capture') {
                    // Check if ball should affect player based on team rules
                    const playerId = myPlayerId || 'player_0';
                    if (!shouldBallAffectTarget(ballPlayerIndex, playerId)) {
                      return; // Same team - no effect
                    }
                    // In capture mode: stun the player
                    this.stunPlayer();
                  } else {
                    // In dodge mode: score for bot
                    const gameManager = this.el.sceneEl.querySelector('#game-manager');
                    if (gameManager && gameManager.components['game-manager']) {
                      gameManager.components['game-manager'].onOpponentHit();
                    }
                  }
                  
                  this.lastHitTime = now;
                  this.resetPosition();
                  return;
                }
              }
            }
            return;
          }

          // --- MULTIPLAYER LOGIC ---
          // Only score if this ball hits another player's target (not own target)
          for (let i = 0; i < 4; i++) {
            if (ballPlayerIndex === i + 1) continue; // skip own target
            // Only check active players
            if (!activePlayers.has(`player_${i}`)) continue;
            // Find the correct target entity
            let targetEntity = null;
            if (myPlayerId && i === myPlayerIndex) {
              targetEntity = document.querySelector('#player-target');
            } else {
              targetEntity = document.querySelector(`#remote-target-${i}`);
            }
            if (!targetEntity) continue;
            const targetPos = new THREE.Vector3();
            targetEntity.object3D.getWorldPosition(targetPos);
            if (ballPos.distanceTo(targetPos) < 0.3) {
              // Play explosion/sound on hit target
              const impactEffect = targetEntity.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              
              if (gameMode === 'capture') {
                // Check if thrower and target are teammates
                const throwerId = getPlayerIdFromBallIndex(ballPlayerIndex);
                const targetId = `player_${i}`;
                
                if (!shouldBallAffectTarget(ballPlayerIndex, targetId)) {
                  return; // Same team - no effect
                }
                
                // In capture mode: stun the hit player
                if (myPlayerId && i === myPlayerIndex) {
                  // Local player was hit - stun them
                  this.stunPlayer();
                } else {
                  // Remote player was hit - they handle their own stunning
                }
              } else {
                // In dodge mode: score for the thrower
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  if (isHost) {
                    // Score for the thrower (ballPlayerIndex-1)
                    gameManager.components['game-manager'].playerScores[ballPlayerIndex-1] += 1;
                    gameManager.components['game-manager'].updateMultiplayerScore();
                    gameManager.components['game-manager'].sendScoreUpdate();
                  }
                }
              }
              
              this.lastHitTime = now;
              this.startAutoReturn();
              return;
            }
          }
        },
        
        onGrab: function(hand) {
          // CRITICAL FIX: For capture ball, send network message to force release on other players
          if (this.isCaptureBall && isMultiplayer && activePlayers.size > 1) {
            // Send capture ball grab message to all other players
            const data = {
              type: 'capture-ball-grabbed',
              grabberId: myPlayerId,
              timestamp: Date.now()
            };
            
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send(data);
              }
            });
          }
          
          this.isGrabbed = true;
          this.grabbingHand = hand;
          this.body.gravity.set(0, 0, 0);
          
          // CRITICAL FIX: Immediately send grab state to other players
          if (isMultiplayer && activePlayers.size > 1) {
            const pos = this.el.object3D.position;
            const ballPlayerIndex = this.isCaptureBall ? 'capture' : parseInt(this.data.player.replace('player', ''));
            sendBallState({ 
              playerId: ballPlayerIndex,
              x: pos.x, y: pos.y, z: pos.z, 
              vx: 0, vy: 0, vz: 0, // Zero velocity when grabbed
              grabbed: true // Add grabbed state
            });
          }
          
          // Cancel auto-return if player grabs the ball
          if (this.autoReturnActive) {
            this.autoReturnActive = false;
          }
          
          // Start velocity and rotation tracking
          this.velocityHistory = [];
          const handPos = new THREE.Vector3();
          const handQuat = new THREE.Quaternion();
          hand.object3D.getWorldPosition(handPos);
          hand.object3D.getWorldQuaternion(handQuat);
          this.lastPosition.copy(handPos);
          this.lastRotation = handQuat.clone();
          this.lastPositionTime = performance.now();
          
          // Haptic feedback
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.7, 100).catch(() => {});
          }
        },
        
        onRelease: function() {
          if (!this.isGrabbed) return;
          
          
          // Calculate throw velocity from hand movement history
          let velocity = new THREE.Vector3(0, 0, 0);
          
          if (this.velocityHistory.length > 0) {
            // Use weighted average of recent velocities
            let totalWeight = 0;
            for (let i = 0; i < this.velocityHistory.length; i++) {
              const weight = (i + 1) / this.velocityHistory.length;
              velocity.add(this.velocityHistory[i].clone().multiplyScalar(weight));
              totalWeight += weight;
            }
            velocity.divideScalar(totalWeight);
            
            // Scale for satisfying throws
            velocity.multiplyScalar(1.5);
            
            // Cap maximum throw speed (different for capture ball)
            const maxThrowSpeed = this.isCaptureBall ? this.data.maxVelocity : 15; // m/s
            if (velocity.length() > maxThrowSpeed) {
              velocity.normalize().multiplyScalar(maxThrowSpeed);
            }
          }
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          
          // CRITICAL FIX: Immediately send ball state for multiplayer sync when throwing
          if (isMultiplayer && activePlayers.size > 1) {
            // Send immediate ball state with throw velocity for capture ball
            if (this.isCaptureBall) {
              const pos = this.el.object3D.position;
              sendBallState({ 
                playerId: 'capture',
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            } else {
              // Send immediate ball state for regular player balls
              const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
              const pos = this.el.object3D.position;
              sendBallState({ 
                playerId: ballPlayerIndex,
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            }
          }
          
          // Calculate angular velocity based on hand rotation change
          let angularVelocity = new THREE.Vector3(0, 0, 0);
          if (this.lastRotation && this.grabbingHand) {
            const currentHandQuat = new THREE.Quaternion();
            this.grabbingHand.object3D.getWorldQuaternion(currentHandQuat);
            
            // Calculate rotation difference
            const deltaRot = new THREE.Quaternion().multiplyQuaternions(
              currentHandQuat,
              this.lastRotation.clone().invert()
            );
            
            // Convert quaternion to angular velocity
            const angle = 2 * Math.acos(Math.abs(deltaRot.w));
            if (angle > 0.0001) {
              const axis = new THREE.Vector3(deltaRot.x, deltaRot.y, deltaRot.z).normalize();
              // Scale angular velocity for good spin effect (matching index.html)
              axis.multiplyScalar(angle * 40); // Same as index.html for consistency
              angularVelocity = axis;
            }
          }
          
          // Apply calculated angular velocity for realistic spin
          this.body.angularVelocity.set(angularVelocity.x, angularVelocity.y, angularVelocity.z);
          
          
          this.body.gravity.set(0, 0, 0);
          

          
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
          
          // NOTE: Ball state with velocity is already sent immediately above in onRelease
          // No need to send additional release state here since throw velocity sync handles it
        },
        
        stunPlayer: function() {
          // Stun the player for 3 seconds
          const player = document.querySelector('[zerog-player]');
          if (player && player.components['zerog-player']) {
            const playerComponent = player.components['zerog-player'];
            
            // Check if player has stun immunity
            if (Date.now() < playerComponent.stunImmunityEndTime) {
              return;
            }
            
            // Stop player movement
            playerComponent.velocity.set(0, 0, 0);
            
            // Disable controls
            playerComponent.isStunned = true;
            playerComponent.stunEndTime = Date.now() + 3000; // 3 seconds
            playerComponent.stunImmunityEndTime = Date.now() + 13000; // 10 seconds immunity after stun ends
            
            // Release capture ball if holding it
            const captureBall = document.querySelector('#capture-ball');
            if (captureBall && captureBall.components['zerog-ball'] && 
                captureBall.components['zerog-ball'].isGrabbed) {
              captureBall.components['zerog-ball'].onRelease();
            }
            
          }
        },
        
        stunBot: function(botId) {
          // CRITICAL FIX: Stun specific bot based on botId parameter
          let bot = null;
          if (botId === 'bot-red') {
            bot = document.querySelector('#zerog-bot-red');
          } else if (botId === 'bot-blue') {
            bot = document.querySelector('#zerog-bot-blue');
          } else {
            // Fallback to old behavior if no botId specified
            bot = document.querySelector('#zerog-bot-red') || document.querySelector('#zerog-bot-blue');
          }
          
          if (bot && bot.components['zerog-bot']) {
            const botComponent = bot.components['zerog-bot'];
            
            // Check if bot has stun immunity
            if (Date.now() < botComponent.stunImmunityEndTime) {

              return;
            }
            
            // Stop bot movement
            if (botComponent.body) {
              botComponent.body.velocity.set(0, 0, 0);
            }
            
            // Disable bot AI
            botComponent.isStunned = true;
            botComponent.stunEndTime = Date.now() + 3000; // 3 seconds
            botComponent.stunImmunityEndTime = Date.now() + 13000; // 10 seconds immunity after stun ends
            

          }
        },
        
        tick: function() {
          if (this.body) {

            
            if (this.isGrabbed && this.grabbingHand) {
              // When grabbed, track hand movement and rotation for throwing
              const handPos = new THREE.Vector3();
              const handQuat = new THREE.Quaternion();
              this.grabbingHand.object3D.getWorldPosition(handPos);
              this.grabbingHand.object3D.getWorldQuaternion(handQuat);
              
              // Update ball position AND rotation to match hand
              this.el.object3D.position.copy(handPos);
              this.el.object3D.quaternion.copy(handQuat);
              this.body.position.copy(handPos);
              this.body.quaternion.copy(handQuat);
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              

              

              
              // Track velocity history for throwing
              const currentTime = performance.now();
              if (this.lastPositionTime > 0) {
                const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.001);
                const displacement = new THREE.Vector3().subVectors(handPos, this.lastPosition);
                const instantVelocity = displacement.divideScalar(deltaTime);
                
                this.velocityHistory.push(instantVelocity.clone());
                if (this.velocityHistory.length > this.maxHistorySize) {
                  this.velocityHistory.shift();
                }
              }
              
              this.lastPosition.copy(handPos);
              this.lastRotation = handQuat.clone();
              this.lastPositionTime = currentTime;
            } else {
              // When not grabbed, update visual position from physics
              // BUT: Don't override if this is a remote ball that was manually updated
              const isRemoteBall = this.el.hasAttribute('data-remote-update');
              
              // Always update visual position from physics body when not grabbed
              // This ensures the ball moves smoothly during auto-return and tractor beam
              if (!isRemoteBall && !this.isGrabbed) {
                this.el.object3D.position.copy(this.body.position);
                this.el.object3D.quaternion.copy(this.body.quaternion);
              }
              
              // Check auto-return timeout (turn off after 2 seconds)
              if (this.autoReturnActive && Date.now() - this.autoReturnStartTime > this.autoReturnDuration) {
                this.autoReturnActive = false;
              }
              
              // Tractor beam logic (only for current player's ball when A is held OR grip is held OR auto-return)
              if (this.shouldActivateTractorBeam()) {
                // Determine which ball belongs to the current player
                let currentPlayerBall = 'player2'; // Default for singleplayer
                if (isMultiplayer && myPlayerId) {
                  const ballNumber = getBallForPlayer(myPlayerId);
                  currentPlayerBall = `player${ballNumber}`;
                }
                
                // Only apply tractor beam to the current player's ball
                if (this.data.player === currentPlayerBall) {
                  this.applyTractorBeam();
                }
              }
              
              // Check for target hits each frame when moving
              this.checkTargetHit();
              
              // Keep zero gravity
              this.body.gravity.set(0, 0, 0);
              
              // Apply Magnus effect for spinning balls (matching index.html exactly)
              if (this.body.velocity.length() > 0.1) {
                const velocity = new THREE.Vector3(
                  this.body.velocity.x,
                  this.body.velocity.y,
                  this.body.velocity.z
                );

                const angularVelocity = new THREE.Vector3(
                  this.body.angularVelocity.x,
                  this.body.angularVelocity.y,
                  this.body.angularVelocity.z
                );

                const angularSpeed = angularVelocity.length();
                const linearSpeed = velocity.length();
                
                // Debug: Always log spin and speed when ball is moving to see what we're working with
                // if (linearSpeed > 0.5) {
                // }
                
                // Apply Magnus effect - subtle curve to existing motion
                if (angularSpeed > 0.1 && linearSpeed > 0.5) { // Much lower thresholds
                  // Calculate Magnus force as acceleration (not velocity change)
                  const magnusAcceleration = new THREE.Vector3()
                    .crossVectors(angularVelocity, velocity);
                  
                  // Small but noticeable effect - frame rate independent acceleration
                  const frameTime = 1/72; // Assume 72fps for consistent effect
                  const magnusStrength = 0.008; // Slightly stronger Magnus effect - more noticeable curvature
                  
                  // Scale acceleration by frame time and strength
                  magnusAcceleration.multiplyScalar(magnusStrength * frameTime);
                  
                  // Apply as acceleration (small velocity change per frame)
                  this.body.velocity.x += magnusAcceleration.x;
                  this.body.velocity.y += magnusAcceleration.y;
                  this.body.velocity.z += magnusAcceleration.z;
                  
                  // Log Magnus effect very rarely
                  // Magnus effect logging removed
                }

                // Add minimal damping only for very slow balls to prevent infinite bouncing
                const speed = velocity.length();
                const currentAngularSpeed = angularVelocity.length();
                if (speed < 0.5 && currentAngularSpeed < 1.0) { // Only damp if both linear and angular are slow
                  const damping = 0.995;
                  this.body.velocity.x *= damping;
                  this.body.velocity.y *= damping;
                  this.body.velocity.z *= damping;
                  this.body.angularVelocity.x *= damping;
                  this.body.angularVelocity.y *= damping;
                  this.body.angularVelocity.z *= damping;
                }
                
                // GLOBAL SPEED LIMIT: Prevent any ball from escaping the environment
                const maxGlobalSpeed = 12.0; // Maximum speed for any ball movement
                if (speed > maxGlobalSpeed) {
                  const scale = maxGlobalSpeed / speed;
                  this.body.velocity.x *= scale;
                  this.body.velocity.y *= scale;
                  this.body.velocity.z *= scale;
                  
                  // Also limit angular velocity to prevent excessive spinning
                  const maxAngularSpeed = 20.0;
                  if (currentAngularSpeed > maxAngularSpeed) {
                    const angularScale = maxAngularSpeed / currentAngularSpeed;
                    this.body.angularVelocity.x *= angularScale;
                    this.body.angularVelocity.y *= angularScale;
                    this.body.angularVelocity.z *= angularScale;
                  }
                }
              }
            }
          }
        },
        
        // NEW: Check if tractor beam should be activated (A button OR grip buttons OR auto-return)
        shouldActivateTractorBeam: function() {
          // CRITICAL: Don't activate tractor beam if ball is grabbed
          if (this.isGrabbed) {
            return false;
          }
          
          // Always activate if A button is held
          if (this.tractorBeamActive) {
            return true;
          }
          
          // Always activate if in auto-return mode (after hitting target)
          if (this.autoReturnActive) {
            return true;
          }
          
          // Check if player is holding grips (get from zerog-player component)
          const player = document.querySelector('[zerog-player]');
          if (player && player.components['zerog-player']) {
            const playerComponent = player.components['zerog-player'];
            const gripState = playerComponent.gripHeld;
            const grabbingState = playerComponent.isGrabbing;
            
            // Only allow tractor beam from hands that are holding grip BUT NOT grabbing surfaces
            const leftHandFree = gripState.left && !grabbingState.left;
            const rightHandFree = gripState.right && !grabbingState.right;
            
            return leftHandFree || rightHandFree;
          }
          
          return false;
        },
        
        // NEW: Start auto-return mode (called when ball hits target)
        startAutoReturn: function() {
          // Determine which ball belongs to the current player
          let currentPlayerBall = 'player2'; // Default for singleplayer
          if (isMultiplayer && myPlayerId) {
            const ballNumber = getBallForPlayer(myPlayerId);
            currentPlayerBall = `player${ballNumber}`;
          }
          
          if (this.data.player === currentPlayerBall) { // Only for current player's ball
            this.autoReturnActive = true;
            this.autoReturnStartTime = Date.now();
            // Auto-return activated
          }
        },
        
        // NEW: Tractor beam effect - attracts ball to position in front of player
        applyTractorBeam: function() {
          if (!this.body) return;
          
          // Get player camera (the "player" position)
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          // Get camera world position and rotation
          const cameraWorldPos = new THREE.Vector3();
          const cameraWorldQuat = new THREE.Quaternion();
          camera.object3D.getWorldPosition(cameraWorldPos);
          camera.object3D.getWorldQuaternion(cameraWorldQuat);
          
          // Calculate target position: 30cm in front of camera, 30cm lower (chest height)
          const forwardDirection = new THREE.Vector3(0, 0, -1); // Forward in camera space
          forwardDirection.applyQuaternion(cameraWorldQuat);
          
          this.targetPosition.copy(cameraWorldPos);
          this.targetPosition.add(forwardDirection.multiplyScalar(0.3)); // 30cm forward
          this.targetPosition.y -= 0.3; // 30cm lower for chest height
          
          // Calculate attraction force toward target position
          const ballPos = new THREE.Vector3().copy(this.body.position);
          const attractionVector = new THREE.Vector3().subVectors(this.targetPosition, ballPos);
          const distance = attractionVector.length();
          
          if (distance > 0.01) { // Only apply force if not already at target
            // Normalize and apply force - stronger when farther away
            attractionVector.normalize();
            
            // Adaptive force: stronger for distant objects, gentler when close
            let forceMultiplier;
            if (distance > 2.0) {
              forceMultiplier = 25.0; // Strong force for distant balls
            } else if (distance > 0.5) {
              forceMultiplier = 15.0; // Medium force for medium distance
            } else {
              forceMultiplier = 8.0;  // Gentle force when close to avoid jitter
            }
            
            attractionVector.multiplyScalar(forceMultiplier);
            
            // Apply force to ball
            this.body.velocity.x += attractionVector.x * 0.016; // Assume ~60fps
            this.body.velocity.y += attractionVector.y * 0.016;
            this.body.velocity.z += attractionVector.z * 0.016;
            
            // Dampen velocity to prevent overshooting when close
            if (distance < 0.5) {
              this.body.velocity.x *= 0.9;
              this.body.velocity.y *= 0.9;
              this.body.velocity.z *= 0.9;
            }
            
            // Cap maximum tractor beam velocity for safety - much lower limit to prevent escaping
            const maxTractorSpeed = 6.0; // Reduced from 10.0 to 6.0 m/s
            const currentSpeed = Math.sqrt(
              this.body.velocity.x * this.body.velocity.x +
              this.body.velocity.y * this.body.velocity.y +
              this.body.velocity.z * this.body.velocity.z
            );
            
            if (currentSpeed > maxTractorSpeed) {
              const scale = maxTractorSpeed / currentSpeed;
              this.body.velocity.x *= scale;
              this.body.velocity.y *= scale;
              this.body.velocity.z *= scale;
            }
            
            // Additional safety: Check if ball is too far from environment center and gently pull it back
            const environmentCenter = new THREE.Vector3(0, 2, 0); // Center of the space
            const ballToCenter = new THREE.Vector3().subVectors(environmentCenter, ballPos);
            const distanceFromCenter = ballToCenter.length();
            
            if (distanceFromCenter > 15.0) { // If ball is more than 15m from center
              ballToCenter.normalize();
              // Gentle pull back toward center
              const pullForce = 2.0;
              this.body.velocity.x += ballToCenter.x * pullForce * 0.016;
              this.body.velocity.y += ballToCenter.y * pullForce * 0.016;
              this.body.velocity.z += ballToCenter.z * pullForce * 0.016;
              
            }
            
            // Debug info (occasional)
            if (Math.random() < 0.02) { // 2% chance per frame (~1.2 times per second at 60fps)
              let activationMethod;
              if (this.tractorBeamActive) {
                activationMethod = 'A button';
              } else if (this.autoReturnActive) {
                activationMethod = 'Auto-return';
              } else {
                activationMethod = 'Grip buttons';
              }
              
            }
          }
        }
      });

      // FPS counter
      AFRAME.registerComponent('fps-counter', {
        init: function() {
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.fps = 0;
          this.fpsHistory = [];
          this.updateInterval = 500;
          this.lastUpdate = 0;
        },
        
        tick: function() {
          const currentTime = performance.now();
          this.frameCount++;
          
          if (currentTime - this.lastUpdate >= this.updateInterval) {
            const deltaTime = currentTime - this.lastTime;
            const currentFPS = Math.round((this.frameCount * 1000) / deltaTime);
            
            this.fpsHistory.push(currentFPS);
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift();
            }
            
            const avgFPS = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);
            this.fps = avgFPS;
            
            this.updateVersionDisplay();
            
            this.frameCount = 0;
            this.lastTime = currentTime;
            this.lastUpdate = currentTime;
          }
        },
        
        updateVersionDisplay: function() {
          const versionDisplay = document.getElementById('version-display');
          if (versionDisplay) {
            versionDisplay.setAttribute('text', 'value', `Zero-G v1.30 | ${this.fps} FPS`);
          }
        }
      });

      // Fix for hand-controls clipAction error
      AFRAME.registerComponent('custom-hand-controls', {
        init: function() {
          // Override the problematic animation methods to prevent clipAction errors
          setTimeout(() => {
            const handControls = this.el.components['hand-controls'];
            if (handControls) {
              // Store original methods
              this.originalAnimateGesture = handControls.animateGesture;
              this.originalPlayAnimation = handControls.playAnimation;
              
              // Override with no-op functions
              handControls.animateGesture = function() {};
              handControls.playAnimation = function() {};
              
            }
          }, 100);
        },
        
        remove: function() {
          // Restore original methods if needed
          const handControls = this.el.components['hand-controls'];
          if (handControls && this.originalAnimateGesture && this.originalPlayAnimation) {
            handControls.animateGesture = this.originalAnimateGesture;
            handControls.playAnimation = this.originalPlayAnimation;
          }
        }
      });

      // Cursor listener component for menu interactions
      AFRAME.registerComponent('cursor-listener', {
        init: function() {
          this.el.addEventListener('click', this.onClick.bind(this));
          this.el.addEventListener('mouseenter', this.onHover.bind(this));
          this.el.addEventListener('mouseleave', this.onLeave.bind(this));
        },

        onClick: function() {
          const id = this.el.id;
          
          if (id === 'menu-singleplayer') {
            this.switchToSingleplayer();
          } else if (id === 'menu-multiplayer') {
            this.switchToMultiplayer();
          } else if (id === 'menu-lobby-minus') {
            this.changeLobby(-1);
          } else if (id === 'menu-lobby-plus') {
            this.changeLobby(1);
          } else if (id === 'menu-connect') {
            this.connectToLobby();
          } else if (id === 'menu-auto-connect') {
            this.autoConnect();
          } else if (id === 'menu-team-red') {
            this.selectTeam('red');
          } else if (id === 'menu-team-blue') {
            this.selectTeam('blue');
          } else if (id === 'menu-mode-dodge') {
            this.selectGameMode('dodgeball');
          } else if (id === 'menu-mode-capture') {
            this.selectGameMode('capture');
          }
        },

        onHover: function() {
          // Highlight button on hover
          const material = this.el.getAttribute('material');
          this.originalColor = material.color;
          this.el.setAttribute('material', 'color', '#ffffff');
          this.el.setAttribute('material', 'opacity', 1.0);
        },

        onLeave: function() {
          // Restore original color
          if (this.originalColor) {
            this.el.setAttribute('material', 'color', this.originalColor);
            this.el.setAttribute('material', 'opacity', 0.8);
          }
        },

        switchToSingleplayer: function() {
          // Prevent switching during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          isMultiplayer = false;
          
          // Hide lobby section and auto connect button
          const lobbySection = document.querySelector('#menu-lobby-section');
          const autoConnect = document.querySelector('#menu-auto-connect');
          
          if (lobbySection) {
            lobbySection.setAttribute('visible', false);
          }
          if (autoConnect) {
            autoConnect.setAttribute('visible', false);
          }
          
          // End any active multiplayer connection
          if (peer) {
            peer.destroy();
            peer = null;
          }
          connections.clear();
          connectionToPlayer.clear();
          activePlayers.clear();
          myPlayerId = null;
          
          this.updateCurrentModeDisplay('Singleplayer');
        },

        switchToMultiplayer: function() {
          // Prevent switching during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          isMultiplayer = true;
          
          // Show lobby section and auto connect button
          const lobbySection = document.querySelector('#menu-lobby-section');
          const autoConnect = document.querySelector('#menu-auto-connect');
          
          if (lobbySection) {
            lobbySection.setAttribute('visible', true);
          }
          if (autoConnect) {
            autoConnect.setAttribute('visible', true);
          }
          
          this.updateCurrentModeDisplay('Multiplayer - Select Lobby');
        },

        updateCurrentModeDisplay: function(mode) {
          const currentModeDisplay = document.querySelector('#menu-current-mode');
          if (currentModeDisplay) {
            currentModeDisplay.setAttribute('text', 'value', `Mode: ${mode}`);
            currentModeDisplay.setAttribute('text', 'color', '#ffffff');
          }
        },

        changeLobby: function(delta) {
          selectedLobby = Math.max(1, Math.min(MAX_LOBBIES, selectedLobby + delta));
          const lobbyNumber = document.querySelector('#menu-lobby-number');
          if (lobbyNumber) {
            lobbyNumber.setAttribute('text', 'value', selectedLobby.toString());
          }
        },

        connectToLobby: function() {
          // Prevent connecting during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          connectToLobby(selectedLobby);
        },

        autoConnect: function() {
          // Prevent auto-connecting during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          autoConnect();
        },
        
        selectTeam: function(team) {
          // Set the player's team
          const currentPlayerId = myPlayerId || 'player_0';
          playerTeams.set(currentPlayerId, team);
          
          // Update player visual color
          updatePlayerTeamColor(currentPlayerId, team);
          
          // Update ball colors for team assignments
          updateBallColors();
          
          // Send team assignments to clients if host
          if (isHost) {
            sendTeamAssignments();
          }
          
          // Update bot ball assignments for team change
          const redBot = document.querySelector('#zerog-bot-red');
          const blueBot = document.querySelector('#zerog-bot-blue');
          if (redBot && redBot.components['zerog-bot']) {
            redBot.components['zerog-bot'].updateBallAssignment();
          }
          if (blueBot && blueBot.components['zerog-bot']) {
            blueBot.components['zerog-bot'].updateBallAssignment();
          }
          
          // Force release any currently grabbed balls that are no longer owned
          this.releaseNonOwnedBalls();
          
          // Update the team display
          const currentTeamDisplay = document.querySelector('#menu-current-team');
          if (currentTeamDisplay) {
            currentTeamDisplay.setAttribute('text', 'value', `Team: ${team.toUpperCase()}`);
            currentTeamDisplay.setAttribute('text', 'color', team === 'red' ? '#ff0000' : '#0000ff');
          }
          
          // Update button highlighting
          const redButton = document.querySelector('#menu-team-red');
          const blueButton = document.querySelector('#menu-team-blue');
          
          if (redButton && blueButton) {
            if (team === 'red') {
              redButton.setAttribute('material', 'opacity', 1.0);
              blueButton.setAttribute('material', 'opacity', 0.5);
            } else {
              blueButton.setAttribute('material', 'opacity', 1.0);
              redButton.setAttribute('material', 'opacity', 0.5);
            }
          }
        },
        
        releaseNonOwnedBalls: function() {
          // Release any balls that are no longer owned by this player
          const currentPlayerId = myPlayerId || 'player_0';
          const myBallIndex = getBallForPlayer(currentPlayerId);
          
          // Check all balls and release any that are grabbed but not owned
          for (let i = 1; i <= 4; i++) {
            const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
            if (ball && ball.components['zerog-ball']) {
              const ballComponent = ball.components['zerog-ball'];
              if (ballComponent.isGrabbed && i !== myBallIndex && !ballComponent.isCaptureBall) {
                // This ball is grabbed but not owned by current player - release it
                ballComponent.onRelease();
                
                // Also clear the grab info from the player component
                const player = document.querySelector('[zerog-player]');
                if (player && player.components['zerog-player']) {
                  const playerComponent = player.components['zerog-player'];
                  ['left', 'right'].forEach(handKey => {
                    if (playerComponent.grabInfo[handKey] && 
                        playerComponent.grabInfo[handKey].surface === ball) {
                      playerComponent.grabInfo[handKey] = null;
                      playerComponent.isGrabbing[handKey] = false;
                    }
                  });
                }
              }
            }
          }
        },
        
        selectGameMode: function(mode) {
          // Switch the game mode
          switchGameMode(mode);
          
          
          // Update the mode display
          const currentModeDisplay = document.querySelector('#menu-current-mode-game');
          if (currentModeDisplay) {
            const displayText = mode === 'capture' ? 'Capture' : 'Dodge';
            currentModeDisplay.setAttribute('text', 'value', `Mode: ${displayText}`);
            currentModeDisplay.setAttribute('text', 'color', mode === 'capture' ? '#8800ff' : '#ff8800');
          }
          
          // Update button highlighting
          const dodgeButton = document.querySelector('#menu-mode-dodge');
          const captureButton = document.querySelector('#menu-mode-capture');
          
          if (dodgeButton && captureButton) {
            if (mode === 'capture') {
              captureButton.setAttribute('material', 'opacity', 1.0);
              dodgeButton.setAttribute('material', 'opacity', 0.5);
            } else {
              dodgeButton.setAttribute('material', 'opacity', 1.0);
              captureButton.setAttribute('material', 'opacity', 0.5);
            }
          }
          
          // Show/hide team selection based on mode
          const teamSelection = document.querySelector('#menu-team-selection');
          if (teamSelection) {
            teamSelection.setAttribute('visible', mode === 'capture');
          }
        }
      });

    </script>

    <a-scene physics-world fps-counter game-manager sound-manager multiplayer-sync menu-toggle y-button-shortcut
             renderer="antialias: true; colorManagement: true; shadowMapEnabled: false; maxDeltaTime: 0.2"
             webxr="requiredFeatures: local-floor">
      
      <!-- Space Station Environment -->
      
      <!-- Main chamber floor (doubled size) -->
      <a-box position="0 -2 0" 
             width="16" 
             height="0.2" 
             depth="32" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>

      <!-- Main chamber ceiling (doubled size) -->
      <a-box position="0 6 0" 
             width="16" 
             height="0.2" 
             depth="32" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>

      <!-- Left wall (doubled size) -->
      <a-box position="-8 2 0" 
             width="0.2" 
             height="8" 
             depth="32" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>
      
      <!-- Right wall (doubled size) -->
      <a-box position="8 2 0" 
             width="0.2" 
             height="8" 
             depth="32" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>
      
      <!-- Back wall (doubled size) -->
      <a-box position="0 2 -16" 
             width="16" 
             height="8" 
             depth="0.2" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>
      
      <!-- Front wall (doubled size) -->
      <a-box position="0 2 16" 
             width="16" 
             height="8" 
             depth="0.2" 
             color="#444444"
             material="shader: standard; metalness: 0.8; roughness: 0.2"
             grab-surface="type: static">
      </a-box>

      <!-- Red Team Goal (back side, 1m from wall) -->
      <a-cylinder id="red-goal"
                  position="0 2 -14.8"
                  radius="1"
                  height="0.1"
                  rotation="90 0 0"
                  color="#ff0000"
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.3; transparent: true; opacity: 0.7"
                  goal="team: red"
                  visible="false">
        <a-entity light="type: point; color: #ff0000; intensity: 2; distance: 8"></a-entity>
        <a-text value="RED GOAL" position="0 0 0.1" align="center" width="4" color="#ffffff"></a-text>
      </a-cylinder>

      <!-- Blue Team Goal (front side, 1m from wall) -->
      <a-cylinder id="blue-goal"
                  position="0 2 14.8"
                  radius="1"
                  height="0.1"
                  rotation="90 0 0"
                  color="#0000ff"
                  material="shader: standard; emissive: #0000ff; emissiveIntensity: 0.3; transparent: true; opacity: 0.7"
                  goal="team: blue"
                  visible="false">
        <a-entity light="type: point; color: #0000ff; intensity: 2; distance: 8"></a-entity>
        <a-text value="BLUE GOAL" position="0 0 -0.1" align="center" width="4" color="#ffffff"></a-text>
      </a-cylinder>

      <!-- Randomly positioned 1m cubes throughout the space -->
      <a-box position="-5 1 -10" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="3 4 -5" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="-2 3 8" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="6 2 -12" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="-7 5 3" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="1 1 -8" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="-4 4 -2" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="5 3 12" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="-1 2 5" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="7 5 -6" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="-6 1 -14" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>
      
      <a-box position="2 4 9" 
             width="1" height="1" depth="1" 
             color="#888888"
             material="shader: standard; metalness: 0.7; roughness: 0.3"
             grab-surface="type: static">
      </a-box>

      <!-- Floating objects/balls (spawned at center) -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ff0000" 
                glow="color: #ff0000; intensity: 1.5"
                zerog-ball="player: player1; owner: bot">
        <a-entity light="type: point;
                       color: #ff0000;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2;"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff0000" material="wireframe: true; color: #ff0000; opacity: 0.5"></a-sphere>
        <a-entity id="red-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#0000ff" 
                glow="color: #0000ff; intensity: 1.5"
                zerog-ball="player: player2; owner: human">
        <a-entity light="type: point; 
                       color: #0000ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#0000ff" material="wireframe: true; color: #0000ff; opacity: 0.5"></a-sphere>
        <a-entity id="blue-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Ball 3 (Purple) - Blue Bot Ball -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ff00ff" 
                glow="color: #ff00ff; intensity: 1.5"
                zerog-ball="player: player3; owner: bot">
        <a-entity light="type: point; 
                       color: #ff00ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff00ff" material="wireframe: true; color: #ff00ff; opacity: 0.5"></a-sphere>
        <a-entity id="purple-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Ball 4 (Yellow) - Human Player 1 Ball -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ffff00" 
                glow="color: #ffff00; intensity: 1.5"
                zerog-ball="player: player4; owner: human">
        <a-entity light="type: point; 
                       color: #ffff00;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ffff00" material="wireframe: true; color: #ffff00; opacity: 0.5"></a-sphere>
        <a-entity id="yellow-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Special white capture ball (twice the size, half max velocity) -->
      <a-sphere id="capture-ball"
                position="0 2 0" 
                radius="0.2"
                color="#ffffff" 
                glow="color: #ffffff; intensity: 2.0"
                zerog-ball="player: capture; maxVelocity: 4"
                visible="false">
        <a-entity light="type: point; 
                       color: #ffffff;
                       intensity: 2.0;     
                       distance: 8;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.2" color="#ffffff" material="wireframe: true; color: #ffffff; opacity: 0.3"></a-sphere>
        <a-entity id="white-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.8;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 6;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player with zero-g physics -->
      <a-entity id="player" position="0 2 12" zerog-player="mass: 70; thrusterForce: 0.8">
        <a-entity id="rig" position="0 0 0">
          <a-entity camera look-controls="pointerLockEnabled: false">
            <!-- Player target sphere (like in original dodgeball project) -->
            <a-sphere id="player-target" 
                      radius="0.2" 
                      color="#ff0000" 
                      material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                      position="0 0 0"
                      impact-effect="color: #ff0000">
              <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 3"></a-entity>
              <!-- Impact sphere with animation component -->
              <a-sphere id="player-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
                animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
                animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
              </a-sphere>
            </a-sphere>
            
            <!-- HUD display -->
            <a-entity id="version-display" position="0 0.3 -0.5" text="value: Zero-G v1.0; align: center; width: 0.4; color: #ffffff"></a-entity>
            
            <!-- Game Status Display -->
            <a-entity id="hud-status" position="0 0.2 -0.5" text="value: Singleplayer; align: center; width: 1.1; color: #ffffff"></a-entity>
            
            <!-- Score Display in HUD -->
            <a-entity id="hud-score" position="0 0.1 -0.5" visible="false">
              <a-entity position="-0.15 0 0" text="value: You: 0; align: center; width: 1.5; color: #0099ff"></a-entity>
              <a-entity position="0.15 0 0" text="value: Bot: 0; align: center; width: 1.5; color: #ff4444"></a-entity>
            </a-entity>
            
            <!-- Timer Display in HUD -->
            <a-entity id="hud-timer" position="0 0.05 -0.5" text="value: Time: 3:00; align: center; width: 1.2; color: #ffff00" visible="false"></a-entity>
            
            <!-- Game Messages in HUD -->
            <a-entity id="hud-message" position="0 0 -0.5" text="value: Press A to Start; align: center; width: 1.1; color: #ffffff" visible="false"></a-entity>
            
            <!-- Game Menu in HUD (initially hidden) -->
            <a-entity id="game-menu" position="0 0 -0.8" visible="false">
              <!-- Menu background panel -->
              <a-plane width="1.2" height="0.8" color="#000000" material="opacity: 0.9; transparent: true" position="0 0 -0.01"></a-plane>
              
              <!-- Menu title -->
              <a-text value="DODGE VR MENU" position="0 0.3 0" align="center" width="1.2" color="#ffffff"></a-text>

              <!-- Current mode display -->
              <a-text id="menu-current-mode" value="Mode: Singleplayer" position="0 0.25 0" align="center" width="1.1" color="#ffffff"></a-text>
              
              <!-- Singleplayer button -->
              <a-entity id="menu-singleplayer" position="-0.2 0.15 0" 
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #004499; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="SINGLE" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Multiplayer button -->
              <a-entity id="menu-multiplayer" position="0.2 0.15 0"
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #990044; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="MULTI" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Lobby selection (only visible in multiplayer) -->
              <a-entity id="menu-lobby-section" position="0 0.05 0" visible="false">
                <a-text value="Lobby:" position="-0.4 0 0" align="center" width="0.3" color="#ffffff"></a-text>
                <a-entity id="menu-lobby-minus" position="-0.075 0 0"
                          geometry="primitive: plane; width: 0.04; height: 0.04"
                          material="color: #ff4444; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="-" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
                <a-text id="menu-lobby-number" value="1" position="-0.02 0 0" align="center" width="1" color="#ffffff"></a-text>
                <a-entity id="menu-lobby-plus" position="0.05 0 0"
                          geometry="primitive: plane; width: 0.04; height: 0.04"
                          material="color: #44ff44; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="+" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-connect" position="0.15 0 0"
                          geometry="primitive: plane; width: 0.1; height: 0.04"
                          material="color: #4444ff; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="JOIN" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Auto connect button -->
              <!--<a-entity id="menu-auto-connect" position="0.2 0.05 0"
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #44aa44; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable"
                        visible="false">
                <a-text value="AUTO JOIN" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>-->
              
              <!-- Player slots display -->
              <!--<a-entity id="menu-player-slots" position="0 0 0">
                <a-text value="Players:" position="-0.4 0 0" align="center" width="0.3" color="#ffffff"></a-text>
                <a-entity id="menu-slot-0" position="-0.1 0 0">
                  <a-sphere radius="0.02" color="#ff0000" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P0" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-1" position="-0 0 0">
                  <a-sphere radius="0.02" color="#00ff00" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P1" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-2" position="0.1 0 0">
                  <a-sphere radius="0.02" color="#ff00ff" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P2" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-3" position="0.2 0 0">
                  <a-sphere radius="0.02" color="#ffff00" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P3" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>-->
              
              <!-- Game Mode Selection -->
              <a-entity id="menu-game-mode" position="0 -0.12 0">
                <a-text value="Game Mode:" position="0 0.05 0" align="center" width="0.4" color="#ffffff"></a-text>
                <a-text id="menu-current-mode-game" value="Mode: Dodge" position="0 0.03 0" align="center" width="0.4" color="#ff8800"></a-text>
                <a-entity id="menu-mode-dodge" position="-0.12 -0.02 0"
                          geometry="primitive: plane; width: 0.1; height: 0.04"
                          material="color: #ff8800; transparent: true; opacity: 1.0"
                          cursor-listener
                          class="clickable">
                  <a-text value="DODGE" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-mode-capture" position="0.12 -0.02 0"
                          geometry="primitive: plane; width: 0.1; height: 0.04"
                          material="color: #8800ff; transparent: true; opacity: 0.5"
                          cursor-listener
                          class="clickable">
                  <a-text value="CAPTURE" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Team Selection -->
              <a-entity id="menu-team-selection" position="0 -0.25 0">
                <a-text value="Your Team:" position="0 0.05 0" align="center" width="0.4" color="#ffffff"></a-text>
                <a-text id="menu-current-team" value="Team: None" position="0 0.03 0" align="center" width="0.4" color="#ffff00"></a-text>
                <a-entity id="menu-team-red" position="-0.1 -0.02 0"
                          geometry="primitive: plane; width: 0.08; height: 0.04"
                          material="color: #ff0000; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="RED" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-team-blue" position="0.1 -0.02 0"
                          geometry="primitive: plane; width: 0.08; height: 0.04"
                          material="color: #0000ff; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="BLUE" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Instructions -->
              <a-text value="B to close" 
                      position="0 -0.35 0" align="center" width="0.6" color="#ffffff"></a-text>
            </a-entity>
          </a-entity>
          
          <a-entity id="leftHand" 
                   hand-controls="hand: left"
                   oculus-touch-controls="hand: left"
                   laser-controls="hand: left"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
          </a-entity>
          
          <a-entity id="rightHand" 
                   hand-controls="hand: right"
                   oculus-touch-controls="hand: right"
                   laser-controls="hand: right"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Remote players (for multiplayer) -->
      <a-entity id="remote-player-0" position="-2 0 -2" visible="false">
        <a-sphere id="remote-target-0" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ff0000">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-0" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <a-entity id="remote-player-1" position="2 0 -2" visible="false">
        <a-sphere id="remote-target-1" 
                  radius="0.2" 
                  color="#00ff00" 
                  material="shader: standard; emissive: #00ff00; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #00ff00">
          <a-entity light="type: point; color: #00ff00; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-1" radius="0.1" color="#00ff00" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <a-entity id="remote-player-2" position="-2 0 2" visible="false">
        <a-sphere id="remote-target-2" 
                  radius="0.2" 
                  color="#ff00ff" 
                  material="shader: standard; emissive: #ff00ff; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ff00ff">
          <a-entity light="type: point; color: #ff00ff; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-2" radius="0.1" color="#ff00ff" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <a-entity id="remote-player-3" position="2 0 2" visible="false">
        <a-sphere id="remote-target-3" 
                  radius="0.2" 
                  color="#ffff00" 
                  material="shader: standard; emissive: #ffff00; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ffff00">
          <a-entity light="type: point; color: #ffff00; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-3" radius="0.1" color="#ffff00" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Zero-G Bot Red Team (for singleplayer) -->
      <a-entity id="zerog-bot-red" position="0 2 -12" zerog-bot="enabled: true; difficulty: medium; team: red">
        <a-sphere id="bot-target" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; wireframe: false"
                  position="0 0 0"
                  impact-effect="color: #ff0000">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Zero-G Bot Blue Team (for singleplayer) -->
      <a-entity id="zerog-bot-blue" position="0 2 12" zerog-bot="enabled: true; difficulty: medium; team: blue">
        <a-sphere id="bot-blue-target" 
                  radius="0.2" 
                  color="#0000ff" 
                  material="shader: standard; emissive: #0000ff; emissiveIntensity: 0.5; wireframe: false"
                  position="0 0 0"
                  impact-effect="color: #0000ff">
          <a-entity light="type: point; color: #0000ff; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-blue-impact" radius="0.1" color="#0000ff" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Add game manager entity with score display -->
      <a-entity id="game-manager" game-manager>
        <!-- Version display moved closer to top -->
        <a-entity id="version-display-override" position="0 7 0" text="value: Zero-G v1.0; align: center; width: 0.5; color: #ffffff"></a-entity>
        
        <!-- Large colored score display -->
        <a-entity id="score-display" position="0 6.5 0">
          <!-- Blue player score (left side) -->
          <a-entity id="blue-score" position="-0.5 0 0" text="value: 0; align: center; width: 4; color: #0099ff"></a-entity>
          <!-- Dash separator -->
          <a-entity position="0 0 0" text="value: -; align: center; width: 4; color: #ffffff"></a-entity>
          <!-- Red player score (right side) -->
          <a-entity id="red-score" position="0.5 0 0" text="value: 0; align: center; width: 4; color: #ff4444"></a-entity>
        </a-entity>
        
        <a-entity id="timer-display" position="0 6 0" text="value: Time: 3:00; align: center; width: 2; color: #ffff00"></a-entity>
        <a-entity id="start-message" position="0 5.5 0" text="value: Press A to Start; align: center; width: 2; color: #ffffff"></a-entity>
      </a-entity>

      <!-- Ambient space lighting -->
      <a-entity light="type: ambient; color: #404040; intensity: 0.75"></a-entity>
      
      <!-- Directional light simulating distant star -->
      <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="5 5 5"></a-entity>

      <!-- Add impact sound entities -->
      <a-entity id="impact-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 2;">
      </a-entity>

      <!-- Add bounce sound entity -->
      <a-entity id="bounce-sound" sound="src: url(audio/impact-cinematic-boom-5-352465.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 8;
                                        rate: 1.5;">
      </a-entity>

      <!-- Goal sound entity -->
      <a-entity id="goal-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                      autoplay: false; 
                                      loop: false; 
                                      volume: 1.0;
                                      positional: false;
                                      poolSize: 2;">
      </a-entity>

      <!-- Space background -->
      <a-sky color="#000011"></a-sky>
    </a-scene>
    
    <script>
      // Y button shortcut for quick multiplayer
      AFRAME.registerComponent('y-button-shortcut', {
        init: function() {
          this.el.sceneEl.addEventListener('ybuttondown', () => {
            
            // If not already in multiplayer, start it and connect to lobby 1
            if (!isMultiplayer) {
              updateMultiplayerStatus('Quick connect to lobby 1...');
              
              // Try to connect to lobby 1
              connectToLobby(1).then(() => {
                updateMultiplayerStatus('Connected to lobby 1');
                
                // Close menu if it's open
                const menu = document.querySelector('#hud-menu');
                if (menu && menu.getAttribute('visible')) {
                  menu.setAttribute('visible', false);
                  isMenuVisible = false;
                }
              }).catch((error) => {
                updateMultiplayerStatus('Lobby 1 unavailable');
              });
            } else {
              updateMultiplayerStatus('Already in multiplayer');
            }
          });
          
          // Add B button for testing position sync
          this.el.sceneEl.addEventListener('bbuttondown', () => {
            // B button pressed
            testPositionSync();
          });
          
          // Add A button for testing connection
          this.el.sceneEl.addEventListener('abuttondown', () => {
            // A button pressed
            testConnection();
          });
          
        }
      });
      

      
      // Test function to force send position data
      function testPositionSync() {
        // Testing position sync
        if (isMultiplayer && activePlayers.size > 1) {
          const camera = document.querySelector('[camera]');
          if (camera) {
            const worldPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(worldPos);
            const worldQuat = new THREE.Quaternion();
            camera.object3D.getWorldQuaternion(worldQuat);
            const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
            const playerState = {
              x: worldPos.x, y: worldPos.y, z: worldPos.z,
              rx: worldRot.x, ry: worldRot.y, rz: worldRot.z
            };
            sendPlayerState(playerState);
          }
        } else {
          // Not in multiplayer
        }
      }
      
      // Test function to check connection status
      function testConnection() {
        // Testing connection status
        
        if (isHost) {
        } else {
          const hostID = `dodgevr-host-${multiplayerStartType}-${selectedLobby}`;
        }
        
        // Force send test data
        if (isMultiplayer && activePlayers.size > 1) {
          const camera = document.querySelector('[camera]');
          if (camera) {
            const worldPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(worldPos);
            const playerState = {
              x: worldPos.x, y: worldPos.y, z: worldPos.z,
              rx: 0, ry: 0, rz: 0
            };
            sendPlayerState(playerState);
          }
        }
      }
      
      // Multiplayer state synchronization functions
      let remotePlayerStates = new Map();
      let remoteBallStates = new Map();
      
      function sendPlayerState(state) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const data = {
          type: 'player-state',
          state: state,
          playerId: myPlayerId
        };
        
        // Only log if there are connections to send to (throttled to once per 30 seconds)
        if (connections.size > 0) {
          if (!this.lastPlayerStateLog || Date.now() - this.lastPlayerStateLog > 30000) {
            this.lastPlayerStateLog = Date.now();
          }
        }
        
        // Send to all connections
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send(data);
          }
        });
      }
      
      function sendGameModeUpdate(mode) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const data = {
          type: 'game-mode-update',
          gameMode: mode,
          playerId: myPlayerId
        };
        
        // Send to all connections
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send(data);
          }
        });
      }
      
      function sendBotState(botState) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const data = {
          type: 'bot-state',
          botState: botState,
          playerId: myPlayerId
        };
        
        // Send to all connections
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send(data);
          }
        });
      }
      
      function sendTeamAssignments() {
        if (!isHost || !isMultiplayer) return;
        
        // Send current team assignments to all clients
        const teamData = {};
        playerTeams.forEach((team, playerId) => {
          teamData[playerId] = team;
        });
        
        const data = {
          type: 'team-assignments',
          teams: teamData
        };
        
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send(data);
          }
        });
      }
      
      function handleTeamAssignments(data) {
        // Update local team assignments from host
        if (data.teams) {
          Object.entries(data.teams).forEach(([playerId, team]) => {
            playerTeams.set(playerId, team);
          });
          
          // Update ball colors based on new team assignments
          updateBallColors();
        }
      }

      function sendBallState(ballState) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        // CRITICAL: Don't send ball state if this ball is being controlled locally
        const ballNumber = ballState.playerId;
        const currentPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
        const currentPlayerBallNumber = getBallForPlayer(myPlayerId || 'player_0'); // Use dynamic ball assignment
        
        // CRITICAL FIX: Always send ball state for our own ball - other players need to see it!
        // The receiving end (handleBallState) will decide whether to apply the update or not
        
        const data = {
          type: 'ball-state',
          ballState: ballState,
          playerId: myPlayerId
        };
        
        // Only log if there are connections to send to (throttled to once per 30 seconds)
        if (connections.size > 0) {
          if (!this.lastBallStateLog || Date.now() - this.lastBallStateLog > 30000) {
            this.lastBallStateLog = Date.now();
          }
        }
        
        // Send to all connections
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send(data);
          }
        });
      }

      // Initialize multiplayer system when page loads
      document.addEventListener('DOMContentLoaded', function() {
        initMultiplayer();
      });
      // Function to manage active players and bots
      function manageActivePlayersAndBots() {
        const humanPlayerCount = isMultiplayer ? activePlayers.size : 1;

        
        // Get bot entities
        const redBot = document.querySelector('#zerog-bot-red');
        const blueBot = document.querySelector('#zerog-bot-blue');
        
        if (gameMode === 'capture') {
          if (humanPlayerCount >= 2) {
            // 2+ human players: Hide both bots

            if (redBot) {
              redBot.setAttribute('visible', false);
              if (redBot.components['zerog-bot']) redBot.setAttribute('zerog-bot', 'enabled', false);
            }
            if (blueBot) {
              blueBot.setAttribute('visible', false);
              if (blueBot.components['zerog-bot']) blueBot.setAttribute('zerog-bot', 'enabled', false);
            }
          } else {
            // 1 human player: Show both bots for balanced teams

            if (redBot) {
              redBot.setAttribute('visible', true);
              if (redBot.components['zerog-bot']) redBot.setAttribute('zerog-bot', 'enabled', true);
            }
            if (blueBot) {
              blueBot.setAttribute('visible', true);
              if (blueBot.components['zerog-bot']) blueBot.setAttribute('zerog-bot', 'enabled', true);
            }
          }
        } else {
          // Dodgeball mode: Only show red bot

          if (redBot) {
            redBot.setAttribute('visible', !isMultiplayer || activePlayers.size <= 1);
            if (redBot.components['zerog-bot']) {
              redBot.setAttribute('zerog-bot', 'enabled', !isMultiplayer || activePlayers.size <= 1);
            }
          }
          if (blueBot) {
            blueBot.setAttribute('visible', false);
            if (blueBot.components['zerog-bot']) blueBot.setAttribute('zerog-bot', 'enabled', false);
          }
        }
        
        // Manage ball visibility
        manageBallVisibility();
      }

      // Function to manage ball visibility based on active players
      function manageBallVisibility() {
        const humanPlayerCount = isMultiplayer ? activePlayers.size : 1;
        
        // Always show capture ball in capture mode
        const captureBall = document.querySelector('#capture-ball');
        if (captureBall) {
          captureBall.setAttribute('visible', gameMode === 'capture');
        }
        
        // Manage regular balls (all 4 balls exist, show/hide based on context)
        for (let i = 1; i <= 4; i++) {
          const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
          if (ball) {
            let shouldShow = false;
            
            if (gameMode === 'capture') {
              if (humanPlayerCount >= 2) {
                // 2+ humans: Show all human player balls dynamically
                activePlayers.forEach(playerId => {
                  const playerBallIndex = getBallForPlayer(playerId);
                  if (playerBallIndex === i) {
                    shouldShow = true;
                  }
                });
                // Hide bot balls when 2+ humans (bots don't get added to activePlayers)
              } else {
                // 1 human: Show bot balls and host's ball
                if (i === 1) shouldShow = true; // Red bot ball
                if (i === 2) shouldShow = true; // Host's ball (always ball 2)
                if (i === 3) shouldShow = true; // Blue bot ball
                // Hide ball 4 when only 1 human (no client)
              }
            } else {
              // Dodgeball mode
              if (isMultiplayer) {
                // CRITICAL FIX: Use dynamic ball assignments for each active player
                activePlayers.forEach(playerId => {
                  const playerBallIndex = getBallForPlayer(playerId);
                  if (playerBallIndex === i) {
                    shouldShow = true;
                  }
                });
              } else {
                // Singleplayer: Show red bot ball and human ball only
                if (i === 1 || i === 2) shouldShow = true;
              }
            }
            
            ball.setAttribute('visible', shouldShow);
          }
        }
      }

    </script>
  </body>
</html> 
