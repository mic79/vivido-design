<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Zero-G Environment v2.0 - Dual-Mesh Collision</title>
    <meta name="description" content="Enhanced zero-gravity WebXR environment with 4-player multiplayer support, teams, bot fill-in, and dual-mesh collision system">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js" onload="onScriptLoad('A-Frame')" onerror="debugLog('‚ùå A-Frame failed to load', true)"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js" onload="onScriptLoad('aframe-extras')" onerror="debugLog('‚ùå aframe-extras failed to load', true)"></script>
    <!--<script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.2.3/dist/aframe-physics-system.min.js"></script>-->
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>-->
    <script src="https://kripken.github.io/ammo.js/builds/ammo.js" onload="debugLog('‚úÖ Ammo.js script loaded')" onerror="debugLog('‚ùå Ammo.js failed to load from CDN', true)"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" onload="onScriptLoad('PeerJS')" onerror="debugLog('‚ùå PeerJS failed to load', true)"></script>

    <script src="advanced-bot.js"></script>
    <script src="game-modes.js"></script>
  </head>
  <body>
    <!-- Loading Debug Overlay -->
    <div id="debug-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); color: #00ff00; font-family: monospace; font-size: 14px; padding: 20px; z-index: 99999; overflow-y: auto;">
      <div style="text-align: center; margin-bottom: 20px;">
                  <h2>üîß Debug Loading</h2>
        <div id="loading-progress" style="font-size: 18px; color: #ffff00;">Starting...</div>
      </div>
      <div id="debug-log" style="max-height: 70vh; overflow-y: auto; border: 1px solid #333; padding: 10px; background: rgba(0,0,0,0.5);">
        <div>üöÄ Debug system initialized</div>
      </div>
      <div style="text-align: center; margin-top: 20px;">
        <button onclick="hideDebugOverlay()" style="padding: 10px 20px; background: #006600; color: white; border: none; border-radius: 5px;">Hide Debug & Continue</button>
        <button onclick="location.reload()" style="padding: 10px 20px; background: #cc6600; color: white; border: none; border-radius: 5px; margin-left: 10px;">Reload Page</button>
      </div>
    </div>

    <script>
      // Debug logging system
      let debugStep = 0;
      const debugSteps = [
        'Loading Scripts...',
        'Ammo.js Loading...',
        'Ammo.js Initializing...',
        'Physics World Setup...',
        'A-Frame Scene Loading...',
        'Assets Loading...',
        'Components Initializing...',
        'Ready!'
      ];

      function debugLog(message, isError = false) {
        const log = document.getElementById('debug-log');
        const progress = document.getElementById('loading-progress');
        const timestamp = new Date().toLocaleTimeString();
        const color = isError ? '#ff0000' : '#00ff00';
        
        if (log) {
          log.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
          log.scrollTop = log.scrollHeight;
        }
        
        console.log(`üîß ${message}`);
      }

      function updateProgress(step, details = '') {
        debugStep = Math.max(debugStep, step);
        const progress = document.getElementById('loading-progress');
        if (progress) {
          const percentage = Math.round((step / (debugSteps.length - 1)) * 100);
          progress.textContent = `${debugSteps[step]} (${percentage}%) ${details}`;
        }
        debugLog(`STEP ${step}: ${debugSteps[step]} ${details}`);
      }

      function hideDebugOverlay() {
        const overlay = document.getElementById('debug-overlay');
        if (overlay) {
          overlay.style.display = 'none';
          debugLog('ü´• Debug overlay hidden - if you see A-Frame blue loading screen now, that is the issue');
          console.log('ü´• Debug overlay hidden - watching for A-Frame loading issues...');
        }
      }

      // Monitor A-Frame loading and force completion if stuck
      function monitorAFrameLoading() {
        const scene = document.querySelector('a-scene');
        if (!scene) {
          debugLog('‚ùå No A-Frame scene found', true);
          return;
        }

                 debugLog('üé¨ A-Frame scene found, checking state...');
         debugLog(`üé¨ Scene hasLoaded: ${scene.hasLoaded}`);
         debugLog(`üé¨ Scene is: ${scene.is}`);
         
         // DETAILED ROOT CAUSE ANALYSIS
         debugLog('üîç === ROOT CAUSE ANALYSIS ===');
         
         // Check what components are blocking loading
         analyzeLoadingBlockers(scene);
         
         // Add detailed system info for debugging
         debugLog(`üåê WebXR supported: ${navigator.xr ? 'YES' : 'NO'}`);
         debugLog(`üéÆ VR display: ${navigator.getVRDisplays ? 'Legacy API available' : 'WebXR only'}`);
         
         // Check WebGL context
         const canvas = document.createElement('canvas');
         const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
         debugLog(`üé® WebGL context: ${gl ? 'Available' : 'FAILED'}`);
         if (gl) {
           debugLog(`üé® WebGL renderer: ${gl.getParameter(gl.RENDERER)}`);
           debugLog(`üé® WebGL vendor: ${gl.getParameter(gl.VENDOR)}`);
           
           // Check WebGL limits that might cause issues
           debugLog(`üé® Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
           debugLog(`üé® Max vertex attribs: ${gl.getParameter(gl.MAX_VERTEX_ATTRIBS)}`);
           debugLog(`üé® Max varying vectors: ${gl.getParameter(gl.MAX_VARYING_VECTORS)}`);
         }
        
        // Check if scene is stuck in loading
        let checkCount = 0;
        const maxChecks = 20; // 10 seconds total
        
        const loadingChecker = setInterval(() => {
          checkCount++;
          
          debugLog(`üé¨ Check ${checkCount}/${maxChecks} - Scene hasLoaded: ${scene.hasLoaded}`);
         console.log(`üé¨ A-FRAME CHECK ${checkCount}/${maxChecks} - hasLoaded: ${scene.hasLoaded}`);
         
         // Detailed state logging for all platforms
         debugLog(`üîç Scene.hasLoaded = ${scene.hasLoaded} (${typeof scene.hasLoaded})`);
         debugLog(`üîç Scene.loaded = ${scene.loaded} (${typeof scene.loaded})`);
         debugLog(`üîç Scene.object3D = ${scene.object3D ? 'exists' : 'missing'}`);
         debugLog(`üîç Scene.renderer = ${scene.renderer ? 'exists' : 'missing'}`);
         debugLog(`üîç Scene.renderStarted = ${scene.renderStarted}`);
         
         // Check for VR button
         const vrButton = document.querySelector('[vr-mode-ui]') || document.querySelector('.a-enter-vr-button');
         debugLog(`ü•Ω VR Button found: ${vrButton ? 'YES' : 'NO'}`);
         if (vrButton) {
           debugLog(`ü•Ω VR Button visible: ${vrButton.style.display !== 'none'}`);
         }
          
          if (scene.hasLoaded) {
            clearInterval(loadingChecker);
            debugLog('‚úÖ A-Frame scene loaded successfully');
            return;
          }
          
                     if (checkCount >= maxChecks) {
             clearInterval(loadingChecker);
             debugLog('‚ö†Ô∏è A-Frame scene stuck loading - forcing completion', true);
             console.log('‚ö†Ô∏è A-FRAME STUCK - FORCING COMPLETION');
             
             // Apply loading fixes for all platforms
             forceAFrameLoading();
           }
        }, 500);

                 // Also listen for actual loading events
         scene.addEventListener('loaded', () => {
           clearInterval(loadingChecker);
           debugLog('‚úÖ A-Frame scene loaded (event fired)');
         });

         scene.addEventListener('renderstart', () => {
           debugLog('üé® A-Frame render started');
           
           // Monitor for white screen issue (WebGL context loss)
           setTimeout(() => {
             monitorForWhiteScreen();
           }, 2000);
         });
      }

             function forceAFrameLoading() {
         const scene = document.querySelector('a-scene');
         if (!scene) return;

         debugLog('üö® FORCING A-Frame to complete loading...');

        try {
          // Method 1: Force emit loaded event
          scene.emit('loaded');
          debugLog('üîß Emitted loaded event');

          // Method 2: Force hasLoaded flag
          scene.hasLoaded = true;
          debugLog('üîß Set hasLoaded to true');

          // Method 3: Force remove loading screen
          setTimeout(() => {
            const loadingScreen = document.querySelector('.a-loader-title');
            if (loadingScreen && loadingScreen.parentNode) {
              //loadingScreen.parentNode.style.display = 'none';
              debugLog('üîß Removed A-Frame loading screen');
            }

            // Force remove any other loading elements
            const loaderElements = document.querySelectorAll('[class*="loader"], [class*="loading"]');
            loaderElements.forEach(el => {
              //if (el.style) el.style.display = 'none';
            });

            debugLog('üö® A-Frame force-loading complete');
             
           }, 1000);

         } catch (e) {
           debugLog(`‚ùå Error in force loading: ${e.message}`, true);
         }
       }



              function monitorForWhiteScreen() {
         debugLog('üëÄ Monitoring for white screen issue...');
         
         const scene = document.querySelector('a-scene');
         if (!scene || !scene.renderer) {
           debugLog('‚ùå No renderer found for white screen monitoring - waiting...');
           // Try again in 2 seconds
           setTimeout(monitorForWhiteScreen, 2000);
           return;
         }

         debugLog('‚úÖ Renderer found - starting white screen monitoring');
         
         let whiteScreenCount = 0;
         const maxWhiteScreenChecks = 10;
         
         // Monitor memory usage
         if (navigator.deviceMemory) {
           debugLog(`üíæ Device Memory: ${navigator.deviceMemory}GB`);
         }
         
         if (performance.memory) {
           const memMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
           debugLog(`üíæ JS Heap Used: ${memMB}MB`);
         }
         
         const whiteScreenChecker = setInterval(() => {
           whiteScreenCount++;
           
           try {
             const renderer = scene.renderer;
             const gl = renderer.getContext();
             
             // Check for WebGL context loss (main cause of white screen)
             if (gl.isContextLost()) {
               clearInterval(whiteScreenChecker);
               debugLog('‚ùå WEBGL CONTEXT LOST - This is the white screen cause!', true);
               console.log('‚ùå WEBGL CONTEXT LOST - WHITE SCREEN DETECTED');
               
               // Identify what might have caused context loss
               debugLog('üîç Investigating WebGL context loss cause...');
               investigateContextLoss();
               
               return;
             }

             // Check if canvas is actually rendering
             const canvas = renderer.domElement;
             if (canvas && canvas.width > 0 && canvas.height > 0) {
               debugLog(`‚úÖ Frame ${whiteScreenCount}: Rendering OK - Canvas: ${canvas.width}x${canvas.height}`);
               
               // Monitor memory growth
               if (performance.memory) {
                 const memMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                 debugLog(`üíæ Frame ${whiteScreenCount}: JS Heap: ${memMB}MB`);
                 
                 // Warn if memory is growing rapidly
                 if (memMB > 300) {
                   debugLog(`‚ö†Ô∏è HIGH MEMORY USAGE: ${memMB}MB - may impact performance!`, true);
                 }
               }
               
             } else {
               debugLog('‚ö†Ô∏è Canvas rendering issues detected', true);
             }

           } catch (e) {
             debugLog(`‚ùå White screen monitor error: ${e.message}`, true);
             
             // This error itself might indicate the context loss
             if (e.message.includes('context') || e.message.includes('WebGL')) {
               clearInterval(whiteScreenChecker);
               debugLog('‚ùå WebGL error detected - likely context loss!', true);
               investigateContextLoss();
               return;
             }
           }

           if (whiteScreenCount >= maxWhiteScreenChecks) {
             clearInterval(whiteScreenChecker);
             debugLog('‚úÖ White screen monitoring complete - 10 seconds passed without issues');
           }
         }, 1000);
       }

       function investigateContextLoss() {
         debugLog('üîç === WEBGL CONTEXT LOSS INVESTIGATION ===');
         
         try {
           // Check what might cause context loss
           const ammoPhysicsCount = document.querySelectorAll('[ammo-physics]').length;
           debugLog(`üîç Ammo physics bodies: ${ammoPhysicsCount}`);
           
           const gltfModels = document.querySelectorAll('[gltf-model]').length;
           debugLog(`üîç GLTF models: ${gltfModels}`);
           
           const objModels = document.querySelectorAll('[obj-model]').length;
           debugLog(`üîç OBJ models: ${objModels}`);
           
           // Check for large textures/models
           const scene = document.querySelector('a-scene');
           if (scene && scene.renderer) {
             const gl = scene.renderer.getContext();
             const ext = gl.getExtension('WEBGL_debug_renderer_info');
             if (ext) {
               debugLog(`üîç GPU: ${gl.getParameter(ext.UNMASKED_RENDERER_WEBGL)}`);
             }
           }
           
           debugLog('üîç PROBABLE CAUSES:');
                     debugLog('   1. Triangle mesh collision too complex for GPU');
          debugLog('   2. GLTF model too large for memory');
           debugLog('   3. Too many Ammo.js physics bodies');
           debugLog('   4. WebGL shader compilation failure');
           
           debugLog('üí° SOLUTION: Try disabling collision mesh or GLTF model');
           
         } catch (e) {
           debugLog(`‚ùå Investigation error: ${e.message}`, true);
         }
       }



                   function analyzeLoadingBlockers(scene) {
            debugLog('üîç Analyzing what is blocking A-Frame loading...');
            
            try {
              // Check all components and their loading state
              const entities = scene.querySelectorAll('*');
              let totalEntities = 0;
              let loadedEntities = 0;
              let problematicEntities = [];
              
              entities.forEach(entity => {
                if (entity.hasLoaded !== undefined) {
                  totalEntities++;
                  if (entity.hasLoaded) {
                    loadedEntities++;
                  } else {
                    problematicEntities.push({
                      tagName: entity.tagName,
                      id: entity.id,
                      className: entity.className,
                      components: Object.keys(entity.components || {})
                    });
                  }
                }
              });
              
              debugLog(`üîç Entities: ${loadedEntities}/${totalEntities} loaded`);
              
              if (problematicEntities.length > 0) {
                debugLog(`‚ùå ${problematicEntities.length} entities not loaded:`);
                problematicEntities.slice(0, 5).forEach(entity => {
                  debugLog(`   ‚Ä¢ ${entity.tagName}${entity.id ? '#' + entity.id : ''} - Components: ${entity.components.join(', ')}`);
                });
              }
              
              // Check specific problematic components
              const suspiciousComponents = [
                'ammo-physics',
                'gltf-model', 
                'obj-model',
                'zerog-player',
                'physics-world'
              ];
              
              suspiciousComponents.forEach(componentName => {
                const elements = scene.querySelectorAll(`[${componentName}]`);
                debugLog(`üîç ${componentName}: ${elements.length} instances`);
                
                elements.forEach((el, index) => {
                  const component = el.components[componentName];
                  if (component) {
                    debugLog(`   ‚Ä¢ ${componentName} ${index}: ${component.initialized ? 'initialized' : 'NOT initialized'}`);
                  }
                });
              });
              
              // Check for specific problematic elements
              const collisionMesh = scene.querySelector('#hallway-collision');
              if (collisionMesh) {
                debugLog(`üîç Collision mesh: ${collisionMesh.hasLoaded ? 'loaded' : 'NOT LOADED'} ‚ö†Ô∏è`);
                const objModel = collisionMesh.components['obj-model'];
                if (objModel) {
                  debugLog(`   ‚Ä¢ OBJ model component: ${objModel.initialized ? 'initialized' : 'NOT initialized'}`);
                }
              }
              
              const visualMesh = scene.querySelector('#hallway-visual');
              if (visualMesh) {
                debugLog(`üîç Visual mesh: ${visualMesh.hasLoaded ? 'loaded' : 'NOT LOADED'} ‚ö†Ô∏è`);
                const gltfModel = visualMesh.components['gltf-model'];
                if (gltfModel) {
                  debugLog(`   ‚Ä¢ GLTF model component: ${gltfModel.initialized ? 'initialized' : 'NOT initialized'}`);
                }
              }
              
            } catch (e) {
              debugLog(`‚ùå Error analyzing loading blockers: ${e.message}`, true);
            }
          }

          function createManualVRButton() {
                            debugLog('üîß Creating manual VR button...');
           
           const button = document.createElement('button');
           button.textContent = 'ENTER VR';
           button.style.cssText = `
             position: fixed;
             bottom: 20px;
             right: 20px;
             z-index: 9999;
             background: #0066cc;
             color: white;
             border: none;
             border-radius: 8px;
             padding: 12px 20px;
             font-size: 16px;
             font-weight: bold;
             cursor: pointer;
             box-shadow: 0 4px 8px rgba(0,0,0,0.3);
           `;
           
           button.addEventListener('click', () => {
             debugLog('ü•Ω Manual VR button clicked');
             const scene = document.querySelector('a-scene');
             if (scene && scene.enterVR) {
               scene.enterVR();
               debugLog('‚úÖ Attempted to enter VR manually');
             } else {
               debugLog('‚ùå Scene.enterVR not available');
             }
           });
           
           document.body.appendChild(button);
           debugLog('‚úÖ Manual VR button created');
         }

        // Start debugging
      updateProgress(0);
      debugLog('üîß Debug System Active');
      debugLog(`üåê User Agent: ${navigator.userAgent}`);
      debugLog(`üíæ Memory: ${navigator.deviceMemory || 'unknown'}GB`);
      debugLog(`üîó WebAssembly Support: ${typeof WebAssembly !== 'undefined' ? 'YES' : 'NO'}`);

      // Track script loading
      let scriptsLoaded = 0;
      const totalScripts = 4; // A-Frame, aframe-extras, Ammo.js, PeerJS

      function onScriptLoad(scriptName) {
        scriptsLoaded++;
        debugLog(`‚úÖ ${scriptName} loaded (${scriptsLoaded}/${totalScripts})`);
        if (scriptsLoaded >= totalScripts) {
          updateProgress(1, '- All scripts loaded');
        }
      }

      // Global error handler for debugging
      window.addEventListener('error', (event) => {
        debugLog(`‚ùå ERROR: ${event.error?.message || event.message}`, true);
        debugLog(`üìÅ File: ${event.filename}:${event.lineno}`, true);
        if (event.error?.stack) {
          debugLog(`üìö Stack: ${event.error.stack.substring(0, 200)}...`, true);
        }
      });

      // Track unhandled promise rejections
      window.addEventListener('unhandledrejection', (event) => {
        debugLog(`‚ùå PROMISE REJECTION: ${event.reason}`, true);
      });

      // Monitor Ammo.js loading specifically - but don't interfere with normal loading
      let ammoCheckInterval = setInterval(() => {
        if (typeof Ammo !== 'undefined') {
          clearInterval(ammoCheckInterval);
          updateProgress(2, '- Ammo.js available');
          onScriptLoad('Ammo.js');
        }
      }, 500); // Check less frequently to avoid interference

      // Timeout for Ammo.js loading
      setTimeout(() => {
        if (typeof Ammo === 'undefined') {
          debugLog('‚ùå TIMEOUT: Ammo.js failed to load after 30 seconds', true);
          debugLog('üîó CDN may be blocked or slow', true);
          debugLog('üí° SOLUTION: Try downloading ammo.js locally', true);
        }
      }, 30000);

      // Universal system checks
      debugLog('üñ•Ô∏è Checking system capabilities...');
      
      // Monitor memory usage if available
      if (navigator.deviceMemory) {
        debugLog(`üíæ Device Memory: ${navigator.deviceMemory}GB`);
      }

      // Check for WebGL capabilities
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
      if (gl) {
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        debugLog(`üé® Max Texture Size: ${maxTextureSize}px`);
        debugLog(`üé® Max Renderbuffer Size: ${gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)}`);
        debugLog(`üé® Max Vertex Uniforms: ${gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)}`);
        debugLog(`üé® Max Fragment Uniforms: ${gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)}`);
        
        // Check for extensions
        const extensions = gl.getSupportedExtensions();
        debugLog(`üé® WebGL Extensions: ${extensions ? extensions.length : 0} available`);
        
        // Test for capabilities
        const hasFloatTextures = gl.getExtension('OES_texture_float');
        debugLog(`üé® Float Textures: ${hasFloatTextures ? 'YES' : 'NO'}`);
        
        const hasInstancedArrays = gl.getExtension('ANGLE_instanced_arrays');
        debugLog(`üé® Instanced Arrays: ${hasInstancedArrays ? 'YES' : 'NO'}`);
      }

      // Global error handler to suppress Meta Touch Controls and physics errors
      window.addEventListener('error', (event) => {
        if (event.error && event.error.message && 
            (event.error.message.includes('thumbstick') || 
             event.error.message.includes('Cannot read properties of undefined') ||
             event.error.message.includes("reading 'x'") ||
             event.error.message.includes("reading 'y'") ||
             event.error.message.includes("reading 'z'") ||
             event.error.message.includes("reading 'body'") ||
             event.error.message.includes('three.core.js') ||
             event.error.message.includes('meta-touch-controls'))) {
          // Suppress Meta Touch Controls, physics and related errors
          console.log('üîï Suppressed error:', event.error.message.substring(0, 100));
          event.preventDefault();
          return false;
        }
      });

      // Additional console.error suppression for physics errors
      const originalConsoleError = console.error;
      console.error = function(...args) {
        const message = args.join(' ');
        if (message.includes('Cannot read properties of undefined') && 
            (message.includes("reading 'x'") || message.includes("reading 'y'") || message.includes("reading 'z'") || message.includes("reading 'body'"))) {
          console.log('üîï Suppressed console error:', message.substring(0, 100));
          return;
        }
        originalConsoleError.apply(console, args);
      };

      // Ammo.js physics world for dual-mesh collision (from aframe-ammo-working.html)
      let physicsWorld;
      let ammoInstance;
      let physicsBodies = [];
      let physicsObjects = [];
      let tempTransform;

      // Initialize Ammo.js physics world (exactly like aframe-ammo-working.html)
      function initAmmoPhysics() {
        if (typeof Ammo === 'undefined') {
          debugLog('‚ùå Ammo.js not loaded! Waiting longer...', true);
          // Don't retry immediately - give it more time
          setTimeout(initAmmoPhysics, 3000);
          return false;
        }

        debugLog('üîß Ammo.js found, initializing...');
        updateProgress(3, '- Starting Ammo() call...');

        Ammo().then((Ammo) => {
          debugLog('‚úÖ Ammo() promise resolved successfully');
          ammoInstance = Ammo;
          updateProgress(4, '- Ammo instance created');
          
          debugLog('üèóÔ∏è Setting up physics world...');
          setupAmmoPhysicsWorld(Ammo);
          
          // Initialize temp transform for updates
          tempTransform = new Ammo.btTransform();
          debugLog('‚úÖ Transform initialized');
          
          // Start physics update loop
          updateAmmoPhysics();
          debugLog('‚úÖ Physics update loop started');
          
          updateProgress(5, '- Physics world ready');
          debugLog('üéØ Ammo.js physics world ready for dual-mesh collision!');
        }).catch((error) => {
          debugLog(`‚ùå Failed to initialize Ammo.js: ${error}`, true);
          debugLog('üîÑ Retrying in 2 seconds...');
          setTimeout(initAmmoPhysics, 2000);
        });

        return true;
      }

      // Setup Ammo.js physics world (from aframe-ammo-working.html)
      function setupAmmoPhysicsWorld(Ammo) {
        let collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
        let dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
        let overlappingPairCache = new Ammo.btDbvtBroadphase();
        let solver = new Ammo.btSequentialImpulseConstraintSolver();

        physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
        physicsWorld.setGravity(new Ammo.btVector3(0, 0, 0)); // Zero gravity to match Cannon.js
        
        console.log('‚úÖ Ammo.js physics world created for dual-mesh collision');
      }

      // Physics simulation loop for Ammo.js (from aframe-ammo-working.html)
      let clock = new THREE.Clock();
      
      function updateAmmoPhysics() {
        if (!physicsWorld || !ammoInstance) {
          requestAnimationFrame(updateAmmoPhysics);
          return;
        }

        const delta = clock.getDelta();
        
        // Step physics simulation
        physicsWorld.stepSimulation(delta, 10);
        
        // Wake up all physics objects to ensure they respond to forces
        physicsObjects.forEach(obj => {
          if (obj.body && obj.body.activate) {
            obj.body.activate();
          }
        });

        // Update A-Frame entities based on Ammo bodies (if any)
        physicsObjects.forEach(obj => {
          if (!obj || !obj.body) return; // Safety check
          
          // Skip player body - it's handled manually in the VR movement component
          if (obj.isPlayer) {
            return; // Player physics are handled separately
          }
          
          // Handle normal objects (balls, etc.)
          if (obj.object3D && obj.entity) {
            try {
              // Skip grabbed balls - they're positioned manually
              const ballComponent = obj.entity.components && obj.entity.components['zerog-ball'];
              if (ballComponent && ballComponent.isGrabbed) {
                return; // Don't sync physics for grabbed balls
              }
              
              let ammoObject = obj.body;
              let ms = ammoObject.getMotionState();

              if (ms) {
                ms.getWorldTransform(tempTransform);
                let pos = tempTransform.getOrigin();
                let quat = tempTransform.getRotation();
                
                // Safety checks for valid transform data
                if (pos && typeof pos.x === 'function' && quat && typeof quat.x === 'function') {
                  obj.object3D.position.set(pos.x(), pos.y(), pos.z());
                  obj.object3D.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
                }
              }
            } catch (e) {
              // Silently handle any errors in physics sync
            }
          }
        });

        requestAnimationFrame(updateAmmoPhysics);
      }

      // Enhanced Multiplayer state for 4-player support
      let isMultiplayer = false;
      let isHost = false;
      let peer = null;
      let connections = new Map(); // playerId -> connection (for star topology)
      let multiplayerSlot = null;
      let multiplayerStatus = 'Singleplayer';
      let hasConnected = false;
      const MAX_LOBBIES = 10;
      let multiplayerStartType = 'zerog';
      let sessionID = null;
      let connectionState = 'disconnected';

      let remotePlayerStates = new Map(); // playerId -> state
      let remoteBallStates = new Map(); // playerId -> ballState
      let multiplayerCleanup = null;
      let isSearchingForMatch = false;

      // Enhanced game configuration
      let gameConfig = {
        mode: 'singleplayer', // 'singleplayer', 'multiplayer'
        playStyle: 'solo', // 'solo', 'teams'
        playerCount: 2, // 2 or 4
        botFillEnabled: true, // Fill empty slots with bots
        botReplaceEnabled: true // Replace disconnected players with bots
      };

      // Player management for 4-player support
      let players = new Map(); // playerId -> playerData
      let playerColors = ['#0099ff', '#ff4444', '#00ff00', '#ffff00']; // Blue, Red, Green, Yellow
      let playerNames = ['Player 1', 'Player 2', 'Player 3', 'Player 4'];
      let activePlayers = new Set(); // Currently active player IDs
      let botPlayers = new Set(); // Bot-controlled player IDs

      // Enhanced score tracking
      let multiplayerScore = new Map(); // playerId -> score
      let teamScores = { team1: 0, team2: 0 }; // For team play
      let multiplayerReady = new Map(); // playerId -> ready state

      // Menu state tracking
      let isMenuVisible = false;

      // Helper: check if menu is currently visible
      function getMenuVisibility() {
        return isMenuVisible;
      }

      // Helper: update HUD status display
      function updateMultiplayerStatus(text) {
        const hudStatus = document.getElementById('hud-status');
        if (hudStatus) {
          hudStatus.setAttribute('text', 'value', text);
        }
      }

      // Helper: update player count display for 4-player mode
      function updatePlayerCountDisplay() {
        if (gameConfig.playerCount === 4 && isMultiplayer) {
          if (isHost) {
            // Host: send update to all clients
            sendPlayerCountUpdate();
          }
          // Clients: do nothing, they only update on player-count-update from host
        }
      }

      // Helper: check if multiplayer is connected
      function isMultiplayerConnected() {
        if (!isMultiplayer) return false;
        
        if (gameConfig.playerCount === 2) {
          // 2-player mode: check for any connection
          return connections.size > 0 && Array.from(connections.values()).some(conn => conn && conn.open);
        } else {
          // 4-player mode: check host connection for clients, or any connection for host
          if (isHost) {
            return Array.from(connections.values()).some(conn => conn && conn.open);
          } else {
            const hostConn = connections.get('host');
            return hostConn && hostConn.open;
          }
        }
      }

      // Helper: get local player ID for clients
      function getLocalPlayerId() {
        // Find which player slot this client is assigned to
        for (const [playerId, player] of players) {
          if (player.isConnected && !player.isBot && playerId !== 'player_0') {
            return playerId;
          }
        }
        return null;
      }

      // Helper: send data to appropriate connections
      function sendToMultiplayer(data) {
        if (!isMultiplayer) return;
        
        if (gameConfig.playerCount === 2) {
          // 2-player mode: send to the one other player
          connections.forEach(connection => {
            if (connection && connection.open) {
              connection.send(data);
            }
          });
        } else {
          // 4-player mode: 
          if (isHost) {
            // Host sends to all clients
            connections.forEach(connection => {
              if (connection && connection.open) {
                connection.send(data);
              }
            });
          } else {
            // Client sends only to host
            const hostConn = connections.get('host');
            if (hostConn && hostConn.open) {
              hostConn.send(data);
            }
          }
        }
      }

      // Player slot configuration for 4-player mode
      const playerSlots = {
        0: { id: 'player_0', name: 'Host', color: '#ff0000', entityId: null, isHost: true },      // Red - Host (no entity, local player)
        1: { id: 'player_1', name: 'Client 1', color: '#0000ff', entityId: 'player-1', isHost: false }, // Blue
        2: { id: 'player_2', name: 'Client 2', color: '#00ff00', entityId: 'player-2', isHost: false }, // Green  
        3: { id: 'player_3', name: 'Client 3', color: '#ffff00', entityId: 'player-3', isHost: false }  // Yellow
      };

      // Initialize players for multiplayer
      function initializePlayers() {
        players.clear();
        multiplayerScore.clear();
        multiplayerReady.clear();
        
        for (let i = 0; i < gameConfig.playerCount; i++) {
          const slot = playerSlots[i];
          const playerId = slot.id;
          players.set(playerId, {
            id: playerId,
            slotNumber: i,
            name: slot.name,
            color: slot.color,
            entityId: slot.entityId,
            isBot: false,
            isConnected: i === 0, // Host is always connected initially
            position: { x: 0, y: 2, z: 0 },
            team: gameConfig.playStyle === 'teams' ? (i < 2 ? 'team1' : 'team2') : null
          });
          multiplayerScore.set(playerId, 0);
          multiplayerReady.set(playerId, false);
        }
        
        // Local player is always slot 0 (host)
        activePlayers.add('player_0');
        
        // Apply colors to player entities and balls
        applyPlayerColors();
        
        console.log('Players initialized with slot system:', Array.from(players.entries()));
      }

      // Apply slot-based colors to player entities and balls
      function applyPlayerColors() {
        for (let i = 0; i < gameConfig.playerCount; i++) {
          const slot = playerSlots[i];
          
          // Apply color to player entity (if it exists)
          if (slot.entityId) {
            const playerEntity = document.querySelector(`#${slot.entityId}`);
            if (playerEntity) {
              const targetSphere = playerEntity.querySelector('a-sphere');
              if (targetSphere) {
                targetSphere.setAttribute('color', slot.color);
                targetSphere.setAttribute('material', `color: ${slot.color}; opacity: 0.8`);
                console.log(`üé® Applied color ${slot.color} to ${slot.entityId}`);
              }
            }
          }
          
          // Apply color to ball (now all 4 balls exist)
          const ballSelectors = [
            '[zerog-ball="player: player1"]',
            '[zerog-ball="player: player2"]', 
            '[zerog-ball="player: player3"]',
            '[zerog-ball="player: player4"]'
          ];
          
          if (i < 4) {
            const ballSelector = ballSelectors[i];
            const ball = document.querySelector(ballSelector);
            if (ball) {
              ball.setAttribute('color', slot.color);
              ball.setAttribute('material', `color: ${slot.color}`);
              
              // Also apply to the light
              const light = ball.querySelector('[light]');
              if (light) {
                light.setAttribute('light', `color: ${slot.color}`);
              }
              
              console.log(`‚öΩ Applied color ${slot.color} to ball ${i} (${slot.name})`);
            }
          }
        }
      }

      // Fill remaining slots with bots after real players have joined
      function fillRemainingSlotsWithBots() {
        console.log('ü§ñ Filling remaining slots with bots');
        
        for (let i = 1; i < gameConfig.playerCount; i++) {
          const playerId = `player_${i}`;
          const player = players.get(playerId);
          if (player && !player.isConnected && !player.isBot) {
            player.isBot = true;
            botPlayers.add(playerId);
            activePlayers.add(playerId);
            multiplayerReady.set(playerId, true); // Bots are always ready
            console.log(`Bot added to remaining slot ${i} as ${playerId}`);
          }
        }
        
        console.log('ü§ñ After filling remaining slots. Active players:', Array.from(activePlayers));
        console.log('ü§ñ Bot players:', Array.from(botPlayers));
      }

      // Start singleplayer game
      function startSingleplayerGame() {
        console.log('üéÆ Starting singleplayer game');
        
        // Reset multiplayer state
        isMultiplayer = false;
        activePlayers.clear();
        botPlayers.clear();
        
        // Set up singleplayer: Player (blue ball) + Bot (red ball)
        activePlayers.add('player_0'); // Host (you) - blue ball (player2 entity)
        activePlayers.add('player_1'); // Bot - red ball (player1 entity)
        botPlayers.add('player_1');    // Mark player_1 as bot
        
        console.log('üéÆ Singleplayer setup: You (blue ball) vs Bot (red ball)');
        console.log('üîµ Player (You): Blue ball (player2)');
        console.log('üî¥ Bot: Red ball (player1)');
        
        // Enable bot entity
        const bot = document.querySelector('#zerog-bot');
        if (bot && bot.components['zerog-bot']) {
          bot.setAttribute('zerog-bot', 'enabled', true);
        }
        
        // Make sure both balls are visible and active
        const redBall = document.querySelector('[zerog-ball="player: player1"]'); // Bot's red ball
        const blueBall = document.querySelector('[zerog-ball="player: player2"]'); // Your blue ball
        
        if (redBall) {
          redBall.setAttribute('visible', true);
          console.log('üî¥ Red ball (bot) made visible');
        }
        if (blueBall) {
          blueBall.setAttribute('visible', true);
          console.log('üîµ Blue ball (player) made visible');
        }
        
        // Initialize game manager
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].resetMatch();
        }
        
        updateMultiplayerStatus('Singleplayer');
      }

      // Enhanced multiplayer connection for star topology
      function startMultiplayerConnection() {
        console.log('üåê Starting multiplayer connection with config:', gameConfig);
        
        // Initialize players
        initializePlayers();
        console.log('üë• Players initialized. Active players:', Array.from(activePlayers));
        console.log('ü§ñ Bot players:', Array.from(botPlayers));
        
        // Don't fill bots immediately in multiplayer - wait for real players first
        // Bots will be filled later when the game actually starts
        console.log('ü§ñ Bot fill deferred - waiting for real players to join first');
        
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        
        // Start connection based on player count
        if (gameConfig.playerCount === 2) {
          startTwoPlayerConnection();
        } else {
          startFourPlayerConnection();
        }
      }

      // Fill empty slots with bots (but don't fill slots that real players might join)
      function fillEmptySlotsWithBots() {
        console.log('ü§ñ Filling empty slots with bots');
        
        // Only fill slots if we're not in a multiplayer lobby where real players might join
        // For now, we'll only fill bots in singleplayer mode or when explicitly requested
        if (!isMultiplayer) {
          for (let i = 1; i < gameConfig.playerCount; i++) {
            const playerId = `player_${i}`;
            const player = players.get(playerId);
            if (player && !player.isConnected) {
              player.isBot = true;
              botPlayers.add(playerId);
              activePlayers.add(playerId);
              multiplayerReady.set(playerId, true); // Bots are always ready
              console.log(`Bot added as ${playerId}`);
            }
          }
        } else {
          console.log('ü§ñ Skipping bot fill - in multiplayer mode, waiting for real players');
        }
      }

      // Start 2-player connection (original logic)
      async function startTwoPlayerConnection() {
        try {
          const slot = await findAvailableSlot(multiplayerStartType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupTwoPlayerHost(multiplayerSlot);
          } else {
            await setupTwoPlayerPeer(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      // Start 4-player connection (new star topology)
      async function startFourPlayerConnection() {
        try {
          const slot = await findAvailableSlot(multiplayerStartType + '_4p');
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupFourPlayerHost(multiplayerSlot);
          } else {
            await setupFourPlayerClient(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      // Update HUD score display
      function updateHUDScore(playerScore, opponentScore, isMultiplayer = false) {
        const hudScore = document.querySelector('#hud-score');
        
        if (hudScore) {
          const playerScoreEl = hudScore.children[0];
          const opponentScoreEl = hudScore.children[1];
          
          if (playerScoreEl && opponentScoreEl) {
            const opponentLabel = isMultiplayer ? 'Opponent' : 'Bot';
            playerScoreEl.setAttribute('text', 'value', `You: ${playerScore}`);
            opponentScoreEl.setAttribute('text', 'value', `${opponentLabel}: ${opponentScore}`);
            console.log('üì± HUD updated - You:', playerScore, opponentLabel + ':', opponentScore, '(visible:', hudScore.getAttribute('visible') + ')');
          }
        } else {
          console.log('üì± ERROR: #hud-score element not found');
        }
      }

      // Show/hide HUD elements during gameplay
function setGameplayHUD(isPlaying) {
  // Don't change HUD visibility if menu is open
  if (isMenuVisible) {
    console.log('üö´ HUD update blocked - menu is open');
    return;
  }
  
  const hudStatus = document.querySelector('#hud-status');
  const hudScore = document.querySelector('#hud-score');
  const hudTimer = document.querySelector('#hud-timer');
  const hudMessage = document.querySelector('#hud-message');
  
  if (hudStatus) {
    hudStatus.setAttribute('visible', !isPlaying);
  }
  if (hudScore) {
    // Only show score during active matches (not just when gameplay is enabled)
    const gameManager = document.querySelector('#game-manager');
    const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                         gameManager.components['game-manager'].gameStarted;
    hudScore.setAttribute('visible', isPlaying && isMatchActive);
  }
  if (hudTimer) {
    // Only show timer during active matches (not just when gameplay is enabled)
    const gameManager = document.querySelector('#game-manager');
    const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                         gameManager.components['game-manager'].gameStarted;
    hudTimer.setAttribute('visible', isPlaying && isMatchActive);
  }
  if (hudMessage) {
    // Show "Press A to Start" when not playing, hide during active gameplay
    if (isPlaying) {
      hudMessage.setAttribute('visible', false); // Hide during active gameplay
    } else {
      hudMessage.setAttribute('visible', true); // Show in default state
      hudMessage.setAttribute('text', 'value', 'Press A to Start');
    }
  }
  
  console.log('HUD updated:', {
    playing: isPlaying,
    status: !isPlaying ? 'VISIBLE' : 'HIDDEN',
    score: isPlaying ? 'CONDITIONAL' : 'HIDDEN',
    timer: isPlaying ? 'CONDITIONAL' : 'HIDDEN',
    message: !isPlaying ? 'VISIBLE (Press A to Start)' : 'HIDDEN'
  });
}

      // Materials moved to Ammo.js - using collision filtering instead

      // Zero-G Player Controller - Physics-based movement
      AFRAME.registerComponent('zerog-player', {
        schema: {
          mass: { type: 'number', default: 70 }, // kg
          linearDamping: { type: 'number', default: 0.05 },
          angularDamping: { type: 'number', default: 0.1 },
          thrusterForce: { type: 'number', default: 2.0 },
          maxSpeed: { type: 'number', default: 8 },
          rotationSpeed: { type: 'number', default: 2 }
        },

        init: function() {
          console.log('üöÄ Zero-G Player Controller initialized (Option B: Visual Collision System)');
          
          // Initialize ALL state first - MUST be before any event listeners
          this.hands = {
            left: {
              physicsBody: null,
              physicsWireframe: null,
              grabRangeWireframe: null,
              isGrabbing: false,
              nearbyObject: null,
              gripHeld: false,
              grabbedSurface: null,
              grabInfo: null,
              thrusterActive: false,
              isBraking: false
            },
            right: {
              physicsBody: null,
              physicsWireframe: null,
              grabRangeWireframe: null,
              isGrabbing: false,
              nearbyObject: null,
              gripHeld: false,
              grabbedSurface: null,
              grabInfo: null,
              thrusterActive: false,
              isBraking: false
            }
          };
          
          // Option B: No physics body - use visual collision detection instead
          
          // Create collision visualization (this IS our collision system now)
          this.createCollisionVisualization();
          
          // Option B: Custom physics simulation state
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.angularVelocity = new THREE.Vector3(0, 0, 0);
          this.lastPosition = new THREE.Vector3(0, 0, 0);
          this.collisionMargin = 0.02; // 2cm safety margin
          this.damping = 0.996; // 0.4% velocity loss per frame (much gentler)
          this.minVelocity = 0.01; // Stop very slow movement
          
          // Rotation state
          this.rotationY = 0;
          this.thumbstickRotation = { left: 0, right: 0 };
          
          // Braking force
          this.brakingForce = 0.9; // Stronger braking for immediate effect
          
          // Get hand references
          this.leftHand = null;
          this.rightHand = null;
          this.rig = null;
          
          // Debug mode (for optional console output)
          this.debugMode = this.data.debug || false;
          
          // Wait for scene to load to get hand references
          this.el.sceneEl.addEventListener('loaded', () => {
            this.leftHand = document.querySelector('#leftHand');
            this.rightHand = document.querySelector('#rightHand');
            this.rig = document.querySelector('#rig');
            
            console.log('üéØ Zero-G player initialized with Ammo.js physics:');
            console.log(`   ‚Ä¢ Left hand: ${this.leftHand ? 'Found' : 'NOT FOUND'}`);
            console.log(`   ‚Ä¢ Right hand: ${this.rightHand ? 'Found' : 'NOT FOUND'}`);
            console.log(`   ‚Ä¢ Rig: ${this.rig ? 'Found' : 'NOT FOUND'}`);
            console.log(`   ‚Ä¢ Physics body: Ammo.js kinematic capsule (0.3m radius, 1.6m height)`);
            console.log(`   ‚Ä¢ Collision: Triangle mesh environment (scale 1.0, optimized)`);
            console.log(`   ‚Ä¢ Surface grabbing: DISABLED for performance`);
            console.log(`   ‚Ä¢ Ball grabbing: ENABLED (player2 ball only)`);
            
            this.setupHandEvents();
            
            // Create Ammo.js physics body for player collision with triangle mesh
            this.createPlayerPhysicsBody();
            
            // Create physics bodies and visualizations for hands
            this.createHandPhysicsBodies();
            
            // Add keyboard listener for toggling collision visualization
            this.keydownListener = (evt) => {
              if (evt.key === 'c' || evt.key === 'C') {
                this.toggleCollisionVisualization();
              } else if (evt.key === 'r' || evt.key === 'R') {
                // R key to reposition player physics body
                this.repositionPlayerPhysicsBody();
                console.log('üéØ Press R to reposition player physics body to current camera location');
              }
            };
            document.addEventListener('keydown', this.keydownListener);

          });
        },
        
        setupHandEvents: function() {
          // Grip controls for grabbing surfaces AND balls (EchoVR style)
          this.el.sceneEl.addEventListener('gripdown', (evt) => {
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            // Track grip state for continuous ball grabbing
            this.hands[handKey].gripHeld = true;
            
            // Try to grab balls first (priority), then static surfaces (original logic)
            console.log(`Grip down: ${handKey} hand - trying to grab ball`);
            this.tryGrabBall(hand);
            
            // If no ball was grabbed, try static surfaces (but surfaces are disabled for performance)
            if (!this.hands[handKey].isGrabbing) {
              console.log(`Grip down: ${handKey} hand - no ball grabbed, surfaces disabled`);
            }
          });
          
          this.el.sceneEl.addEventListener('gripup', (evt) => {
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            // Track grip state
            this.hands[handKey].gripHeld = false;
            
            // Release whatever is being grabbed (ball or surface)
            if (this.hands[handKey].isGrabbing) {
              this.releaseGrabbedBall(hand);
            }
          });
          
          // Trigger controls for thrusters ONLY when menu is not visible
          this.el.sceneEl.addEventListener('triggerdown', (evt) => {
            if (getMenuVisibility()) {
              console.log('üö´ Thruster blocked - menu is open');
              return; // Don't activate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, true);
          });
          
          this.el.sceneEl.addEventListener('triggerup', (evt) => {
            if (getMenuVisibility()) {
              return; // Don't deactivate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, false);
          });
          
          // X button for shooting balls
          this.el.sceneEl.addEventListener('xbuttondown', (evt) => {
            if (getMenuVisibility()) {
              console.log('üö´ Ball shooting blocked - menu is open');
              return; // Don't shoot when menu is visible
            }
            console.log('X button: Shooting ball from camera');
            this.shootBallFromCamera();
          });
          
          // Y button for debug overlay toggle (with debouncing)
          let lastYButtonPress = 0;
          this.el.sceneEl.addEventListener('ybuttondown', (evt) => {
            const now = Date.now();
            if (now - lastYButtonPress < 500) { // 500ms debounce
              console.log('üö´ Y button: Ignoring rapid double-press');
              return;
            }
            lastYButtonPress = now;
            
            console.log('Y button: Toggling debug overlay');
            const debugOverlay = document.getElementById('debug-overlay');
            if (debugOverlay) {
              const isHidden = debugOverlay.style.display === 'none' || !debugOverlay.style.display;
              if (isHidden) {
                debugOverlay.style.display = 'block';
                console.log('üêõ Debug overlay SHOWN via Y button');
              } else {
                hideDebugOverlay();
                console.log('üêõ Debug overlay HIDDEN via Y button');
              }
            }
          });
          
          // Thumbstick controls for rotation
          this.el.sceneEl.addEventListener('thumbstickmoved', (evt) => {
            // Safety checks to prevent meta-touch-controls errors
            if (!evt || !evt.target || !evt.detail) {
              return; // Skip silently
            }
            const hand = evt.target;
            this.handleThumbstick(hand, evt.detail);
          });
          
          // B button assigned to menu toggle (see menu-toggle component)
          
          // Thumbstick click for braking (Echo VR style)
          this.el.sceneEl.addEventListener('thumbstickdown', (evt) => {
            const hand = evt.target;
            this.startBraking(hand);
          });
          
          this.el.sceneEl.addEventListener('thumbstickup', (evt) => {
            const hand = evt.target;
            this.stopBraking(hand);
          });
        },
        
        // Debug arrows removed - not useful for this system
        
        handleThumbstick: function(hand, detail) {
          // Safety checks to prevent errors
          if (!hand || !hand.id || !detail || typeof detail.x === 'undefined') {
            return; // Skip silently to avoid spam
          }
          
          const isLeft = hand.id === 'leftHand';
          
          // Use right thumbstick for rotation (common VR convention)
          // Flip the direction to match expected behavior
          if (!isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.right = -detail.x;
            if (this.debugMode) {
              console.log(`üéÆ Right thumbstick: ${detail.x.toFixed(2)} ‚Üí rotation: ${this.thumbstickRotation.right.toFixed(2)}`);
            }
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
          
          // Left thumbstick could be used for other things in the future
          if (isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.left = -detail.x;
            if (this.debugMode) {
              console.log(`üéÆ Left thumbstick: ${detail.x.toFixed(2)} ‚Üí rotation: ${this.thumbstickRotation.left.toFixed(2)}`);
            }
          } else if (isLeft) {
            this.thumbstickRotation.left = 0;
          }
        },
        
        handleGrab: function(hand, isDown) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          if (isDown) {
            // Surface grabbing disabled for performance
            return;
          } else {
            // RELEASE: Always allow releasing whatever is grabbed
            if (this.hands[handKey].isGrabbing) {
              this.releaseFromSurface(hand);
              this.hands[handKey].grabbedSurface = null;
              this.hands[handKey].isGrabbing = false;
            }
          }
        },
        
        handleThruster: function(hand, isActive) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          this.hands[handKey].thrusterActive = isActive;
          
          if (isActive) {
            // Visual thruster effect
            this.showThrusterEffect(hand);
          } else {
            this.hideThrusterEffect(hand);
          }
        },
        
        findNearestGrabbableSurface: function(hand) {
          // DISABLED: 3D model grabbing disabled for performance
          return null;
        },

        getDistanceToTriangleMesh: function(handPos) {
          // DISABLED: Triangle mesh distance calculation disabled for performance
          // Use Ammo.js collision detection instead of expensive raycasting
          return 0.12; // Return max distance to disable surface grabbing
        },
        
        getDistanceToSurface: function(handPos, handRadius, element) {
          const elementPos = new THREE.Vector3();
          element.object3D.getWorldPosition(elementPos);
          const geometry = element.getAttribute('geometry');
          
          if (!geometry) {
            // Fallback to simple distance for elements without geometry
            return handPos.distanceTo(elementPos) - handRadius;
          }
          
          // Check collision based on geometry type
          if (geometry.primitive === 'box') {
            return this.distanceToBox(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'sphere') {
            return this.distanceToSphere(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'cylinder') {
            return this.distanceToCylinder(handPos, handRadius, elementPos, geometry);
          } else {
            // Fallback
            return handPos.distanceTo(elementPos) - handRadius;
          }
        },
        
        distanceToBox: function(handPos, handRadius, boxPos, geometry) {
          // Calculate distance from hand sphere to box surface
          const halfWidth = geometry.width / 2;
          const halfHeight = geometry.height / 2;
          const halfDepth = geometry.depth / 2;
          
          // Get relative position of hand to box center
          const relativePos = new THREE.Vector3().subVectors(handPos, boxPos);
          
          // Calculate closest point on box to hand
          const closestPoint = new THREE.Vector3(
            Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
            Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
            Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
          );
          
          // Distance from hand to closest point on box surface
          const distance = relativePos.distanceTo(closestPoint);
          
          // Subtract hand radius to get surface distance
          return Math.max(0, distance - handRadius);
        },
        
        distanceToSphere: function(handPos, handRadius, spherePos, geometry) {
          const sphereRadius = geometry.radius;
          const centerDistance = handPos.distanceTo(spherePos);
          
          // Distance to sphere surface minus hand radius
          return Math.max(0, centerDistance - sphereRadius - handRadius);
        },
        
        distanceToCylinder: function(handPos, handRadius, cylinderPos, geometry) {
          const cylinderRadius = geometry.radius;
          const cylinderHeight = geometry.height;
          
          // Get relative position
          const relativePos = new THREE.Vector3().subVectors(handPos, cylinderPos);
          
          // Distance to cylinder axis (ignoring Y)
          const radialDistance = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
          
          // Clamp Y to cylinder height
          const clampedY = Math.max(-cylinderHeight/2, Math.min(cylinderHeight/2, relativePos.y));
          
          // Calculate distance to cylinder surface
          let distance;
          if (Math.abs(relativePos.y) <= cylinderHeight/2) {
            // Hand is within cylinder height, check radial distance
            distance = Math.max(0, radialDistance - cylinderRadius);
          } else {
            // Hand is above/below cylinder, check distance to circular ends
            const endDistance = Math.abs(relativePos.y) - cylinderHeight/2;
            if (radialDistance <= cylinderRadius) {
              distance = endDistance;
            } else {
              distance = Math.sqrt(endDistance * endDistance + Math.pow(radialDistance - cylinderRadius, 2));
            }
          }
          
          // Subtract hand radius
          return Math.max(0, distance - handRadius);
        },
        
                attachToSurface: function(hand, surface) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          
          const surfacePos = new THREE.Vector3();
          surface.object3D.getWorldPosition(surfacePos);
          
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Check if this is a ball and handle differently
          if (surface.hasAttribute('zerog-ball') && surface.components['zerog-ball']) {
            // For balls, call the ball's onGrab method
            surface.components['zerog-ball'].onGrab(hand);
            
            this.hands[handKey].grabInfo = {
              surface: surface,
              isBall: true,
              initialHandPos: handPos.clone(),
              lastHandPos: handPos.clone()
            };
          }
          
          // Set grabbing flag
          this.hands[handKey].isGrabbing = true;
        },
        
        releaseFromSurface: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabInfo = this.hands[handKey].grabInfo;
          if (grabInfo) {
            // If releasing a ball, call the ball's onRelease method
            if (grabInfo.isBall && grabInfo.surface.components['zerog-ball']) {
              grabInfo.surface.components['zerog-ball'].onRelease();
            }
          }
          
          // Clear grab info
          this.hands[handKey].grabInfo = null;
          this.hands[handKey].isGrabbing = false;
          this.hands[handKey].grabbedSurface = null;
        },
        
        showThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', true);
            thrusterVFX.setAttribute('material', 'opacity', 0.8);
          }
        },
        
        hideThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', false);
          }
        },
        
        // Debug arrow functions removed - not useful for this system
        
        playHapticFeedback: function(hand, intensity, duration) {
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(intensity, duration).catch(() => {});
          }
                },

        createCollisionVisualization: function() {
          // Create wireframe visualization of the collision capsule
          const radius = 0.25;
          const height = 1.6;
          
          // Option A: Add wireframes as camera children so they follow VR headset automatically
          const camera = document.querySelector('[camera]');
          if (!camera) {
            console.warn('Camera not found - cannot create collision visualization');
            return;
          }
          
          // Main cylinder (body center) - positioned relative to camera
          const cylinderWireframe = document.createElement('a-cylinder');
          cylinderWireframe.setAttribute('radius', radius);
          cylinderWireframe.setAttribute('height', height);
          cylinderWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          cylinderWireframe.setAttribute('position', '0 -0.4 0'); // 0.4m below camera (body center)
          camera.appendChild(cylinderWireframe);
          
          // Top sphere (head level) - positioned at camera position
          const topSphereWireframe = document.createElement('a-sphere');
          topSphereWireframe.setAttribute('radius', radius);
          topSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          topSphereWireframe.setAttribute('position', '0 0 0'); // At camera position (head level)
          camera.appendChild(topSphereWireframe);
          
          // Bottom sphere (feet level) - positioned 1.6m below camera
          const bottomSphereWireframe = document.createElement('a-sphere');
          bottomSphereWireframe.setAttribute('radius', radius);
          bottomSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          bottomSphereWireframe.setAttribute('position', '0 -0.8 0'); // 0.8m below camera (feet level)
          camera.appendChild(bottomSphereWireframe);
          
          // Store references and hide by default
          this.collisionVisualization = {
            cylinder: cylinderWireframe,
            topSphere: topSphereWireframe,
            bottomSphere: bottomSphereWireframe,
            visible: false
          };
          
          // Hide by default
          this.setCollisionVisualizationVisible(false);
          
          console.log('üîç Player collision capsule visualization created (Option A: follows VR headset)');
          console.log(`   ‚Ä¢ Cylinder: ${radius}m radius √ó ${height}m height at body center (-0.8m from head)`);
          console.log(`   ‚Ä¢ Top sphere: ${radius}m radius at head level (camera position)`);
          console.log(`   ‚Ä¢ Bottom sphere: ${radius}m radius at feet level (-1.6m from head)`);
          console.log(`   ‚Ä¢ Wireframes automatically follow VR headset movement`);
          console.log(`   ‚Ä¢ Physics body also follows headset, so visual and collision are synced`);
          console.log(`   ‚Ä¢ Press 'C' key to toggle collision visualization`);
        },

        toggleCollisionVisualization: function() {
          if (this.collisionVisualization) {
            this.collisionVisualization.visible = !this.collisionVisualization.visible;
            this.setCollisionVisualizationVisible(this.collisionVisualization.visible);
            console.log(`üîç Collision visualization: ${this.collisionVisualization.visible ? 'ON' : 'OFF'}`);
          }
        },

        setCollisionVisualizationVisible: function(visible) {
          if (this.collisionVisualization) {
            this.collisionVisualization.cylinder.setAttribute('visible', visible);
            this.collisionVisualization.topSphere.setAttribute('visible', visible);
            this.collisionVisualization.bottomSphere.setAttribute('visible', visible);
          }
        },

        tick: function(time, deltaTime) {
          // Option B: Custom physics simulation with visual collision detection
          if (!this.rig) return;
          
          const dt = Math.min(deltaTime / 1000, 0.033); // Cap at 30fps for stability
          
          // Apply thumbstick rotation
          this.applyRotation(dt);
          
                            // RESTORED: Original movement system with physics collision detection
          
          // Apply thruster forces to velocity (original system)
          this.applyThrusterForces(dt);
          
          // OLD: Apply movement from grabbed surfaces (now handled by updateEnvironmentGrabbing)
          // this.applyGrabMovement(dt);
          
          // Apply gradual braking if active
          this.applyGradualBraking(dt);
          
          // Apply damping to velocity
          this.applyDamping(dt);
          
          // Check if grabbing environment (affects multiple systems)
          const isGrabbingEnvironment = this.hands.left.isGrabbing && this.hands.left.nearbyObject === 'environment' ||
                                       this.hands.right.isGrabbing && this.hands.right.nearbyObject === 'environment';
          
          // Apply velocity to move VR rig (original system) - but not when grabbing environment
          if (!isGrabbingEnvironment) {
            this.applyVelocityToRig(dt);
          }
          
          // Update physics bodies to follow VR rig and hands (but not when grabbing environment)
          
          if (!isGrabbingEnvironment) {
            this.updatePhysicsBodyToFollowRig();
          }
          this.updateHandPhysicsBodies();
          
          // Check for physics collisions and adjust velocity (but not when grabbing environment)
          if (!isGrabbingEnvironment) {
            this.checkPhysicsCollisionAndAdjust(dt);
            this.checkHandCollisions();
          }
          
          // Check for ball collisions
          this.checkBallCollisions();
          
          // Update grab visual feedback - DISABLED for performance
          // this.updateGrabFeedback();
          
          // NEW: Continuous ball grabbing while grip is held (but not when grabbing environment)
          if (!isGrabbingEnvironment) {
            this.updateGripBallGrabbing();
          }
          
          // NEW: Update environment grabbing (moving player based on hand movement)
          this.updateEnvironmentGrabbing();
        },

        // RESTORED: Original velocity functions for smooth movement
        
        // Apply damping to velocity
        applyDamping: function(dt) {
          const dampingFactor = Math.pow(this.damping, dt * 60); // Frame-rate independent
          this.velocity.multiplyScalar(dampingFactor);
          
          // Stop very slow movement to prevent infinite drift
          if (this.velocity.length() < this.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
        },
        
        // Apply velocity to move VR rig
        applyVelocityToRig: function(dt) {
          if (this.velocity.length() > 0) {
            const movement = this.velocity.clone().multiplyScalar(dt);
            this.rig.object3D.position.add(movement);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
              console.log('Rig moved by velocity:', movement.toArray().map(x => x.toFixed(3)));
            }
          }
        },
        
        // NEW: Update physics body to follow VR rig position (for collision detection)
        updateHandPhysicsBodies: function() {
          if (!ammoInstance) return;
          
          ['left', 'right'].forEach(handKey => {
            const hand = this[handKey + 'Hand'];
            const handState = this.hands[handKey];
            if (!hand || !handState.physicsBody) return;
            
            // Get hand world position
            const handPos = new THREE.Vector3();
            hand.object3D.getWorldPosition(handPos);
            
            // Update physics body position
            const transform = new ammoInstance.btTransform();
            handState.physicsBody.getMotionState().getWorldTransform(transform);
            transform.setOrigin(new ammoInstance.btVector3(handPos.x, handPos.y, handPos.z));
            handState.physicsBody.getMotionState().setWorldTransform(transform);
            handState.physicsBody.setCenterOfMassTransform(transform);
            handState.physicsBody.activate();
            
            // Update wireframe positions
            if (handState.physicsWireframe) {
              handState.physicsWireframe.object3D.position.set(0, 0, 0);
            }
            if (handState.grabRangeWireframe) {
              handState.grabRangeWireframe.object3D.position.set(0, 0, 0);
            }
            
            // Update grab range wireframe color based on nearby objects
            if (handState.grabRangeWireframe) {
              let color = '#0000ff'; // Default blue
              
              if (handState.isGrabbing) {
                // Green when actively grabbing anything
                color = '#00ff00';
              } else if (handState.nearbyObject) {
                // Orange when near any grabbable object (environment or ball)
                color = '#ffa500';
              }
              
              handState.grabRangeWireframe.setAttribute('material', {color: color});
            }
            
            ammoInstance.destroy(transform);
          });
        },
        
        updatePhysicsBodyToFollowRig: function() {
          if (!this.playerPhysicsBody || !ammoInstance) return;
          
          // Get current camera position
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          const Ammo = ammoInstance;
          const cameraWorldPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraWorldPos);
          
          // Move physics body to follow camera (kinematic style)
          const transform = new Ammo.btTransform();
          this.playerPhysicsBody.getMotionState().getWorldTransform(transform);
          transform.setOrigin(new Ammo.btVector3(cameraWorldPos.x, cameraWorldPos.y, cameraWorldPos.z));
          this.playerPhysicsBody.getMotionState().setWorldTransform(transform);
          this.playerPhysicsBody.setCenterOfMassTransform(transform);
          this.playerPhysicsBody.activate();
          
          // Update wireframe to follow
          if (this.playerWireframe) {
            this.playerWireframe.setAttribute('position', `${cameraWorldPos.x} ${cameraWorldPos.y} ${cameraWorldPos.z}`);
          }
          
          Ammo.destroy(transform);
        },

        // NEW: Check for physics collision and adjust velocity
        checkHandCollisions: function() {
          if (!ammoInstance || !physicsWorld) return;
          
          ['left', 'right'].forEach(handKey => {
            const handState = this.hands[handKey];
            if (!handState.physicsBody) return;
            
            // Reset nearbyObject detection for this frame
            handState.nearbyObject = null;
            
            // Check for collisions with environment
            const numManifolds = physicsWorld.getDispatcher().getNumManifolds();
            let isColliding = false;
            let collisionNormal = new THREE.Vector3();
            
            for (let i = 0; i < numManifolds; i++) {
              const contactManifold = physicsWorld.getDispatcher().getManifoldByIndexInternal(i);
              const body0 = ammoInstance.castObject(contactManifold.getBody0(), ammoInstance.btRigidBody);
              const body1 = ammoInstance.castObject(contactManifold.getBody1(), ammoInstance.btRigidBody);
              
              if (ammoInstance.compare(body0, handState.physicsBody) || ammoInstance.compare(body1, handState.physicsBody)) {
                const numContacts = contactManifold.getNumContacts();
                
                for (let j = 0; j < numContacts; j++) {
                  const contactPoint = contactManifold.getContactPoint(j);
                  const distance = contactPoint.getDistance();
                  
                  if (distance < 0.1) { // Close contact
                    isColliding = true;
                    const normal = contactPoint.get_m_normalWorldOnB();
                    
                    // Safety check for valid normal vector
                    if (normal && typeof normal.x === 'function') {
                      // Get normal direction (away from surface)
                      let normalDir = new THREE.Vector3(normal.x(), normal.y(), normal.z());
                      if (ammoInstance.compare(body1, handState.physicsBody)) {
                        normalDir.negate(); // Flip if hand is body1
                      }
                      
                      collisionNormal.add(normalDir);
                    }
                    break;
                  }
                }
              }
            }
            
            if (isColliding) {
              // Hand is touching environment - can push against it
              // BUT: Don't set to 'environment' if already grabbing a ball
              if (!handState.isGrabbing || (handState.grabInfo && !handState.grabInfo.isBall)) {
                handState.nearbyObject = 'environment';
              }
              // If grabbing a ball, keep the current nearbyObject (don't change it)
              
              // Environment grabbing is handled in updateEnvironmentGrabbing()
            } else {
              // Only check for nearby ball if not already grabbing something
              if (!handState.isGrabbing) {
                const ball = this.findNearestBall(this[handKey + 'Hand']);
                handState.nearbyObject = ball;
              }
              // If already grabbing, keep the current nearbyObject
            }
          });
        },
        
        checkPhysicsCollisionAndAdjust: function(dt) {
          if (!this.playerPhysicsBody || !ammoInstance || !physicsWorld) return;
          
          // Check if physics body is colliding with environment
          const numManifolds = physicsWorld.getDispatcher().getNumManifolds();
          let isColliding = false;
          let collisionNormal = new THREE.Vector3();
          
          for (let i = 0; i < numManifolds; i++) {
            const contactManifold = physicsWorld.getDispatcher().getManifoldByIndexInternal(i);
            const body0 = ammoInstance.castObject(contactManifold.getBody0(), ammoInstance.btRigidBody);
            const body1 = ammoInstance.castObject(contactManifold.getBody1(), ammoInstance.btRigidBody);
            
            // Check if one of the bodies is our physics body
            if (ammoInstance.compare(body0, this.playerPhysicsBody) || ammoInstance.compare(body1, this.playerPhysicsBody)) {
              const numContacts = contactManifold.getNumContacts();
              
              for (let j = 0; j < numContacts; j++) {
                const contactPoint = contactManifold.getContactPoint(j);
                const distance = contactPoint.getDistance();
                
                if (distance < 0.1) { // Close contact
                  isColliding = true;
                  const normal = contactPoint.get_m_normalWorldOnB();
                  
                  // Safety check for valid normal vector
                  if (normal && typeof normal.x === 'function') {
                    // Get normal direction (away from surface)
                    let normalDir = new THREE.Vector3(normal.x(), normal.y(), normal.z());
                    if (ammoInstance.compare(body1, this.playerPhysicsBody)) {
                      normalDir.negate(); // Flip if player is body1
                    }
                    
                    collisionNormal.add(normalDir);
                  }
                  break;
                }
              }
            }
          }
          
          if (isColliding && collisionNormal.length() > 0) {
            collisionNormal.normalize();
            
            // Remove velocity in collision direction and bounce slightly
            const velocityInCollisionDirection = this.velocity.clone().projectOnVector(collisionNormal);
            this.velocity.sub(velocityInCollisionDirection.multiplyScalar(1.2)); // Remove + bounce
            
            // Add small bounce in normal direction
            this.velocity.add(collisionNormal.clone().multiplyScalar(0.1));
            
            console.log('üö´ Physics collision detected - velocity adjusted');
          }
        },

        // SIMPLE: Check ball collisions (separate from physics world collision)
        checkBallCollisions: function() {
          // Get current camera position for ball hit detection
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          const cameraWorldPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraWorldPos);
          
          // Check for ball hits on player target (separate from wall collisions)
          this.checkBallHits(cameraWorldPos);
        },

        // Option B: Calculate collision response for point vs geometry
        getCollisionResponse: function(point, radius, surfacePos, geometry) {
          const response = new THREE.Vector3(0, 0, 0);
          
          if (geometry.primitive === 'box') {
            // Box collision
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            const penetration = radius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              // Calculate push-out direction
              const direction = relativePos.clone().sub(closestPoint).normalize();
              if (direction.length() === 0) {
                // Point is exactly on surface, push up
                direction.set(0, 1, 0);
              }
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision
            const sphereRadius = geometry.radius;
            const distance = point.distanceTo(surfacePos);
            const penetration = radius + sphereRadius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              const direction = point.clone().sub(surfacePos).normalize();
              response.copy(direction.multiplyScalar(penetration));
            }
          }
          
          return response;
        },
        
        // Check for ball hits on player target sphere
        checkBallHits: function(playerPos) {
          // Get all balls
          const balls = document.querySelectorAll('[zerog-ball]');
          
          balls.forEach(ball => {
            if (!ball.body) return; // Skip if no physics body
            
            const ballPos = new THREE.Vector3();
            ballPos.copy(ball.body.position);
            const ballVelocity = ball.body.velocity.length();
            
            // Check distance to player target (camera position)
            const distance = ballPos.distanceTo(playerPos);
            const hitDistance = 0.3; // 0.2m target radius + 0.1m ball radius
            
            // Only trigger if ball is moving and close to player target
            if (distance <= hitDistance && ballVelocity > 0.5) {
              // Check which player owns this ball
              const ballPlayer = ball.getAttribute('zerog-ball').player;
              
              // Only opponent balls (player1) can hit the player target
              if (ballPlayer === 'player1') {
                // Play impact effect
                const playerTarget = document.querySelector('#player-target');
                if (playerTarget && playerTarget.components['impact-effect']) {
                  playerTarget.components['impact-effect'].playEffect();
                  
                  // Reset ball after hit
                  if (ball.components['zerog-ball']) {
                    ball.components['zerog-ball'].resetPosition();
                  }
                  
                  if (this.debugMode) {
                    console.log('Player hit by opponent ball!');
                  }
                }
              }
            }
          });
        },
        
        updateGrabFeedback: function() {
          // DISABLED: Visual feedback for grabbable surfaces disabled for performance
          return;
          
          // Reset all grabbable objects to normal color first
          document.querySelectorAll('.grabbable-surface, [zerog-ball]').forEach(el => {
            if (el.hasAttribute('material')) {
              const currentColor = el.getAttribute('material').color;
              if (currentColor === '#00ff00') { // Reset if it was highlighted
                el.setAttribute('material', 'color', '#888888');
              }
            }
          });
          
          // Highlight objects in grab range
          if (leftNearby && !this.hands.left.isGrabbing) {
            leftNearby.setAttribute('material', 'color', '#00ff00');
          }
          if (rightNearby && !this.hands.right.isGrabbing && rightNearby !== leftNearby) {
            rightNearby.setAttribute('material', 'color', '#00ff00');
          }
        },
        
        // Option B: Apply rotation to VR rig only (no physics body)
        applyRotation: function(deltaTime) {
          if (!this.rig) {
            console.log('‚ö†Ô∏è Rig not found for rotation');
            return;
          }
          
          // Apply rotation from right thumbstick
          const rotationInput = this.thumbstickRotation.right;
          if (Math.abs(rotationInput) > 0.1) {
            const rotationSpeed = this.data.rotationSpeed * deltaTime; // deltaTime is already in seconds
            this.rotationY += rotationInput * rotationSpeed;
            
            // Apply rotation to the rig only (Option B: no physics body)
            this.rig.object3D.rotation.y = this.rotationY;
            
            // Debug output
            if (this.debugMode) {
              console.log(`üîÑ Rotation applied: input=${rotationInput.toFixed(2)}, Y=${this.rotationY.toFixed(2)}`);
            }
          }
        },
        
        // Option B: Apply thruster forces to velocity
        applyThrusterForces: function(dt) {
          if (!this.leftHand || !this.rightHand) return;
          
          let totalThrust = new THREE.Vector3(0, 0, 0);
          
          // Left hand thruster
          if (this.hands.left.thrusterActive) {
            // Get thrust direction from controller orientation
            const leftDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.leftHand.object3D.getWorldQuaternion(worldQuat);
            leftDir.applyQuaternion(worldQuat);
            leftDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(leftDir);
            
            if (this.debugMode) {
              console.log('Left thrust force:', leftDir.clone().normalize().toArray().map(x => x.toFixed(2)));
            }
          }
          
          // Right hand thruster
          if (this.hands.right.thrusterActive) {
            // Get thrust direction from controller orientation
            const rightDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.rightHand.object3D.getWorldQuaternion(worldQuat);
            rightDir.applyQuaternion(worldQuat);
            rightDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(rightDir);
            
            if (this.debugMode) {
              console.log('Right thrust force:', rightDir.clone().normalize().toArray().map(x => x.toFixed(2)));
            }
          }
          
          // Apply thrust to velocity (Option B approach)
          if (totalThrust.length() > 0) {
            // RESTORED: Apply thrust to velocity (original system)
            this.velocity.add(totalThrust);
            
            // Apply max speed limit
            if (this.velocity.length() > this.data.maxSpeed) {
              this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
            }
            
            if (this.debugMode) {
              console.log('Velocity changed by thrust:', totalThrust.toArray().map(x => x.toFixed(3)));
            }
          }
        },
        
        // Option B: Apply grab movement to velocity
        applyGrabMovement: function(dt) {
          // Handle pulling/pushing when grabbing STATIC surfaces (not balls)
          ['left', 'right'].forEach(handKey => {
            if (this.hands[handKey].isGrabbing && this.hands[handKey].grabInfo) {
              const grabInfo = this.hands[handKey].grabInfo;
              
              // CRITICAL: Only apply player movement for static surfaces, NEVER for balls
              if (grabInfo.isBall) {
                return; // Balls handle their own movement, do NOT affect player
              }
              
              // Double-check: Ensure surface is not a ball by checking for zerog-ball attribute
              if (grabInfo.surface && grabInfo.surface.hasAttribute('zerog-ball')) {
                return; // Additional safety check
              }
              
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              if (!hand) return;
              
              const currentHandPos = new THREE.Vector3();
              hand.object3D.getWorldPosition(currentHandPos);
              
              // Calculate how much the hand has moved since last frame
              const handMovement = new THREE.Vector3()
                .subVectors(currentHandPos, grabInfo.lastHandPos);
              
              const movementMagnitude = handMovement.length();
              
              // Only apply movement if hand has moved significantly
              if (movementMagnitude > 0.001) { // 0.1cm minimum movement
                // Apply hand movement as velocity change in opposite direction
                // This creates the "pulling yourself toward/away from object" effect
                const movementStrength = 80.0; // Scale factor for responsiveness
                const velocityChange = handMovement.clone().negate().multiplyScalar(movementStrength / dt);
                
                // Add to velocity (Option B approach)
                this.velocity.add(velocityChange.multiplyScalar(dt));
                
                // Cap maximum velocity
                if (this.velocity.length() > this.data.maxSpeed) {
                  this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
                }
                
                if (this.debugMode) {
                  console.log('Velocity changed by grab:', velocityChange.toArray().map(x => x.toFixed(3)));
                }
              }
              
              // Update last hand position for next frame
              grabInfo.lastHandPos.copy(currentHandPos);
            }
          });
        },
        
        startBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Start braking for this hand
          this.hands[handKey].isBraking = true;
          
          // Haptic feedback when starting braking
          this.playHapticFeedback(hand, 0.2, 100);
        },
        
        stopBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Stop braking for this hand
          this.hands[handKey].isBraking = false;
          
          // Haptic feedback when stopping braking
          this.playHapticFeedback(hand, 0.1, 50);
        },
        
        // Option B: Apply braking to velocity
        applyGradualBraking: function(dt) {
          // Check if either hand is braking
          const isBrakingActive = this.hands.left.isBraking || this.hands.right.isBraking;
          
          if (isBrakingActive) {
            // Apply stronger braking to velocity
            const brakingFactor = Math.pow(this.brakingForce, dt * 60); // Frame-rate independent
            this.velocity.multiplyScalar(brakingFactor);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
              console.log('Braking applied, velocity:', this.velocity.length().toFixed(2));
            }
          }
        },

        // NEW: Try to grab a ball with the specified hand
        tryGrabBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          console.log('ü§≤ Trying to grab ball with', handKey, 'hand');
          
          // Don't grab if already grabbing something
          if (this.hands[handKey].isGrabbing) {
            console.log('‚ùå Already grabbing something');
            return;
          }
          
          // Look for nearby balls only (not static surfaces)
          const ball = this.findNearestBall(hand);
          
          if (ball) {
            console.log('üéæ Found ball:', ball.id);
            // Use original working logic - get component data directly
            const ballComponent = ball.components['zerog-ball'];
            const ballPlayer = ballComponent ? ballComponent.data.player : null;
            console.log('üë§ Ball player:', ballPlayer);
            
            if (ballPlayer === 'player2') {
              console.log('‚úÖ Grabbing player2 ball!');
              this.hands[handKey].grabbedSurface = ball;
              this.attachToSurface(hand, ball);
              this.playHapticFeedback(hand, 0.5, 100);
            } else {
              console.log('‚ùå Not player2 ball, cannot grab');
            }
          } else {
            console.log('‚ùå No ball found in range');
          }
        },
        
        releaseGrabbedBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // If grabbing something, release it
          if (this.hands[handKey].isGrabbing) {
            const surface = this.hands[handKey].grabbedSurface;
            
            // If grabbing environment, apply release physics
            if (this.hands[handKey].nearbyObject === 'environment' && this.hands[handKey].grabInfo) {
              // Apply some momentum preservation but limit it
              const maxReleaseVelocity = 5.0; // Allow some momentum but not too much
              if (this.velocity.length() > maxReleaseVelocity) {
                this.velocity.normalize().multiplyScalar(maxReleaseVelocity);
                console.log('üöß Limited release velocity to prevent excessive flinging');
              }
              console.log('üèóÔ∏è Released environment grab - momentum preserved');
            }
            // If it's a ball, call its onRelease method
            else if (surface && surface.hasAttribute('zerog-ball') && surface.components['zerog-ball']) {
              surface.components['zerog-ball'].onRelease();
            }
            
            // Clear ALL grab state
            this.hands[handKey].isGrabbing = false;
            this.hands[handKey].grabbedSurface = null;
            this.hands[handKey].grabInfo = null;
          }
        },
        
        // NEW: Find nearest ball (not static surfaces)
        findNearestBall: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
          // Look for balls only
          const balls = document.querySelectorAll('[zerog-ball]');
          let nearestBall = null;
          let minDistance = Infinity;
          
          balls.forEach(ball => {
            const distance = this.getDistanceToSurface(handPos, handRadius, ball);
            
            // If hand is touching or very close to ball (within 10cm for easier grabbing)
            if (distance <= 0.10) {
              if (distance < minDistance) {
                minDistance = distance;
                nearestBall = ball;
              }
            }
          });
          
          return nearestBall;
        },
        
        // NEW: Continuous ball grabbing while grip is held
        updateGripBallGrabbing: function() {
          let anyHandGrabbingBalls = false; // Only count ball grabbing for tractor beam
          
          // Check each hand
          ['left', 'right'].forEach(handKey => {
            const hand = handKey === 'left' ? this.leftHand : this.rightHand;
            if (!hand) return;
            
            // If grip is held but not currently grabbing anything
            if (this.hands[handKey].gripHeld && !this.hands[handKey].isGrabbing) {
              // Check what's in range and try to grab it
              if (this.hands[handKey].nearbyObject === 'environment') {
                // Environment grabbing with proper tracking
                const handPos = new THREE.Vector3();
                hand.object3D.getWorldPosition(handPos);
                
                this.hands[handKey].isGrabbing = true;
                this.hands[handKey].grabInfo = {
                  grabPoint: handPos.clone(),
                  handPositionAtGrab: handPos.clone(),
                  playerPositionAtGrab: this.playerPhysicsBody ? this.playerPhysicsBody.getWorldTransform().getOrigin() : handPos.clone(),
                  grabTime: Date.now()
                };
                console.log('üèóÔ∏è Environment grab with', handKey, 'hand');
                // DON'T count environment grabbing for tractor beam blocker
              } else if (this.hands[handKey].nearbyObject) {
                // Try to grab nearby ball
                this.tryGrabBall(hand);
                if (this.hands[handKey].isGrabbing && this.hands[handKey].grabInfo && this.hands[handKey].grabInfo.isBall) {
                  anyHandGrabbingBalls = true; // Only count ball grabbing
                }
              }
            } else if (this.hands[handKey].isGrabbing && this.hands[handKey].grabInfo && this.hands[handKey].grabInfo.isBall) {
              anyHandGrabbingBalls = true; // Only count ball grabbing
            }
          });
          
          // Only activate tractor beam if NO hands are grabbing BALLS (environment grabbing is OK)
          if ((this.hands.left.gripHeld || this.hands.right.gripHeld) && !anyHandGrabbingBalls) {
            console.log('üîß Grip held, no ball grabbing, calling tractor beam');
            this.updateTractorBeam();
          }
        },
        
        updateEnvironmentGrabbing: function() {
          // Real environment grabbing - track hand movement relative to grab point
          ['left', 'right'].forEach(handKey => {
            const handState = this.hands[handKey];
            
            if (handState.isGrabbing && handState.nearbyObject === 'environment' && handState.grabInfo) {
              // CRITICAL: Only process if this is actually environment grabbing (not ball grabbing)
              if (handState.grabInfo.isBall) {
                return; // Skip ball grabs - this function is only for environment grabbing
              }
              
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              if (!hand) return;
              
              const grabInfo = handState.grabInfo;
              
              // Safety check for valid grabInfo structure
              if (!grabInfo.handPositionAtGrab) {
                console.log('‚ö†Ô∏è Invalid grabInfo structure for environment grabbing');
                return;
              }
              
              // Calculate how much the hand has moved since grab started
              const currentHandPos = new THREE.Vector3();
              hand.object3D.getWorldPosition(currentHandPos);
              
              // Triple safety check: ensure handPositionAtGrab exists and is a Vector3
              if (!grabInfo.handPositionAtGrab || typeof grabInfo.handPositionAtGrab.x === 'undefined') {
                console.log('‚ö†Ô∏è handPositionAtGrab is invalid, skipping environment grabbing');
                return;
              }
              
              const handMovement = currentHandPos.clone().sub(grabInfo.handPositionAtGrab);
              
              // Apply opposite movement to player (if hand moves right, player moves left)
              // Moderate amplification for natural feel without stuttering
              const playerMovement = handMovement.clone().multiplyScalar(-1.5); // Reduced to 1.5x to prevent stuttering
              
              // Limit movement speed to prevent wild flinging and stuttering
              const maxMovementPerFrame = 0.15; // Reduced to 15cm max to prevent oscillation
              if (playerMovement.length() > maxMovementPerFrame) {
                playerMovement.normalize().multiplyScalar(maxMovementPerFrame);
              }
              
              // Add smoothing to prevent stuttering
              if (playerMovement.length() < 0.005) { // Ignore tiny movements (0.5cm threshold)
                return; // Skip very small movements that can cause jitter
              }
              
              // CHANGED: Apply movement directly to VR rig position for immediate response
              // Don't use velocity - move the rig directly for real-time feedback
              if (this.rig) {
                this.rig.object3D.position.add(playerMovement);
                
                // Update physics body to follow the new rig position immediately
                this.updatePhysicsBodyToFollowRig();
                
                // Track movement for momentum on release (reduced to prevent stuttering)
                const movementVelocity = playerMovement.clone().multiplyScalar(80); // Reduced from 120 to prevent over-amplification
                this.velocity.lerp(movementVelocity, 0.2); // Reduced blend factor to prevent oscillation
                
                console.log('üèóÔ∏è Direct rig movement:', playerMovement.length().toFixed(3), 'm');
              }
              
              // CRITICAL FIX: DON'T update the grab reference point - keep it fixed at original grab location
              // This was causing feedback loops and jitter
              // grabInfo.handPositionAtGrab.copy(currentHandPos); // REMOVED - causes jitter
            }
          });
        },
        
        updateTractorBeam: function() {
          console.log('üîß updateTractorBeam called');
          
          const ball = document.querySelector('[zerog-ball="player: player2"]');
          if (!ball || !ball.components['zerog-ball']) {
            console.log('üö´ No player2 ball found');
            return;
          }
          
          const ballComponent = ball.components['zerog-ball'];
          if (!ballComponent || !ballComponent.body) {
            console.log('üö´ Ball component or body missing');
            return;
          }
          
          // Skip if ball is grabbed
          if (ballComponent.isGrabbed) {
            console.log('üö´ Ball is grabbed, skipping tractor beam');
            return;
          }
          
          console.log('‚úÖ Tractor beam conditions met');
          
          // Get ball position
          const ballPos = new THREE.Vector3();
          ball.object3D.getWorldPosition(ballPos);
          
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          // Calculate target position: 30cm lower and 30cm forward from camera
          const cameraPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraPos);
          
          const cameraDirection = new THREE.Vector3();
          camera.object3D.getWorldDirection(cameraDirection);
          
          const targetPos = cameraPos.clone()
            .add(cameraDirection.multiplyScalar(-0.3)) // 30cm backward (toward you)
            .add(new THREE.Vector3(0, -0.3, 0)); // 30cm down
          
          // Calculate direction and distance to target
          const direction = targetPos.clone().sub(ballPos);
          const distance = direction.length();
          
          // No distance limit - tractor beam works from anywhere
          
          // Use different force based on distance to target for smooth settling (halved speed)
          let force;
          if (distance > 0.5) {
            // Far from target: strong pull toward target (halved)
            force = direction.normalize().multiplyScalar(Math.min(distance * 4, 7.5));
          } else {
            // Close to target: gentle settling with damping (halved)
            const currentVel = ballComponent.body.getLinearVelocity();
            
            // Safety check for valid velocity
            if (currentVel && typeof currentVel.x === 'function') {
              const velocityDamping = new THREE.Vector3(-currentVel.x() * 2.5, -currentVel.y() * 2.5, -currentVel.z() * 2.5);
              force = direction.multiplyScalar(1.5).add(velocityDamping); // Gentle pull + velocity damping
            } else {
              force = direction.multiplyScalar(1.5); // Just gentle pull without damping
            }
          }
          
          // Apply to ball physics - use the velocity API if ball is in physics world
          try {
            // Use the compatibility API we set up
            if (ballComponent.body.velocity) {
              const currentVel = ballComponent.body.getLinearVelocity();
              const newVel = new ammoInstance.btVector3(
                currentVel.x() + force.x * 0.016, // Assuming 60fps
                currentVel.y() + force.y * 0.016,
                currentVel.z() + force.z * 0.016
              );
              ballComponent.body.setLinearVelocity(newVel);
              ballComponent.body.activate();
              ammoInstance.destroy(newVel);
            }
          } catch (e) {
            // Ball might not be in physics world, skip
            console.log('üö´ Tractor beam: Ball not in physics world');
          }
          
          // Debug logging (throttled)
          if (!this.lastTractorLog || Date.now() - this.lastTractorLog > 1000) {
            console.log('üîµ Tractor beam active - distance to target:', distance.toFixed(2), 'force magnitude:', force.length().toFixed(2));
            this.lastTractorLog = Date.now();
          }
        },

        remove: function() {
          // Option B: No physics body to remove
          
          // Clean up event listener
          if (this.keydownListener) {
            document.removeEventListener('keydown', this.keydownListener);
          }
          
          // Clean up collision visualization elements from camera
          if (this.collisionVisualization) {
            if (this.collisionVisualization.cylinder && this.collisionVisualization.cylinder.parentNode) {
              this.collisionVisualization.cylinder.parentNode.removeChild(this.collisionVisualization.cylinder);
            }
            if (this.collisionVisualization.topSphere && this.collisionVisualization.topSphere.parentNode) {
              this.collisionVisualization.topSphere.parentNode.removeChild(this.collisionVisualization.topSphere);
            }
            if (this.collisionVisualization.bottomSphere && this.collisionVisualization.bottomSphere.parentNode) {
              this.collisionVisualization.bottomSphere.parentNode.removeChild(this.collisionVisualization.bottomSphere);
            }
          }
        },

        createHandPhysicsBodies: function() {
          if (!ammoInstance || !physicsWorld) {
            console.log('üö´ Cannot create hand physics bodies - Ammo.js not ready');
            setTimeout(() => this.createHandPhysicsBodies(), 1000);
            return;
          }

          const Ammo = ammoInstance;
          
          ['left', 'right'].forEach(handKey => {
            const hand = this[handKey + 'Hand'];
            if (!hand) return;
            
            // Create physics sphere for hand
            const radius = 0.05; // 5cm radius for hand collision
            const shape = new Ammo.btSphereShape(radius);
            
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            
            const handPos = new THREE.Vector3();
            hand.object3D.getWorldPosition(handPos);
            transform.setOrigin(new Ammo.btVector3(handPos.x, handPos.y, handPos.z));
            
            const motionState = new Ammo.btDefaultMotionState(transform);
            const mass = 0; // Kinematic body
            const localInertia = new Ammo.btVector3(0, 0, 0);
            
            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            const body = new Ammo.btRigidBody(rbInfo);
            
            // Make it kinematic
            body.setCollisionFlags(body.getCollisionFlags() | 2);
            body.setActivationState(4);
            
            // Add hands with collision filtering - don't collide with player body or balls
            const HAND_GROUP = 4;
            const HAND_MASK = 1; // Only collide with environment (group 1)
            
            physicsWorld.addRigidBody(body, HAND_GROUP, HAND_MASK);
            
            // Store reference
            this.hands[handKey].physicsBody = body;
            
            // Create physics wireframe sphere
            const wireSphere = document.createElement('a-sphere');
            wireSphere.setAttribute('radius', radius);
            wireSphere.setAttribute('material', {
              color: '#0000ff',
              wireframe: true,
              opacity: 0.5,
              transparent: true
            });
            wireSphere.setAttribute('position', '0 0 0');
            hand.appendChild(wireSphere);
            this.hands[handKey].physicsWireframe = wireSphere;
            
            // Create grab range sphere (2x size)
            const grabSphere = document.createElement('a-sphere');
            grabSphere.setAttribute('radius', radius * 2);
            grabSphere.setAttribute('material', {
              color: '#0000ff',
              wireframe: true,
              opacity: 0.3,
              transparent: true
            });
            grabSphere.setAttribute('position', '0 0 0');
            hand.appendChild(grabSphere);
            this.hands[handKey].grabRangeWireframe = grabSphere;
            
            // Clean up Ammo objects
            Ammo.destroy(transform);
            Ammo.destroy(localInertia);
            Ammo.destroy(rbInfo);
          });
          
          console.log('‚úÖ Created physics bodies and visualizations for hands');
        },
        
        createPlayerPhysicsBody: function() {
          if (!ammoInstance || !physicsWorld) {
            console.log('üö´ Cannot create player physics body - Ammo.js not ready');
            // Try again later
            setTimeout(() => {
              if (!this.playerPhysicsBody) { // Only retry if not already created
                this.createPlayerPhysicsBody();
              }
            }, 1000);
            return;
          }

          if (this.playerPhysicsBody) {
            console.log('üîß Player physics body already exists');
            return; // Already created
          }

          console.log('üîß Creating real physics body for player (like balls)');
          const Ammo = ammoInstance;
          
          // Create sphere shape for player body (like balls but bigger)
          const radius = 0.4; // 40cm radius sphere for player
          const shape = new Ammo.btSphereShape(radius);
          
          // Create DYNAMIC body (like balls) - real physics
          const mass = 1; // Give it mass like balls
          const localInertia = new Ammo.btVector3(0, 0, 0);
          shape.calculateLocalInertia(mass, localInertia);
          
          const transform = new Ammo.btTransform();
          transform.setIdentity();
          
          // Get current camera position to initialize physics body there
          const camera = document.querySelector('[camera]');
          if (camera) {
            const cameraWorldPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(cameraWorldPos);
            transform.setOrigin(new Ammo.btVector3(cameraWorldPos.x, cameraWorldPos.y, cameraWorldPos.z));
            console.log('üîß Player physics body initialized at camera position:', cameraWorldPos.toArray().map(x => x.toFixed(2)));
          } else {
            transform.setOrigin(new Ammo.btVector3(0, 1.6, -2)); // Fallback position
            console.log('üîß Player physics body initialized at fallback position');
          }
          
          const motionState = new Ammo.btDefaultMotionState(transform);
          const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
          this.playerPhysicsBody = new Ammo.btRigidBody(rigidBodyInfo);
          
          // Set damping (like balls but less for responsiveness)
          this.playerPhysicsBody.setDamping(0.01, 0.1); // Low linear damping, medium angular damping
          
          // Prevent rotation (player should only translate, not tumble)
          this.playerPhysicsBody.setAngularFactor(new Ammo.btVector3(0, 0, 0));
          
          // Add velocity API (like balls)
          this.setupPlayerVelocityAPI();
          
          // Add player with collision filtering
          const PLAYER_GROUP = 2;
          const PLAYER_MASK = 1 | 16; // Collide with environment (1) and enemy balls (16), not hands (4) or player ball (8)
          physicsWorld.addRigidBody(this.playerPhysicsBody, PLAYER_GROUP, PLAYER_MASK);
          
          // Add to physics objects for automatic position sync
          const playerPhysicsObject = {
            entity: this.el || null,
            object3D: null,
            body: this.playerPhysicsBody,
            isPlayer: true // Mark as player body
          };
          physicsObjects.push(playerPhysicsObject);
          
          // Create wireframe visualization
          this.createPlayerWireframe();
          
          console.log('‚úÖ Player physics body added to Ammo.js physics world (dynamic sphere, like balls)');
          
          // Test collision
          this.testPlayerCollision();
          
          // Position the physics body correctly after a delay
          setTimeout(() => {
            this.repositionPlayerPhysicsBody();
          }, 2000);
        },

        setupPlayerVelocityAPI: function() {
          // Add velocity API to player physics body (same as balls)
          const Ammo = ammoInstance;
          
          this.playerPhysicsBody.velocity = {
            set: (x, y, z) => {
              const velocity = new Ammo.btVector3(x, y, z);
              this.playerPhysicsBody.setLinearVelocity(velocity);
              Ammo.destroy(velocity);
            },
            add: (x, y, z) => {
              const currentVel = this.playerPhysicsBody.getLinearVelocity();
              const newVel = new Ammo.btVector3(currentVel.x() + x, currentVel.y() + y, currentVel.z() + z);
              this.playerPhysicsBody.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            length: () => {
              const vel = this.playerPhysicsBody.getLinearVelocity();
              const length = Math.sqrt(vel.x() * vel.x() + vel.y() * vel.y() + vel.z() * vel.z());
              return length;
            },
            multiplyScalar: (scalar) => {
              const vel = this.playerPhysicsBody.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x() * scalar, vel.y() * scalar, vel.z() * scalar);
              this.playerPhysicsBody.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            }
          };
          
          this.playerPhysicsBody.position = {
            copy: (vector3) => {
              const transform = new Ammo.btTransform();
              this.playerPhysicsBody.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              
              // Safety check for valid origin
              if (origin && typeof origin.x === 'function') {
                vector3.set(origin.x(), origin.y(), origin.z());
              }
              Ammo.destroy(transform);
            }
          };
        },

        createPlayerWireframe: function() {
          // Create wireframe sphere to visualize collision body
          if (this.playerWireframe) {
            this.playerWireframe.parentNode.removeChild(this.playerWireframe);
          }
          
          this.playerWireframe = document.createElement('a-sphere');
          this.playerWireframe.setAttribute('radius', '0.4'); // Same as physics body
          this.playerWireframe.setAttribute('material', 'wireframe: true; color: #00ff00; opacity: 0.8');
          this.playerWireframe.setAttribute('position', '0 0 0');
          this.el.sceneEl.appendChild(this.playerWireframe);
          
          console.log('‚úÖ Player wireframe sphere created');
        },

        repositionPlayerPhysicsBody: function() {
          if (!this.playerPhysicsBody || !ammoInstance) return;
          
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          const Ammo = ammoInstance;
          const cameraWorldPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraWorldPos);
          
          // Move physics body to current camera position
          const transform = new Ammo.btTransform();
          this.playerPhysicsBody.getMotionState().getWorldTransform(transform);
          transform.setOrigin(new Ammo.btVector3(cameraWorldPos.x, cameraWorldPos.y, cameraWorldPos.z));
          this.playerPhysicsBody.getMotionState().setWorldTransform(transform);
          this.playerPhysicsBody.setCenterOfMassTransform(transform);
          this.playerPhysicsBody.activate();
          
          console.log('üîß Repositioned player physics body to camera position:', cameraWorldPos.toArray().map(x => x.toFixed(2)));
          
          Ammo.destroy(transform);
        },

        updatePlayerFromPhysics: function() {
          if (!this.playerPhysicsBody || !ammoInstance) return;
          
          // Get physics body position
          const physicsPos = new THREE.Vector3();
          this.playerPhysicsBody.position.copy(physicsPos);
          
          // Update VR rig to follow physics body position
          this.rig.object3D.position.copy(physicsPos);
          
          // Update wireframe position to match physics body
          if (this.playerWireframe) {
            this.playerWireframe.setAttribute('position', `${physicsPos.x} ${physicsPos.y} ${physicsPos.z}`);
          }
          
          // Debug output occasionally
          if (Math.random() < 0.01) { // 1% of frames
            console.log('üìç Player physics position:', physicsPos.toArray().map(x => x.toFixed(2)));
          }
        },

        testPlayerCollision: function() {
          setTimeout(() => {
            if (this.playerPhysicsBody && ammoInstance && physicsWorld) {
              console.log('Player collision: Testing player physics body...');
              const numManifolds = physicsWorld.getDispatcher().getNumManifolds();
              console.log(`Player collision: ${numManifolds} total manifolds in physics world`);
              
              console.log('Player collision: Player physics body initialized successfully');
            } else {
              console.log('Player collision: ERROR - Missing player physics body or physics world');
            }
          }, 1000);
        },

        shootBallFromCamera: function() {
          const camera = document.querySelector('[camera]');
          if (!camera) {
            console.log('üö´ No camera found for ball shooting');
            return;
          }

          // Get camera world position and rotation
          const cameraPos = new THREE.Vector3();
          const cameraQuat = new THREE.Quaternion();
          camera.object3D.getWorldPosition(cameraPos);
          camera.object3D.getWorldQuaternion(cameraQuat);

          // Calculate forward direction
          const forwardDir = new THREE.Vector3(0, 0, -1);
          forwardDir.applyQuaternion(cameraQuat);

          // Create spawn position slightly in front of camera
          const spawnPos = cameraPos.clone().add(forwardDir.clone().multiplyScalar(0.5));

          // Create ball entity
          const scene = document.querySelector('a-scene');
          const ball = document.createElement('a-sphere');
          
          // Set ball properties
          ball.setAttribute('radius', '0.1');
          ball.setAttribute('color', '#ff4444'); // Red color for shot balls
          ball.setAttribute('material', 'shader: standard; metalness: 0.3; roughness: 0.4');
          ball.setAttribute('position', `${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);
          
          // Add physics component for shot balls
          ball.setAttribute('shot-ball', '');
          
          scene.appendChild(ball);
          
          // Wait a frame for the ball to be properly added, then apply velocity
          setTimeout(() => {
            this.applyShotBallVelocity(ball, forwardDir);
          }, 50);
          
          console.log(`‚úÖ Shot ball created at position: ${spawnPos.x.toFixed(2)}, ${spawnPos.y.toFixed(2)}, ${spawnPos.z.toFixed(2)}`);
        },

        applyShotBallVelocity: function(ballEl, direction) {
          const ballComponent = ballEl.components['shot-ball'];
          if (ballComponent && ballComponent.body) {
            // Apply forward velocity (10 m/s)
            const velocity = direction.clone().multiplyScalar(10);
            ballComponent.body.velocity.set(velocity.x, velocity.y, velocity.z);
            
            // Add some random spin
            const spin = new THREE.Vector3(
              (Math.random() - 0.5) * 20,
              (Math.random() - 0.5) * 20, 
              (Math.random() - 0.5) * 20
            );
            ballComponent.body.angularVelocity.set(spin.x, spin.y, spin.z);
            
            console.log(`‚úÖ Applied velocity to shot ball: ${velocity.length().toFixed(2)} m/s`);
          }
        }
      });

      // Zero-G Bot Component - AI opponent for singleplayer
      AFRAME.registerComponent('zerog-bot', {
        schema: {
          enabled: { type: 'boolean', default: true },
          difficulty: { type: 'string', default: 'medium' },
          throwInterval: { type: 'number', default: 4000 }, // 4 seconds between throws
          minThrowForce: { type: 'number', default: 3 },
          maxThrowForce: { type: 'number', default: 8 },
          movementSpeed: { type: 'number', default: 1.5 },
          accuracy: { type: 'number', default: 0.7 }
        },
        
        init: function() {
          debugLog('ü§ñ === ZEROG-BOT INITIALIZATION START ===');
          
          this.ball = null;
          this.lastThrowTime = 0;
          this.lastMoveTime = 0;
          this.moveInterval = 6000; // Move every 6 seconds
          this.targetPosition = new THREE.Vector3();
          this.isMoving = false;
          this.moveStartTime = 0;
          this.moveStartPos = new THREE.Vector3();
          this.moveDuration = 2000; // 2 second movement duration
          
          // Player tracking for predictive aiming
          this.playerPos = new THREE.Vector3();
          this.playerLastPos = new THREE.Vector3();
          this.playerVelocity = new THREE.Vector3();
          this.lastPlayerUpdate = 0;
          
          // Initialize body as null for safety
          this.body = null;
          
          debugLog('ü§ñ Creating bot physics body...');
          
          // Create Ammo.js physics body for the bot
          if (ammoInstance && physicsWorld) {
            try {
              this.createAmmoPhysicsBody();
              debugLog('‚úÖ Bot physics body created successfully');
            } catch (e) {
              debugLog(`‚ùå Bot physics creation failed: ${e.message}`, true);
              this.body = null;
              this.physicsDisabled = true;
            }
          } else {
            debugLog('‚è≥ Waiting for Ammo.js to initialize bot physics...');
            // Wait for Ammo.js to initialize
            setTimeout(() => {
              if (ammoInstance && physicsWorld && !this.physicsDisabled) {
                try {
                  this.createAmmoPhysicsBody();
                  debugLog('‚úÖ Bot physics body created (delayed)');
                } catch (e) {
                  debugLog(`‚ùå Bot physics creation failed (delayed): ${e.message}`, true);
                  this.body = null;
                  this.physicsDisabled = true;
                }
              }
            }, 2000);
          }
          
          // Initialize position (don't depend on physics)
          this.generateNewTargetPosition();
          
          // Listen for game events
          this.el.sceneEl.addEventListener('loaded', () => {
            this.ball = this.el.sceneEl.querySelector('[zerog-ball="player: player1"]');
            debugLog('ü§ñ Bot found ball reference');
          });
          
          // Update difficulty settings
          if (this.data.difficulty === 'easy') {
            this.data.throwInterval = 6000;  // 6 seconds between throws
            this.data.accuracy = 0.5;        // 50% accuracy
          } else if (this.data.difficulty === 'medium') {
            this.data.throwInterval = 4000;  // 4 seconds between throws  
            this.data.accuracy = 0.7;        // 70% accuracy
          } else if (this.data.difficulty === 'hard') {
            this.data.throwInterval = 3000;  // 3 seconds between throws
            this.data.accuracy = 0.9;        // 90% accuracy
          }
          
          debugLog('ü§ñ === ZEROG-BOT INITIALIZATION COMPLETE ===');
        },
        
        generateNewTargetPosition: function() {
          // Generate a random position in the back half of the space
          this.targetPosition.set(
            (Math.random() - 0.5) * 12, // X: -6 to 6
            Math.random() * 4 + 1,      // Y: 1 to 5
            Math.random() * -6 - 4      // Z: -4 to -10 (back half)
          );
        },
        
        updatePlayerTracking: function(time) {
          // Get player TARGET position (the actual sphere that needs to be hit)
          const playerTarget = document.querySelector('#player-target');
          if (!playerTarget) return;
          
          // Store previous position
          this.playerLastPos.copy(this.playerPos);
          
          // Get current world position of the target sphere
          playerTarget.object3D.getWorldPosition(this.playerPos);
          
          // Calculate velocity if we have a previous frame
          if (this.lastPlayerUpdate > 0) {
            const deltaTime = (time - this.lastPlayerUpdate) / 1000; // Convert to seconds
            if (deltaTime > 0.001) { // Avoid division by zero
              this.playerVelocity.subVectors(this.playerPos, this.playerLastPos).divideScalar(deltaTime);
            }
          }
          
          this.lastPlayerUpdate = time;
        },
        
        startMovementToTarget: function(currentTime) {
          // Safety check: Don't move if body is null
          if (!this.body || !this.body.position) {
            debugLog('‚ùå Bot body missing or invalid');
            return;
          }
          
          try {
            this.isMoving = true;
            this.moveStartTime = currentTime; // Use A-Frame time consistently
            this.moveStartPos.copy(this.body.position);
            
            // Calculate velocity needed to reach target
            const direction = new THREE.Vector3()
              .subVectors(this.targetPosition, this.moveStartPos)
              .normalize();
            
            const velocity = direction.multiplyScalar(this.data.movementSpeed);
            
            // Apply velocity to physics body
            this.body.velocity.set(velocity.x, velocity.y, velocity.z);
            
            // console.log(`Bot moving to: ${this.targetPosition.x.toFixed(1)}, ${this.targetPosition.y.toFixed(1)}, ${this.targetPosition.z.toFixed(1)}`); // Disabled to reduce console spam
                     } catch (e) {
             debugLog(`‚ùå Bot movement error: ${e.message}`, true);
           }
        },
        
        stopMovement: function() {
          this.isMoving = false;
          
          // Safety check: Don't access body if null
          if (!this.body || !this.body.velocity) {
            this.generateNewTargetPosition();
            return;
          }
          
          // Apply damping to slow down
          this.body.velocity.scale(0.1, this.body.velocity);
          // console.log('Bot stopped moving, generating new target...'); // Disabled to reduce console spam
          
          this.generateNewTargetPosition();
        },
        
        throwBallAtPlayer: function() {
          if (!this.ball || !this.ball.components['zerog-ball']) return;
          
          // Reset ball to bot position
          this.ball.components['zerog-ball'].resetPosition();
          const ballBody = this.ball.components['zerog-ball'].body;
          
          // Get bot position (prefer physics, fallback to visual)
          let botPos;
          if (this.body && this.body.position) {
            // Use physics position
            botPos = new THREE.Vector3().copy(this.body.position);
          } else {
            // Fallback to visual position
            botPos = new THREE.Vector3().copy(this.el.object3D.position);
            debugLog('ü§ñ Ball throw: Using visual position (fallback)');
          }
          
          // Position ball slightly in front of bot
          botPos.z += 0.5; // Slightly forward
          ballBody.position.set(botPos.x, botPos.y, botPos.z);
          
          // Calculate throw force
          const throwForce = this.data.minThrowForce + 
            Math.random() * (this.data.maxThrowForce - this.data.minThrowForce);
          
          // SIMPLIFIED AIMING: Direct aim at player target with minimal prediction
          let targetPos = this.playerPos.clone();
          const velocityMagnitude = this.playerVelocity.length();
          
          // Only use light prediction for fast-moving players (> 2 m/s)
          if (velocityMagnitude > 2.0) {
            const currentDistance = botPos.distanceTo(this.playerPos);
            const estimatedTravelTime = currentDistance / throwForce;
            const predictedMovement = this.playerVelocity.clone().multiplyScalar(estimatedTravelTime * 0.3); // Only 30% prediction
            targetPos.add(predictedMovement);
            console.log(`Light prediction: Player moving fast (${velocityMagnitude.toFixed(2)} m/s)`);
          } else {
            console.log(`Direct aim: Target at player position`);
          }
          
          // Calculate throw direction
          let direction = new THREE.Vector3().subVectors(targetPos, botPos).normalize();
          
          // Bot accuracy - set to 100% accurate (no inaccuracy)
          let inaccuracy = 0; // 100% accurate - no spread
          
          // No inaccuracy applied - bot is perfectly accurate
          // direction.x += (Math.random() - 0.5) * inaccuracy;
          // direction.y += (Math.random() - 0.5) * inaccuracy;
          // direction.z += (Math.random() - 0.5) * inaccuracy;
          // direction.normalize(); // Already normalized above
          
          // Apply velocity to ball
          ballBody.velocity.set(
            direction.x * throwForce,
            direction.y * throwForce,
            direction.z * throwForce
          );
          
          // Add some spin
          ballBody.angularVelocity.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          
          // Log position info for debugging
          console.log(`Bot at: (${botPos.x.toFixed(1)}, ${botPos.y.toFixed(1)}, ${botPos.z.toFixed(1)})`);
          console.log(`Player target at: (${this.playerPos.x.toFixed(1)}, ${this.playerPos.y.toFixed(1)}, ${this.playerPos.z.toFixed(1)})`);

        },
        
        tick: function(time) {
          if (!this.data.enabled) return;
          
          // Safety check: Skip if no physics body (shouldn't happen after proper init)
          if (!this.body) {
            return;
          }
          
          // Update visual position from physics (Ammo.js)
          if (this.body && ammoInstance) {
            try {
              const transform = new ammoInstance.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const rotation = transform.getRotation();
              
              // Safety checks for valid transform data
              if (origin && typeof origin.x === 'function' && rotation && typeof rotation.x === 'function') {
                this.el.object3D.position.set(origin.x(), origin.y(), origin.z());
                this.el.object3D.quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w());
              }
              
              ammoInstance.destroy(transform);
            } catch (e) {
              debugLog(`‚ùå Bot physics update error: ${e.message}`, true);
              // Disable physics to prevent further errors
              this.physicsDisabled = true;
              this.body = null;
              return;
            }
          }
          
          // Track player movement for predictive aiming
          this.updatePlayerTracking(time);
          
          // Movement logic - only if physics is working
          if (this.body && !this.isMoving && time - this.lastMoveTime > this.moveInterval) {
            // console.log(`Bot preparing to move (${((time - this.lastMoveTime)/1000).toFixed(1)}s since last move)`); // Disabled to reduce console spam
            this.startMovementToTarget(time); // Pass current time
            this.lastMoveTime = time;
          }
          
          // Stop movement after duration
          if (this.body && this.isMoving && time - this.moveStartTime > this.moveDuration) {
            this.stopMovement();
          }
          
          // Throwing logic - only when match is active (can work without physics)
          const gameManager = this.el.sceneEl.querySelector('#game-manager');
          const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                               (gameManager.components['game-manager'].matchState === 'PLAYING' || 
                                gameManager.components['game-manager'].matchState === 'OVERTIME');
          
          if (isMatchActive && time - this.lastThrowTime > this.data.throwInterval) {
            // Ball throwing can work without bot physics
            this.throwBallAtPlayer();
            this.lastThrowTime = time;
          }
        },
        
        createAmmoPhysicsBody: function() {
          debugLog('üîß Creating Ammo.js physics body for bot');
          const Ammo = ammoInstance;
          
          // Create physics body normally - memory issues resolved
          
          // Create sphere shape
          const radius = 0.2;
          const shape = new Ammo.btSphereShape(radius);
          
          // Create rigid body
          const mass = 50; // 50kg bot
          const localInertia = new Ammo.btVector3(0, 0, 0);
          shape.calculateLocalInertia(mass, localInertia);
          
          const transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(0, 2, -10)); // Start at back of space
          
          const motionState = new Ammo.btDefaultMotionState(transform);
          const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
          this.body = new Ammo.btRigidBody(rigidBodyInfo);
          
          // Store element reference AFTER successful creation
          this.body.el = this.el;
          
          // Set damping
          this.body.setDamping(0.8, 0.8);
          
          // Add compatibility layer for Cannon.js API
          this.setupVelocityAPI();
          
          // Add to physics world
          physicsWorld.addRigidBody(this.body);
          
          // Store reference for physics object sync
          physicsObjects.push({
            entity: this.el,
            object3D: this.el.object3D,
            body: this.body
          });
          
          debugLog('‚úÖ Bot added to Ammo.js physics world');
        },

        setupVelocityAPI: function() {
          // Add Cannon.js-like velocity API to Ammo.js body
          const Ammo = ammoInstance;
          
          this.body.velocity = {
            set: (x, y, z) => {
              const velocity = new Ammo.btVector3(x, y, z);
              this.body.setLinearVelocity(velocity);
              Ammo.destroy(velocity);
            },
            length: () => {
              const vel = this.body.getLinearVelocity();
              const length = Math.sqrt(vel.x() * vel.x() + vel.y() * vel.y() + vel.z() * vel.z());
              return length;
            },
            scale: (factor, target) => {
              const vel = this.body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x() * factor, vel.y() * factor, vel.z() * factor);
              this.body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get x() {
              return this._body.getLinearVelocity().x();
            },
            set x(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(value, vel.y(), vel.z());
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get y() {
              return this._body.getLinearVelocity().y();
            },
            set y(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x(), value, vel.z());
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get z() {
              return this._body.getLinearVelocity().z();
            },
            set z(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x(), vel.y(), value);
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            _body: this.body
          };

          // Add position API compatibility
          this.body.position = {
            set: (x, y, z) => {
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setOrigin(new Ammo.btVector3(x, y, z));
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(transform);
            },
            copy: (vector3) => {
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setOrigin(new Ammo.btVector3(vector3.x, vector3.y, vector3.z));
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(transform);
            },
            get x() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const x = origin.x();
              Ammo.destroy(transform);
              return x;
            },
            get y() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const y = origin.y();
              Ammo.destroy(transform);
              return y;
            },
            get z() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const z = origin.z();
              Ammo.destroy(transform);
              return z;
            },
            _body: this.body
          };

          // Add quaternion API compatibility
          this.body.quaternion = {
            setFromEuler: (x, y, z) => {
              const rotation = new Ammo.btQuaternion();
              rotation.setEulerZYX(z, y, x); // Ammo uses ZYX order
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setRotation(rotation);
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(rotation);
              Ammo.destroy(transform);
            },
            copy: (quaternion) => {
              const rotation = new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setRotation(rotation);
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(rotation);
              Ammo.destroy(transform);
            },
            _body: this.body
          };
        },

        remove: function() {
          if (this.body && physicsWorld) {
            physicsWorld.removeRigidBody(this.body);
          }
        }
      });

      // Add sound manager component
      AFRAME.registerComponent('sound-manager', {
        init: function() {
          this.ballSounds = [];
          this.soundsInitialized = false;
          
          // Get all ball sounds
          this.el.sceneEl.querySelectorAll('[zerog-ball]').forEach(ball => {
            const sound = ball.querySelector('[sound]');
            if (sound) {
              this.ballSounds.push(sound);
              // Initially pause all sounds
              sound.components.sound.pauseSound();
            }
          });
          
          // Get bounce sound
          this.bounceSound = this.el.sceneEl.querySelector('#bounce-sound');
          if (this.bounceSound) {
            this.bounceSound.components.sound.pauseSound();
          }
          
          // Listen for game start
          this.el.sceneEl.addEventListener('gameStarted', () => {
            this.initializeSounds();
          });
          
          // Try to start sounds on first user interaction (helps with autoplay restrictions)
          this.el.sceneEl.addEventListener('abuttondown', () => {
            this.tryStartSounds();
          });
        },
        
        initializeSounds: function() {
          if (this.soundsInitialized) return;
          
          console.log('üîä Sound Manager: Initializing sounds...');
          console.log('üîä Found ball sounds:', this.ballSounds.length);
          
          // Resume AudioContext
          const audioContext = this.el.sceneEl.audioContext;
          console.log('üîä AudioContext state:', audioContext ? audioContext.state : 'not found');
          if (audioContext && audioContext.state === 'suspended') {
            console.log('üîä Resuming suspended AudioContext...');
            audioContext.resume();
          }
          
          // Start all ball hum sounds
          this.ballSounds.forEach((sound, index) => {
            console.log(`üîä Processing ball sound ${index}:`, sound.id);
            if (sound.id && (sound.id === 'red-ball-hum' || sound.id === 'blue-ball-hum')) {
              console.log(`üîä Starting hum sound: ${sound.id}`);
              try {
                sound.components.sound.playSound();
                console.log(`‚úÖ Successfully started: ${sound.id}`);
              } catch (e) {
                console.log(`‚ùå Failed to start: ${sound.id}`, e);
              }
            }
          });
          
          // Initialize bounce sound
          if (this.bounceSound) {
            console.log('üîä Initializing bounce sound...');
            try {
              this.bounceSound.components.sound.playSound();
              this.bounceSound.components.sound.pauseSound();
              console.log('‚úÖ Bounce sound initialized');
            } catch (e) {
              console.log('‚ùå Failed to initialize bounce sound:', e);
            }
          }
          
          this.soundsInitialized = true;
          console.log('üîä Sound initialization complete!');
        },
        
        // Add method to try starting sounds immediately on user interaction
        tryStartSounds: function() {
          console.log('üîä Trying to start sounds immediately...');
          this.initializeSounds();
        }
      });

      AFRAME.registerComponent('game-manager', {
        schema: {
          playerScore: { type: 'number', default: 0 },
          opponentScore: { type: 'number', default: 0 },
          gameStarted: { type: 'boolean', default: false }
        },
        init: function() {
          this.playerScore = 0;
          this.opponentScore = 0;
          this.gameStarted = false;
          
          // Match states: WAITING, COUNTDOWN, PLAYING, OVERTIME, ENDED
          this.matchState = 'WAITING';
          this.matchDuration = 180; // 3 minutes in seconds
          this.matchStartTime = 0;
          this.countdownTime = 3;
          this.countdownStartTime = 0;
          
          // Get references to the HUD displays
          this.scoreDisplay = this.el.querySelector('#score-display');
          this.startMessage = document.querySelector('#hud-message');
          this.timerDisplay = document.querySelector('#hud-timer');
          
          // Show initial message in HUD
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          
          // Hide score and timer displays initially
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
          // Listen for A button press on both controllers
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            if (this.matchState === 'WAITING') {
              if (isMultiplayerConnected()) {
                this.handleMultiplayerReady();
              } else {
                this.startCountdown();
              }
            } else if (this.matchState === 'ENDED') {
              this.resetMatch();
            }
          });
        },

        tick: function() {
          const currentTime = Date.now();
          
          if (this.matchState === 'COUNTDOWN') {
            const elapsed = (currentTime - this.countdownStartTime) / 1000;
            const remaining = Math.ceil(this.countdownTime - elapsed);
            
            if (remaining > 0) {
              this.startMessage.setAttribute('text', 'value', remaining.toString());
            } else {
              this.startMessage.setAttribute('text', 'value', 'GO!');
              setTimeout(() => {
                this.startMatch();
              }, 500);
            }
          } else if (this.matchState === 'PLAYING') {
            this.updateTimer();
          }
        },

        handleMultiplayerReady: function() {
          // Mark local player as ready
          multiplayerReady.local = true;
          sendReadyUpdate();
          this.updateReadyState();
        },

        updateReadyState: function() {
          if (!isMultiplayerConnected()) return;
          
          if (multiplayerReady.local && !multiplayerReady.remote) {
            this.startMessage.setAttribute('text', 'value', 'Waiting for other player...');
          } else if (!multiplayerReady.local && multiplayerReady.remote) {
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          } else           if (multiplayerReady.local && multiplayerReady.remote) {
            // Both ready - start countdown
            const startTime = Date.now();
            this.syncedStartCountdown(startTime);
            // Send countdown sync to other player
            sendToMultiplayer({ type: 'countdown-start', startTime: startTime });
          }
        },

        setMultiplayerWaiting: function() {
          this.matchState = 'WAITING';
          this.gameStarted = false;
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Show start message
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
          console.log('Multiplayer waiting for both players to be ready');
        },

        syncedStartCountdown: function(startTime) {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = startTime;
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset ready states
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Reset and respawn balls
          this.respawnBalls();
          
          console.log('Synchronized countdown started');
        },

        startCountdown: function() {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = Date.now();
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset and respawn balls
          this.respawnBalls();
          
          console.log('Match countdown started');
        },

        startMatch: function() {
          console.log('startMatch called - isMultiplayer:', isMultiplayer, 'connected:', isMultiplayerConnected());
          this.matchState = 'PLAYING';
          this.matchStartTime = Date.now();
          this.gameStarted = true;
          
          // Hide start message, show game UI
          if (this.startMessage) this.startMessage.setAttribute('visible', false);
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', true);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', true);
          
          // Show HUD score display, hide controls
          setGameplayHUD(true);
          
          // Reset scores
          this.playerScore = 0;
          this.opponentScore = 0;
          this.updateScore();
          
          // NEW: Activate tractor beam for 2 seconds at start
          this.activateStartTractorBeam();
          
          // Dispatch game started event to trigger sound initialization
          this.el.sceneEl.emit('gameStarted');
          
          console.log('Zero-G match started - 3 minutes, matchState set to PLAYING');
        },
        
        // NEW: Activate tractor beam for player's ball at start
        activateStartTractorBeam: function() {
          const playerBall = document.querySelector('[zerog-ball="player: player2"]');
          if (playerBall && playerBall.components['zerog-ball']) {
            playerBall.components['zerog-ball'].startAutoReturn();
            console.log('üî• Start tractor beam activated for player ball!');
          }
        },

        updateTimer: function() {
          if (!this.timerDisplay) return;
          
          const currentTime = Date.now();
          const elapsed = (currentTime - this.matchStartTime) / 1000;
          const remaining = Math.max(0, this.matchDuration - elapsed);
          
          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.timerDisplay.setAttribute('text', 'value', `Time: ${timeString}`);
          
          // Check if time is up
          if (remaining <= 0 && this.matchState === 'PLAYING') {
            // Use correct scores for multiplayer vs singleplayer
            let score1, score2;
            if (isMultiplayerConnected()) {
              score1 = multiplayerScore.local;
              score2 = multiplayerScore.remote;
            } else {
              score1 = this.playerScore;
              score2 = this.opponentScore;
            }
            
            if (score1 === score2) {
              this.startOvertime();
            } else {
              this.endMatch();
            }
          }
        },

        startOvertime: function() {
          this.matchState = 'OVERTIME';
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next hit wins!');
          }
          console.log('Match went to overtime - sudden death');
          
          // Sync overtime state in multiplayer
          if (isMultiplayerConnected()) {
            sendToMultiplayer({ type: 'game-state', state: 'OVERTIME' });
          }
        },

        endMatch: function() {
          this.matchState = 'ENDED';
          this.gameStarted = false;
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Determine winner
          let winner;
          if (isMultiplayerConnected()) {
            winner = multiplayerScore.local > multiplayerScore.remote ? 'You win!' : 'Opponent wins!';
          } else {
            winner = this.playerScore > this.opponentScore ? 'Player wins!' : 'Opponent wins!';
          }
          
          // Show end message
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', `${winner}\nPress A to play again`);
          }
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'Match ended');
          }
          
          // Sync end state in multiplayer
          if (isMultiplayerConnected()) {
            sendToMultiplayer({ type: 'game-state', state: 'ENDED', winner: winner });
          }
          
          console.log(`Zero-G match ended: ${winner}`);
        },

        resetMatch: function() {
          this.matchState = 'WAITING';
          this.playerScore = 0;
          this.opponentScore = 0;
          this.gameStarted = false;
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Reset multiplayer scores and ready states
          if (isMultiplayer) {
            multiplayerScore.local = 0;
            multiplayerScore.remote = 0;
            multiplayerReady.local = false;
            multiplayerReady.remote = false;
          }
          
          // Hide game UI, show start message
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          }
          
          console.log('Zero-G match reset to waiting state');
        },

        respawnBalls: function() {
          // Reset both balls to their spawn positions
          const blueBall = document.querySelector('[zerog-ball="player: player2"]');
          const redBall = document.querySelector('[zerog-ball="player: player1"]');
          
          if (blueBall && blueBall.components['zerog-ball']) {
            blueBall.components['zerog-ball'].resetPosition();
          }
          if (redBall && redBall.components['zerog-ball']) {
            redBall.components['zerog-ball'].resetPosition();
          }
          
          console.log('Zero-G balls respawned');
        },

        onPlayerHit: function() {
          console.log('üéØ onPlayerHit called - matchState:', this.matchState, 'isMultiplayer:', isMultiplayer, 'connected:', isMultiplayerConnected());
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            console.log('üéØ onPlayerHit: Game not in PLAYING/OVERTIME state, returning');
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastPlayerHitTime = this.lastPlayerHitTime || 0;
          this.playerHitCooldown = this.playerHitCooldown || 1000; // 1 second cooldown
          
          if (now - this.lastPlayerHitTime < this.playerHitCooldown) {
            console.log('üéØ onPlayerHit: Blocked by cooldown - last hit was', now - this.lastPlayerHitTime, 'ms ago');
            return;
          }
          
          this.lastPlayerHitTime = now;
          this._playerHitCount = (this._playerHitCount || 0) + 1;
          console.log('üéØ onPlayerHit #' + this._playerHitCount + ' - processing hit');
          
          if (isMultiplayerConnected()) {
            // HOST-AUTHORITATIVE SCORING: Only host handles scoring logic
            if (isHost) {
              multiplayerScore.local += 1;
              console.log('üéØ HOST onPlayerHit: Updated multiplayer score - local:', multiplayerScore.local, 'remote:', multiplayerScore.remote);
              updateScoreDisplayMultiplayer();
              updateHUDScore(multiplayerScore.local, multiplayerScore.remote, true);
              sendScoreUpdate();
            } else {
              console.log('üéØ CLIENT onPlayerHit: Ignoring - host handles scoring');
            }
          } else {
            this.playerScore += 1;
            console.log('üéØ onPlayerHit: Updated singleplayer score - player:', this.playerScore, 'opponent:', this.opponentScore);
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        onOpponentHit: function() {
          console.log('üî¥ onOpponentHit called - matchState:', this.matchState, 'isMultiplayer:', isMultiplayer, 'connected:', isMultiplayerConnected());
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            console.log('üî¥ onOpponentHit: Game not in PLAYING/OVERTIME state, returning');
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastOpponentHitTime = this.lastOpponentHitTime || 0;
          this.opponentHitCooldown = this.opponentHitCooldown || 1000; // 1 second cooldown
          
          if (now - this.lastOpponentHitTime < this.opponentHitCooldown) {
            console.log('üî¥ onOpponentHit: Blocked by cooldown - last hit was', now - this.lastOpponentHitTime, 'ms ago');
            return;
          }
          
          this.lastOpponentHitTime = now;
          this._opponentHitCount = (this._opponentHitCount || 0) + 1;
          console.log('üî¥ onOpponentHit #' + this._opponentHitCount + ' - processing hit');
          
          if (isMultiplayerConnected()) {
            // HOST-AUTHORITATIVE SCORING: Only host handles scoring logic
            if (isHost) {
              multiplayerScore.remote += 1;
              console.log('üî¥ HOST onOpponentHit: Updated multiplayer score - local:', multiplayerScore.local, 'remote:', multiplayerScore.remote);
              updateScoreDisplayMultiplayer();
              updateHUDScore(multiplayerScore.local, multiplayerScore.remote, true);
              sendScoreUpdate();
            } else {
              console.log('üî¥ CLIENT onOpponentHit: Ignoring - host handles scoring');
            }
          } else {
            this.opponentScore += 1;
            console.log('üî¥ onOpponentHit: Updated singleplayer score - player:', this.playerScore, 'opponent:', this.opponentScore);
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        updateScore: function() {
          if (isMultiplayerConnected()) {
            updateScoreDisplayMultiplayer();
            updateHUDScore(multiplayerScore.local, multiplayerScore.remote, true);
          } else {
            // In singleplayer, player is blue, opponent is red
            const blueScore = document.getElementById('blue-score');
            const redScore = document.getElementById('red-score');
            if (blueScore && redScore) {
              blueScore.setAttribute('text', 'value', this.playerScore.toString());
              redScore.setAttribute('text', 'value', this.opponentScore.toString());
            }
            // Update HUD score display
            updateHUDScore(this.playerScore, this.opponentScore, false);
          }
        }
      });

      // Physics update handled by Ammo.js updateAmmoPhysics() function

      // Impact effect component
      AFRAME.registerComponent('impact-effect', {
        schema: {
          color: { type: 'color', default: '#ffffff' }
        },
        init: function() {
          // Find the impact sphere within this entity
          this.impactSphere = this.el.querySelector('a-sphere[id$="-impact"]');
          if (!this.impactSphere) {
            console.warn('Impact sphere not found for:', this.el.id);
            return;
          }
        },
        
        playEffect: function() {
          if (!this.impactSphere) {
            console.warn('Cannot play effect - impact sphere not found');
            return;
          }
          
          // Play impact sound at the world position of the hit target
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            const worldPosition = new THREE.Vector3();
            this.el.object3D.getWorldPosition(worldPosition);
            impactSound.object3D.position.copy(worldPosition);
            console.log('üîä Impact sound positioned at:', worldPosition.x.toFixed(1), worldPosition.y.toFixed(1), worldPosition.z.toFixed(1));
            impactSound.components.sound.playSound();
          }
          
          // Reset impact sphere state
          this.impactSphere.setAttribute('radius', 0.1);
          this.impactSphere.setAttribute('material', 'opacity', 0.5);
          this.impactSphere.setAttribute('visible', true);
          
          // Trigger the animations
          this.impactSphere.emit('impact');
          
          // Note: Scoring is handled by the zerog-ball component collision detection
          
          // Reset after animation completes
          setTimeout(() => {
            this.impactSphere.setAttribute('visible', false);
            this.impactSphere.setAttribute('material', 'opacity', 0);
            this.impactSphere.setAttribute('radius', 0.1);
          }, 1000);
        }
      });

      // B button for menu system
      AFRAME.registerComponent('menu-toggle', {
        init: function() {
          this.menuVisible = false;
          this.lastBButtonPress = 0;
          
          // B button to toggle menu with debouncing
          this.el.sceneEl.addEventListener('bbuttondown', () => {
            const now = Date.now();
            if (now - this.lastBButtonPress < 500) return; // 500ms debounce
            this.lastBButtonPress = now;
            this.toggleMenu();
          });
        },

        toggleMenu: function() {
          this.menuVisible = !this.menuVisible;
          isMenuVisible = this.menuVisible; // Update global state
          
          const menu = document.querySelector('#game-menu');
          const leftHand = document.querySelector('#leftHand');
          const rightHand = document.querySelector('#rightHand');
          
          // Toggle menu visibility
          if (menu) {
            menu.setAttribute('visible', this.menuVisible);
          }
          
          // Toggle HUD layers - only show one at a time
          this.toggleHUDLayers(this.menuVisible);
          
          // Show/hide laser pointers based on menu visibility
          const leftRaycastSettings = `objects: .clickable; lineColor: #ffffff; lineOpacity: ${this.menuVisible ? 1 : 0}; far: 10`;
          const rightRaycastSettings = `objects: .clickable; lineColor: #ffffff; lineOpacity: ${this.menuVisible ? 1 : 0}; far: 10`;
          
          if (leftHand) {
            leftHand.setAttribute('raycaster', leftRaycastSettings);
            console.log('Left hand raycaster set to:', leftRaycastSettings);
            
            // If opening menu, force disable any active thrusters
            if (this.menuVisible) {
              const leftThruster = leftHand.querySelector('.thruster-vfx');
              if (leftThruster) leftThruster.setAttribute('visible', false);
            }
          }
          if (rightHand) {
            rightHand.setAttribute('raycaster', rightRaycastSettings);
            console.log('Right hand raycaster set to:', rightRaycastSettings);
            
            // If opening menu, force disable any active thrusters
            if (this.menuVisible) {
              const rightThruster = rightHand.querySelector('.thruster-vfx');
              if (rightThruster) rightThruster.setAttribute('visible', false);
            }
          }
          
          // Reset thruster states when menu opens
          if (this.menuVisible) {
            const zerogPlayer = document.querySelector('[zerog-player]');
            if (zerogPlayer && zerogPlayer.components['zerog-player']) {
              const player = zerogPlayer.components['zerog-player'];
              player.thrusterActive.left = false;
              player.thrusterActive.right = false;
            }
          }
          
          console.log('Menu toggled:', this.menuVisible ? 'ON' : 'OFF');
          console.log('HUD layers:', this.menuVisible ? 'MENU ONLY' : 'GAME ONLY');
          console.log('Laser pointers:', this.menuVisible ? 'VISIBLE' : 'HIDDEN');
          console.log('Thruster mode:', this.menuVisible ? 'DISABLED' : 'ENABLED');
          
          // When menu closes, refresh HUD to apply any changes made during menu interaction
          if (!this.menuVisible) {
            this.refreshGameHUD();
          }
        },

        toggleHUDLayers: function(showMenu) {
          // Game HUD elements (hidden when menu is shown)
          const gameHudElements = [
            '#version-display',
            '#hud-status', 
            '#hud-score',
            '#hud-timer',
            '#hud-message'
          ];
          
          // Toggle game HUD visibility
          gameHudElements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
              element.setAttribute('visible', !showMenu);
            }
          });
          
          // Menu HUD (the menu itself) is handled in the main toggleMenu function
          
          console.log('Game HUD elements:', !showMenu ? 'VISIBLE' : 'HIDDEN');
          console.log('Menu HUD:', showMenu ? 'VISIBLE' : 'HIDDEN');
        },

        refreshGameHUD: function() {
          // Refresh the game HUD based on current game state
          setTimeout(() => {
            const gameManager = document.querySelector('#game-manager');
            const isMatchActive = gameManager && gameManager.components['game-manager'] && 
                                 gameManager.components['game-manager'].gameStarted;
            
                      console.log('üîÑ Refreshing HUD - isMatchActive:', isMatchActive, 'isMultiplayer:', isMultiplayer, 'connected:', isMultiplayerConnected());
          
          if (isMatchActive) {
            // Match is active - show gameplay HUD
            setGameplayHUD(true);
          } else if (isMultiplayerConnected()) {
              // Multiplayer connected but no match - set waiting state
              setGameplayHUD(false);
              if (gameManager && gameManager.components['game-manager']) {
                gameManager.components['game-manager'].setMultiplayerWaiting();
              }
            } else {
              // Singleplayer or no connection - show default state
              setGameplayHUD(false);
              
              // Ensure "Press A to Start" message is visible in default state
              const hudMessage = document.querySelector('#hud-message');
              if (hudMessage) {
                hudMessage.setAttribute('visible', true);
                hudMessage.setAttribute('text', 'value', 'Press A to Start');
              }
            }
            
            console.log('üîÑ Game HUD refreshed after menu close');
          }, 100); // Small delay to ensure menu state is fully updated
        }
      });

      // Multiplayer connection logic (slot-based, PeerJS, TURN support)
      async function startMultiplayerConnection() {
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        isMultiplayer = false;
        try {
          // Use correct slot type based on player count
          const slotType = gameConfig.playerCount === 4 ? multiplayerStartType + '_4p' : multiplayerStartType;
          console.log(`üîç Starting multiplayer connection with slotType: "${slotType}" for ${gameConfig.playerCount}-player mode`);
          
          const slot = await findAvailableSlot(slotType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            if (gameConfig.playerCount === 4) {
              await setupFourPlayerHost(multiplayerSlot);
            } else {
              await setupTwoPlayerHost(multiplayerSlot);
            }
          } else {
            if (gameConfig.playerCount === 4) {
              await setupFourPlayerClient(multiplayerSlot);
            } else {
              await setupTwoPlayerPeer(multiplayerSlot);
            }
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      async function checkPeerAvailability(id) {
        console.log(`üîç Checking PeerJS availability for ID: "${id}"`);
        return new Promise((resolve) => {
          const tempPeer = new Peer(id, { host: "0.peerjs.com", port: 443, secure: true });
          const timeout = setTimeout(() => {
            console.log(`‚è∞ Timeout checking availability for "${id}" - assuming available`);
            tempPeer.destroy();
            resolve(false);
          }, 2000);
          tempPeer.on("open", () => {
            console.log(`‚úÖ PeerJS ID "${id}" is AVAILABLE (not in use)`);
            clearTimeout(timeout);
            tempPeer.destroy();
            resolve(true);
          });
          tempPeer.on("error", (err) => {
            console.log(`‚ùå PeerJS ID "${id}" error: ${err.type} - ${err.message}`);
            clearTimeout(timeout);
            tempPeer.destroy();
            if (err.type === 'unavailable-id') {
              console.log(`üîí PeerJS ID "${id}" is UNAVAILABLE (in use)`);
              resolve(false);
            } else {
              console.log(`‚ö†Ô∏è PeerJS ID "${id}" other error - assuming available`);
              resolve(true);
            }
          });
        });
      }

      async function findAvailableSlot(desiredStartType) {
        console.log(`üîç findAvailableSlot called with desiredStartType: "${desiredStartType}"`);
        
        // Check if this is 4-player mode
        const is4Player = desiredStartType.includes('_4p');
        
        if (is4Player) {
          // For 4-player mode, first try to find an existing host to join
          console.log(`üîç 4-player mode: Looking for existing hosts to join first`);
          
          for (let i = 1; i <= MAX_LOBBIES; i++) {
            const hostId = `zerog-host-${desiredStartType}-${i}`;
            
            console.log(`üîç Checking slot ${i} for existing host: ${hostId}`);
            const hostAvailable = await checkPeerAvailability(hostId);
            
            if (!hostAvailable) {
              // Host exists, we can join it (multiple clients can join same host)
              console.log(`‚úÖ Found existing host at slot ${i}, joining as client`);
              return { slotNumber: i, role: 'client' };
            } else {
              console.log(`üîç No host at slot ${i}, will check if we should become host`);
            }
          }
          
          // No existing hosts found, become a new host
          console.log(`üîç No existing hosts found, looking for available host slot`);
          for (let i = 1; i <= MAX_LOBBIES; i++) {
            const hostId = `zerog-host-${desiredStartType}-${i}`;
            const hostAvailable = await checkPeerAvailability(hostId);
            
            if (hostAvailable) {
              console.log(`‚úÖ Host available at slot ${i}, becoming new host`);
              return { slotNumber: i, role: 'host' };
            }
          }
        } else {
          // 2-player mode: original logic
          for (let i = 1; i <= MAX_LOBBIES; i++) {
            const hostId = `zerog-host-${desiredStartType}-${i}`;
            const clientId = is4Player ? `zerog-client-${desiredStartType}-${i}` : `zerog-peer-${desiredStartType}-${i}`;
            
            console.log(`üîç Checking slot ${i} - Host: ${hostId}, Client: ${clientId}, desiredStartType: ${desiredStartType}`);
            
            const hostAvailable = await checkPeerAvailability(hostId);
            console.log(`üîç Slot ${i} - Host "${hostId}" available: ${hostAvailable}`);
            
            if (hostAvailable) {
              console.log(`‚úÖ Host available at slot ${i}`);
              return { slotNumber: i, role: 'host' };
            } else {
              const clientAvailable = await checkPeerAvailability(clientId);
              console.log(`üîç Slot ${i} - Client "${clientId}" available: ${clientAvailable}`);
              
              if (clientAvailable) {
                console.log(`‚úÖ Client available at slot ${i}`);
                return { slotNumber: i, role: is4Player ? 'client' : 'peer' };
              }
            }
          }
        }
        
        console.log('‚ùå No available slots found');
        return null;
      }

      // Setup 2-player host (original logic)
      async function setupTwoPlayerHost(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = true;
        sessionID = `zerog-host-${multiplayerStartType}-${slotNumber}`;
        
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev/");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        
        peer.on("open", function() {
          updateMultiplayerStatus('Waiting for opponent...');
          peer.on("connection", function(newConn) {
            if (connections.has('player_1')) {
              newConn.close();
            } else {
              connections.set('player_1', newConn);
              newConn.on("open", function() {
                setupConnectionHandlers(newConn, 'player_1');
                onMultiplayerStart();
              });
            }
          });
        });
        
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Host error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      // Setup 2-player peer (original logic)
      async function setupTwoPlayerPeer(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = false;
        sessionID = `zerog-peer-${multiplayerStartType}-${slotNumber}`;
        
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        
        peer.on("open", function() {
          updateMultiplayerStatus('Connecting to host...');
          const hostID = `zerog-host-${multiplayerStartType}-${slotNumber}`;
          const conn = peer.connect(hostID);
          connections.set('host', conn);
          
          conn.on("open", function() {
            setupConnectionHandlers(conn, 'host');
            onMultiplayerStart();
          });
        });
        
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      // Setup 4-player host (new star topology)
      async function setupFourPlayerHost(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = true;
        sessionID = `zerog-host-${multiplayerStartType}_4p-${slotNumber}`;
        console.log(`üéØ 4-player host starting with sessionID: "${sessionID}"`);
        
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev/");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        
                          peer.on("open", function() {
          console.log(`‚úÖ 4-player host successfully registered with PeerJS: "${sessionID}"`);
          updateMultiplayerStatus('Waiting for players...');
          console.log(`üéØ 4-player host started with sessionID: ${sessionID}`);
          console.log(`üëÇ Host listening for incoming connections...`);
          
          // Host is always active player 0
          activePlayers.add('player_0');
          console.log(`üë§ Host added as player_0 to active players`);
            
                        peer.on("connection", function(newConn) {
              console.log(`üîó Host received incoming connection from: ${newConn.peer}`);
              
              // Find the first available slot (excluding slot 0 which is the host)
              let assignedSlot = null;
              for (let slotNumber = 1; slotNumber < gameConfig.playerCount; slotNumber++) {
                const playerId = `player_${slotNumber}`;
                const player = players.get(playerId);
                console.log(`üîç Checking slot ${slotNumber}: player ${playerId} - connected: ${player?.isConnected}`);
                if (!player || !player.isConnected) {
                  assignedSlot = slotNumber;
                  console.log(`‚úÖ Found available slot ${slotNumber} for player ${playerId}`);
                  break;
                }
              }
              
              if (assignedSlot === null) {
                console.log('‚ùå No available slots, rejecting connection');
                console.log('üîç Current players:', Array.from(players.entries()));
                console.log('üîç Active players:', Array.from(activePlayers));
                newConn.close(); // No available slots
                return;
              }
            
            const playerId = `player_${assignedSlot}`;
            const slot = playerSlots[assignedSlot];
            console.log(`‚úÖ Assigning connection to slot ${assignedSlot} (${slot.name}) - ${slot.color}`);
            connections.set(playerId, newConn);
            
            newConn.on("open", function() {
              console.log(`üîó ${slot.name} (${playerId}) connected successfully in slot ${assignedSlot}`);
              setupConnectionHandlers(newConn, playerId);
              
              // Mark player as connected
              const player = players.get(playerId);
              if (player) {
                player.isConnected = true;
                player.isBot = false;
                activePlayers.add(playerId);
                
                // Remove from bot players if it was filled by a bot
                if (botPlayers.has(playerId)) {
                  botPlayers.delete(playerId);
                }
                
                console.log(`üë§ ${slot.name} assigned to slot ${assignedSlot} with color ${slot.color}`);
              }
              
              // Update player count display
              updatePlayerCountDisplay();
              
              // Send player count update to all clients
              sendPlayerCountUpdate();
              
              // Check if ready to start
              const connectedCount = Array.from(activePlayers).filter(id => players.get(id)?.isConnected).length;
              console.log(`üéÆ Connected players: ${connectedCount} (minimum 2 to start)`);
              if (connectedCount >= 2) { // Minimum 2 players to start
                console.log('üöÄ Starting multiplayer with', connectedCount, 'players');
                onMultiplayerStart();
              } else {
                // Update status to show waiting for more players
                updateMultiplayerStatus(`Waiting for players... (${connectedCount}/${gameConfig.playerCount})`);
              }
            });
          });
        });
        
        peer.on("error", function(err) {
          console.log(`‚ùå 4-player host error: ${err.type} - ${err.message}`);
          updateMultiplayerStatus(`Host error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      // Setup 4-player client (connects to host only)
      async function setupFourPlayerClient(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = false;
        
        // Generate unique client ID with timestamp and random suffix to avoid conflicts
        const timestamp = Date.now();
        const randomSuffix = Math.floor(Math.random() * 10000);
        sessionID = `zerog-client-${multiplayerStartType}_4p-${slotNumber}-${timestamp}-${randomSuffix}`;
        console.log(`üîó 4-player client starting with sessionID: "${sessionID}"`);
        
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        
        peer.on("open", function() {
          console.log(`‚úÖ 4-player client successfully registered with PeerJS: "${sessionID}"`);
          updateMultiplayerStatus('Connecting to host...');
          const hostID = `zerog-host-${multiplayerStartType}_4p-${slotNumber}`;
          console.log(`üîó 4-player client connecting to host: ${hostID}`);
          console.log(`üîç Client sessionID: ${sessionID}, HostID: ${hostID}`);
          
          // Add retry logic for connection
          let retryCount = 0;
          const maxRetries = 3;
          
          const attemptConnection = () => {
            console.log(`üîÑ Connection attempt ${retryCount + 1}/${maxRetries + 1} to host: ${hostID}`);
            const conn = peer.connect(hostID);
            connections.set('host', conn);
            
            console.log(`üì° Client attempting connection to host...`);
            
            conn.on("open", function() {
              console.log(`‚úÖ Successfully connected to host: ${hostID}`);
              console.log(`ü§ù Connection established - client ready to communicate`);
              setupConnectionHandlers(conn, 'host');
              
              // Request current player count from host for 4-player mode
              if (gameConfig.playerCount === 4) {
                console.log('üì§ Requesting player count from host');
                conn.send({ type: 'request-player-count' });
              }
              
              onMultiplayerStart();
            });
            
            conn.on("close", function() {
              console.log(`üîå Connection to host closed`);
            });
            
            conn.on("error", function(err) {
              console.log(`‚ùå Connection attempt ${retryCount + 1} failed: ${err.type} - ${err.message}`);
              retryCount++;
              
              if (retryCount <= maxRetries) {
                console.log(`üîÑ Retrying connection in 2 seconds...`);
                setTimeout(attemptConnection, 2000);
              } else {
                console.log(`‚ùå All connection attempts failed. Ending multiplayer.`);
                updateMultiplayerStatus('Failed to connect to host. Try again.');
                setTimeout(() => {
                  endMultiplayer();
                }, 100);
              }
            });
          };
          
          attemptConnection();
        });
        
        peer.on("error", function(err) {
          console.log(`‚ùå 4-player client error: ${err.type} - ${err.message}`);
          updateMultiplayerStatus(`Client error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      async function setupPeer(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = false;
        
        // Generate unique client ID with timestamp and random suffix to avoid conflicts
        const timestamp = Date.now();
        const randomSuffix = Math.floor(Math.random() * 10000);
        sessionID = `zerog-peer-${multiplayerStartType}-${slotNumber}-${timestamp}-${randomSuffix}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {
          console.log('TURN server proxy not available, using fallback STUN servers:', e.message);
          // Fallback to basic STUN servers if TURN proxy fails
          iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
        }
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Connecting to host...');
          const hostID = `zerog-host-${multiplayerStartType}-${slotNumber}`;
          const conn = peer.connect(hostID);
          connections.set('host', conn);
          
          conn.on("open", function() {
            setupConnectionHandlers(conn, 'host');
            onMultiplayerStart();
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      async function setupHost(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = true;
        sessionID = `zerog-host-${multiplayerStartType}-${slotNumber}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev/");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {
          console.log('TURN server proxy not available, using fallback STUN servers:', e.message);
          // Fallback to basic STUN servers if TURN proxy fails
          iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
        }
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Waiting for players...');
          peer.on("connection", function(newConn) {
            // Add to connections map with unique player ID
            const playerId = `player_${connections.size + 1}`; // +1 because connections.size starts at 0
            connections.set(playerId, newConn);
            
            console.log(`üîó New client connected: ${playerId}`);
            
            newConn.on("open", function() {
              console.log(`‚úÖ Client ${playerId} connection established`);
              setupConnectionHandlers(newConn, playerId);
              
              // Mark this player as connected
              const player = players.get(playerId);
              if (player) {
                player.isConnected = true;
                activePlayers.add(playerId);
                console.log(`üë§ Player ${playerId} marked as connected`);
              }
              
              // Update player count and send to all clients
              if (gameConfig.playerCount === 4) {
                sendPlayerCountUpdate();
              }
              
              // Only call onMultiplayerStart once when first client connects
              if (connections.size === 1) {
                onMultiplayerStart();
              }
              
              // Update host status when clients connect
              if (isHost && gameConfig.playerCount === 4) {
                const totalCount = Array.from(connections.keys()).filter(k => k.startsWith('player_')).length + 1;
                const statusText = `Multiplayer Connected (${totalCount}/${gameConfig.playerCount})`;
                multiplayerStatus = statusText;
                updateMultiplayerStatus(statusText);
                
                // Update menu display
                const currentModeDisplay = document.querySelector('#menu-current-mode');
                if (currentModeDisplay) {
                  currentModeDisplay.setAttribute('text', 'value', `Mode: ${statusText}`);
                  currentModeDisplay.setAttribute('text', 'color', '#ffffff');
                }
                
                console.log(`üë• Host updated status: ${totalCount}/${gameConfig.playerCount} players`);
              }
            });
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function setupConnectionHandlers(conn, playerId) {
        conn.on('data', (data) => {
          if (data.type === 'player-state') {
            if (isHost && gameConfig.playerCount === 4) {
              // Host relays player state to all other clients
              console.log(`üì® Host received player state from ${playerId}:`, data.state.x.toFixed(1), data.state.y.toFixed(1), data.state.z.toFixed(1));
              
              // Relay to ALL clients (including the sender for consistency)
              connections.forEach((otherConn, otherPlayerId) => {
                if (otherConn && otherConn.open) {
                  const relayData = {
                    type: 'player-state',
                    state: data.state,
                    playerId: playerId
                  };
                  otherConn.send(relayData);
                  console.log(`üì§ Host relayed ${playerId} state to ${otherPlayerId}`);
                }
              });
              
              // Also store for local display
              remotePlayerStates.set(playerId, data.state);
            } else {
              // Client or 2-player mode: store directly
              const receivedPlayerId = data.playerId || playerId || 'opponent';
              remotePlayerStates.set(receivedPlayerId, data.state);
              console.log(`üì® Received player state from ${receivedPlayerId}:`, data.state.x.toFixed(1), data.state.y.toFixed(1), data.state.z.toFixed(1));
            }
          } else if (data.type === 'ball-state') {
            if (isHost && gameConfig.playerCount === 4) {
              // Host relays ball state to all other clients
              console.log(`üì® Host received ball state from ${playerId}`);
              
              // Relay to ALL clients (including the sender for consistency)
              connections.forEach((otherConn, otherPlayerId) => {
                if (otherConn && otherConn.open) {
                  const relayData = {
                    type: 'ball-state',
                    state: data.state,
                    playerId: playerId
                  };
                  otherConn.send(relayData);
                  console.log(`üì§ Host relayed ${playerId} ball state to ${otherPlayerId}`);
                }
              });
              
              // Also store for local display
              remoteBallStates.set(playerId, data.state);
            } else {
              // Client or 2-player mode: store directly
              const receivedPlayerId = data.playerId || playerId || 'opponent';
              remoteBallStates.set(receivedPlayerId, data.state);
              console.log(`üì® Received ball state from ${receivedPlayerId}`);
            }
          } else if (data.type === 'score-update') {
            console.log('üì® CLIENT received score-update:', data.score, '‚Üí setting local:', data.score.remote, 'remote:', data.score.local);
            // Mirror remote/local for display (client displays what host sends)
            multiplayerScore.remote = data.score.local;
            multiplayerScore.local = data.score.remote;
            updateScoreDisplayMultiplayer();
            updateHUDScore(multiplayerScore.local, multiplayerScore.remote, true);
          } else if (data.type === 'ready-update') {
            // Sync ready state
            multiplayerReady.remote = data.ready;
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].updateReadyState();
            }
          } else if (data.type === 'countdown-start') {
            // Sync countdown start
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].syncedStartCountdown(data.startTime);
            }
          } else if (data.type === 'game-state') {
            // Sync game state changes (overtime/end)
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              const gm = gameManager.components['game-manager'];
              gm.matchState = data.state;
              
              if (data.state === 'OVERTIME') {
                gm.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next hit wins!');
                console.log('Synced: Match went to overtime');
              } else if (data.state === 'ENDED') {
                // Flip the winner message for the receiving player
                const flippedWinner = data.winner.includes('You win!') ? 'Opponent wins!' : 'You win!';
                gm.startMessage.setAttribute('visible', true);
                gm.startMessage.setAttribute('text', 'value', `${flippedWinner}\nPress A to play again`);
                gm.timerDisplay.setAttribute('text', 'value', 'Match ended');
                gm.gameStarted = false;
                console.log('Synced: Match ended -', flippedWinner);
              }
            }
          } else if (data.type === 'player-count-update') {
            // Host sends total player count to clients
            if (!isHost && gameConfig.playerCount === 4) {
              const totalCount = data.totalCount;
              const statusText = `Multiplayer Connected (${totalCount}/${gameConfig.playerCount})`;
              multiplayerStatus = statusText;
              updateMultiplayerStatus(statusText);
              
              // Update menu display
              const currentModeDisplay = document.querySelector('#menu-current-mode');
              if (currentModeDisplay) {
                currentModeDisplay.setAttribute('text', 'value', `Mode: ${statusText}`);
                currentModeDisplay.setAttribute('text', 'color', '#ffffff');
              }
              
              console.log(`üë• Received player count update from host: ${totalCount}/${gameConfig.playerCount}`);
            }
          } else if (data.type === 'request-player-count') {
            // Client requests current player count from host
            if (isHost && gameConfig.playerCount === 4) {
              const totalCount = Array.from(connections.keys()).filter(k => k.startsWith('player_')).length + 1;
              conn.send({ type: 'player-count-update', totalCount });
              console.log(`üì§ Host responded to player count request: ${totalCount}/${gameConfig.playerCount}`);
            }
          }
        });
        conn.on('close', () => {
          console.log(`üîå Connection closed for ${playerId}`);
          
          // Mark player as disconnected and free up the slot
          const player = players.get(playerId);
          if (player) {
            const slot = playerSlots[player.slotNumber];
            console.log(`üì§ ${slot.name} (slot ${player.slotNumber}) disconnected`);
            
            player.isConnected = false;
            activePlayers.delete(playerId);
            connections.delete(playerId);
            
            // For 4-player mode, try to replace with bot if enabled
            if (gameConfig.playerCount === 4 && gameConfig.botReplaceEnabled) {
              player.isBot = true;
              botPlayers.add(playerId);
              activePlayers.add(playerId); // Keep active but as bot
              console.log(`ü§ñ Bot replacement activated for slot ${player.slotNumber} (${slot.name})`);
              
              // Update player count display
              updatePlayerCountDisplay();
              
              // Send player count update to all clients
              sendPlayerCountUpdate();
              
              return; // Don't end multiplayer, just replace with bot
            } else {
              // Remove from bot players if it was a bot
              botPlayers.delete(playerId);
              console.log(`üö™ Slot ${player.slotNumber} (${slot.name}) is now available`);
            }
          }
          
          // For 2-player mode or when bot replacement is disabled, end multiplayer if no other players
          const connectedCount = Array.from(activePlayers).filter(id => players.get(id)?.isConnected).length;
          if (connectedCount < 2) {
            updateMultiplayerStatus('Connection lost. Returning to singleplayer.');
            setTimeout(() => {
              endMultiplayer();
            }, 100);
          } else {
            // Update player count display
            updatePlayerCountDisplay();
            sendPlayerCountUpdate();
            
            // Update host status when clients disconnect (4-player mode)
            if (isHost && gameConfig.playerCount === 4) {
              const totalCount = Array.from(connections.keys()).filter(k => k.startsWith('player_')).length + 1;
              const statusText = `Multiplayer Connected (${totalCount}/${gameConfig.playerCount})`;
              multiplayerStatus = statusText;
              updateMultiplayerStatus(statusText);
              
              // Update menu display
              const currentModeDisplay = document.querySelector('#menu-current-mode');
              if (currentModeDisplay) {
                currentModeDisplay.setAttribute('text', 'value', `Mode: ${statusText}`);
                currentModeDisplay.setAttribute('text', 'color', '#ffffff');
              }
              
              console.log(`üë• Host updated status after disconnect: ${totalCount}/${gameConfig.playerCount} players`);
            }
          }
        });
        conn.on('error', (err) => {
          updateMultiplayerStatus('Connection error. Returning to singleplayer.');
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function sendPlayerState(state) {
        sendToMultiplayer({ type: 'player-state', state, playerId: state.playerId });
      }
      function sendBallState(state) {
        sendToMultiplayer({ type: 'ball-state', state, playerId: state.playerId });
      }
      
      function sendPlayerCountUpdate() {
        if (isHost && gameConfig.playerCount === 4) {
          const connectedCount = Array.from(connections.keys()).filter(k => k.startsWith('player_')).length + 1;
          const updateData = { 
            type: 'player-count-update', 
            totalCount: connectedCount,
            slotInfo: getSlotInfo()
          };
          console.log(`üì§ Host sending player count update: ${connectedCount}/${gameConfig.playerCount} to ${connections.size} connections`);
          
          sendToMultiplayer(updateData);
          console.log(`üì§ Host sent player count update: ${connectedCount}/${gameConfig.playerCount}`);
        }
      }

      // Get current slot information for display
      function getSlotInfo() {
        const slotInfo = {};
        for (let i = 0; i < gameConfig.playerCount; i++) {
          const playerId = `player_${i}`;
          const player = players.get(playerId);
          const slot = playerSlots[i];
          
          if (player) {
            slotInfo[i] = {
              name: slot.name,
              color: slot.color,
              isConnected: player.isConnected,
              isBot: player.isBot,
              status: player.isConnected ? (player.isBot ? 'Bot' : 'Player') : 'Empty'
            };
          }
        }
        return slotInfo;
      }

      function onMultiplayerStart() {
        // Only fully start multiplayer when connection is established
        if (isMultiplayerConnected()) {
          isMultiplayer = true;
          
          // Fill remaining slots with bots if enabled and we have real players
          if (gameConfig.botFillEnabled && gameConfig.playerCount === 4) {
            fillRemainingSlotsWithBots();
          }
          
          // Calculate connected player count for status display
          let connectedCount = 1; // Local player
          if (gameConfig.playerCount === 2) {
            // 2-player mode: check if we have a connection
            if (connections.size > 0 && Array.from(connections.values()).some(conn => conn && conn.open)) {
              connectedCount = 2;
            }
          } else {
            // 4-player mode: count active connections + local player
            connectedCount = Array.from(connections.keys()).filter(k => k.startsWith('player_')).length + 1;
          }
          
          // Update status with player count
          if (gameConfig.playerCount === 2) {
            multiplayerStatus = 'Multiplayer Connected';
            updateMultiplayerStatus('Multiplayer Connected');
          } else {
            // For 4-player mode, only update status if we're not the host
            // Host status is updated separately when clients connect
            if (!isHost) {
              multiplayerStatus = `Multiplayer Connected (${connectedCount}/${gameConfig.playerCount})`;
              updateMultiplayerStatus(`Multiplayer Connected (${connectedCount}/${gameConfig.playerCount})`);
            }
          }
          
          isSearchingForMatch = false;
          
          // Update menu display (always safe to update)
          const currentModeDisplay = document.querySelector('#menu-current-mode');
          if (currentModeDisplay) {
            if (gameConfig.playerCount === 2) {
              currentModeDisplay.setAttribute('text', 'value', 'Mode: Multiplayer Connected');
            } else {
              // For 4-player mode, only update menu if we're not the host
              // Host menu is updated separately when clients connect
              if (!isHost) {
                currentModeDisplay.setAttribute('text', 'value', `Mode: Multiplayer Connected (${connectedCount}/${gameConfig.playerCount})`);
              }
            }
            if (!isHost || gameConfig.playerCount === 2) {
              currentModeDisplay.setAttribute('text', 'color', '#ffffff');
            }
          }
          
          // Always reset multiplayer score state (safe to do)
          multiplayerScore = { local: 0, remote: 0 };
          multiplayerReady = { local: false, remote: false };
          updateScoreDisplayMultiplayer();
          
          // Only update game state if menu is closed
          if (!isMenuVisible) {
            // Set game to waiting for ready state
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].setMultiplayerWaiting();
            }
          } else {
            console.log('üö´ onMultiplayerStart: Game state updates deferred - menu is open');
          }
          
          console.log(`üéÆ Multiplayer started with ${connectedCount}/${gameConfig.playerCount} players`);
          
          // Ensure all connected players are visible
          ensureConnectedPlayersVisible();
        }
      }
      
      // Helper: ensure all connected players are visible
      function ensureConnectedPlayersVisible() {
        if (gameConfig.playerCount === 4) {
          console.log('üë• Ensuring all connected players are visible...');
          
          // Hide bot
          const bot = document.querySelector('#zerog-bot');
          if (bot) {
            bot.setAttribute('visible', false);
            if (bot.components['zerog-bot']) {
              bot.setAttribute('zerog-bot', 'enabled', false);
            }
          }
          
          // Show all connected players
          for (let i = 1; i < gameConfig.playerCount; i++) {
            const playerId = `player_${i}`;
            const player = players.get(playerId);
            if (player && player.isConnected && player.entityId) {
              const playerEntity = document.querySelector(`#${player.entityId}`);
              if (playerEntity) {
                playerEntity.setAttribute('visible', true);
                console.log(`üë§ Made ${player.entityId} visible for connected player ${playerId}`);
              }
            }
          }
        }
      }
      
      function endMultiplayer() {
        isMultiplayer = false;
        isHost = false;
        multiplayerStatus = 'Singleplayer';
        updateMultiplayerStatus('Singleplayer');
        cleanupMultiplayer();
        isSearchingForMatch = false;
        
        // Update menu display (always safe to update)
        const currentModeDisplay = document.querySelector('#menu-current-mode');
        if (currentModeDisplay) {
          currentModeDisplay.setAttribute('text', 'value', 'Mode: Singleplayer');
          currentModeDisplay.setAttribute('text', 'color', '#ffffff');
        }
        
        // CRITICAL: Re-enable bot for singleplayer (always safe to do)
        const opponent = document.querySelector('#player-1');
        const bot = document.querySelector('#zerog-bot');
        
        if (opponent) {
          opponent.setAttribute('visible', false);
        }
        if (bot) {
          bot.setAttribute('visible', true);
          if (bot.components['zerog-bot']) {
            bot.setAttribute('zerog-bot', 'enabled', true);
          }
        }
        
        // Only update game HUD if menu is closed
        if (!isMenuVisible) {
          // Reset to singleplayer display
          setGameplayHUD(false);
          
          // Reset game manager
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            const gm = gameManager.components['game-manager'];
            gm.resetMatch();
          }
        } else {
          console.log('üö´ endMultiplayer: Game HUD updates deferred - menu is open');
        }
        
        // Always reset multiplayer score state (safe to do)
        multiplayerScore = { local: 0, remote: 0 };
        multiplayerReady = { local: false, remote: false };
        
        console.log('üîÑ Multiplayer ended, returned to singleplayer - bot re-enabled');
      }
      
      function cleanupMultiplayer() {
        // Close all connections
        connections.forEach(conn => {
          try { conn.close(); } catch(e){}
        });
        connections.clear();
        
        if (peer) { try { peer.destroy(); } catch(e){} }
        peer = null;
        multiplayerSlot = null;
        hasConnected = false;
        
        // Reset player states
        players.clear();
        activePlayers.clear();
        botPlayers.clear();
        multiplayerScore.clear();
        multiplayerReady.clear();
        remotePlayerStates.clear();
        remoteBallStates.clear();
      }

      function sendScoreUpdate() {
        console.log('üì§ Sending score-update:', multiplayerScore);
        sendToMultiplayer({ type: 'score-update', score: multiplayerScore });
      }
      function sendReadyUpdate() {
        sendToMultiplayer({ type: 'ready-update', ready: multiplayerReady.local });
      }
      function updateScoreDisplayMultiplayer() {
        const blueScore = document.getElementById('blue-score');
        const redScore = document.getElementById('red-score');
        
        if (blueScore && redScore) {
          // In multiplayer, local player is always blue, remote is red
          blueScore.setAttribute('text', 'value', multiplayerScore.local.toString());
          redScore.setAttribute('text', 'value', multiplayerScore.remote.toString());
          console.log('üìä Main display updated - Blue:', multiplayerScore.local, 'Red:', multiplayerScore.remote);
        } else {
          console.log('üìä ERROR: Score elements not found - blueScore:', !!blueScore, 'redScore:', !!redScore);
        }
      }
      
      // Removed complex patching system - scoring is now handled directly in the game-manager component

      // Attach menu-toggle to scene
      document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene && !scene.hasAttribute('menu-toggle')) {
          scene.setAttribute('menu-toggle', '');
        }
        
        // Initialize visibility: bot visible for singleplayer, opponent hidden
        const opponent = document.querySelector('#player-1');
        const bot = document.querySelector('#zerog-bot');
        
        if (opponent) {
          opponent.setAttribute('visible', false);
        }
        if (bot) {
          bot.setAttribute('visible', true);
          if (bot.components['zerog-bot']) {
            bot.setAttribute('zerog-bot', 'enabled', true);
          }
        }
        
        // Initialize status display
        updateMultiplayerStatus('Singleplayer');
        
        // CRITICAL: Start singleplayer game to setup both balls properly
        startSingleplayerGame();
        
        // Scoring is now handled directly in the game-manager component - no patching needed
      });

      // --- MULTIPLAYER SYNC COMPONENT ---
      AFRAME.registerComponent('multiplayer-sync', {
        tick: function() {
          // In multiplayer, send the local camera's world position/rotation as player state
          if (isMultiplayerConnected()) {
            const camera = document.querySelector('[camera]');
            if (camera) {
              const worldPos = new THREE.Vector3();
              camera.object3D.getWorldPosition(worldPos);
              const worldQuat = new THREE.Quaternion();
              camera.object3D.getWorldQuaternion(worldQuat);
              const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
              const playerState = {
                x: worldPos.x, y: worldPos.y, z: worldPos.z,
                rx: worldRot.x, ry: worldRot.y, rz: worldRot.z,
                playerId: 'local'
              };
              sendPlayerState(playerState);
              console.log(`üì§ Sent player state (${isHost ? 'host' : 'client'}):`, playerState.x.toFixed(1), playerState.y.toFixed(1), playerState.z.toFixed(1));
            }
          }
          
          // Send ball states - each player controls their own ball based on slot
          let localBall = null;
          const localPlayerId = isHost ? 'player_0' : getLocalPlayerId();
          if (localPlayerId) {
            const player = players.get(localPlayerId);
            if (player) {
              const ballNumber = player.slotNumber + 1; // player1 = slot 0, player2 = slot 1, etc.
              localBall = document.querySelector(`[zerog-ball="player: player${ballNumber}"]`);
              console.log(`üéØ Local player ${localPlayerId} (slot ${player.slotNumber}) controls ball ${ballNumber}`);
            }
          }
          
          if (localBall && isMultiplayerConnected()) {
            const pos = localBall.object3D.position;
            const ballComponent = localBall.components['zerog-ball'];
            const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
            sendBallState({ 
              x: pos.x, y: pos.y, z: pos.z, 
              vx: velocity.x, vy: velocity.y, vz: velocity.z,
              playerId: localPlayerId
            });
          }
          
          // Apply remote player states (direct positioning for zero-g)
          if (isMultiplayer && remotePlayerStates.size > 0) {
            // For 2-player mode: use player-1 as the opponent
            if (gameConfig.playerCount === 2) {
              const opponent = document.querySelector('#player-1');
              if (opponent) {
                console.log('‚úÖ Found opponent entity for 2-player mode');
                // Make sure opponent is visible and bot is hidden
                opponent.setAttribute('visible', true);
                console.log('üë§ Made opponent visible, hiding bot');
                const bot = document.querySelector('#zerog-bot');
                if (bot) {
                  bot.setAttribute('visible', false);
                  if (bot.components['zerog-bot']) {
                    bot.setAttribute('zerog-bot', 'enabled', false);
                  }
                }
                
                // Get the first remote player state (for 2-player mode)
                const firstRemoteState = remotePlayerStates.values().next().value;
                if (firstRemoteState) {
                  // Update opponent position (no mirroring for zero-g environment)
                  opponent.object3D.position.set(firstRemoteState.x, firstRemoteState.y, firstRemoteState.z);
                  opponent.object3D.rotation.set(firstRemoteState.rx, firstRemoteState.ry, firstRemoteState.rz);
                  console.log('üéØ Updated opponent position:', firstRemoteState.x.toFixed(1), firstRemoteState.y.toFixed(1), firstRemoteState.z.toFixed(1));
                } else {
                  console.log('‚ö†Ô∏è No remote player state available');
                }
              }
            } else {
              // For 4-player mode: handle multiple remote players
              console.log(`üéÆ 4-player mode: Processing ${remotePlayerStates.size} remote player states`);
              
              // Hide bot in multiplayer
              const bot = document.querySelector('#zerog-bot');
              if (bot) {
                bot.setAttribute('visible', false);
                if (bot.components['zerog-bot']) {
                  bot.setAttribute('zerog-bot', 'enabled', false);
                }
              }
              
              // Update each remote player with their corresponding state using slot system
              remotePlayerStates.forEach((state, playerId) => {
                const player = players.get(playerId);
                if (player && player.entityId) {
                  const slot = playerSlots[player.slotNumber];
                  const playerEntity = document.querySelector(`#${player.entityId}`);
                  
                  if (playerEntity) {
                    playerEntity.setAttribute('visible', true);
                    playerEntity.object3D.position.set(state.x, state.y, state.z);
                    playerEntity.object3D.rotation.set(state.rx, state.ry, state.rz);
                    
                    // Apply player color to the target sphere
                    const targetSphere = playerEntity.querySelector('a-sphere');
                    if (targetSphere) {
                      targetSphere.setAttribute('color', slot.color);
                    }
                    
                    console.log(`üéØ Updated ${player.entityId} (slot ${player.slotNumber} - ${slot.name}) position:`, state.x.toFixed(1), state.y.toFixed(1), state.z.toFixed(1));
                  } else {
                    console.log(`‚ö†Ô∏è Player entity ${player.entityId} not found for ${playerId} (slot ${player.slotNumber})`);
                  }
                } else {
                  console.log(`‚ö†Ô∏è Player data not found for ${playerId} or no entity assigned`);
                }
              });
              
              // Also ensure all connected players are visible (even if no state received yet)
              for (let i = 1; i < gameConfig.playerCount; i++) {
                const playerId = `player_${i}`;
                const player = players.get(playerId);
                if (player && player.isConnected && player.entityId) {
                  const playerEntity = document.querySelector(`#${player.entityId}`);
                  if (playerEntity) {
                    playerEntity.setAttribute('visible', true);
                    console.log(`üë§ Made ${player.entityId} visible for connected player ${playerId}`);
                  }
                }
              }
              
              // For clients: also show host position (host doesn't have an entity, so we show a visual indicator)
              if (!isHost) {
                // Clients should see host position - we could add a host indicator entity here
                console.log('üë§ Client: Host position received but no host entity to display');
              }
            }
          } else if (!isMultiplayer) {
            // CRITICAL: Ensure bot is enabled and visible in singleplayer mode
            // Hide all player entities
            const player1 = document.querySelector('#player-1');
            const player2 = document.querySelector('#player-2');
            const player3 = document.querySelector('#player-3');
            const bot = document.querySelector('#zerog-bot');
            
            if (player1) player1.setAttribute('visible', false);
            if (player2) player2.setAttribute('visible', false);
            if (player3) player3.setAttribute('visible', false);
            
            if (bot) {
              bot.setAttribute('visible', true);
              if (bot.components['zerog-bot']) {
                bot.setAttribute('zerog-bot', 'enabled', true);
              }
            }
          }
          
          // Apply remote ball states - each player sees other players' balls
          if (isMultiplayer && remoteBallStates.size > 0) {
            // Process each remote ball state
            remoteBallStates.forEach((ballState, playerId) => {
              const player = players.get(playerId);
              if (player) {
                const ballNumber = player.slotNumber + 1; // player1 = slot 0, player2 = slot 1, etc.
                const remoteBall = document.querySelector(`[zerog-ball="player: player${ballNumber}"]`);
                
                if (remoteBall) {
                  remoteBall.object3D.position.set(ballState.x, ballState.y, ballState.z);
                  if (remoteBall.components['zerog-ball']?.body) {
                    remoteBall.components['zerog-ball'].body.position.set(ballState.x, ballState.y, ballState.z);
                    remoteBall.components['zerog-ball'].body.velocity.set(ballState.vx, ballState.vy, ballState.vz);
                  }
                  console.log(`üéØ Updated remote ball ${ballNumber} (${player.name}) position:`, ballState.x.toFixed(1), ballState.y.toFixed(1), ballState.z.toFixed(1));
                }
              }
            });
          }
          
          // Prevent local input from affecting other players' balls in multiplayer
          if (isMultiplayerConnected()) {
            const localPlayerId = isHost ? 'player_0' : getLocalPlayerId();
            if (localPlayerId) {
              const localPlayer = players.get(localPlayerId);
              if (localPlayer) {
                // Prevent grabbing of all balls except the local player's ball
                for (let i = 1; i <= 4; i++) {
                  const ball = document.querySelector(`[zerog-ball="player: player${i}"]`);
                  if (ball && ball.components['zerog-ball']) {
                    const ballPlayerSlot = i - 1; // player1 = slot 0, player2 = slot 1, etc.
                    if (ballPlayerSlot !== localPlayer.slotNumber) {
                      // This is not the local player's ball, prevent grabbing
                      ball.components['zerog-ball'].isGrabbed = false;
                      ball.components['zerog-ball'].grabbingHand = null;
                    }
                  }
                }
              }
            }
          }
        }
      });

      // Dynamic ball physics for zero-g - can be grabbed and thrown
      AFRAME.registerComponent('zerog-ball', {
        schema: {
          player: { type: 'string', default: 'player1' }
        },
        
        init: function() {
          // Make balls grabbable
          this.el.classList.add('grabbable-surface');
          
          // Track if ball is being grabbed
          this.isGrabbed = false;
          this.grabbingHand = null;
          
          // Set initial position based on player
          const spawnPos = this.el.getAttribute('position');
          
          // Wait for Ammo.js to be ready before creating physics body
          if (ammoInstance && physicsWorld) {
            this.createAmmoPhysicsBody(spawnPos);
          } else {
            // Wait for Ammo.js to initialize
            setTimeout(() => {
              if (ammoInstance && physicsWorld) {
                this.createAmmoPhysicsBody(spawnPos);
              }
            }, 2000);
          }
          
          // Store body reference will be set after physics body creation
          
          // Set up Ammo.js collision detection for bounce sounds
          this.lastCollisionTime = 0;
          this.collisionCooldown = 200; // 200ms between collision sounds
          
          // Velocity tracking for smooth throwing
          this.velocityHistory = [];
          this.maxHistorySize = 5;
          this.lastPosition = new THREE.Vector3();
          this.lastPositionTime = 0;
          
          // Tractor beam with A button - only for player's own ball
          this.tractorBeamActive = false;
          this.targetPosition = new THREE.Vector3();
          
          // NEW: Auto-return mode (for 2 seconds after hitting target)
          this.autoReturnActive = false;
          this.autoReturnStartTime = 0;
          this.autoReturnDuration = 2000; // 2 seconds
          
          // NEW: Hit cooldown to prevent multiple hits during auto-return
          this.lastHitTime = 0;
          this.hitCooldown = 2000; // 2 seconds cooldown
          
          this.el.sceneEl.addEventListener('abuttondown', () => {
            // Only allow human player to control their own ball (player2's ball)
            if (this.data.player === 'player2') {
              this.tractorBeamActive = true;
              console.log('A button: Tractor beam ON');
            }
          });
          
          this.el.sceneEl.addEventListener('abuttonup', () => {
            // Only for player's ball
            if (this.data.player === 'player2') {
              this.tractorBeamActive = false;
              console.log('A button: Tractor beam OFF');
            }
          });
        },
        
        resetPosition: function() {
          this.body.position.copy(this.initialPosition);
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          // Note: Ammo.js uses world gravity, not per-body gravity
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
          
          // Clear hit cooldown and auto-return when manually resetting
          this.lastHitTime = 0;
          this.autoReturnActive = false;
        },
        
        checkTargetHit: function() {
          if (this.isGrabbed || !this.body) return;
          
          // CRITICAL: Check hit cooldown FIRST to prevent multiple hits
          const now = Date.now();
          if (now - this.lastHitTime < this.hitCooldown) {
            return; // Still in cooldown period - no hits allowed
          }
          
          // Don't check hits during auto-return period to prevent rapid scoring
          if (this.autoReturnActive) {
            return; // Skip hit detection during auto-return
          }
          
          const ballPos = new THREE.Vector3().copy(this.body.position);
          const ballVelocity = this.body.velocity.length();
          
          // Only check hits if ball is moving
          if (ballVelocity < 0.5) return;
          
          // Check distance to player target (always target sphere inside camera)
          const playerTarget = document.querySelector('#player-target');
          if (playerTarget && this.data.player === 'player1') {

            const playerTargetPos = new THREE.Vector3();
            playerTarget.object3D.getWorldPosition(playerTargetPos);
            const distance = ballPos.distanceTo(playerTargetPos);
            
            if (distance < 0.3) { // 0.2m target radius + 0.1m ball radius
              const impactEffect = playerTarget.components['impact-effect'];
              if (impactEffect) {
                impactEffect.playEffect();
              }
              
                                             // Update score through game manager (bot ball hit player - bot scores)
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  console.log('üéØ BALL HIT: Player1 ball hit player target - calling onOpponentHit');
                  gameManager.components['game-manager'].onOpponentHit();
                } else {
                  console.log('ERROR: Game manager not found for onOpponentHit');
                }
              
              // Record hit time to prevent multiple hits
              this.lastHitTime = now;
              console.log('‚è∞ Hit cooldown set (opponent hit) - next hit allowed in', this.hitCooldown, 'ms');
              
              this.resetPosition(); // Reset ball after hit
              console.log('Bot ball hit player target!');
              return;
            }
          }
          
          // Check distance to opponent target (in multiplayer) OR bot target (in singleplayer)
          const opponentTarget = document.querySelector('#opponent-target');
          const botTarget = document.querySelector('#bot-target');
          
          if (this.data.player === 'player2') {
            // Player ball - check hits on opponent (multiplayer) or bot (singleplayer)
            let targetToCheck = null;
            
            if (isMultiplayer && opponentTarget) {
              targetToCheck = opponentTarget;
            } else if (!isMultiplayer && botTarget) {
              targetToCheck = botTarget;
            }
            
            if (targetToCheck) {
              const targetPos = new THREE.Vector3();
              targetToCheck.object3D.getWorldPosition(targetPos);
              const distance = ballPos.distanceTo(targetPos);
              
              if (distance < 0.3) { // 0.2m target radius + 0.1m ball radius
                const impactEffect = targetToCheck.components['impact-effect'];
                if (impactEffect) {
                  impactEffect.playEffect();
                }
                
                                                 // Update score through game manager (player ball hit opponent/bot - player scores)
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  console.log('üîµ BALL HIT: Player2 ball hit opponent target - calling onPlayerHit');
                  gameManager.components['game-manager'].onPlayerHit();
                } else {
                  console.log('ERROR: Game manager not found for onPlayerHit');
                }
                
                // Record hit time to prevent multiple hits
                this.lastHitTime = now;
                console.log('‚è∞ Hit cooldown set - next hit allowed in', this.hitCooldown, 'ms');
                
                this.startAutoReturn(); // Start auto-return instead of instant reset
                console.log('‚úÖ Player ball hit target - auto-return started');
                return;
              }
            }
          }
        },
        
        onGrab: function(hand) {
          this.isGrabbed = true;
          this.grabbingHand = hand;
          
          // CRITICAL: Make ball kinematic (non-colliding) when grabbed
          if (this.body) {
            // Remove from physics world temporarily
            physicsWorld.removeRigidBody(this.body);
            console.log('üö´ Ball removed from physics during grab');
          }
          
          // Cancel auto-return if player grabs the ball
          if (this.autoReturnActive) {
            this.autoReturnActive = false;
          }
          
          // Start velocity and rotation tracking
          this.velocityHistory = [];
          const handPos = new THREE.Vector3();
          const handQuat = new THREE.Quaternion();
          hand.object3D.getWorldPosition(handPos);
          hand.object3D.getWorldQuaternion(handQuat);
          this.lastPosition.copy(handPos);
          this.lastRotation = handQuat.clone();
          this.lastPositionTime = performance.now();
          
          // Haptic feedback
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.7, 100).catch(() => {});
          }
        },
        
        onRelease: function() {
          console.log('üéæ Ball onRelease called - isGrabbed:', this.isGrabbed);
          if (!this.isGrabbed) return;
          
          // CRITICAL: Re-add ball to physics world when released with collision filtering
          if (this.body) {
            // Physics body position is already synced in tick(), just re-add to world
            let BALL_GROUP, BALL_MASK;
            
            if (this.data.player === 'player2') {
              // Player's own ball - group 8, only collide with environment
              BALL_GROUP = 8;
              BALL_MASK = 1; // Only environment
            } else {
              // Enemy balls - group 16, collide with environment and player
              BALL_GROUP = 16;
              BALL_MASK = 1 | 2; // Environment and player
            }
            
            physicsWorld.addRigidBody(this.body, BALL_GROUP, BALL_MASK);
            
            const currentPos = this.el.object3D.position;
            console.log('‚úÖ Ball re-added to physics after release at position:', currentPos.toArray().map(x => x.toFixed(2)));
          }
          
          // Calculate throw velocity from hand movement history
          let velocity = new THREE.Vector3(0, 0, 0);
          
          if (this.velocityHistory.length > 0) {
            // Use weighted average of recent velocities
            let totalWeight = 0;
            for (let i = 0; i < this.velocityHistory.length; i++) {
              const weight = (i + 1) / this.velocityHistory.length;
              velocity.add(this.velocityHistory[i].clone().multiplyScalar(weight));
              totalWeight += weight;
            }
            velocity.divideScalar(totalWeight);
            
            // Scale for satisfying throws
            velocity.multiplyScalar(1.5);
            
            // Cap maximum throw speed
            const maxThrowSpeed = 15; // m/s
            if (velocity.length() > maxThrowSpeed) {
              velocity.normalize().multiplyScalar(maxThrowSpeed);
            }
          }
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          
          // Calculate angular velocity based on hand rotation change
          let angularVelocity = new THREE.Vector3(0, 0, 0);
          if (this.lastRotation && this.grabbingHand) {
            const currentHandQuat = new THREE.Quaternion();
            this.grabbingHand.object3D.getWorldQuaternion(currentHandQuat);
            
            // Calculate rotation difference
            const deltaRot = new THREE.Quaternion().multiplyQuaternions(
              currentHandQuat,
              this.lastRotation.clone().invert()
            );
            
            // Convert quaternion to angular velocity
            const angle = 2 * Math.acos(Math.abs(deltaRot.w));
            if (angle > 0.0001) {
              const axis = new THREE.Vector3(deltaRot.x, deltaRot.y, deltaRot.z).normalize();
              // Scale angular velocity for good spin effect (matching index.html)
              axis.multiplyScalar(angle * 40); // Same as index.html for consistency
              angularVelocity = axis;
            }
          }
          
          // Apply calculated angular velocity for realistic spin
          this.body.angularVelocity.set(angularVelocity.x, angularVelocity.y, angularVelocity.z);
          
          console.log('Ball released - Velocity:', velocity.length().toFixed(2), 'm/s, Spin:', angularVelocity.length().toFixed(2), 'rad/s');
          
          // Ensure the ball is active in Ammo.js physics
          this.body.activate();
          
          // Clear grabbed state
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
        },
        
        tick: function() {
          if (this.body) {
            if (this.isGrabbed && this.grabbingHand) {
              // When grabbed, track hand movement and rotation for throwing
              const handPos = new THREE.Vector3();
              const handQuat = new THREE.Quaternion();
              this.grabbingHand.object3D.getWorldPosition(handPos);
              this.grabbingHand.object3D.getWorldQuaternion(handQuat);
              
              // Update ball position AND rotation to match hand
              this.el.object3D.position.copy(handPos);
              this.el.object3D.quaternion.copy(handQuat);
              this.body.position.copy(handPos);
              this.body.quaternion.copy(handQuat);
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              
              // Track velocity history for throwing
              const currentTime = performance.now();
              if (this.lastPositionTime > 0) {
                const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.001);
                const displacement = new THREE.Vector3().subVectors(handPos, this.lastPosition);
                const instantVelocity = displacement.divideScalar(deltaTime);
                
                this.velocityHistory.push(instantVelocity.clone());
                if (this.velocityHistory.length > this.maxHistorySize) {
                  this.velocityHistory.shift();
                }
              }
              
              this.lastPosition.copy(handPos);
              this.lastRotation = handQuat.clone();
              this.lastPositionTime = currentTime;
            } else {
              // When not grabbed, update visual position from physics (Ammo.js)
              if (this.body && ammoInstance) {
                const transform = new ammoInstance.btTransform();
                this.body.getMotionState().getWorldTransform(transform);
                const origin = transform.getOrigin();
                const rotation = transform.getRotation();
                
                // Safety checks for valid transform data
                if (origin && typeof origin.x === 'function' && rotation && typeof rotation.x === 'function') {
                  this.el.object3D.position.set(origin.x(), origin.y(), origin.z());
                  this.el.object3D.quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                }
                
                ammoInstance.destroy(transform);
              }
              
              // Check auto-return timeout (turn off after 2 seconds)
              if (this.autoReturnActive && Date.now() - this.autoReturnStartTime > this.autoReturnDuration) {
                this.autoReturnActive = false;
                console.log('‚úÖ Auto-return ended - hit detection re-enabled');
              }
              
              // Tractor beam logic (only for player's ball when A is held OR grip is held OR auto-return)
              const shouldActivate = this.shouldActivateTractorBeam();
              const isPlayer2 = this.data.player === 'player2';
              
              if (shouldActivate && isPlayer2) {
                this.applyTractorBeam();
                console.log('Tractor beam: APPLIED');
              }
              
              // Check for target hits each frame when moving
              this.checkTargetHit();
              
              // Note: Ammo.js uses world gravity (already set to zero in physics world)
              
              // Apply Magnus effect for spinning balls (matching index.html exactly)
              if (this.body.velocity.length() > 0.1) {
                const velocity = new THREE.Vector3(
                  this.body.velocity.x,
                  this.body.velocity.y,
                  this.body.velocity.z
                );

                const angularVelocity = new THREE.Vector3(
                  this.body.angularVelocity.x,
                  this.body.angularVelocity.y,
                  this.body.angularVelocity.z
                );

                const angularSpeed = angularVelocity.length();
                const linearSpeed = velocity.length();
                
                // Debug: Always log spin and speed when ball is moving to see what we're working with
                if (linearSpeed > 0.5) {
                  // console.log('Ball moving - Speed:', linearSpeed.toFixed(2), 'm/s, Spin:', angularSpeed.toFixed(2), 'rad/s'); // Disabled to reduce console spam
                }
                
                // Apply Magnus effect - subtle curve to existing motion
                if (angularSpeed > 0.1 && linearSpeed > 0.5) { // Much lower thresholds
                  // Calculate Magnus force as acceleration (not velocity change)
                  const magnusAcceleration = new THREE.Vector3()
                    .crossVectors(angularVelocity, velocity);
                  
                  // Small but noticeable effect - frame rate independent acceleration
                  const frameTime = 1/72; // Assume 72fps for consistent effect
                  const magnusStrength = 0.008; // Slightly stronger Magnus effect - more noticeable curvature
                  
                  // Scale acceleration by frame time and strength
                  magnusAcceleration.multiplyScalar(magnusStrength * frameTime);
                  
                  // Apply as acceleration (small velocity change per frame)
                  this.body.velocity.x += magnusAcceleration.x;
                  this.body.velocity.y += magnusAcceleration.y;
                  this.body.velocity.z += magnusAcceleration.z;
                  
                  // Log Magnus effect occasionally (not every frame) - DISABLED to reduce console spam
                  // if (Math.random() < 0.01) { // 1% chance per frame (~0.7 times per second at 72fps)
                  //   console.log('Magnus ACTIVE - Accel:', magnusAcceleration.length().toFixed(6), 
                  //              'Spin:', angularSpeed.toFixed(2), 'Speed:', linearSpeed.toFixed(2));
                  // }
                }

                // Add minimal damping only for very slow balls to prevent infinite bouncing
                const speed = velocity.length();
                const currentAngularSpeed = angularVelocity.length();
                if (speed < 0.5 && currentAngularSpeed < 1.0) { // Only damp if both linear and angular are slow
                  const damping = 0.995;
                  this.body.velocity.x *= damping;
                  this.body.velocity.y *= damping;
                  this.body.velocity.z *= damping;
                  this.body.angularVelocity.x *= damping;
                  this.body.angularVelocity.y *= damping;
                  this.body.angularVelocity.z *= damping;
                }
              }
            }
          }
        },
        
        // NEW: Check if tractor beam should be activated (A button OR grip buttons OR auto-return)
        shouldActivateTractorBeam: function() {
          // Always activate if A button is held
          if (this.tractorBeamActive) {
            console.log('Tractor beam: A button held');
            return true;
          }
          
          // Always activate if in auto-return mode (after hitting target)
          if (this.autoReturnActive) {
            console.log('Tractor beam: Auto-return mode');
            return true;
          }
          
          // Also activate if either grip is held but ball is not currently being grabbed
          if (this.isGrabbed) {
            console.log('Tractor beam: Ball is grabbed, no tractor beam');
            return false; // Don't use tractor beam if ball is already grabbed
          }
          
          // Check if player is holding grips (get from zerog-player component)
          const player = document.querySelector('[zerog-player]');
          if (player && player.components['zerog-player']) {
            const playerComponent = player.components['zerog-player'];
            const gripState = playerComponent.gripHeld;
            const grabbingState = playerComponent.isGrabbing;
            
            console.log(`Tractor beam: gripState=${JSON.stringify(gripState)}, grabbingState=${JSON.stringify(grabbingState)}`);
            
            // Only allow tractor beam from hands that are holding grip BUT NOT grabbing surfaces
            const leftHandFree = gripState && gripState.left && (!grabbingState || !grabbingState.left);
            const rightHandFree = gripState && gripState.right && (!grabbingState || !grabbingState.right);
            
            const result = leftHandFree || rightHandFree;
            console.log(`Tractor beam: leftHandFree=${leftHandFree}, rightHandFree=${rightHandFree}, result=${result}`);
            
            return result;
          }
          
          console.log('Tractor beam: No player component found');
          return false;
        },
        
        // NEW: Start auto-return mode (called when ball hits target)
        startAutoReturn: function() {
          if (this.data.player === 'player2') { // Only for player's ball
            this.autoReturnActive = true;
            this.autoReturnStartTime = Date.now();
            console.log('üî• Auto-return activated for 2 seconds (hit detection disabled during auto-return)');
          }
        },
        
        // NEW: Tractor beam effect - attracts ball to position in front of player
        applyTractorBeam: function() {
          if (!this.body) return;
          
          // Get player camera (the "player" position)
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          // Get camera world position and rotation
          const cameraWorldPos = new THREE.Vector3();
          const cameraWorldQuat = new THREE.Quaternion();
          camera.object3D.getWorldPosition(cameraWorldPos);
          camera.object3D.getWorldQuaternion(cameraWorldQuat);
          
          // Calculate target position: 30cm in front of camera, 30cm lower (chest height)
          const forwardDirection = new THREE.Vector3(0, 0, -1); // Forward in camera space
          forwardDirection.applyQuaternion(cameraWorldQuat);
          
          this.targetPosition.copy(cameraWorldPos);
          this.targetPosition.add(forwardDirection.multiplyScalar(0.3)); // 30cm forward
          this.targetPosition.y -= 0.3; // 30cm lower for chest height
          
          // Calculate attraction force toward target position
          const ballPos = new THREE.Vector3().copy(this.body.position);
          const attractionVector = new THREE.Vector3().subVectors(this.targetPosition, ballPos);
          const distance = attractionVector.length();
          
          if (distance > 0.01) { // Only apply force if not already at target
            // Normalize and apply force - stronger when farther away
            attractionVector.normalize();
            
            // Adaptive force: stronger for distant objects, gentler when close
            let forceMultiplier;
            if (distance > 2.0) {
              forceMultiplier = 25.0; // Strong force for distant balls
            } else if (distance > 0.5) {
              forceMultiplier = 15.0; // Medium force for medium distance
            } else {
              forceMultiplier = 8.0;  // Gentle force when close to avoid jitter
            }
            
            attractionVector.multiplyScalar(forceMultiplier);
            
            // Apply force to ball
            this.body.velocity.x += attractionVector.x * 0.016; // Assume ~60fps
            this.body.velocity.y += attractionVector.y * 0.016;
            this.body.velocity.z += attractionVector.z * 0.016;
            
            // Dampen velocity to prevent overshooting when close
            if (distance < 0.5) {
              this.body.velocity.x *= 0.9;
              this.body.velocity.y *= 0.9;
              this.body.velocity.z *= 0.9;
            }
            
            // Cap maximum tractor beam velocity for safety
            const maxTractorSpeed = 10.0;
            const currentSpeed = Math.sqrt(
              this.body.velocity.x * this.body.velocity.x +
              this.body.velocity.y * this.body.velocity.y +
              this.body.velocity.z * this.body.velocity.z
            );
            
            if (currentSpeed > maxTractorSpeed) {
              const scale = maxTractorSpeed / currentSpeed;
              this.body.velocity.x *= scale;
              this.body.velocity.y *= scale;
              this.body.velocity.z *= scale;
            }
            
            // Debug info (occasional)
            if (Math.random() < 0.02) { // 2% chance per frame (~1.2 times per second at 60fps)
              let activationMethod;
              if (this.tractorBeamActive) {
                activationMethod = 'A button';
              } else if (this.autoReturnActive) {
                activationMethod = 'Auto-return';
              } else {
                activationMethod = 'Grip buttons';
              }
  
            }
          }
        },

        createAmmoPhysicsBody: function(spawnPos) {
          console.log('üîß Creating Ammo.js physics body for ball');
          const Ammo = ammoInstance;
          
          // Store initial position for reset functionality
          this.initialPosition = new THREE.Vector3(spawnPos.x, spawnPos.y, spawnPos.z);
          
          // Create sphere shape
          const radius = 0.1;
          const shape = new Ammo.btSphereShape(radius);
          
          // Create rigid body
          const mass = 1;
          const localInertia = new Ammo.btVector3(0, 0, 0);
          shape.calculateLocalInertia(mass, localInertia);
          
          const transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(spawnPos.x, spawnPos.y, spawnPos.z));
          
          const motionState = new Ammo.btDefaultMotionState(transform);
          const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
          this.body = new Ammo.btRigidBody(rigidBodyInfo);
          
          // Set damping
          this.body.setDamping(0.02, 0.02);
          
          // Add compatibility layer for Cannon.js API
          this.setupVelocityAPI();
          
          // Add balls with collision filtering
          let BALL_GROUP, BALL_MASK;
          
          if (this.data.player === 'player2') {
            // Player's own ball - group 8, only collide with environment
            BALL_GROUP = 8;
            BALL_MASK = 1; // Only environment
          } else {
            // Enemy balls - group 16, collide with environment and player
            BALL_GROUP = 16;
            BALL_MASK = 1 | 2; // Environment and player
          }
          
          physicsWorld.addRigidBody(this.body, BALL_GROUP, BALL_MASK);
          
          // Store reference for physics object sync
          physicsObjects.push({
            entity: this.el,
            object3D: this.el.object3D,
            body: this.body
          });
          
          // Store body reference for grabbing (now that body is created)
          this.el.body = this.body;
          
          console.log('‚úÖ Ball added to Ammo.js physics world - Player:', this.data.player, 'Group:', BALL_GROUP, 'Mask:', BALL_MASK);
        },

        setupVelocityAPI: function() {
          // Add Cannon.js-like velocity API to Ammo.js body
          const Ammo = ammoInstance;
          
          this.body.velocity = {
            set: (x, y, z) => {
              const velocity = new Ammo.btVector3(x, y, z);
              this.body.setLinearVelocity(velocity);
              Ammo.destroy(velocity);
            },
            length: () => {
              const vel = this.body.getLinearVelocity();
              const length = Math.sqrt(vel.x() * vel.x() + vel.y() * vel.y() + vel.z() * vel.z());
              return length;
            },
            scale: (factor, target) => {
              const vel = this.body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x() * factor, vel.y() * factor, vel.z() * factor);
              this.body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get x() {
              return this._body.getLinearVelocity().x();
            },
            set x(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(value, vel.y(), vel.z());
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get y() {
              return this._body.getLinearVelocity().y();
            },
            set y(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x(), value, vel.z());
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get z() {
              return this._body.getLinearVelocity().z();
            },
            set z(value) {
              const vel = this._body.getLinearVelocity();
              const newVel = new Ammo.btVector3(vel.x(), vel.y(), value);
              this._body.setLinearVelocity(newVel);
              Ammo.destroy(newVel);
            },
            _body: this.body
          };

          // Add position API compatibility
          this.body.position = {
            set: (x, y, z) => {
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setOrigin(new Ammo.btVector3(x, y, z));
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(transform);
            },
            copy: (vector3) => {
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setOrigin(new Ammo.btVector3(vector3.x, vector3.y, vector3.z));
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(transform);
            },
            get x() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const x = origin.x();
              Ammo.destroy(transform);
              return x;
            },
            get y() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const y = origin.y();
              Ammo.destroy(transform);
              return y;
            },
            get z() {
              const transform = new Ammo.btTransform();
              this._body.getMotionState().getWorldTransform(transform);
              const origin = transform.getOrigin();
              const z = origin.z();
              Ammo.destroy(transform);
              return z;
            },
            _body: this.body
          };

          // Add angular velocity API compatibility
          this.body.angularVelocity = {
            set: (x, y, z) => {
              const angularVelocity = new Ammo.btVector3(x, y, z);
              this.body.setAngularVelocity(angularVelocity);
              Ammo.destroy(angularVelocity);
            },
            get x() {
              return this._body.getAngularVelocity().x();
            },
            set x(value) {
              const vel = this._body.getAngularVelocity();
              const newVel = new Ammo.btVector3(value, vel.y(), vel.z());
              this._body.setAngularVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get y() {
              return this._body.getAngularVelocity().y();
            },
            set y(value) {
              const vel = this._body.getAngularVelocity();
              const newVel = new Ammo.btVector3(vel.x(), value, vel.z());
              this._body.setAngularVelocity(newVel);
              Ammo.destroy(newVel);
            },
            get z() {
              return this._body.getAngularVelocity().z();
            },
            set z(value) {
              const vel = this._body.getAngularVelocity();
              const newVel = new Ammo.btVector3(vel.x(), vel.y(), value);
              this._body.setAngularVelocity(newVel);
              Ammo.destroy(newVel);
            },
            _body: this.body
          };

          // Add quaternion API compatibility
          this.body.quaternion = {
            setFromEuler: (x, y, z) => {
              const rotation = new Ammo.btQuaternion();
              rotation.setEulerZYX(z, y, x); // Ammo uses ZYX order
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setRotation(rotation);
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(rotation);
              Ammo.destroy(transform);
            },
            copy: (quaternion) => {
              const rotation = new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
              const transform = new Ammo.btTransform();
              this.body.getMotionState().getWorldTransform(transform);
              transform.setRotation(rotation);
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              Ammo.destroy(rotation);
              Ammo.destroy(transform);
            },
            _body: this.body
          };
        },

        tick: function() {
          // If ball is grabbed, update position to follow hand (but no physics)
          if (this.isGrabbed && this.grabbingHand) {
            // Update ball visual position to match hand (directly, no physics)
            const handPos = new THREE.Vector3();
            this.grabbingHand.object3D.getWorldPosition(handPos);
            
            // Update visual position directly
            this.el.object3D.position.copy(handPos);
            
            // CRITICAL: Also update the physics body position while grabbed (but don't add to world)
            // This ensures when released, the ball starts from the correct position
            if (this.body) {
              const transform = new ammoInstance.btTransform();
              transform.setIdentity();
              transform.setOrigin(new ammoInstance.btVector3(handPos.x, handPos.y, handPos.z));
              this.body.getMotionState().setWorldTransform(transform);
              this.body.setCenterOfMassTransform(transform);
              ammoInstance.destroy(transform);
            }
            
            // Track velocity for throwing
            const currentTime = performance.now();
            if (currentTime - this.lastPositionTime > 0) {
              const velocity = handPos.clone().sub(this.lastPosition);
              velocity.multiplyScalar(1000 / (currentTime - this.lastPositionTime)); // Convert to m/s
              this.velocityHistory.push(velocity);
              if (this.velocityHistory.length > this.maxHistorySize) {
                this.velocityHistory.shift();
              }
            }
            
            this.lastPosition.copy(handPos);
            this.lastPositionTime = currentTime;
            
            // Don't do physics checks while grabbed
            return;
          }
          
          // Only do physics checks when not grabbed
          // Check for collisions and play bounce sounds
          this.checkAmmoCollisions();
          
          // Check for target hits
          this.checkTargetHit();
        },

        checkAmmoCollisions: function() {
          if (!this.body || !ammoInstance || !physicsWorld) return;
          
          const now = Date.now();
          if (now - this.lastCollisionTime < this.collisionCooldown) return;
          
          const Ammo = ammoInstance;
          const numManifolds = physicsWorld.getDispatcher().getNumManifolds();
          
          for (let i = 0; i < numManifolds; i++) {
            const contactManifold = physicsWorld.getDispatcher().getManifoldByIndexInternal(i);
            const body0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
            const body1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);
            
            // Check if one of the bodies is this ball
            if (body0 === this.body || body1 === this.body) {
              const numContacts = contactManifold.getNumContacts();
              
              for (let j = 0; j < numContacts; j++) {
                const contactPoint = contactManifold.getContactPoint(j);
                const distance = contactPoint.getDistance();
                
                // Only process actual contacts (not just near misses)
                if (distance < 0.01) {
                  // Check if ball is moving fast enough for sound
                  const velocity = this.body.getLinearVelocity();
                  
                  // Safety check for valid velocity
                  if (velocity && typeof velocity.x === 'function') {
                    const speed = Math.sqrt(velocity.x() * velocity.x() + velocity.y() * velocity.y() + velocity.z() * velocity.z());
                    
                    if (!this.isGrabbed && speed > 0.5) {
                      this.playBounceSound();
                      this.lastCollisionTime = now;
                      return; // Only play one sound per frame
                    }
                  }
                }
              }
            }
          }
        },

        playBounceSound: function() {
          const bounceSound = document.querySelector('#bounce-sound');
          if (bounceSound) {
            // Position sound at ball location
            const transform = new ammoInstance.btTransform();
            this.body.getMotionState().getWorldTransform(transform);
            const origin = transform.getOrigin();
            
            // Safety check for valid origin
            if (origin && typeof origin.x === 'function') {
              bounceSound.object3D.position.set(origin.x(), origin.y(), origin.z());
            }
            
            // Stop any currently playing sound and play new one
            if (bounceSound.components.sound) {
              bounceSound.components.sound.stopSound();
              bounceSound.components.sound.playSound();
            }
            
            ammoInstance.destroy(transform);
          }
        }
      });

      // Shot Ball component for X button shooting
      AFRAME.registerComponent('shot-ball', {
        init: function() {
          // Wait for Ammo.js to be ready before creating physics body
          if (ammoInstance && physicsWorld) {
            this.createAmmoPhysicsBody();
          } else {
            // Wait for Ammo.js to initialize
            setTimeout(() => {
              if (ammoInstance && physicsWorld) {
                this.createAmmoPhysicsBody();
              }
            }, 1000);
          }
          
          // Auto-remove shot balls after 10 seconds
          setTimeout(() => {
            this.remove();
          }, 10000);
        },

        createAmmoPhysicsBody: function() {
          const spawnPos = this.el.getAttribute('position');
          const Ammo = ammoInstance;
          
          // Create sphere shape
          const radius = 0.1;
          const shape = new Ammo.btSphereShape(radius);
          
          // Create rigid body
          const mass = 1;
          const localInertia = new Ammo.btVector3(0, 0, 0);
          shape.calculateLocalInertia(mass, localInertia);
          
          const transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(spawnPos.x, spawnPos.y, spawnPos.z));
          
          const motionState = new Ammo.btDefaultMotionState(transform);
          const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
          this.body = new Ammo.btRigidBody(rigidBodyInfo);
          
          // Set damping
          this.body.setDamping(0.02, 0.02);
          
          // Add compatibility layer for velocity manipulation
          this.setupVelocityAPI();
          
          // Add to physics world
          physicsWorld.addRigidBody(this.body);
          
          // Store reference for physics object sync
          physicsObjects.push({
            entity: this.el,
            object3D: this.el.object3D,
            body: this.body
          });
        },

        setupVelocityAPI: function() {
          // Add Cannon.js-like velocity API to Ammo.js body
          const Ammo = ammoInstance;
          
          this.body.velocity = {
            set: (x, y, z) => {
              const velocity = new Ammo.btVector3(x, y, z);
              this.body.setLinearVelocity(velocity);
              this.body.activate(); // Wake up the body
              Ammo.destroy(velocity);
            }
          };

          this.body.angularVelocity = {
            set: (x, y, z) => {
              const angularVelocity = new Ammo.btVector3(x, y, z);
              this.body.setAngularVelocity(angularVelocity);
              this.body.activate(); // Wake up the body
              Ammo.destroy(angularVelocity);
            }
          };
        },

        remove: function() {
          if (this.body && physicsWorld) {
            physicsWorld.removeRigidBody(this.body);
            
            // Remove from physics objects array
            const index = physicsObjects.findIndex(obj => obj.entity === this.el);
            if (index !== -1) {
              physicsObjects.splice(index, 1);
            }
          }
          
          // Remove the entity from scene
          if (this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
          }
        }
      });

      // FPS counter
      AFRAME.registerComponent('fps-counter', {
        init: function() {
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.fps = 0;
          this.fpsHistory = [];
          this.updateInterval = 500;
          this.lastUpdate = 0;
        },
        
        tick: function() {
          const currentTime = performance.now();
          this.frameCount++;
          
          if (currentTime - this.lastUpdate >= this.updateInterval) {
            const deltaTime = currentTime - this.lastTime;
            const currentFPS = Math.round((this.frameCount * 1000) / deltaTime);
            
            this.fpsHistory.push(currentFPS);
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift();
            }
            
            const avgFPS = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);
            this.fps = avgFPS;
            
            this.updateVersionDisplay();
            
            this.frameCount = 0;
            this.lastTime = currentTime;
            this.lastUpdate = currentTime;
          }
        },
        
        updateVersionDisplay: function() {
          const versionDisplay = document.getElementById('version-display');
          if (versionDisplay) {
            versionDisplay.setAttribute('text', 'value', `Zero-G v1.28 | ${this.fps} FPS`);
          }
        }
      });

      // Fix for hand-controls clipAction error
      AFRAME.registerComponent('custom-hand-controls', {
        init: function() {
          // Override the problematic animation methods to prevent clipAction errors
          setTimeout(() => {
            const handControls = this.el.components['hand-controls'];
            if (handControls) {
              // Store original methods
              this.originalAnimateGesture = handControls.animateGesture;
              this.originalPlayAnimation = handControls.playAnimation;
              
              // Override with no-op functions
              handControls.animateGesture = function() {};
              handControls.playAnimation = function() {};
              
              console.log('Fixed hand-controls clipAction error for', this.el.id);
            }
          }, 100);
        },
        
        remove: function() {
          // Restore original methods if needed
          const handControls = this.el.components['hand-controls'];
          if (handControls && this.originalAnimateGesture && this.originalPlayAnimation) {
            handControls.animateGesture = this.originalAnimateGesture;
            handControls.playAnimation = this.originalPlayAnimation;
          }
        }
      });

      // Enhanced cursor listener component for menu interactions
      AFRAME.registerComponent('cursor-listener', {
        init: function() {
          this.el.addEventListener('click', this.onClick.bind(this));
          this.el.addEventListener('mouseenter', this.onHover.bind(this));
          this.el.addEventListener('mouseleave', this.onLeave.bind(this));
        },

        onClick: function() {
          const id = this.el.id;
          console.log('Menu button clicked:', id);
          
          // Handle menu button clicks
          switch(id) {
            case 'menu-singleplayer':
              this.selectSingleplayer();
              break;
            case 'menu-multiplayer':
              this.selectMultiplayer();
              break;
            case 'menu-solo':
              this.selectPlayStyle('solo');
              break;
            case 'menu-teams':
              this.selectPlayStyle('teams');
              break;
            case 'menu-2players':
              this.selectPlayerCount(2);
              break;
            case 'menu-4players':
              this.selectPlayerCount(4);
              break;
            case 'menu-bot-fill':
              this.toggleBotFill();
              break;
            case 'menu-bot-replace':
              this.toggleBotReplace();
              break;
            case 'menu-start-game':
              this.startGame();
              break;
          }
        },

        onHover: function() {
          // Highlight button on hover
          const material = this.el.getAttribute('material');
          this.originalColor = material.color;
          this.el.setAttribute('material', 'color', '#ffffff');
          this.el.setAttribute('material', 'opacity', 1.0);
        },

        onLeave: function() {
          // Restore original color
          if (this.originalColor) {
            this.el.setAttribute('material', 'color', this.originalColor);
            this.el.setAttribute('material', 'opacity', 0.8);
          }
        },

        selectSingleplayer: function() {
          console.log('üéÆ Singleplayer selected');
          
          // End any existing multiplayer connection
          if (isMultiplayer) {
            endMultiplayer();
          }
          
          // Update game configuration
          gameConfig.mode = 'singleplayer';
          
          // Hide multiplayer-specific sections
          this.toggleMultiplayerSections(false);
          
          // Update configuration display
          this.updateConfigDisplay();
          
          // Update button visual states
          this.updateButtonStates('mode', 'single');
        },
        
        selectMultiplayer: function() {
          console.log('üåê Multiplayer selected');
          
          // Update game configuration
          gameConfig.mode = 'multiplayer';
          
          // Show multiplayer-specific sections
          this.toggleMultiplayerSections(true);
          
          // Update configuration display
          this.updateConfigDisplay();
          
          // Update button visual states
          this.updateButtonStates('mode', 'multi');
        },
        
        selectPlayStyle: function(style) {
          console.log('üéØ Play style selected:', style);
          gameConfig.playStyle = style;
          this.updateConfigDisplay();
          this.updateButtonStates('playstyle', style);
        },
        
        selectPlayerCount: function(count) {
          console.log('üë• Player count selected:', count);
          gameConfig.playerCount = count;
          this.updateConfigDisplay();
          this.updateButtonStates('playercount', count.toString());
        },
        
        toggleBotFill: function() {
          gameConfig.botFillEnabled = !gameConfig.botFillEnabled;
          console.log('ü§ñ Bot fill toggled:', gameConfig.botFillEnabled);
          this.updateConfigDisplay();
          this.updateButtonStates('botfill', gameConfig.botFillEnabled);
        },
        
        toggleBotReplace: function() {
          gameConfig.botReplaceEnabled = !gameConfig.botReplaceEnabled;
          console.log('üîÑ Bot replace toggled:', gameConfig.botReplaceEnabled);
          this.updateConfigDisplay();
          this.updateButtonStates('botreplace', gameConfig.botReplaceEnabled);
        },
        
        startGame: function() {
          console.log('üöÄ Starting game with config:', gameConfig);
          
          if (gameConfig.mode === 'multiplayer') {
            startMultiplayerConnection();
          } else {
            startSingleplayerGame();
          }
          
          // Close menu
          const menuToggle = document.querySelector('a-scene').components['menu-toggle'];
          if (menuToggle) {
            menuToggle.toggleMenu();
          }
        },
        
        toggleMultiplayerSections: function(show) {
          const sections = [
            '#menu-playstyle-section',
            '#menu-playercount-section',
            '#menu-bots-section'
          ];
          
          sections.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
              element.setAttribute('visible', show);
            }
          });
        },
        
        updateConfigDisplay: function() {
          const configEl = document.querySelector('#menu-current-config');
          if (!configEl) return;
          
          let configText = '';
          
          if (gameConfig.mode === 'singleplayer') {
            configText = 'Singleplayer';
          } else {
            configText = `Multiplayer ${gameConfig.playerCount}P`;
            if (gameConfig.playStyle === 'teams') {
              configText += ' Teams';
            } else {
              configText += ' Solo';
            }
            
            const botOptions = [];
            if (gameConfig.botFillEnabled) botOptions.push('Fill');
            if (gameConfig.botReplaceEnabled) botOptions.push('Replace');
            if (botOptions.length > 0) {
              configText += ` (Bots: ${botOptions.join(', ')})`;
            }
          }
          
          configEl.setAttribute('text', 'value', configText);
        },
        
        updateButtonStates: function(category, selected) {
          const buttons = {
            mode: ['menu-singleplayer', 'menu-multiplayer'],
            playstyle: ['menu-solo', 'menu-teams'],
            playercount: ['menu-2players', 'menu-4players']
          };
          
          if (buttons[category]) {
            buttons[category].forEach(btnId => {
              const btn = document.querySelector(`#${btnId}`);
              if (btn) {
                const material = btn.getAttribute('material');
                const isSelected = (
                  (category === 'mode' && ((selected === 'single' && btnId.includes('single')) || 
                                          (selected === 'multi' && btnId.includes('multi')))) ||
                  (category === 'playstyle' && btnId.includes(selected)) ||
                  (category === 'playercount' && btnId.includes(selected))
                );
                
                if (isSelected) {
                  btn.setAttribute('material', 'color', this.brightenColor(material.color));
                } else {
                  btn.setAttribute('material', 'color', material.color);
                }
              }
            });
          }
          
          // Handle bot toggle buttons
          if (category === 'botfill') {
            const btn = document.querySelector('#menu-bot-fill');
            if (btn) {
              btn.setAttribute('material', 'color', selected ? '#880000' : '#440000');
            }
          } else if (category === 'botreplace') {
            const btn = document.querySelector('#menu-bot-replace');
            if (btn) {
              btn.setAttribute('material', 'color', selected ? '#008800' : '#004400');
            }
          }
        },
        
        brightenColor: function(color) {
          // Simple color brightening by increasing intensity
          const colorMap = {
            '#004499': '#0066cc',
            '#990044': '#cc0066',
            '#666600': '#999900',
            '#006666': '#009999',
            '#444400': '#777700',
            '#440044': '#770077'
          };
          return colorMap[color] || color;
        }
      });

      // Ammo.js Dual-Mesh Physics Component (from aframe-ammo-working.html)
      AFRAME.registerComponent('ammo-physics', {
        init: function() {
          this.el.addEventListener('model-loaded', () => {
            setTimeout(() => {
              this.setupAmmoMeshPhysics();
            }, 2000); // Wait for Ammo to be ready
          });
        },

        setupAmmoMeshPhysics: function() {
          if (!ammoInstance || !physicsWorld) {
            console.error('‚ùå Ammo.js not ready for mesh physics');
            setTimeout(() => this.setupAmmoMeshPhysics(), 1000);
            return;
          }

          const entityObject3D = this.el.object3D;
          console.log('üîß Setting up Ammo.js mesh physics (dual-mesh approach)');
          console.log('üéØ COLLISION MESH: Simple OBJ geometry for physics (invisible)');
          console.log('üé® VISUAL MESH: Detailed GLB model for appearance (no physics)');

          // Find the mesh in the OBJ
          let meshObject = null;
          entityObject3D.traverse((child) => {
            if (child.isMesh && child.geometry) {
              meshObject = child;
              console.log('Found mesh for Ammo physics:', child.name || 'unnamed');
              console.log('Mesh vertices:', child.geometry.attributes.position.count);
            }
          });

          if (!meshObject) {
            console.error('No mesh found for Ammo physics');
            return;
          }

          this.createAmmoTriangleMesh(meshObject.geometry);
        },

        createAmmoTriangleMesh: function(geometry) {
          const Ammo = ammoInstance;
          
          console.log('üîß Creating Ammo.js triangle mesh from geometry');

          // Get entity transforms
          const entityPosition = this.el.getAttribute('position') || { x: 0, y: 0, z: 0 };
          const entityRotation = this.el.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
          const entityScale = this.el.getAttribute('scale') || { x: 1, y: 1, z: 1 };

          // Create triangle mesh
          const triangle_mesh = new Ammo.btTriangleMesh(true, true);
          
          // Extract vertices
          const vertices = [];
          const positionAttribute = geometry.attributes.position;
          
          for (let i = 0; i < positionAttribute.count; i++) {
            vertices.push({
              x: positionAttribute.getX(i),
              y: positionAttribute.getY(i),
              z: positionAttribute.getZ(i)
            });
          }

          console.log('üìä Geometry vertices:', vertices.length);

          // Create temporary vectors for triangle vertices
          const vectA = new Ammo.btVector3(0, 0, 0);
          const vectB = new Ammo.btVector3(0, 0, 0);
          const vectC = new Ammo.btVector3(0, 0, 0);

          let triangleCount = 0;
          const indices = geometry.index;

          if (indices) {
            // Indexed geometry
            console.log('üîß Processing indexed geometry...');
            for (let i = 0; i < indices.count; i += 3) {
              const a = indices.getX(i);
              const b = indices.getX(i + 1);
              const c = indices.getX(i + 2);

              vectA.setX(vertices[a].x * entityScale.x);
              vectA.setY(vertices[a].y * entityScale.y);
              vectA.setZ(vertices[a].z * entityScale.z);

              vectB.setX(vertices[b].x * entityScale.x);
              vectB.setY(vertices[b].y * entityScale.y);
              vectB.setZ(vertices[b].z * entityScale.z);

              vectC.setX(vertices[c].x * entityScale.x);
              vectC.setY(vertices[c].y * entityScale.y);
              vectC.setZ(vertices[c].z * entityScale.z);

              triangle_mesh.addTriangle(vectA, vectB, vectC, true);
              triangleCount++;
            }
          } else {
            // Non-indexed geometry
            console.log('üîß Processing non-indexed geometry...');
            for (let i = 0; i < vertices.length - 2; i += 3) {
              vectA.setX(vertices[i].x * entityScale.x);
              vectA.setY(vertices[i].y * entityScale.y);
              vectA.setZ(vertices[i].z * entityScale.z);

              vectB.setX(vertices[i + 1].x * entityScale.x);
              vectB.setY(vertices[i + 1].y * entityScale.y);
              vectB.setZ(vertices[i + 1].z * entityScale.z);

              vectC.setX(vertices[i + 2].x * entityScale.x);
              vectC.setY(vertices[i + 2].y * entityScale.y);
              vectC.setZ(vertices[i + 2].z * entityScale.z);

              triangle_mesh.addTriangle(vectA, vectB, vectC, true);
              triangleCount++;
            }
          }

          console.log('üîß Added', triangleCount, 'triangles to physics mesh');

          // Clean up vectors
          Ammo.destroy(vectA);
          Ammo.destroy(vectB);
          Ammo.destroy(vectC);

          // Create BVH triangle mesh shape for concave meshes
          let shape = new Ammo.btBvhTriangleMeshShape(triangle_mesh, true, true);
          
          // Create rigid body
          let transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(entityPosition.x, entityPosition.y, entityPosition.z));
          
          // Apply rotation
          let quat = new Ammo.btQuaternion();
          quat.setEulerZYX(
            entityRotation.z * Math.PI / 180,
            entityRotation.y * Math.PI / 180, 
            entityRotation.x * Math.PI / 180
          );
          transform.setRotation(quat);

          let motionState = new Ammo.btDefaultMotionState(transform);
          let localInertia = new Ammo.btVector3(0, 0, 0);
          let mass = 0; // Static body

          let rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
          let rBody = new Ammo.btRigidBody(rigidBodyInfo);

          // Add environment with collision group 1 (default - collides with everything)
          physicsWorld.addRigidBody(rBody, 1, -1); // Group 1, collides with all groups (-1)

          console.log('‚úÖ COLLISION MESH: BVH triangle mesh added to Ammo.js physics world!');
          console.log('üéØ DUAL MESH SETUP: Simple collision OBJ + Detailed visual GLB!');
          console.log('üîß Collision mesh stats:', {
            trianglesAdded: triangleCount,
            geometryType: indices ? 'indexed' : 'non-indexed',
            shapeType: 'BVH_TRIANGLE_MESH_SHAPE'
          });

          // Create wireframe visualization
          this.createPhysicsWireframe(vertices, indices, entityPosition, entityRotation, entityScale);

          this.physicsReady = true;
        },

        createPhysicsWireframe: function(vertices, geometryIndices, entityPosition, entityRotation, entityScale) {
          console.log('üîß Creating physics wireframe visualization...');
          
          const wireframeGeometry = new THREE.BufferGeometry();
          const wireframeVertices = [];
          
          if (geometryIndices) {
            // Indexed geometry - create lines from triangles
            for (let i = 0; i < geometryIndices.count; i += 3) {
              const a = geometryIndices.getX(i);
              const b = geometryIndices.getX(i + 1);
              const c = geometryIndices.getX(i + 2);
              
              // Triangle edges
              wireframeVertices.push(
                vertices[a].x * entityScale.x, vertices[a].y * entityScale.y, vertices[a].z * entityScale.z,
                vertices[b].x * entityScale.x, vertices[b].y * entityScale.y, vertices[b].z * entityScale.z,
                
                vertices[b].x * entityScale.x, vertices[b].y * entityScale.y, vertices[b].z * entityScale.z,
                vertices[c].x * entityScale.x, vertices[c].y * entityScale.y, vertices[c].z * entityScale.z,
                
                vertices[c].x * entityScale.x, vertices[c].y * entityScale.y, vertices[c].z * entityScale.z,
                vertices[a].x * entityScale.x, vertices[a].y * entityScale.y, vertices[a].z * entityScale.z
              );
            }
          } else {
            // Non-indexed geometry
            for (let i = 0; i < vertices.length - 2; i += 3) {
              // Triangle edges
              wireframeVertices.push(
                vertices[i].x * entityScale.x, vertices[i].y * entityScale.y, vertices[i].z * entityScale.z,
                vertices[i + 1].x * entityScale.x, vertices[i + 1].y * entityScale.y, vertices[i + 1].z * entityScale.z,
                
                vertices[i + 1].x * entityScale.x, vertices[i + 1].y * entityScale.y, vertices[i + 1].z * entityScale.z,
                vertices[i + 2].x * entityScale.x, vertices[i + 2].y * entityScale.y, vertices[i + 2].z * entityScale.z,
                
                vertices[i + 2].x * entityScale.x, vertices[i + 2].y * entityScale.y, vertices[i + 2].z * entityScale.z,
                vertices[i].x * entityScale.x, vertices[i].y * entityScale.y, vertices[i].z * entityScale.z
              );
            }
          }
          
          wireframeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(wireframeVertices, 3));
          
          const wireframeMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5
          });
          
          this.physicsWireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
          this.physicsWireframe.position.set(entityPosition.x, entityPosition.y, entityPosition.z);
          this.physicsWireframe.rotation.set(
            entityRotation.x * Math.PI / 180,
            entityRotation.y * Math.PI / 180,
            entityRotation.z * Math.PI / 180
          );
          
          // Add to scene
          this.el.sceneEl.object3D.add(this.physicsWireframe);
          
          // Hide by default
          this.physicsWireframe.visible = false;
          
          console.log('‚úÖ Physics wireframe created (press W to toggle)');
        },

        toggleWireframe: function() {
          if (this.physicsWireframe) {
            this.physicsWireframe.visible = !this.physicsWireframe.visible;
            console.log('üîß Physics wireframe:', this.physicsWireframe.visible ? 'ON' : 'OFF');
          }
        },

        remove: function() {
          if (this.physicsWireframe) {
            this.el.sceneEl.object3D.remove(this.physicsWireframe);
          }
        }
      });



      // Wireframe toggle keyboard listener
      document.addEventListener('keydown', function(event) {
        if (event.key === 'w' || event.key === 'W') {
          const collisionEl = document.querySelector('[ammo-physics]');
          if (collisionEl && collisionEl.components['ammo-physics']) {
            collisionEl.components['ammo-physics'].toggleWireframe();
          }
        }
      });

      // Initialize Ammo.js when scene loads
      document.addEventListener('DOMContentLoaded', function() {
        debugLog('üìã DOM Content Loaded');
        debugLog('üîß Scene loaded, initializing Ammo.js physics...');
        
        // Track A-Frame availability
        if (typeof AFRAME !== 'undefined') {
          debugLog('‚úÖ A-Frame is available');
          onScriptLoad('A-Frame');
        } else {
          debugLog('‚è≥ Waiting for A-Frame...');
          let aframeWait = setInterval(() => {
            if (typeof AFRAME !== 'undefined') {
              clearInterval(aframeWait);
              debugLog('‚úÖ A-Frame loaded');
              onScriptLoad('A-Frame');
            }
          }, 100);
        }

        // Enhanced asset tracking
        setTimeout(() => {
          const assets = document.querySelector('a-assets');
          
          if (assets) {
            debugLog('üì¶ Setting up asset loading listeners...');
            
            // Track individual assets
            const myModel = document.querySelector('#myModel');
            const collisionObj = document.querySelector('#hallway-collision-obj');
            
            let assetsLoaded = 0;
            let assetsTotal = 2;
            let assetTimeout;
            
            function checkAssetsComplete() {
              debugLog(`üì¶ Assets loaded: ${assetsLoaded}/${assetsTotal}`);
              if (assetsLoaded >= assetsTotal) {
                clearTimeout(assetTimeout);
                debugLog('üé® All assets loaded successfully');
                updateProgress(6, '- Assets ready');
                
                              setTimeout(() => {
                updateProgress(7, '- Ready!');
                debugLog('‚úÖ All systems ready! Auto-hiding debug overlay...');
                
                // Add A-Frame loading monitoring
                setTimeout(() => {
                  debugLog('üé¨ Monitoring A-Frame loading state...');
                  monitorAFrameLoading();
                }, 500);
                
                // Auto-hide debug overlay on all platforms
                setTimeout(hideDebugOverlay, 5000);
              }, 1000);
              }
            }
            
            // Set generous timeout for all platforms (especially slower networks)
            const timeoutDuration = 30000; // 30s for all platforms
            assetTimeout = setTimeout(() => {
              debugLog('‚è∞ Asset loading timeout - continuing anyway');
              
              updateProgress(6, '- Assets ready (timeout)');
              setTimeout(() => {
                updateProgress(7, '- Ready!');
                debugLog('‚úÖ All systems ready!');
                
                // Monitor A-Frame loading
                setTimeout(() => {
                  debugLog('üé¨ Monitoring A-Frame loading state...');
                  monitorAFrameLoading();
                }, 500);
                
                // Auto-hide debug overlay on all platforms
                setTimeout(hideDebugOverlay, 5000);
              }, 1000);
            }, timeoutDuration);
            
            // Listen for individual asset loading
            if (myModel) {
              myModel.addEventListener('loaded', () => {
                debugLog('‚úÖ GLB model loaded');
                assetsLoaded++;
                checkAssetsComplete();
              });
              
              myModel.addEventListener('error', (e) => {
                debugLog('‚ùå GLB model failed to load', true);
                debugLog('üîÑ Will retry or continue with basic environment');
                // Note: No longer auto-disabling visual mesh - let it retry or work with basic geometry
                assetsLoaded++; // Count as loaded so we can continue
                checkAssetsComplete();
              });
            }
            
            if (collisionObj) {
              collisionObj.addEventListener('loaded', () => {
                debugLog('‚úÖ Collision OBJ loaded');
                assetsLoaded++;
                checkAssetsComplete();
              });
              
              collisionObj.addEventListener('error', () => {
                debugLog('‚ùå Collision OBJ failed to load', true);
                assetsLoaded++; // Count as loaded so we can continue
                checkAssetsComplete();
              });
            }
            
            // Also listen for the overall assets loaded event (backup)
            assets.addEventListener('loaded', () => {
              clearTimeout(assetTimeout);
              debugLog('üé® Assets container reports all loaded');
              updateProgress(6, '- Assets ready');
              
                             setTimeout(() => {
                 updateProgress(7, '- Ready!');
                 debugLog('‚úÖ All systems ready!');
                 
                 // Monitor A-Frame loading
                 setTimeout(() => {
                   debugLog('üé¨ Monitoring A-Frame loading state...');
                   monitorAFrameLoading();
                 }, 500);
                 
                 // Auto-hide debug overlay on all platforms
                 setTimeout(hideDebugOverlay, 5000);
               }, 1000);
            });
            
          } else {
            debugLog('‚ùå No assets element found');
                         // Skip to ready if no assets
             updateProgress(6, '- No assets to load');
             setTimeout(() => {
               updateProgress(7, '- Ready!');
               
               // Monitor A-Frame loading
               setTimeout(() => {
                 debugLog('üé¨ Monitoring A-Frame loading state (no assets)...');
                 monitorAFrameLoading();
               }, 500);
               
               // Auto-hide debug overlay on all platforms
               setTimeout(hideDebugOverlay, 5000);
             }, 1000);
          }
        }, 1000);
        
        setTimeout(() => {
          updateProgress(2, '- Starting physics initialization...');
          initAmmoPhysics();
        }, 1000);
        
        // Safety: Always ensure debug overlay disappears
        setTimeout(() => {
          if (debugStep < 7) {
            debugLog('‚è∞ SAFETY: Forcing completion after 30 seconds');
            updateProgress(7, '- Forced ready');
            setTimeout(hideDebugOverlay, 1000);
          }
        }, 30000);
      });

      console.log('üéØ Ammo.js collision system ready! (Performance Optimized)');
      console.log('üéÆ Original zero-gravity project with Ammo.js physics!');
      console.log('üîß Everything now uses Ammo.js physics:');
      console.log('  üìê Environment: Triangle mesh collision (20k+ triangles, scale 1.0)');
      console.log('  üë§ Player: Kinematic capsule (10fps collision checks)');
      console.log('  ‚öæ Balls: Sphere bodies with collision sound detection');
      console.log('  ü§ñ Bots: Sphere collision bodies');
      console.log('  üî¥ Shot balls: X button shooting (auto-remove after 10s)');
      console.log('  üö´ Surface grabbing: DISABLED for performance');
      console.log('  ‚úÖ Ball grabbing: ENABLED (player2 ball only)');
      console.log('‚ö° Performance optimizations: Disabled surface grabbing, cached collision detection');
      console.log('üîß Press W to toggle collision wireframe');
      console.log('üî¥ Press X button to shoot balls from camera');
      console.log('‚öæ Console spam has been disabled for cleaner output!');

    </script>

    <a-scene fps-counter game-manager sound-manager multiplayer-sync menu-toggle
             renderer="antialias: true; colorManagement: true; shadowMapEnabled: false; maxDeltaTime: 0.2"
             webxr="requiredFeatures: local-floor"
             obb-collider="showColliders: true">
      
      <!-- Space Station Environment -->
            <!-- SCI-FI HALLWAY ENVIRONMENT MODEL -->
        <a-assets>
          <a-asset-item id="myModel" src="https://pub-65c21cd4f13345fcb1574dc28def6a19.r2.dev/sci_fi_hallway_center.glb" response-type="arraybuffer"></a-asset-item>
          <a-asset-item id="hallway-collision-obj" src="assets/sci_fi_hallway_center-simple2.obj"></a-asset-item>
        </a-assets>
      <!-- Dual-Mesh System: Invisible collision + Visible graphics -->
      
      <!-- COLLISION MESH: Ammo.js triangle mesh physics (invisible) -->
      <a-entity id="hallway-collision"
                obj-model="obj: #hallway-collision-obj"
                ammo-physics
                position="0 0 0"
                scale="1 1 1"
                visible="false">
      </a-entity>
      
      <!-- VISUAL MESH: Detailed GLB model for appearance (no physics) -->
      <a-entity id="hallway-visual"
                gltf-model="#myModel" 
                position="0 0 0" 
                scale="1 1 1">
      </a-entity>

      <!-- Floating objects/balls (spawned at center) -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ff0000" 
                material="shader: standard; emissive: #ff0000; emissiveIntensity: 1.5"
                zerog-ball="player: player1">
        <a-entity light="type: point;
                       color: #ff0000;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2;"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff0000" material="wireframe: true; color: #ff0000; opacity: 0.5"></a-sphere>
        <a-entity id="red-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#0000ff" 
                material="shader: standard; emissive: #0000ff; emissiveIntensity: 1.5"
                zerog-ball="player: player2">
        <a-entity light="type: point; 
                       color: #0000ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#0000ff" material="wireframe: true; color: #0000ff; opacity: 0.5"></a-sphere>
        <a-entity id="blue-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player 3 Ball (Green) -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#00ff00" 
                material="shader: standard; emissive: #00ff00; emissiveIntensity: 1.5"
                zerog-ball="player: player3">
        <a-entity light="type: point; 
                       color: #00ff00;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#00ff00" material="wireframe: true; color: #00ff00; opacity: 0.5"></a-sphere>
        <a-entity id="green-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player 4 Ball (Yellow) -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ffff00" 
                material="shader: standard; emissive: #ffff00; emissiveIntensity: 1.5"
                zerog-ball="player: player4">
        <a-entity light="type: point; 
                       color: #ffff00;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ffff00" material="wireframe: true; color: #ffff00; opacity: 0.5"></a-sphere>
        <a-entity id="yellow-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player with zero-g physics -->
      <a-entity id="player" position="0 2 12" zerog-player="mass: 70; thrusterForce: 0.8">
        <a-entity id="rig" position="0 0 0">
          <a-entity camera look-controls="pointerLockEnabled: false">
            <!-- Player target sphere (like in original dodgeball project) -->
            <a-sphere id="player-target" 
                      radius="0.2" 
                      color="#0000ff" 
                      material="shader: standard; emissive: #0000ff; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                      position="0 0 0"
                      impact-effect="color: #0000ff">
              <a-entity light="type: point; color: #0000ff; intensity: 1; distance: 3"></a-entity>
              <!-- Impact sphere with animation component -->
              <a-sphere id="player-impact" radius="0.1" color="#0000ff" opacity="0" visible="false" material="side: double; transparent: true"
                animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
                animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
              </a-sphere>
            </a-sphere>
            
            <!-- HUD display -->
            <a-entity id="version-display" position="0 0.3 -0.5" text="value: Zero-G v2.0; align: center; width: 0.4; color: #ffffff"></a-entity>
            
            <!-- Game Status Display -->
            <a-entity id="hud-status" position="0 0.2 -0.5" text="value: Singleplayer; align: center; width: 1.1; color: #ffffff"></a-entity>
            
            <!-- Score Display in HUD -->
            <a-entity id="hud-score" position="0 0.1 -0.5" visible="false">
              <a-entity position="-0.15 0 0" text="value: You: 0; align: center; width: 1.5; color: #0099ff"></a-entity>
              <a-entity position="0.15 0 0" text="value: Bot: 0; align: center; width: 1.5; color: #ff4444"></a-entity>
            </a-entity>
            
            <!-- Timer Display in HUD -->
            <a-entity id="hud-timer" position="0 0.05 -0.5" text="value: Time: 3:00; align: center; width: 1.2; color: #ffff00" visible="false"></a-entity>
            
            <!-- Game Messages in HUD -->
            <a-entity id="hud-message" position="0 0 -0.5" text="value: Press A to Start; align: center; width: 1.1; color: #ffffff" visible="false"></a-entity>
            
            <!-- Enhanced Game Menu in HUD (initially hidden) -->
            <a-entity id="game-menu" position="0 0 -0.8" visible="false">
              <!-- Menu background panel -->
              <a-plane width="1.2" height="1.0" color="#000000" material="opacity: 0.9; transparent: true" position="0 0 -0.01"></a-plane>
              
              <!-- Menu title -->
              <a-text value="GAME SETUP" position="0 0.42 0" align="center" width="1.2" color="#ffffff"></a-text>
              
              <!-- Game Mode Selection -->
              <a-text value="GAME MODE:" position="0 0.32 0" align="center" width="0.8" color="#ffff00"></a-text>
              <a-entity id="menu-singleplayer" position="-0.2 0.25 0" 
                        geometry="primitive: plane; width: 0.18; height: 0.06"
                        material="color: #004499; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="SINGLE" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              <a-entity id="menu-multiplayer" position="0.2 0.25 0"
                        geometry="primitive: plane; width: 0.18; height: 0.06"
                        material="color: #990044; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="MULTI" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Play Style Selection (only for multiplayer) -->
              <a-entity id="menu-playstyle-section" visible="false">
                <a-text value="PLAY STYLE:" position="0 0.15 0" align="center" width="0.8" color="#ffff00"></a-text>
                <a-entity id="menu-solo" position="-0.2 0.08 0" 
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #666600; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="SOLO" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-teams" position="0.2 0.08 0"
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #006666; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="TEAMS" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Player Count Selection (only for multiplayer) -->
              <a-entity id="menu-playercount-section" visible="false">
                <a-text value="PLAYERS:" position="0 -0.02 0" align="center" width="0.8" color="#ffff00"></a-text>
                <a-entity id="menu-2players" position="-0.2 -0.09 0" 
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #444400; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="2" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-4players" position="0.2 -0.09 0"
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #440044; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="4" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Bot Options (only for multiplayer) -->
              <a-entity id="menu-bots-section" visible="false">
                <a-text value="BOTS:" position="0 -0.19 0" align="center" width="0.8" color="#ffff00"></a-text>
                <a-entity id="menu-bot-fill" position="-0.2 -0.26 0" 
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #440000; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="FILL" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-bot-replace" position="0.2 -0.26 0"
                          geometry="primitive: plane; width: 0.18; height: 0.06"
                          material="color: #004400; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="REPLACE" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Start Game Button -->
              <a-entity id="menu-start-game" position="0 -0.36 0" 
                        geometry="primitive: plane; width: 0.4; height: 0.08"
                        material="color: #009900; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="START GAME" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Current Configuration Display -->
              <a-text id="menu-current-config" value="Singleplayer" position="0 -0.46 0" align="center" width="0.7" color="#ffffff"></a-text>
              
              <!-- Instructions -->
              <a-text value="B to close" 
                      position="0 -0.52 0" align="center" width="0.6" color="#888888"></a-text>
            </a-entity>
          </a-entity>
          
          <a-entity id="leftHand" 
                   hand-controls="hand: left"
                   oculus-touch-controls="hand: left"
                   laser-controls="hand: left"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
            
            <!-- Collision Sphere (like balls) -->

          </a-entity>
          
          <a-entity id="rightHand" 
                   hand-controls="hand: right"
                   oculus-touch-controls="hand: right"
                   laser-controls="hand: right"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Multiplayer Player Targets -->
      <!-- Player 1 (Red) -->
      <a-entity id="player-1" position="0 2 -12" visible="false">
        <a-sphere id="player-1-target" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ff0000">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="player-1-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Player 2 (Green) -->
      <a-entity id="player-2" position="4 2 -8" visible="false">
        <a-sphere id="player-2-target" 
                  radius="0.2" 
                  color="#00ff00" 
                  material="shader: standard; emissive: #00ff00; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #00ff00">
          <a-entity light="type: point; color: #00ff00; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="player-2-impact" radius="0.1" color="#00ff00" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Player 3 (Yellow) -->
      <a-entity id="player-3" position="-4 2 -8" visible="false">
        <a-sphere id="player-3-target" 
                  radius="0.2" 
                  color="#ffff00" 
                  material="shader: standard; emissive: #ffff00; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ffff00">
          <a-entity light="type: point; color: #ffff00; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="player-3-impact" radius="0.1" color="#ffff00" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Zero-G Bot (for singleplayer) -->
      <a-entity id="zerog-bot" position="0 2 -10" zerog-bot="enabled: true; difficulty: medium">
        <a-sphere id="bot-target" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; wireframe: false"
                  position="0 0 0"
                  impact-effect="color: #ff0000">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Add game manager entity with score display -->
      <a-entity id="game-manager" game-manager>
        <!-- Version display moved closer to top -->
        <a-entity id="version-display-override" position="0 7 0" text="value: Zero-G v1.0; align: center; width: 0.5; color: #ffffff"></a-entity>
        
        <!-- Large colored score display -->
        <a-entity id="score-display" position="0 6.5 0">
          <!-- Blue player score (left side) -->
          <a-entity id="blue-score" position="-0.5 0 0" text="value: 0; align: center; width: 4; color: #0099ff"></a-entity>
          <!-- Dash separator -->
          <a-entity position="0 0 0" text="value: -; align: center; width: 4; color: #ffffff"></a-entity>
          <!-- Red player score (right side) -->
          <a-entity id="red-score" position="0.5 0 0" text="value: 0; align: center; width: 4; color: #ff4444"></a-entity>
        </a-entity>
        
        <a-entity id="timer-display" position="0 6 0" text="value: Time: 3:00; align: center; width: 2; color: #ffff00"></a-entity>
        <a-entity id="start-message" position="0 5.5 0" text="value: Press A to Start; align: center; width: 2; color: #ffffff"></a-entity>
      </a-entity>

      <!-- Ambient space lighting -->
      <a-entity light="type: ambient; color: #404040; intensity: 0.5"></a-entity>
      
      <!-- Directional light simulating distant star -->
      <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="5 5 5"></a-entity>

      <!-- Add impact sound entities -->
      <a-entity id="impact-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 2;">
      </a-entity>

      <!-- Add bounce sound entity -->
      <a-entity id="bounce-sound" sound="src: url(audio/impact-cinematic-boom-5-352465.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 8;
                                        rate: 1.5;">
      </a-entity>

      <!-- Space background -->
      <a-sky color="#000011"></a-sky>
    </a-scene>
  </body>
</html>
</html>