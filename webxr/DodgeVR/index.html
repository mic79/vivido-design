<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Environment</title>
    <meta name="description" content="Basic WebXR environment using A-Frame">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://unpkg.com/aframe-glow-component@1.0.0/dist/aframe-glow-component.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="advanced-bot.js"></script>
    <script src="game-modes.js"></script>
  </head>
  <body>
    <script>
      // Physics world setup
      const world = new CANNON.World();
      world.gravity.set(0, 0, 0); // Zero gravity for the world
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // Create materials
      const defaultMaterial = new CANNON.Material('default');
      const ballMaterial = new CANNON.Material('ball');
      const floorMaterial = new CANNON.Material('floor');
      const racketMaterial = new CANNON.Material('racket');
      const backWallMaterial = new CANNON.Material('backWall');

      // Create contact materials
      const ballFloorContact = new CANNON.ContactMaterial(
        ballMaterial,
        floorMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballFloorContact);

      // Add contact material for ball vs. default (walls/ceiling)
      const ballDefaultContact = new CANNON.ContactMaterial(
        ballMaterial,
        defaultMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballDefaultContact);

      // Add contact material for ball vs. ball
      const ballBallContact = new CANNON.ContactMaterial(
        ballMaterial,
        ballMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballBallContact);

      // Add contact material for ball vs. racket (with friction for spin)
      const ballRacketContact = new CANNON.ContactMaterial(
        ballMaterial,
        racketMaterial,
        {
          friction: 0.8,  // Very high friction for spin transfer
          restitution: 0.85,  // Slightly less bouncy than walls
          contactEquationStiffness: 1e8,  // Stiffer contact for better spin transfer
          contactEquationRelaxation: 3    // Better contact resolution
        }
      );
      world.addContactMaterial(ballRacketContact);

      // Add contact material for ball vs. back walls (no bounce - should respawn)
      const ballBackWallContact = new CANNON.ContactMaterial(
        ballMaterial,
        backWallMaterial,
        {
          friction: 0.0,
          restitution: 0.0  // No bounce - ball should respawn instead
        }
      );
      world.addContactMaterial(ballBackWallContact);

      // Add collision event handling to the physics world
      world.addEventListener('beginContact', function(event) {
        const bodyA = event.bodyA;
        const bodyB = event.bodyB;
        
        // Get the A-Frame entities associated with these bodies
        const entityA = bodyA.el;
        const entityB = event.bodyB.el;
        
        // Physics world collision detection (for ball-ball and ball-wall collisions)
        
        if (entityA && entityB) {
          // Check if either entity is a ball
          const isBallA = entityA.hasAttribute('simple-grab');
          const isBallB = entityB.hasAttribute('simple-grab');
          
          // If both are balls, play bounce sound at collision point
          if (isBallA && isBallB) {
            const bounceSound = document.querySelector('#bounce-sound');
            if (bounceSound) {
              // Calculate collision point as midpoint between balls
              const collisionPoint = new THREE.Vector3();
              collisionPoint.addVectors(bodyA.position, bodyB.position).multiplyScalar(0.5);
              bounceSound.object3D.position.copy(collisionPoint);
              // Stop any currently playing sound before starting a new one
              bounceSound.components.sound.stopSound();
              bounceSound.components.sound.playSound();
            }
          }
          
          // CANNON-based back wall detection (backup for OBB misses at high speed)
          // Check if a ball hit a back wall (z=-8 or z=+8)
          const ballEntity = isBallA ? entityA : (isBallB ? entityB : null);
          const wallEntity = isBallA ? entityB : (isBallB ? entityA : null);
          if (ballEntity && wallEntity && (isBallA !== isBallB)) {
            const wallPos = wallEntity.getAttribute('position');
            const wallGeom = wallEntity.getAttribute('geometry');
            if (wallPos && wallGeom && wallGeom.width === 4 && wallGeom.height === 4) {
              const isBackWallBot = Math.abs(wallPos.z + 8) < 0.01;
              const isBackWallPlayer = Math.abs(wallPos.z - 8) < 0.01;
              if (isBackWallBot || isBackWallPlayer) {
                const grab = ballEntity.components['simple-grab'];
                if (grab && grab.body) {
                  const ballPlayer = grab.data.player;
                  const hitOpponentWall = (ballPlayer === 'player2' && isBackWallBot) ||
                                          (ballPlayer === 'player1' && isBackWallPlayer);
                  const hitOwnWall = (ballPlayer === 'player2' && isBackWallPlayer) ||
                                     (ballPlayer === 'player1' && isBackWallBot);
                  if (hitOpponentWall) {
                    // Return ball to spawn at 10m/s (same logic as OBB handler)
                    if (grab.constraint) { world.removeConstraint(grab.constraint); grab.constraint = null; }
                    if (grab.handBody) { world.removeBody(grab.handBody); grab.handBody = null; }
                    grab.body.mass = 1; grab.body.updateMassProperties();
                    grab.isGrabbed = false; grab.grabbingHand = null;
                    grab.isReturning = true;
                    grab.returningGraceUntil = Date.now() + 1000;
                    grab.body.velocity.set(0, 0, 0);
                    grab.body.angularVelocity.set(0, 0, 0);
                    grab.body.quaternion.set(0, 0, 0, 1);
                    grab.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
                    const cp = grab.body.position;
                    const sp = grab.initialPosition;
                    const dx = sp.x - cp.x, dy = sp.y - cp.y, dz = sp.z - cp.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist > 0.01) {
                      grab.body.velocity.set((dx/dist)*10, (dy/dist)*10, (dz/dist)*10);
                    } else {
                      grab.resetPosition();
                    }
                  } else if (hitOwnWall) {
                    grab.isReturning = false;
                    grab.resetPosition();
                  }
                }
              }
            }
          }
          
          // Create and dispatch collision events for both entities
          const eventA = new CustomEvent('collision', {
            detail: { body: bodyB, bodyEl: entityB }
          });
          const eventB = new CustomEvent('collision', {
            detail: { body: bodyA, bodyEl: entityA }
          });
          
          entityA.dispatchEvent(eventA);
          entityB.dispatchEvent(eventB);
        }
      });

      // Add end contact event handling
      world.addEventListener('endContact', function(event) {
        const bodyA = event.bodyA;
        const bodyB = event.bodyB;
        
        // Check for racket-ball contact ending
        if (bodyA.isRacket) {
          bodyA.isInContact = false;
          bodyA.contactBall = null;
        }
        if (bodyB.isRacket) {
          bodyB.isInContact = false;
          bodyB.contactBall = null;
        }
      });

      // Game state
      const gameState = {
        score: { player1: 0, player2: 0 },
        timeRemaining: 120, // 2 minutes in seconds
        isPlaying: false,
        isReady: { player1: false, player2: false },
        ballSpawned: { player1: false, player2: false }
      };

      // Racket mode state - per hand tracking
      const racketMode = {
        player1: { left: false, right: false }, // Red player / opponent in multiplayer
        player2: { left: false, right: false }  // Blue player / local player
      };

      // Multiplayer state
      let isMultiplayer = false;
      let isHost = false;
      let peer = null;
      let conn = null;
      let multiplayerSlot = null;
      let multiplayerStatus = 'Singleplayer';
      let hasConnected = false;
      const MAX_LOBBIES = 10;
      let multiplayerStartType = 'dodgeball';
      let sessionID = null;
      let connectionState = 'disconnected';
      let lastMultiplayerToggle = 0;
      let remotePlayerState = null;
      let remoteBallState = null;
      let multiplayerCleanup = null;
      let isSearchingForMatch = false;

      // Helper: update version display with status
      function updateMultiplayerStatus(text) {
        const versionDisplay = document.getElementById('version-display');
        if (versionDisplay) {
          versionDisplay.setAttribute('text', 'value', `v0.20 | ${text}`);
        }
      }

      // Helper: update mode display
      function updateModeDisplay(mode, enabled) {
        const scene = document.querySelector('a-scene');
        const gameModesComponent = scene && scene.components['game-modes'];
        if (gameModesComponent && gameModesComponent.updateModeDisplay) {
          gameModesComponent.updateModeDisplay(mode, enabled);
        } else {
          // Fallback if component not ready
          setTimeout(() => updateModeDisplay(mode, enabled), 100);
        }
      }

      // Listen for Y button to toggle multiplayer and B button to switch modes
      AFRAME.registerComponent('multiplayer-toggle', {
        init: function() {
          this.lastModeSwitch = 0;
          
          this.el.sceneEl.addEventListener('ybuttondown', () => {
            const now = Date.now();
            if (now - lastMultiplayerToggle < 1000) return; // debounce
            lastMultiplayerToggle = now;
            if (!isMultiplayer) {
              updateMultiplayerStatus('Searching for match...');
              isSearchingForMatch = true;
              startMultiplayerConnection();
            } else {
              updateMultiplayerStatus('Returning to singleplayer...');
              isSearchingForMatch = false;
              endMultiplayer();
            }
          });

          // Listen for B button to switch game modes
          this.el.sceneEl.addEventListener('bbuttondown', () => {
            const now = Date.now();
            if (now - this.lastModeSwitch < 1000) return; // debounce
            this.lastModeSwitch = now;
            
            // In multiplayer, only host can switch modes
            if (isMultiplayer && !isHost) {
              console.log('Only host can switch modes in multiplayer');
              return;
            }
            
            this.switchGameMode();
          });

          // Listen for grip button presses for individual racket control
          this.el.sceneEl.addEventListener('gripdown', (evt) => {
            const hand = evt.target;
            this.handleGripDown(hand);
          });
          
          this.el.sceneEl.addEventListener('gripup', (evt) => {
            const hand = evt.target;
            this.handleGripUp(hand);
          });
        },
        
        handleGripDown: function(hand) {
          const isLeftHand = hand.id === 'leftHand';
          const isRightHand = hand.id === 'rightHand';
          
          if (isLeftHand) {
            this.setRacketVisible('left', true);
          } else if (isRightHand) {
            this.setRacketVisible('right', true);
          }
        },
        
        handleGripUp: function(hand) {
          const isLeftHand = hand.id === 'leftHand';
          const isRightHand = hand.id === 'rightHand';
          
          if (isLeftHand) {
            this.setRacketVisible('left', false);
          } else if (isRightHand) {
            this.setRacketVisible('right', false);
          }
        },
        
        setRacketVisible: function(handSide, visible) {
          // Local player is always player2
          racketMode.player2[handSide] = visible;
          
          // Get the appropriate racket element
          const racketId = handSide === 'left' ? '#leftHandRacket' : '#rightHandRacket';
          const racket = document.querySelector(racketId);
          
          if (racket) {
            racket.setAttribute('visible', visible);
            console.log(`${handSide} racket ${visible ? 'activated' : 'deactivated'}`);
          }
          
          // Send racket state to opponent in multiplayer
          if (isMultiplayer && conn && conn.open) {
            conn.send({ 
              type: 'racket-mode', 
              player: 'player2', 
              hand: handSide, 
              active: visible 
            });
          }
        },

        switchGameMode: function() {
          const scene = this.el.sceneEl;
          const gameModesComponent = scene.components['game-modes'];
          
          if (!gameModesComponent) {
            console.log('Game modes component not found');
            return;
          }
          
          // Get current mode
          const currentMode = gameModesComponent.data.mode;
          const isEnabled = gameModesComponent.data.enabled;
          
          // Toggle between default and bouncing-ball modes
          let newMode, newEnabled;
          if (!isEnabled || currentMode === 'default') {
            newMode = 'bouncing-ball';
            newEnabled = true;
          } else {
            newMode = 'default';
            newEnabled = false;
          }
          
          // Apply mode change locally
          this.applyModeChange(newMode, newEnabled);
          
          // Send mode change to peer in multiplayer
          if (isMultiplayer && conn && conn.open) {
            conn.send({
              type: 'mode-change',
              mode: newMode,
              enabled: newEnabled
            });
          }
          
          console.log(`Mode switched to: ${newEnabled ? newMode : 'default (disabled)'}`);
        },

        applyModeChange: function(mode, enabled) {
          const scene = this.el.sceneEl;
          const gameModesComponent = scene.components['game-modes'];
          
          if (gameModesComponent) {
            // Remove current mode if any
            if (gameModesComponent.data.enabled) {
              gameModesComponent.remove();
            }
            
            // Apply new mode
            scene.setAttribute('game-modes', `enabled: ${enabled}; mode: ${mode}`);
            
            // Update mode display
            updateModeDisplay(mode, enabled);
          }
        }
      });

      // Multiplayer connection logic (slot-based, PeerJS, TURN support)
      async function startMultiplayerConnection() {
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        // Keep bot enabled during connection phase
        isMultiplayer = false;
        try {
          const slot = await findAvailableSlot(multiplayerStartType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupHost(multiplayerSlot);
          } else {
            await setupPeer(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      async function checkPeerAvailability(id) {
        return new Promise((resolve) => {
          const tempPeer = new Peer(id, { host: "0.peerjs.com", port: 443, secure: true });
          const timeout = setTimeout(() => {
            tempPeer.destroy();
            resolve(false);
          }, 2000);
          tempPeer.on("open", () => {
            clearTimeout(timeout);
            tempPeer.destroy();
            resolve(true);
          });
          tempPeer.on("error", (err) => {
            clearTimeout(timeout);
            tempPeer.destroy();
            if (err.type === 'unavailable-id') {
              resolve(false);
            } else {
              resolve(true);
            }
          });
        });
      }

      async function findAvailableSlot(desiredStartType) {
        for (let i = 1; i <= MAX_LOBBIES; i++) {
          const hostId = `dot-host-${desiredStartType}-${i}`;
          const peerId = `dot-peer-${desiredStartType}-${i}`;
          const hostAvailable = await checkPeerAvailability(hostId);
          if (hostAvailable) {
            return { slotNumber: i, role: 'host' };
          } else {
            const peerAvailable = await checkPeerAvailability(peerId);
            if (peerAvailable) {
              return { slotNumber: i, role: 'peer' };
            }
          }
        }
        return null;
      }

      async function setupPeer(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = false;
        sessionID = `dot-peer-${multiplayerStartType}-${slotNumber}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Connecting to host...');
          const hostID = `dot-host-${multiplayerStartType}-${slotNumber}`;
          conn = peer.connect(hostID);
          conn.on("open", function() {
            setupConnectionHandlers(conn);
            onMultiplayerStart();
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      async function setupHost(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = true;
        sessionID = `dot-host-${multiplayerStartType}-${slotNumber}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev/");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Waiting for opponent...');
          peer.on("connection", function(newConn) {
            if (conn) {
              newConn.close();
            } else {
              conn = newConn;
              conn.on("open", function() {
                setupConnectionHandlers(conn);
                onMultiplayerStart();
              });
            }
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function setupConnectionHandlers(conn) {
        conn.on('data', (data) => {
          if (data.type === 'player-state') {
            remotePlayerState = data.state;
          } else if (data.type === 'ball-state') {
            remoteBallState = data.state;
          } else if (data.type === 'score-update') {
            // Mirror remote/local for display
            multiplayerScore.remote = data.score.local;
            multiplayerScore.local = data.score.remote;
            updateScoreDisplayMultiplayer();
          } else if (data.type === 'racket-mode') {
            // Sync opponent's per-hand racket mode state
            racketMode.player1[data.hand] = data.active; // Remote player becomes player1
            console.log(`Opponent ${data.hand} racket:`, data.active ? 'ON' : 'OFF');
          } else if (data.type === 'ready-update') {
            // Sync ready state
            multiplayerReady.remote = data.ready;
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].updateReadyState();
            }
          } else if (data.type === 'countdown-start') {
            // Sync countdown start
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].syncedStartCountdown(data.startTime);
            }
          } else if (data.type === 'game-state') {
            // Sync game state changes (overtime/end)
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              const gm = gameManager.components['game-manager'];
              gm.matchState = data.state;
              
              if (data.state === 'OVERTIME') {
                gm.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next goal wins!');
                console.log('Synced: Match went to overtime');
              } else if (data.state === 'ENDED') {
                // Flip the winner message for the receiving player
                const flippedWinner = data.winner.includes('You win!') ? 'Opponent wins!' : 'You win!';
                gm.startMessage.setAttribute('visible', true);
                gm.startMessage.setAttribute('text', 'value', `${flippedWinner}\nPress A to play again`);
                gm.timerDisplay.setAttribute('text', 'value', 'Match ended');
                gm.gameStarted = false;
                console.log('Synced: Match ended -', flippedWinner);
              }
            }
          } else if (data.type === 'mode-change') {
            // Sync game mode changes from host
            const scene = document.querySelector('a-scene');
            const multiplayerToggle = scene && scene.components['multiplayer-toggle'];
            if (multiplayerToggle) {
              multiplayerToggle.applyModeChange(data.mode, data.enabled);
              console.log(`Received mode change: ${data.enabled ? data.mode : 'default (disabled)'}`);
            }
          }
        });
        conn.on('close', () => {
          updateMultiplayerStatus('Connection lost. Returning to singleplayer.');
          setTimeout(() => {
            endMultiplayer();
          }, 100); // Small delay to ensure proper cleanup
        });
        conn.on('error', (err) => {
          updateMultiplayerStatus('Connection error. Returning to singleplayer.');
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function sendPlayerState(state) {
        if (conn && conn.open) {
          conn.send({ type: 'player-state', state });
        }
      }
      function sendBallState(state) {
        if (conn && conn.open) {
          conn.send({ type: 'ball-state', state });
        }
      }

      function onMultiplayerStart() {
        // Only fully start multiplayer when connection is established
        if (conn && conn.open) {
          // Hide bot, disable bot logic
          const bot = document.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          isMultiplayer = true;
          multiplayerStatus = 'Multiplayer Connected';
          updateMultiplayerStatus('Multiplayer Connected');
          isSearchingForMatch = false;
          
          // Switch to multiplayer score display immediately
          multiplayerScore = { local: 0, remote: 0 };
          multiplayerReady = { local: false, remote: false };
          updateScoreDisplayMultiplayer();
          
          // Set game to waiting for ready state
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            gameManager.components['game-manager'].setMultiplayerWaiting();
          }
        }
      }
      function endMultiplayer() {
        isMultiplayer = false;
        multiplayerStatus = 'Singleplayer';
        updateMultiplayerStatus('Singleplayer');
        cleanupMultiplayer();
        // Re-enable bot
        const bot = document.querySelector('[advanced-bot]');
        if (bot) bot.setAttribute('advanced-bot', 'enabled', true);
        remotePlayerState = null;
        remoteBallState = null;
        multiplayerScore = { local: 0, remote: 0 };
        multiplayerReady = { local: false, remote: false };
        // Clear remote body tracking so bot-body reverts to AI idle animation
        const botBody = document.querySelector('#bot-body');
        if (botBody && botBody.components['mixamo-body']) {
          botBody.components['mixamo-body'].remoteHandData = null;
        }
        
        // Reset the actual game manager scores
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].playerScore = 0;
          gameManager.components['game-manager'].botScore = 0;
        }
        
        // Restore singleplayer score display
        const blueScore = document.getElementById('blue-score');
        const redScore = document.getElementById('red-score');
        if (blueScore && redScore) {
          blueScore.setAttribute('text', 'value', '0');
          redScore.setAttribute('text', 'value', '0');
        }
        isSearchingForMatch = false;
        // Set bot to default singleplayer position (head height)
        const botEntity = document.querySelector('[advanced-bot]');
        if (botEntity) {
          botEntity.object3D.position.set(0, 1.6, -6);
          botEntity.object3D.rotation.set(0, 0, 0);
        }
      }
      function cleanupMultiplayer() {
        if (conn) { try { conn.close(); } catch(e){} }
        if (peer) { try { peer.destroy(); } catch(e){} }
        conn = null;
        peer = null;
        multiplayerSlot = null;
        hasConnected = false;
      }

      // Attach multiplayer-toggle to scene
      document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene && !scene.hasAttribute('multiplayer-toggle')) {
          scene.setAttribute('multiplayer-toggle', '');
        }
        // Wait for the scene to load, then set bot to default singleplayer position (head height) at startup
        function setBotToDefaultPosition() {
          const botEntity = document.querySelector('[advanced-bot]');
          if (botEntity) {
            botEntity.object3D.position.set(0, 1.6, -6);
            botEntity.object3D.rotation.set(0, 0, 0);
          } else {
            setTimeout(setBotToDefaultPosition, 50);
          }
        }
        if (scene) {
          scene.addEventListener('loaded', setBotToDefaultPosition);
        } else {
          setBotToDefaultPosition();
        }
      });

      // --- GAME STATE SYNC ---
      // In tick, send local player2 (blue) and ball state; apply mirrored remote to player1 (red)
      AFRAME.registerComponent('multiplayer-sync', {
        tick: function() {
          // In multiplayer, send head + hand transforms for full body sync
          if (isMultiplayer && conn && conn.open) {
            const camera = document.querySelector('[camera]');
            const leftHand = document.querySelector('#leftHand');
            const rightHand = document.querySelector('#rightHand');
            if (camera) {
              const worldPos = new THREE.Vector3();
              camera.object3D.getWorldPosition(worldPos);
              const worldQuat = new THREE.Quaternion();
              camera.object3D.getWorldQuaternion(worldQuat);
              const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');

              const state = {
                x: worldPos.x, y: worldPos.y, z: worldPos.z,
                rx: worldRot.x, ry: worldRot.y, rz: worldRot.z,
                hqx: worldQuat.x, hqy: worldQuat.y, hqz: worldQuat.z, hqw: worldQuat.w
              };

              // Include hand positions + quaternions if controllers have valid tracking
              if (leftHand) {
                const lp = new THREE.Vector3();
                const lq = new THREE.Quaternion();
                leftHand.object3D.getWorldPosition(lp);
                leftHand.object3D.getWorldQuaternion(lq);
                // Only include if hand has a real tracked position (not at origin)
                if (lp.lengthSq() > 0.001) {
                  state.lhx = lp.x; state.lhy = lp.y; state.lhz = lp.z;
                  state.lhqx = lq.x; state.lhqy = lq.y; state.lhqz = lq.z; state.lhqw = lq.w;
                }
              }
              if (rightHand) {
                const rp = new THREE.Vector3();
                const rq = new THREE.Quaternion();
                rightHand.object3D.getWorldPosition(rp);
                rightHand.object3D.getWorldQuaternion(rq);
                if (rp.lengthSq() > 0.001) {
                  state.rhx = rp.x; state.rhy = rp.y; state.rhz = rp.z;
                  state.rhqx = rq.x; state.rhqy = rq.y; state.rhqz = rq.z; state.rhqw = rq.w;
                }
              }

              sendPlayerState(state);
            }
          }
          // In multiplayer, update the remote player's body with mirrored transforms
          if (isMultiplayer && remotePlayerState) {
            const rs = remotePlayerState;
            // Mirror X and Z since players face each other across the court
            const mirroredX = -rs.x;
            const mirroredZ = -rs.z;
            const mirroredRy = -rs.ry;

            // Move the bot entity (collision targets, etc.)
            const player1 = document.querySelector('[advanced-bot]');
            if (player1) {
              player1.object3D.position.set(mirroredX, rs.y, mirroredZ);
              player1.object3D.rotation.set(rs.rx, mirroredRy, 0);
            }

            // Feed full head + hand transforms to bot-body's mixamo-body for IK
            const botBody = document.querySelector('#bot-body');
            if (botBody && botBody.components['mixamo-body']) {
              const mb = botBody.components['mixamo-body'];

              // Position mirror (-x, y, -z) is equivalent to 180° rotation around Y.
              // Quaternions must be pre-multiplied by this rotation to face the correct direction.
              const yFlip = new THREE.Quaternion(0, 1, 0, 0); // 180° around Y

              const rd = {
                head: {
                  x: mirroredX, y: rs.y, z: mirroredZ
                }
              };

              // Head quaternion: rotate 180° around Y
              if (rs.hqx !== undefined) {
                const hq = new THREE.Quaternion(rs.hqx, rs.hqy, rs.hqz, rs.hqw);
                hq.premultiply(yFlip);
                rd.head.qx = hq.x; rd.head.qy = hq.y; rd.head.qz = hq.z; rd.head.qw = hq.w;
              }

              // Left hand (mirrored position + rotated quaternion)
              if (rs.lhx !== undefined) {
                const lq = new THREE.Quaternion(rs.lhqx, rs.lhqy, rs.lhqz, rs.lhqw);
                lq.premultiply(yFlip);
                rd.leftHand = {
                  x: -rs.lhx, y: rs.lhy, z: -rs.lhz,
                  qx: lq.x, qy: lq.y, qz: lq.z, qw: lq.w
                };
              }

              // Right hand (mirrored position + rotated quaternion)
              if (rs.rhx !== undefined) {
                const rq = new THREE.Quaternion(rs.rhqx, rs.rhqy, rs.rhqz, rs.rhqw);
                rq.premultiply(yFlip);
                rd.rightHand = {
                  x: -rs.rhx, y: rs.rhy, z: -rs.rhz,
                  qx: rq.x, qy: rq.y, qz: rq.z, qw: rq.w
                };
              }

              mb.remoteHandData = rd;
            }
          }
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          if (blueBall) {
            const pos = blueBall.object3D.position;
            const rot = blueBall.components['simple-grab']?.body?.velocity || {x:0,y:0,z:0};
            sendBallState({ x: pos.x, y: pos.y, z: pos.z, rx: rot.x, ry: rot.y, rz: rot.z, vx: rot.x, vy: rot.y, vz: rot.z });
          }
          // --- REMOTE PLAYER (ALWAYS RED, MIRRORED X/Z) ---
          if (remotePlayerState) {
            const mirroredX = -remotePlayerState.x;
            const mirroredZ = -remotePlayerState.z;
            const mirroredVx = -remotePlayerState.vx;
            const mirroredVz = -remotePlayerState.vz;
            const mirroredRy = -remotePlayerState.ry;
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall) {
              redBall.object3D.position.set(mirroredX, remotePlayerState.y, mirroredZ);
              redBall.object3D.rotation.set(remotePlayerState.rx, mirroredRy, remotePlayerState.rz);
              if (redBall.components['simple-grab']?.body) {
                redBall.components['simple-grab'].body.position.set(mirroredX, remotePlayerState.y, mirroredZ);
                redBall.components['simple-grab'].body.velocity.set(mirroredVx, remotePlayerState.vy, mirroredVz);
              }
            }
          }
          // --- REMOTE BALL (ALWAYS RED, MIRRORED X/Z) ---
          if (remoteBallState) {
            const mirroredX = -remoteBallState.x;
            const mirroredZ = -remoteBallState.z;
            const mirroredVx = -remoteBallState.vx;
            const mirroredVz = -remoteBallState.vz;
            const mirroredRy = -remoteBallState.ry;
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall) {
              redBall.object3D.position.set(mirroredX, remoteBallState.y, mirroredZ);
              redBall.object3D.rotation.set(remoteBallState.rx, mirroredRy, remoteBallState.rz);
              if (redBall.components['simple-grab']?.body) {
                redBall.components['simple-grab'].body.position.set(mirroredX, remoteBallState.y, mirroredZ);
                redBall.components['simple-grab'].body.velocity.set(mirroredVx, remoteBallState.vy, mirroredVz);
              }
            }
          }
          // Prevent local input from affecting Player 1 (red) and their ball in multiplayer
          if (isMultiplayer && conn && conn.open) {
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall && redBall.components['simple-grab']) {
              redBall.components['simple-grab'].isGrabbed = false;
              redBall.components['simple-grab'].grabbingHand = null;
            }
          }
        }
      });

      // --- MULTIPLAYER SCORE SYNC ---
      // Multiplayer score state
      let multiplayerScore = { local: 0, remote: 0 };
      // Multiplayer ready state
      let multiplayerReady = { local: false, remote: false };
      function sendScoreUpdate() {
        if (conn && conn.open) {
          conn.send({ type: 'score-update', score: multiplayerScore });
        }
      }
      function sendReadyUpdate() {
        if (conn && conn.open) {
          conn.send({ type: 'ready-update', ready: multiplayerReady.local });
        }
      }
      function updateScoreDisplayMultiplayer() {
        const blueScore = document.getElementById('blue-score');
        const redScore = document.getElementById('red-score');
        if (blueScore && redScore) {
          // In multiplayer, local player is always blue, remote is red
          blueScore.setAttribute('text', 'value', multiplayerScore.local.toString());
          redScore.setAttribute('text', 'value', multiplayerScore.remote.toString());
        }
      }
      // Patch game manager to sync score in multiplayer, but only after A-Frame and the component are loaded
      function patchGameManagerScoreSync() {
        const gm = AFRAME.components['game-manager'];
        if (!gm || !gm.Component) return false;
        if (gm.Component.prototype._multiplayerPatched) return true;
        const origOnBotHit = gm.Component.prototype.onBotHit;
        const origOnPlayerHit = gm.Component.prototype.onPlayerHit;
        gm.Component.prototype.onBotHit = function() {
          if (isMultiplayer && conn && conn.open) {
            const now = Date.now();
            if (now - (this._lastBotHitTime || 0) < 200) return;
            this._lastBotHitTime = now;
            multiplayerScore.local += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            origOnBotHit.call(this);
          }
        };
        gm.Component.prototype.onPlayerHit = function() {
          if (isMultiplayer && conn && conn.open) {
            const now = Date.now();
            if (now - (this._lastPlayerHitTime || 0) < 200) return;
            this._lastPlayerHitTime = now;
            multiplayerScore.remote += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            origOnPlayerHit.call(this);
          }
        };
        gm.Component.prototype._multiplayerPatched = true;
        return true;
      }
      // Wait for A-Frame and scene to be loaded before patching
      function tryPatchGameManager() {
        if (!patchGameManagerScoreSync()) {
          setTimeout(tryPatchGameManager, 100);
        }
      }
      document.addEventListener('DOMContentLoaded', () => {
        if (document.querySelector('a-scene')) {
          document.querySelector('a-scene').addEventListener('loaded', tryPatchGameManager);
        } else {
          setTimeout(tryPatchGameManager, 100);
        }
      });

      // Hand collider component - 144Hz optimized for Quest 3
      AFRAME.registerComponent('hand-collider', {
        init: function() {
          this.el.addEventListener('triggerdown', this.onGripDown.bind(this));
          this.el.addEventListener('triggerup', this.onGripUp.bind(this));
          
          // Create a collision body for the hand
          const shape = new CANNON.Sphere(0.1); // Increased from 0.05 to 0.1
          this.body = new CANNON.Body({
            mass: 0, // Static body
            shape: shape,
            material: defaultMaterial,
            collisionFilterGroup: 2, // Use a different collision group
            collisionFilterMask: 0, // Don't collide with anything
            type: CANNON.Body.KINEMATIC // Use kinematic body to prevent physical interactions
          });
          
          // Store reference to the entity on the body
          this.body.el = this.el;
          
          world.addBody(this.body);
          
          // Track if trigger is held
          this.isTriggerHeld = false;
          this.lastGrabCheck = 0;

          // Determine which player this hand belongs to
          this.isLeftHand = this.el.id === 'leftHand';
          this.player = this.isLeftHand ? 'player2' : 'player2'; // Both hands control player2's ball
        },
        
        tick: function() {
          // Update physics body position to match hand position at full framerate
          const handWorldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(handWorldPos);
          this.body.position.copy(handWorldPos);
          
          // If trigger is held, check for grabbable objects at 144Hz
          if (this.isTriggerHeld) {
            const now = Date.now();
            if (now - this.lastGrabCheck > 7) { // 144Hz - 6.94ms for Quest 3 optimization
              this.checkForGrabbableObjects();
              this.lastGrabCheck = now;
            }
          }
        },
        
        checkForGrabbableObjects: function() {
          const grabbableObjects = this.el.sceneEl.querySelectorAll('[simple-grab]');
          
          grabbableObjects.forEach(obj => {
            if (!obj.components['simple-grab']) return;
            
            // Check if the ball belongs to this player
            const ballPlayer = obj.components['simple-grab'].data.player;
            if (ballPlayer !== this.player) return;
            
            const ballBody = obj.components['simple-grab'].body;
            if (!ballBody) return;
            
            // Check if bodies are colliding
            const distance = this.body.position.distanceTo(ballBody.position);
            const minDistance = this.body.shapes[0].radius + ballBody.shapes[0].radius;
            
            if (distance <= minDistance && !obj.components['simple-grab'].isGrabbed) {
              obj.components['simple-grab'].onGripDown({ target: this.el });
            }
          });
        },
        
        onGripDown: function(evt) {
          this.isTriggerHeld = true;
          this.checkForGrabbableObjects();
        },
        
        onGripUp: function(evt) {
          this.isTriggerHeld = false;
          const grabbableObjects = this.el.sceneEl.querySelectorAll('[simple-grab]');
          grabbableObjects.forEach(obj => {
            if (obj.components['simple-grab'].isGrabbed) {
              obj.components['simple-grab'].onGripUp({ target: this.el });
            }
          });
        }
      });

      // Simple grab component
      AFRAME.registerComponent('simple-grab', {
        schema: {
          player: { type: 'string', default: 'player1' }  // Add player ownership
        },
        init: function() {
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.body = null;
          this.isReturning = false;       // Ball is returning from opponent wall
          this.returningGraceUntil = 0;   // Timestamp: opponent collision ignored until this time
          
          // Set initial position based on player
          const spawnZ = this.data.player === 'player1' ? -5.5 : 5.5;
          this.initialPosition = new CANNON.Vec3(0, 1.0, spawnZ);
          
          const shape = new CANNON.Sphere(0.1);
          this.body = new CANNON.Body({
            mass: 1,
            shape: shape,
            position: this.initialPosition,
            material: ballMaterial,
            linearDamping: 0.0,
            angularDamping: 0.0,
            collisionFilterGroup: 1,
            collisionFilterMask: 1
          });
          this.body.gravity = new CANNON.Vec3(0, 0, 0);
          world.addBody(this.body);

          // Store reference to the entity on the body
          this.body.el = this.el;
          
          // Track previous rotation for spin calculation
          this.lastRotation = new THREE.Quaternion();
          this.lastPosition = new THREE.Vector3();
          this.lastPositionTime = 0;
          
          // Velocity smoothing for consistent throwing
          this.velocityHistory = [];
          this.maxHistorySize = 5;

          // Listen for A button press on the scene
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            // Get the hand that pressed the button
            const hand = evt.target;
            const isLeftHand = hand.id === 'leftHand';
            const isRightHand = hand.id === 'rightHand';
            
            // Check if this ball belongs to the player who pressed the button
            const isPlayer1Ball = this.data.player === 'player1';
            const isPlayer2Ball = this.data.player === 'player2';
            
            // Left hand controls player1's ball, right hand controls player2's ball
            if ((isLeftHand && isPlayer1Ball) || (isRightHand && isPlayer2Ball)) {
              this.resetPosition();
            }
          });

          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            if (!collider) return;
            // Helper to respawn this ball
            const respawn = () => {
              this.isReturning = false;
              this.resetPosition();
            };
            const now = Date.now();
            const inGracePeriod = this.isReturning && now < this.returningGraceUntil;

            const isBotTarget = collider.id === 'bot-target' || collider.id === 'bot-body-collider';
            const isPlayerTarget = collider.id === 'player-target' || collider.id === 'player-body-collider';

            // --- NORMAL HITS: ball hits the OPPONENT's body ---
            // Player2's blue ball (human's) hitting bot = point for human player
            if (this.data.player === 'player2' && isBotTarget) {
              if (inGracePeriod) return; // Ignore during 1s return grace period
              const botTarget = document.querySelector('#bot-target');
              const impactEffect = botTarget && botTarget.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              const gm = document.querySelector('#game-manager');
              if (gm && gm.components['game-manager']) gm.components['game-manager'].onBotHit();
              respawn();
              return;
            }
            // Player1's red ball (bot's) hitting player = point for bot
            if (this.data.player === 'player1' && isPlayerTarget) {
              if (inGracePeriod) return; // Ignore during 1s return grace period
              const playerTarget = document.querySelector('#player-target');
              const impactEffect = playerTarget && playerTarget.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              const gm = document.querySelector('#game-manager');
              if (gm && gm.components['game-manager']) gm.components['game-manager'].onPlayerHit();
              respawn();
              return;
            }

            // --- SELF-HITS: ball hits its OWN player (deflection or own-goal) ---
            // Only trigger if ball is not held and has meaningful velocity
            // (prevents false triggers from spawn overlap or holding the ball near your body)
            const selfHitSpeed = this.body ? this.body.velocity.length() : 0;
            const canSelfHit = !this.isGrabbed && selfHitSpeed > 1;

            // Player1's red ball (bot's) deflected back at bot = point for human player
            if (this.data.player === 'player1' && isBotTarget && canSelfHit) {
              const botTarget = document.querySelector('#bot-target');
              const impactEffect = botTarget && botTarget.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              const gm = document.querySelector('#game-manager');
              if (gm && gm.components['game-manager']) gm.components['game-manager'].onBotHit();
              respawn();
              return;
            }
            // Player2's blue ball (human's) deflected back at player = point for bot
            if (this.data.player === 'player2' && isPlayerTarget && canSelfHit) {
              const playerTarget = document.querySelector('#player-target');
              const impactEffect = playerTarget && playerTarget.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              const gm = document.querySelector('#game-manager');
              if (gm && gm.components['game-manager']) gm.components['game-manager'].onPlayerHit();
              respawn();
              return;
            }
            // Ball hits wall behind opponent - return to spawn at 10 m/s
            if (collider && collider.getAttribute && collider.getAttribute('geometry')) {
              const geom = collider.getAttribute('geometry');
              const wallPos = collider.getAttribute('position');
              if (wallPos && geom && geom.width === 4 && geom.height === 4) {
                const isBackWallBehindBot = Math.abs(wallPos.z + 8) < 0.01;   // z = -8
                const isBackWallBehindPlayer = Math.abs(wallPos.z - 8) < 0.01; // z = +8
                // Ball hits the wall behind the OPPONENT (went past opponent, hit far wall)
                // Player2's blue ball hits wall behind bot (z=-8) = opponent wall for player2
                // Player1's red ball hits wall behind player (z=+8) = opponent wall for player1
                const hitOpponentWall = (this.data.player === 'player2' && isBackWallBehindBot) ||
                                        (this.data.player === 'player1' && isBackWallBehindPlayer);
                if (hitOpponentWall && this.body) {
                  // Release any grab constraint
                  if (this.constraint) {
                    world.removeConstraint(this.constraint);
                    this.constraint = null;
                  }
                  if (this.handBody) {
                    world.removeBody(this.handBody);
                    this.handBody = null;
                  }
                  // Restore normal mass and release grab state
                  this.body.mass = 1;
                  this.body.updateMassProperties();
                  this.isGrabbed = false;
                  this.grabbingHand = null;
                  // Mark as returning with 1s grace period (no opponent collision)
                  this.isReturning = true;
                  this.returningGraceUntil = Date.now() + 1000;
                  // Zero all velocity and spin
                  this.body.velocity.set(0, 0, 0);
                  this.body.angularVelocity.set(0, 0, 0);
                  this.body.quaternion.set(0, 0, 0, 1);
                  this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
                  // Send ball toward its spawn point at 10 m/s
                  const currentPos = this.body.position;
                  const spawnPos = this.initialPosition;
                  const dx = spawnPos.x - currentPos.x;
                  const dy = spawnPos.y - currentPos.y;
                  const dz = spawnPos.z - currentPos.z;
                  const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                  if (dist > 0.01) {
                    const speed = 10;
                    this.body.velocity.set(
                      (dx / dist) * speed,
                      (dy / dist) * speed,
                      (dz / dist) * speed
                    );
                  } else {
                    // Already at spawn, just reset
                    this.resetPosition();
                  }
                  return;
                }
                // Ball hits its OWN back wall - just respawn
                // Player2's blue ball hits wall behind player (z=+8) = own back wall
                // Player1's red ball hits wall behind bot (z=-8) = own back wall
                if ((this.data.player === 'player2' && isBackWallBehindPlayer) ||
                    (this.data.player === 'player1' && isBackWallBehindBot)) {
                  respawn();
                  return;
                }
              }
            }
          });
        },
        
        resetPosition: function() {
          this.isReturning = false;
          this.returningGraceUntil = 0;
          if (this.constraint) {
            world.removeConstraint(this.constraint);
            this.constraint = null;
          }
          if (this.handBody) {
            world.removeBody(this.handBody);
            this.handBody = null;
          }
          this.body.position.copy(this.initialPosition);
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          this.body.quaternion.set(0, 0, 0, 1);
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
          // Restore normal mass in case ball was grabbed
          this.body.mass = 1;
          this.body.updateMassProperties();
          this.isGrabbed = false;
          this.grabbingHand = null;
        },
        
        tick: function() {
          if (this.body) {
            if (this.isGrabbed && this.grabbingHand) {
              // When grabbed, directly update position and rotation
              const handWorldPos = new THREE.Vector3();
              const handWorldQuat = new THREE.Quaternion();
              this.grabbingHand.object3D.getWorldPosition(handWorldPos);
              this.grabbingHand.object3D.getWorldQuaternion(handWorldQuat);
              
              // Store previous position and rotation for velocity calculation
              const currentTime = performance.now();
              const currentPos = new THREE.Vector3();
              this.el.object3D.getWorldPosition(currentPos);
              
              // Calculate instantaneous velocity for history
              if (this.lastPositionTime > 0) {
                const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.001);
                const displacement = new THREE.Vector3().subVectors(currentPos, this.lastPosition);
                const instantVelocity = displacement.divideScalar(deltaTime);
                
                // Add to velocity history for smoothing
                this.velocityHistory.push(instantVelocity.clone());
                if (this.velocityHistory.length > this.maxHistorySize) {
                  this.velocityHistory.shift();
                }
              }
              
              this.lastPosition.copy(currentPos);
              this.lastRotation.copy(this.el.object3D.quaternion);
              this.lastPositionTime = currentTime;
              
              // Update visual position and rotation
              this.el.object3D.position.copy(handWorldPos);
              this.el.object3D.quaternion.copy(handWorldQuat);
              
              // Update physics body
              this.body.position.copy(handWorldPos);
              this.body.quaternion.copy(handWorldQuat);
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              
              // Keep zero gravity
              this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
            } else {
              // When not grabbed, update visual position from physics
              this.el.object3D.position.copy(this.body.position);
              this.el.object3D.quaternion.copy(this.body.quaternion);

              // Apply minimal Magnus effect only for very high spin
              if (this.body.velocity.length() > 0.1) {
                const velocity = new THREE.Vector3(
                  this.body.velocity.x,
                  this.body.velocity.y,
                  this.body.velocity.z
                );

                const angularVelocity = new THREE.Vector3(
                  this.body.angularVelocity.x,
                  this.body.angularVelocity.y,
                  this.body.angularVelocity.z
                );

                const angularSpeed = angularVelocity.length();
                const linearSpeed = velocity.length();
                
                // Debug: Always log spin and speed when ball is moving to see what we're working with
                if (linearSpeed > 0.5) {
                  console.log('Ball moving - Speed:', linearSpeed.toFixed(2), 'm/s, Spin:', angularSpeed.toFixed(2), 'rad/s');
                }
                
                // Apply Magnus effect - subtle curve to existing motion
                if (angularSpeed > 0.1 && linearSpeed > 0.5) { // Much lower thresholds
                  // Calculate Magnus force as acceleration (not velocity change)
                  const magnusAcceleration = new THREE.Vector3()
                    .crossVectors(angularVelocity, velocity);
                  
                  // Small but noticeable effect - frame rate independent acceleration
                  const frameTime = 1/72; // Assume 72fps for consistent effect
                  const magnusStrength = 0.008; // Slightly stronger Magnus effect - more noticeable curvature
                  
                  // Scale acceleration by frame time and strength
                  magnusAcceleration.multiplyScalar(magnusStrength * frameTime);
                  
                  // Apply as acceleration (small velocity change per frame)
                  this.body.velocity.x += magnusAcceleration.x;
                  this.body.velocity.y += magnusAcceleration.y;
                  this.body.velocity.z += magnusAcceleration.z;
                  
                  // Log Magnus effect occasionally (not every frame)
                  if (Math.random() < 0.01) { // 1% chance per frame (~0.7 times per second at 72fps)
                    console.log('Magnus ACTIVE - Accel:', magnusAcceleration.length().toFixed(6), 
                               'Spin:', angularSpeed.toFixed(2), 'Speed:', linearSpeed.toFixed(2));
                  }
                }

                // Add minimal damping only for very slow balls to prevent infinite bouncing
                const speed = velocity.length();
                const currentAngularSpeed = angularVelocity.length();
                if (speed < 0.5 && currentAngularSpeed < 1.0) { // Only damp if both linear and angular are slow
                  const damping = 0.995;
                  this.body.velocity.x *= damping;
                  this.body.velocity.y *= damping;
                  this.body.velocity.z *= damping;
                  this.body.angularVelocity.x *= damping;
                  this.body.angularVelocity.y *= damping;
                  this.body.angularVelocity.z *= damping;
                }
              }
            }
          }
        },
        
        onGripDown: function(evt) {
          if (this.isGrabbed) return;
          
          this.grabbingHand = evt.target;
          this.isGrabbed = true;
          this.isReturning = false; // Caught the ball - cancel returning state
          // Keep zero gravity
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
          // High mass so CANNON treats held ball as a wall during collisions
          this.body.mass = 1000;
          this.body.updateMassProperties();

          // Robust haptic feedback on grab (Meta Quest compatible)
          if (this.grabbingHand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = this.grabbingHand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.7, 100).catch(() => {}); // Silently fail if haptics not supported
          }
        },
        
        onGripUp: function(evt) {
          if (!this.isGrabbed || evt.target !== this.grabbingHand) return;
          
          // Use smoothed velocity from history for more consistent throws
          let velocity = new THREE.Vector3(0, 0, 0);
          
          if (this.velocityHistory.length > 0) {
            // Calculate weighted average of recent velocities (more recent = higher weight)
            let totalWeight = 0;
            for (let i = 0; i < this.velocityHistory.length; i++) {
              const weight = (i + 1) / this.velocityHistory.length; // Linear weighting towards recent
              velocity.add(this.velocityHistory[i].clone().multiplyScalar(weight));
              totalWeight += weight;
            }
            velocity.divideScalar(totalWeight);
            
            // Apply reasonable velocity scaling for better game feel
            const throwMultiplier = 1.5; // Slight boost for satisfying throws
            velocity.multiplyScalar(throwMultiplier);
            
            // Cap maximum throw speed for gameplay balance
            const maxThrowSpeed = 25; // m/s
            if (velocity.length() > maxThrowSpeed) {
              velocity.normalize().multiplyScalar(maxThrowSpeed);
            }
          } else {
            // Fallback to single-frame calculation if no history
            const currentTime = performance.now();
            const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.008); // Min 8ms (125fps)
            
            const currentPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(currentPos);
            const displacement = new THREE.Vector3().subVectors(currentPos, this.lastPosition);
            
            velocity = displacement.divideScalar(deltaTime).multiplyScalar(1.5);
          }
          
          // Calculate angular velocity based on rotation change
          const currentRot = new THREE.Quaternion();
          this.el.object3D.getWorldQuaternion(currentRot);
          const deltaRot = new THREE.Quaternion().multiplyQuaternions(
            currentRot,
            this.lastRotation.invert()
          );
          
          // Convert quaternion to angular velocity
          const axis = new THREE.Vector3();
          const angle = 2 * Math.acos(Math.abs(deltaRot.w));
          if (angle > 0.0001) {
            axis.set(deltaRot.x, deltaRot.y, deltaRot.z).normalize();
            // Balanced angular velocity for noticeable but controlled Magnus effect
            axis.multiplyScalar(angle * 40); // Moderate spin amount
          }
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          this.body.angularVelocity.set(axis.x, axis.y, axis.z);
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
          
          console.log('Throw velocity:', velocity.length().toFixed(2), 'm/s (smoothed)');
          
          // Clear velocity history for next throw
          this.velocityHistory = [];
          
          // Restore normal mass for free-flying ball
          this.body.mass = 1;
          this.body.updateMassProperties();
          
          this.isGrabbed = false;
          this.grabbingHand = null;
        }
      });

      // Swept sphere-sphere CCD for ball-ball collisions
      // Only fires when balls are far enough apart that CANNON.js substeps would miss them
      // (prevents double-response when CANNON can already handle the collision)
      const _ccdRelPos = new CANNON.Vec3();
      const _ccdRelVel = new CANNON.Vec3();
      function checkBallBallCCD(ballA, ballB, dt) {
        if (!ballA || !ballB) return;
        ballA.position.vsub(ballB.position, _ccdRelPos);
        ballA.velocity.vsub(ballB.velocity, _ccdRelVel);
        const combinedRadius = 0.2; // 0.1 + 0.1

        const currentDist = _ccdRelPos.length();
        // If balls are already close enough for CANNON substeps to catch, let CANNON handle it
        if (currentDist < combinedRadius * 3) return;

        const a = _ccdRelVel.dot(_ccdRelVel);
        if (a < 0.0001) return; // Barely moving relative to each other
        const b = 2 * _ccdRelPos.dot(_ccdRelVel);
        const c = _ccdRelPos.dot(_ccdRelPos) - combinedRadius * combinedRadius;

        if (c < 0) return; // Already overlapping

        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return; // Paths don't intersect

        const t = (-b - Math.sqrt(discriminant)) / (2 * a);
        if (t >= 0 && t <= dt) {
          const normal = _ccdRelPos.unit();
          const relVelNormal = _ccdRelVel.dot(normal);
          if (relVelNormal >= 0) return; // Moving apart

          // Check if either ball is grabbed (mass 1000 = held, mass 1 = free)
          const aGrabbed = ballA.mass > 100;
          const bGrabbed = ballB.mass > 100;

          if (aGrabbed && bGrabbed) return; // Both held, no physics response

          if (aGrabbed || bGrabbed) {
            // One ball is held: treat as wall collision for the free ball
            // Free ball reflects at full speed, held ball is unaffected
            if (aGrabbed) {
              // B is free, reflect B's velocity along the collision normal
              const vbDotN = ballB.velocity.dot(normal);
              if (vbDotN > 0) { // B moving toward A (normal points A->B, so positive = approaching)
                const restitution = 0.95;
                const impulseScalar = -vbDotN * (1 + restitution);
                ballB.velocity.x += normal.x * impulseScalar;
                ballB.velocity.y += normal.y * impulseScalar;
                ballB.velocity.z += normal.z * impulseScalar;
              }
            } else {
              // A is free, reflect A's velocity along the collision normal
              const vaDotN = ballA.velocity.dot(normal);
              if (vaDotN < 0) { // A moving toward B (normal points A->B, so negative = approaching)
                const restitution = 0.95;
                const impulseScalar = -vaDotN * (1 + restitution);
                ballA.velocity.x += normal.x * impulseScalar;
                ballA.velocity.y += normal.y * impulseScalar;
                ballA.velocity.z += normal.z * impulseScalar;
              }
            }
          } else {
            // Both free: equal-mass elastic collision
            const impulse = normal.scale(-relVelNormal);
            ballA.velocity.vadd(impulse, ballA.velocity);
            ballB.velocity.vsub(impulse, ballB.velocity);
          }

          // Separate balls so CANNON doesn't also process this collision
          const sep = _ccdRelPos.unit();
          sep.scale(combinedRadius * 0.5, sep);
          if (aGrabbed) {
            // Only move the free ball (B) away; grabbed ball is hand-controlled
            ballB.position.vsub(sep, ballB.position);
            ballB.position.vsub(sep, ballB.position); // Double separation for free ball
          } else if (bGrabbed) {
            ballA.position.vadd(sep, ballA.position);
            ballA.position.vadd(sep, ballA.position);
          } else {
            ballA.position.vadd(sep, ballA.position);
            ballB.position.vsub(sep, ballB.position);
          }
        }
      }

      // Physics update loop - Anti-tunneling optimized
      AFRAME.registerComponent('physics-world', {
        init: function() {
          this.lastTime = 0;
          this.ballBodies = null;
        },
        tick: function(time) {
          const deltaTime = (time - this.lastTime) / 1000;
          if (deltaTime > 0) {
            // Cache ball bodies (find them once, then reuse)
            if (!this.ballBodies) {
              const b1 = document.querySelector('[simple-grab="player: player1"]');
              const b2 = document.querySelector('[simple-grab="player: player2"]');
              if (b1?.components['simple-grab']?.body && b2?.components['simple-grab']?.body) {
                this.ballBodies = {
                  a: b1.components['simple-grab'].body,
                  b: b2.components['simple-grab'].body
                };
              }
            }

            // Pre-step CCD: detect ball-ball tunneling before CANNON substeps
            if (this.ballBodies) {
              checkBallBallCCD(this.ballBodies.a, this.ballBodies.b, deltaTime);
            }

            const maxStep = 1/240;
            const steps = Math.ceil(deltaTime / maxStep);
            const clampedSteps = Math.min(steps, 8);
            const clampedStepSize = deltaTime / clampedSteps;
            
            for (let i = 0; i < clampedSteps; i++) {
              world.step(clampedStepSize);
            }
          }
          this.lastTime = time;
        }
      });

      // Force wireframe on THREE.js material (A-Frame's material wireframe property doesn't work)
      AFRAME.registerComponent('force-wireframe', {
        init: function() {
          this.el.addEventListener('materialtextureloaded', () => this.applyWireframe());
          this.el.addEventListener('material-texture-loaded', () => this.applyWireframe());
          this.el.addEventListener('loaded', () => this.applyWireframe());
          // Also try immediately and after a short delay
          this.applyWireframe();
          setTimeout(() => this.applyWireframe(), 100);
        },
        applyWireframe: function() {
          const mesh = this.el.getObject3D('mesh');
          if (mesh) {
            mesh.traverse((node) => {
              if (node.isMesh && node.material) {
                node.material.wireframe = true;
              }
            });
          }
        }
      });

      // Ball trail component - performant ribbon trails showing speed, direction, spin
      AFRAME.registerComponent('ball-trail', {
        schema: {
          color: { type: 'color', default: '#ffffff' },
          centerWidth: { type: 'number', default: 0.03 },
          sideWidth: { type: 'number', default: 0.01 },
          sideOffset: { type: 'number', default: 0.06 },
          maxSegments: { type: 'number', default: 40 }
        },

        init: function() {
          this.maxSeg = this.data.maxSegments;
          // Ring buffer for position history
          this.positions = [];
          this.headIndex = 0;
          this.filledCount = 0;
          // Reusable vectors
          this._pos = new THREE.Vector3();
          this._vel = new THREE.Vector3();
          this._angVel = new THREE.Vector3();
          this._camPos = new THREE.Vector3();
          this._dir = new THREE.Vector3();
          this._side = new THREE.Vector3();
          this._up = new THREE.Vector3(0, 1, 0);
          this._spinAxis = new THREE.Vector3();
          this._offsetL = new THREE.Vector3();
          this._offsetR = new THREE.Vector3();
          this._right = new THREE.Vector3(1, 0, 0);
          this._quat = new THREE.Quaternion();

          // Pre-allocate position ring buffer
          for (let i = 0; i < this.maxSeg; i++) {
            this.positions.push(new THREE.Vector3());
          }

          // Create 3 ribbon trails
          const color = new THREE.Color(this.data.color);
          this.trails = [];
          const configs = [
            { width: this.data.centerWidth, offsetType: 'center', opacity: 0.9 },
            { width: this.data.sideWidth, offsetType: 'left', opacity: 0.6 },
            { width: this.data.sideWidth, offsetType: 'right', opacity: 0.6 }
          ];

          configs.forEach((cfg) => {
            const maxVerts = (this.maxSeg + 1) * 2;
            const maxIndices = this.maxSeg * 6;

            const posAttr = new THREE.BufferAttribute(new Float32Array(maxVerts * 3), 3);
            posAttr.setUsage(THREE.DynamicDrawUsage);
            const alphaAttr = new THREE.BufferAttribute(new Float32Array(maxVerts), 1);
            alphaAttr.setUsage(THREE.DynamicDrawUsage);

            const indices = new Uint16Array(maxIndices);
            for (let i = 0; i < this.maxSeg; i++) {
              const base = i * 2;
              const idx = i * 6;
              indices[idx]     = base;
              indices[idx + 1] = base + 1;
              indices[idx + 2] = base + 2;
              indices[idx + 3] = base + 1;
              indices[idx + 4] = base + 3;
              indices[idx + 5] = base + 2;
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', posAttr);
            geom.setAttribute('alpha', alphaAttr);
            geom.setIndex(new THREE.BufferAttribute(indices, 1));
            geom.setDrawRange(0, 0); // Start with nothing drawn

            const mat = new THREE.ShaderMaterial({
              uniforms: {
                uColor: { value: color },
                uBaseOpacity: { value: cfg.opacity }
              },
              vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                  vAlpha = alpha;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 uColor;
                uniform float uBaseOpacity;
                varying float vAlpha;
                void main() {
                  gl_FragColor = vec4(uColor, uBaseOpacity * vAlpha);
                }
              `,
              transparent: true,
              depthWrite: false,
              side: THREE.DoubleSide,
              blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Mesh(geom, mat);
            mesh.frustumCulled = false;
            mesh.renderOrder = 1;
            this.el.sceneEl.object3D.add(mesh);

            this.trails.push({
              mesh: mesh,
              geom: geom,
              posAttr: posAttr,
              alphaAttr: alphaAttr,
              width: cfg.width,
              offsetType: cfg.offsetType
            });
          });

          this.spinAngle = 0; // Accumulated spin for side trail spiral
        },

        tick: function(time, dt) {
          const grab = this.el.components['simple-grab'];
          if (!grab || !grab.body) return;

          const body = grab.body;
          this._vel.set(body.velocity.x, body.velocity.y, body.velocity.z);
          const speed = this._vel.length();

          // Get ball world position
          this.el.object3D.getWorldPosition(this._pos);

          // Push position into ring buffer
          this.positions[this.headIndex].copy(this._pos);
          this.headIndex = (this.headIndex + 1) % this.maxSeg;
          if (this.filledCount < this.maxSeg) this.filledCount++;

          // Speed-based visible length: faster = more segments
          const visibleCount = Math.min(
            Math.max(Math.floor(speed * 4), 2),
            this.filledCount
          );

          // Hide trails if essentially stationary
          if (speed < 0.1) {
            this.trails.forEach(t => t.geom.setDrawRange(0, 0));
            return;
          }

          // Get angular velocity for spin
          this._angVel.set(body.angularVelocity.x, body.angularVelocity.y, body.angularVelocity.z);
          const spinSpeed = this._angVel.length();
          const dtSec = (dt || 16) / 1000;

          // Accumulate spin angle for spiral
          if (spinSpeed > 0.5) {
            this.spinAngle += spinSpeed * dtSec;
          }

          // Get camera position for billboard facing
          const cam = this.el.sceneEl.camera;
          if (cam) cam.getWorldPosition(this._camPos);

          // Build ribbons
          for (let t = 0; t < this.trails.length; t++) {
            const trail = this.trails[t];
            const posArr = trail.posAttr.array;
            const alphaArr = trail.alphaAttr.array;
            const halfW = trail.width * 0.5;
            let vertIdx = 0;

            for (let i = 0; i < visibleCount; i++) {
              // Walk backwards from most recent
              const bufIdx = ((this.headIndex - 1 - i) + this.maxSeg * 2) % this.maxSeg;
              const p = this.positions[bufIdx];

              // Get direction for this segment
              if (i < visibleCount - 1) {
                const nextBufIdx = ((this.headIndex - 2 - i) + this.maxSeg * 2) % this.maxSeg;
                this._dir.subVectors(p, this.positions[nextBufIdx]).normalize();
              }
              // else keep previous dir

              // Apply side offset for left/right trails (with spin spiral)
              let offsetX = 0, offsetY = 0, offsetZ = 0;
              if (trail.offsetType !== 'center') {
                const sideSign = trail.offsetType === 'left' ? -1 : 1;
                const angle = this.spinAngle + (i * 0.15 * (spinSpeed > 0.5 ? 1 : 0));

                // Create perpendicular offset, rotated by spin
                if (this._vel.length() > 0.01) {
                  this._spinAxis.copy(this._vel).normalize();
                } else {
                  this._spinAxis.set(0, 0, 1);
                }
                // Get a perpendicular vector
                if (Math.abs(this._spinAxis.y) < 0.99) {
                  this._offsetL.crossVectors(this._spinAxis, this._up).normalize();
                } else {
                  this._offsetL.crossVectors(this._spinAxis, this._right).normalize();
                }
                this._offsetR.crossVectors(this._spinAxis, this._offsetL).normalize();

                const sOff = this.data.sideOffset;
                offsetX = (this._offsetL.x * Math.cos(angle) + this._offsetR.x * Math.sin(angle)) * sOff * sideSign;
                offsetY = (this._offsetL.y * Math.cos(angle) + this._offsetR.y * Math.sin(angle)) * sOff * sideSign;
                offsetZ = (this._offsetL.z * Math.cos(angle) + this._offsetR.z * Math.sin(angle)) * sOff * sideSign;
              }

              const px = p.x + offsetX;
              const py = p.y + offsetY;
              const pz = p.z + offsetZ;

              // Billboard: perpendicular to both trail dir and view dir
              this._side.subVectors(this._camPos, p);
              this._side.crossVectors(this._dir, this._side).normalize().multiplyScalar(halfW);

              // Two vertices per position (left/right of ribbon center)
              const vi = vertIdx * 3;
              posArr[vi]     = px - this._side.x;
              posArr[vi + 1] = py - this._side.y;
              posArr[vi + 2] = pz - this._side.z;
              posArr[vi + 3] = px + this._side.x;
              posArr[vi + 4] = py + this._side.y;
              posArr[vi + 5] = pz + this._side.z;

              // Alpha fades from 1 at head to 0 at tail
              const alpha = 1.0 - (i / visibleCount);
              alphaArr[vertIdx] = alpha;
              alphaArr[vertIdx + 1] = alpha;

              vertIdx += 2;
            }

            trail.posAttr.needsUpdate = true;
            trail.alphaAttr.needsUpdate = true;
            trail.geom.setDrawRange(0, Math.max(0, (visibleCount - 1)) * 6);
          }
        },

        remove: function() {
          this.trails.forEach(t => {
            t.mesh.parent.remove(t.mesh);
            t.geom.dispose();
            t.mesh.material.dispose();
          });
        }
      });

      // Add glow component
      AFRAME.registerComponent('glow', {
        schema: {
          color: {default: '#ffffff', type: 'color'},
          intensity: {default: 1.0}
        },
        init: function () {
          this.el.addEventListener('object3dset', this.update.bind(this));
          this.el.addEventListener('material-loaded', this.update.bind(this));
        },
        update: function () {
          const data = this.data;
          if (!this.el.object3D) return;
          
          this.el.object3D.traverse(function (node) {
            if (node.isMesh && node.material) {
              if (!node.material.emissive) {
                node.material.emissive = new THREE.Color(data.color);
              } else {
                node.material.emissive.copy(new THREE.Color(data.color));
              }
              node.material.emissiveIntensity = data.intensity;
            }
          });
        }
      });

      // Player zone component
      AFRAME.registerComponent('player-zone', {
        schema: {
          player: { type: 'string', default: 'player1' },
          radius: { type: 'number', default: 1 }
        },
        init: function() {
          // Create zone indicator
          this.zoneIndicator = document.createElement('a-ring');
          this.zoneIndicator.setAttribute('radius-inner', this.data.radius - 0.1);
          this.zoneIndicator.setAttribute('radius-outer', this.data.radius);
          this.zoneIndicator.setAttribute('color', this.data.player === 'player1' ? '#ff0000' : '#0000ff');
          this.zoneIndicator.setAttribute('opacity', 0.5);
          this.zoneIndicator.setAttribute('rotation', '-90 0 0');
          this.zoneIndicator.setAttribute('position', '0 0.01 0'); // Slightly above floor to prevent z-fighting
          this.el.appendChild(this.zoneIndicator);
          
          // Create dark overlay
          this.darkOverlay = document.createElement('a-entity');
          this.darkOverlay.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 100,
            phiLength: 180
          });
          this.darkOverlay.setAttribute('material', {
            color: '#000000',
            opacity: 0.8,
            side: 'back'
          });
          this.darkOverlay.setAttribute('visible', false);
          this.el.sceneEl.appendChild(this.darkOverlay);
        },
        
        tick: function() {
          const player = document.querySelector(`#${this.data.player}`);
          if (!player) return;
          
          const playerPos = player.object3D.position;
          const zonePos = this.el.object3D.position;
          const distance = playerPos.distanceTo(zonePos);
          
          // Update zone indicator position
          this.zoneIndicator.object3D.position.copy(zonePos);
          this.zoneIndicator.object3D.position.y = 0.01;
          
          // Check if player is in zone
          if (distance > this.data.radius) {
            this.darkOverlay.setAttribute('visible', true);
            this.zoneIndicator.setAttribute('color', '#ff0000');
          } else {
            this.darkOverlay.setAttribute('visible', false);
            this.zoneIndicator.setAttribute('color', this.data.player === 'player1' ? '#ff0000' : '#0000ff');
          }
        }
      });

      // Add sound manager component
      AFRAME.registerComponent('sound-manager', {
        init: function() {
          this.ballSounds = [];
          this.soundsInitialized = false;
          
          // Get all ball sounds
          this.el.sceneEl.querySelectorAll('[simple-grab]').forEach(ball => {
            const sound = ball.querySelector('[sound]');
            if (sound) {
              this.ballSounds.push(sound);
              // Initially pause all sounds
              sound.components.sound.pauseSound();
            }
          });
          
          // Get bounce sound
          this.bounceSound = this.el.sceneEl.querySelector('#bounce-sound');
          if (this.bounceSound) {
            this.bounceSound.components.sound.pauseSound();
          }
          
          // Listen for game start
          this.el.sceneEl.addEventListener('gameStarted', () => {
            this.initializeSounds();
          });
        },
        
        initializeSounds: function() {
          if (this.soundsInitialized) return;
          
          // Resume AudioContext
          const audioContext = this.el.sceneEl.audioContext;
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          // Start all ball hum sounds
          this.ballSounds.forEach(sound => {
            if (sound.id && (sound.id === 'red-ball-hum' || sound.id === 'blue-ball-hum')) {
              sound.components.sound.playSound();
            }
          });
          
          // Initialize bounce sound
          if (this.bounceSound) {
            this.bounceSound.components.sound.playSound();
            this.bounceSound.components.sound.pauseSound();
          }
          
          this.soundsInitialized = true;
        }
      });

      // Game manager component
      AFRAME.registerComponent('game-manager', {
        schema: {
          playerScore: { type: 'number', default: 0 },
          botScore: { type: 'number', default: 0 },
          gameStarted: { type: 'boolean', default: false }
        },
        init: function() {
          this.playerScore = 0;
          this.botScore = 0;
          this.gameStarted = false;
          
          // Match states: WAITING, COUNTDOWN, PLAYING, OVERTIME, ENDED
          this.matchState = 'WAITING';
          this.matchDuration = 180; // 3 minutes in seconds
          this.matchStartTime = 0;
          this.countdownTime = 3;
          this.countdownStartTime = 0;
          
          // Get references to the displays
          this.scoreDisplay = this.el.querySelector('#score-display');
          this.startMessage = this.el.querySelector('#start-message');
          this.timerDisplay = this.el.querySelector('#timer-display');
          
          // Hide score and timer displays initially
          this.scoreDisplay.setAttribute('visible', false);
          this.timerDisplay.setAttribute('visible', false);
          
          // Listen for A button press on both controllers
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            if (this.matchState === 'WAITING') {
              if (isMultiplayer && conn && conn.open) {
                this.handleMultiplayerReady();
              } else {
                this.startCountdown();
              }
            } else if (this.matchState === 'ENDED') {
              this.resetMatch();
            }
          });
        },

        tick: function() {
          const currentTime = Date.now();
          
          if (this.matchState === 'COUNTDOWN') {
            const elapsed = (currentTime - this.countdownStartTime) / 1000;
            const remaining = Math.ceil(this.countdownTime - elapsed);
            
            if (remaining > 0) {
              this.startMessage.setAttribute('text', 'value', remaining.toString());
            } else {
              this.startMessage.setAttribute('text', 'value', 'GO!');
              setTimeout(() => {
                this.startMatch();
              }, 500);
            }
          } else if (this.matchState === 'PLAYING') {
            this.updateTimer();
          }
        },

        handleMultiplayerReady: function() {
          // Mark local player as ready
          multiplayerReady.local = true;
          sendReadyUpdate();
          this.updateReadyState();
        },

        updateReadyState: function() {
          if (!isMultiplayer || !conn || !conn.open) return;
          
          if (multiplayerReady.local && !multiplayerReady.remote) {
            this.startMessage.setAttribute('text', 'value', 'Waiting for other player...');
          } else if (!multiplayerReady.local && multiplayerReady.remote) {
            this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          } else if (multiplayerReady.local && multiplayerReady.remote) {
            // Both ready - start countdown
            const startTime = Date.now();
            this.syncedStartCountdown(startTime);
            // Send countdown sync to other player
            if (conn && conn.open) {
              conn.send({ type: 'countdown-start', startTime: startTime });
            }
          }
        },

        setMultiplayerWaiting: function() {
          this.matchState = 'WAITING';
          this.gameStarted = false;
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Show start message
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          this.scoreDisplay.setAttribute('visible', false);
          this.timerDisplay.setAttribute('visible', false);
          
          console.log('Multiplayer waiting for both players to be ready');
        },

        syncedStartCountdown: function(startTime) {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = startTime;
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', '3');
          
          // Reset ready states
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Reset and respawn balls
          this.respawnBalls();
          
          console.log('Synchronized countdown started');
        },

        startCountdown: function() {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = Date.now();
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', '3');
          
          // Reset and respawn balls
          this.respawnBalls();
          
          console.log('Match countdown started');
        },

        startMatch: function() {
          this.matchState = 'PLAYING';
          this.matchStartTime = Date.now();
          this.gameStarted = true;
          
          // Hide start message, show game UI
          this.startMessage.setAttribute('visible', false);
          this.scoreDisplay.setAttribute('visible', true);
          this.timerDisplay.setAttribute('visible', true);
          
          // Reset scores
          this.playerScore = 0;
          this.botScore = 0;
          this.updateScore();
          
          // Enable bot and player collision
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          const player = this.el.sceneEl.querySelector('#player');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', true);
          if (player) player.setAttribute('player-collision', 'enabled', true);
          
          // Dispatch game started event
          this.el.sceneEl.emit('gameStarted');
          
          console.log('Match started - 3 minutes');
        },

        updateTimer: function() {
          const currentTime = Date.now();
          const elapsed = (currentTime - this.matchStartTime) / 1000;
          const remaining = Math.max(0, this.matchDuration - elapsed);
          
          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.timerDisplay.setAttribute('text', 'value', `Time: ${timeString}`);
          
          // Check if time is up
          if (remaining <= 0 && this.matchState === 'PLAYING') {
            // Use correct scores for multiplayer vs singleplayer
            let score1, score2;
            if (isMultiplayer && conn && conn.open) {
              score1 = multiplayerScore.local;
              score2 = multiplayerScore.remote;
            } else {
              score1 = this.playerScore;
              score2 = this.botScore;
            }
            
            if (score1 === score2) {
              this.startOvertime();
            } else {
              this.endMatch();
            }
          }
        },

        startOvertime: function() {
          this.matchState = 'OVERTIME';
          this.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next goal wins!');
          console.log('Match went to overtime - sudden death');
          
          // Sync overtime state in multiplayer
          if (isMultiplayer && conn && conn.open) {
            conn.send({ type: 'game-state', state: 'OVERTIME' });
          }
        },

        endMatch: function() {
          this.matchState = 'ENDED';
          this.gameStarted = false;
          
          // Disable bot
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          
          // Determine winner
          let winner;
          if (isMultiplayer && conn && conn.open) {
            winner = multiplayerScore.local > multiplayerScore.remote ? 'You win!' : 'Opponent wins!';
          } else {
            winner = this.playerScore > this.botScore ? 'Player wins!' : 'Bot wins!';
          }
          
          // Show end message
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', `${winner}\nPress A to play again`);
          this.timerDisplay.setAttribute('text', 'value', 'Match ended');
          
          // Sync end state in multiplayer
          if (isMultiplayer && conn && conn.open) {
            conn.send({ type: 'game-state', state: 'ENDED', winner: winner });
          }
          
          console.log(`Match ended: ${winner}`);
        },

        resetMatch: function() {
          this.matchState = 'WAITING';
          this.playerScore = 0;
          this.botScore = 0;
          this.gameStarted = false;
          
          // Reset multiplayer scores and ready states
          if (isMultiplayer) {
            multiplayerScore.local = 0;
            multiplayerScore.remote = 0;
            multiplayerReady.local = false;
            multiplayerReady.remote = false;
          }
          
          // Hide game UI, show start message
          this.scoreDisplay.setAttribute('visible', false);
          this.timerDisplay.setAttribute('visible', false);
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          
          // Disable bot
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          
          console.log('Match reset to waiting state');
        },

        respawnBalls: function() {
          // Reset both balls to their spawn positions
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          const redBall = document.querySelector('[simple-grab="player: player1"]');
          
          if (blueBall && blueBall.components['simple-grab']) {
            blueBall.components['simple-grab'].resetPosition();
          }
          if (redBall && redBall.components['simple-grab']) {
            redBall.components['simple-grab'].resetPosition();
          }
          
          console.log('Balls respawned');
        },

        onBotHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') return;
          // Prevent double-scoring from multiple handlers firing for the same hit
          const now = Date.now();
          if (now - (this._lastBotHitTime || 0) < 200) return;
          this._lastBotHitTime = now;
          
          if (isMultiplayer && conn && conn.open) {
            multiplayerScore.local += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            this.playerScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        onPlayerHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') return;
          const now = Date.now();
          if (now - (this._lastPlayerHitTime || 0) < 200) return;
          this._lastPlayerHitTime = now;
          
          if (isMultiplayer && conn && conn.open) {
            multiplayerScore.remote += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            this.botScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        updateScore: function() {
          if (isMultiplayer && conn && conn.open) {
            updateScoreDisplayMultiplayer();
          } else {
            // In singleplayer, player is blue, bot is red
            const blueScore = document.getElementById('blue-score');
            const redScore = document.getElementById('red-score');
            if (blueScore && redScore) {
              blueScore.setAttribute('text', 'value', this.playerScore.toString());
              redScore.setAttribute('text', 'value', this.botScore.toString());
            }
          }
        }
      });

      // Impact effect component
      // Uses A-Frame tick() for animation instead of requestAnimationFrame,
      // because window-level rAF can be throttled/paused on standalone Quest Browser
      // once inside an immersive WebXR session.
      AFRAME.registerComponent('impact-effect', {
        schema: {
          color: { type: 'color', default: '#ffffff' }
        },
        init: function() {
          // Animation state
          this._animating = false;
          this._animStart = 0;
          this._mat = null;

          // Find the impact sphere within this entity
          this.impactSphere = this.el.querySelector('a-sphere[id$="-impact"]');
          if (!this.impactSphere) {
            console.warn('Impact sphere not found for:', this.el.id);
            return;
          }

          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            if (!collider || !collider.hasAttribute('simple-grab')) return;

            // Don't trigger for held balls (player swinging arm near own head)
            // or balls in grace period (returning through opponent after wall bounce)
            const grab = collider.components['simple-grab'];
            if (!grab) return;
            if (grab.isGrabbed) return;
            if (grab.isReturning && Date.now() < grab.returningGraceUntil) return;

            this.playEffect();
          });
        },
        
        playEffect: function() {
          if (!this.impactSphere) {
            console.warn('Cannot play effect - impact sphere not found');
            return;
          }
          
          // Play impact sound
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            impactSound.object3D.position.copy(this.el.object3D.position);
            impactSound.components.sound.playSound();
          }
          
          // Cache the THREE.js material reference
          if (!this._mat) {
            const mesh = this.impactSphere.getObject3D('mesh');
            if (mesh) {
              this._mat = mesh.material;
            }
          }
          
          // Set up initial state and show
          this.impactSphere.object3D.visible = true;
          this.impactSphere.object3D.scale.set(1, 1, 1);
          if (this._mat) {
            this._mat.opacity = 0.5;
            this._mat.transparent = true;
          }
          
          // Start tick-driven animation
          this._animStart = this.el.sceneEl.time || performance.now();
          this._animating = true;
        },
        
        tick: function(time) {
          if (!this._animating) return;
          
          const elapsed = time - this._animStart;
          const duration = 1000;
          const t = Math.min(elapsed / duration, 1);
          // easeOutQuad
          const eased = t * (2 - t);
          
          const startRadius = 0.05;
          const endRadius = 1.5;
          const currentRadius = startRadius + (endRadius - startRadius) * eased;
          const currentOpacity = 0.5 * (1 - eased);
          
          const s = currentRadius / startRadius;
          this.impactSphere.object3D.scale.set(s, s, s);
          if (this._mat) {
            this._mat.opacity = currentOpacity;
          }
          
          if (t >= 1) {
            // Animation complete - hide and reset
            this._animating = false;
            this.impactSphere.object3D.visible = false;
            if (this._mat) {
              this._mat.opacity = 0;
            }
            this.impactSphere.object3D.scale.set(1, 1, 1);
          }
        }
      });

      // Static physics component for non-grabbable objects
      AFRAME.registerComponent('static-physics', {
        init: function() {
          let shape;
          const geometry = this.el.getAttribute('geometry');
          
          // Check if this is a racket (has id ending with "Racket")
          const isRacket = this.el.id && this.el.id.endsWith('Racket');
          
          // For rackets, don't create physics bodies - handle collision manually
          if (isRacket) {
            this.body = null;
            this.lastHitTime = 0; // Track last hit to prevent multiple rapid hits
            this.lastRacketPos = null; // Initialize as null to detect first frame
            this.lastRacketTime = 0;
            this.tick = function() {
              const worldPos = new THREE.Vector3();
              const worldQuat = new THREE.Quaternion();
              this.el.object3D.getWorldPosition(worldPos);
              this.el.object3D.getWorldQuaternion(worldQuat);
              
              // Initialize position tracking on first frame
              if (!this.lastRacketPos) {
                this.lastRacketPos = worldPos.clone();
                this.lastRacketTime = performance.now();
                console.log('Initialized racket tracking for', this.el.id);
                return;
              }
              
              // Eleven Table Tennis style: Check for ball collision along movement path
              const movement = worldPos.distanceTo(this.lastRacketPos);
              if (movement > 0.00001) { // Extreme sensitivity - detect micro-movements
                this.checkSweptCollision(this.lastRacketPos, worldPos);
              }
              
              // Update position tracking
              this.lastRacketPos.copy(worldPos);
              this.lastRacketTime = performance.now();
            };
          } else {
                      // For non-racket objects, create normal physics bodies
          if (geometry && geometry.primitive === 'box') {
            const width = geometry.width || 1;
            const height = geometry.height || 1;
            const depth = geometry.depth || 1;
            shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
          } else if (geometry && geometry.primitive === 'sphere') {
            shape = new CANNON.Sphere(geometry.radius || 0.2);
          } else if (geometry && geometry.primitive === 'cylinder') {
            const radius = geometry.radius || 0.5;
            const height = geometry.height || 1;
            shape = new CANNON.Cylinder(radius, radius, height, 16);
            
            // Rotate to match A-Frame's orientation
            const quat = new CANNON.Quaternion();
            quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            shape.transformAllPoints(new CANNON.Vec3(), quat);
          } else {
            // Default to sphere shape for bot
            shape = new CANNON.Sphere(0.2);
          }
          
                    // Check if this is a back wall (z = 8 or z = -8)
          const wallPosition = this.el.getAttribute('position');
          let isBackWall = wallPosition && (Math.abs(wallPosition.z - 8) < 0.01 || Math.abs(wallPosition.z + 8) < 0.01);
          
          // In bouncing ball mode, only z=8 (behind blue player) should be a back wall
          // z=-8 (behind red player) should bounce like side walls
          const scene = this.el.sceneEl;
          const gameModesComponent = scene && scene.components['game-modes'];
          if (gameModesComponent && gameModesComponent.data.enabled && gameModesComponent.data.mode === 'bouncing-ball') {
            isBackWall = wallPosition && Math.abs(wallPosition.z - 8) < 0.01; // Only z=8 is back wall
          }
          
          const body = new CANNON.Body({
            mass: 0,
            shape: shape,
            material: isBackWall ? backWallMaterial : defaultMaterial,
            type: CANNON.Body.STATIC,
            collisionFilterGroup: 1,
            collisionFilterMask: 1
          });
          
          const position = this.el.getAttribute('position');
            const rotation = this.el.getAttribute('rotation');
            body.position.set(position.x, position.y, position.z);
            
            if (rotation) {
              const rad = Math.PI / 180;
              body.quaternion.setFromEuler(
                rotation.x * rad,
                rotation.y * rad,
                rotation.z * rad
              );
            }
            
            // Store reference to the entity on the body
            body.el = this.el;
            body.isRacket = false;
            
            // Add collision event listener for non-rackets
            this.el.addEventListener('obbcollisionstarted', (evt) => {
              const collider = evt.detail.withEl;
              if (collider && collider.hasAttribute('simple-grab')) {
                // Regular wall/obstacle collision
                const bounceSound = document.querySelector('#bounce-sound');
                if (bounceSound) {
                  const ballPos = collider.object3D.position;
                  bounceSound.object3D.position.copy(ballPos);
                  bounceSound.components.sound.stopSound();
                  bounceSound.components.sound.playSound();
                }
              }
            });
            
            world.addBody(body);
            this.body = body;
          }
        },
        
        // Swept collision detection - sweeps BOTH racket and ball paths for CCD
        checkSweptCollision: function(startPos, endPos) {
          // Only check collision if THIS SPECIFIC racket is active
          const isLeftRacket = this.el.id === 'leftHandRacket';
          const isRightRacket = this.el.id === 'rightHandRacket';
          
          if (isLeftRacket && !racketMode.player2.left) return;
          if (isRightRacket && !racketMode.player2.right) return;
          if (!isLeftRacket && !isRightRacket) return;
          
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          if (!blueBall || !blueBall.components['simple-grab']?.body) return;
          
          // Cooldown to prevent multiple rapid hits
          const now = Date.now();
          if (now - this.lastHitTime < 16) return;
          
          const ballBody = blueBall.components['simple-grab'].body;
          const ballPos = new THREE.Vector3(ballBody.position.x, ballBody.position.y, ballBody.position.z);
          const ballRadius = 0.1;
          const collisionThreshold = ballRadius + 0.05;
          
          // Get previous ball position for swept test (CCD)
          const lastBallPos = this.lastBallPos || ballPos.clone();
          
          // Racket movement distance
          const movementVector = new THREE.Vector3().subVectors(endPos, startPos);
          const racketSpeed = movementVector.length();
          
          // Ball movement distance
          const ballMovement = new THREE.Vector3().subVectors(ballPos, lastBallPos);
          const ballSpeed = ballMovement.length();
          
          // Number of interpolation steps based on the faster mover
          const maxSpeed = Math.max(racketSpeed, ballSpeed);
          let hitDetected = false;
          
          if (maxSpeed > 0.001) {
            // Sweep both paths simultaneously
            const numSteps = Math.min(Math.max(Math.ceil(maxSpeed * 30), 4), 20);
            
            for (let i = 0; i <= numSteps; i++) {
              const t = i / numSteps;
              const interpRacket = new THREE.Vector3().lerpVectors(startPos, endPos, t);
              const interpBall = new THREE.Vector3().lerpVectors(lastBallPos, ballPos, t);
              
              if (interpRacket.distanceTo(interpBall) <= collisionThreshold) {
                hitDetected = true;
                break;
              }
            }
          } else {
            // Both nearly stationary - direct distance check
            if (endPos.distanceTo(ballPos) <= collisionThreshold) {
              hitDetected = true;
            }
          }
          
          // Store ball position for next frame's swept test
          this.lastBallPos = ballPos.clone();
          
          if (!hitDetected) return;
          
          // Record hit time to enforce cooldown
          this.lastHitTime = now;
          
          // Calculate velocity at point of contact using actual time elapsed
          const currentTime = performance.now();
          const deltaTime = Math.max((currentTime - this.lastRacketTime) / 1000, 0.001);
          const contactVelocity = new THREE.Vector3()
            .subVectors(endPos, startPos)
            .divideScalar(deltaTime);
          
          // Apply impact with proper contact velocity
          this.applySweptImpact(blueBall, contactVelocity, ballPos);
        },
        
        applySweptImpact: function(ballEl, racketVelocity, contactPoint) {
          const ballBody = ballEl.components['simple-grab'].body;
          if (!ballBody) return;
          
          // Use racket-to-ball direction as collision normal
          // This is robust regardless of which face the ball hits
          const racketWorldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(racketWorldPos);
          const ballPos = new THREE.Vector3(ballBody.position.x, ballBody.position.y, ballBody.position.z);
          const collisionNormal = ballPos.clone().sub(racketWorldPos).normalize();
          
          // Ball's current velocity
          const ballVel = new THREE.Vector3(ballBody.velocity.x, ballBody.velocity.y, ballBody.velocity.z);
          const incomingSpeed = ballVel.length();
          
          // Component of ball velocity along the collision normal
          // Negative = ball moving toward racket, Positive = ball moving away
          const velAlongNormal = ballVel.dot(collisionNormal);
          
          // Reflect the ball's velocity component that is moving into the racket
          if (velAlongNormal < 0) {
            // Remove the into-racket component and reverse it (with restitution)
            const restitution = 0.85;
            const reflection = collisionNormal.clone().multiplyScalar(-velAlongNormal * (1 + restitution));
            ballVel.add(reflection);
          }
          
          // Add racket velocity transfer on top of the reflection
          const velocityMultiplier = 0.8;
          ballVel.x += racketVelocity.x * velocityMultiplier;
          ballVel.y += racketVelocity.y * velocityMultiplier;
          ballVel.z += racketVelocity.z * velocityMultiplier;
          
          // Apply final velocity
          ballBody.velocity.set(ballVel.x, ballVel.y, ballVel.z);
          
          // Apply spin based on racket velocity
          ballBody.angularVelocity.x += -racketVelocity.y;
          ballBody.angularVelocity.y += racketVelocity.x;
          ballBody.angularVelocity.z += racketVelocity.z;
          
          // Clear returning state since the ball was intercepted
          const grab = ballEl.components['simple-grab'];
          if (grab && grab.isReturning) {
            grab.isReturning = false;
            grab.returningGraceUntil = 0;
          }
          
          console.log('Racket impact: ball', incomingSpeed.toFixed(1), 'm/s -> ', ballVel.length().toFixed(1), 'm/s, swing:', racketVelocity.length().toFixed(2), 'm/s');
          
          // Play feedback
          const bounceSound = document.querySelector('#bounce-sound');
          if (bounceSound) {
            bounceSound.object3D.position.copy(contactPoint);
            bounceSound.components.sound.stopSound();
            bounceSound.components.sound.playSound();
          }
          
          // Haptic feedback
          const hand = this.el.parentEl;
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.6, 100).catch(() => {});
          }
        },

        // Removed handleRacketHit function - using only swept collision detection now
      });

      // Player collision component
      AFRAME.registerComponent('player-collision', {
        schema: {
          enabled: { type: 'boolean', default: false }
        },
        init: function() {
          // Create a capsule shape for the player (better than sphere for character collision)
          const radius = 0.2; // Slightly smaller radius
          const height = 1.6; // Approximate player height
          const segments = 8; // Number of segments for the capsule
          
          // Create a cylinder for the main body
          const cylinderShape = new CANNON.Cylinder(radius, radius, height, segments);
          
          // Create spheres for the top and bottom
          const sphereShape = new CANNON.Sphere(radius);
          
          // Create the physics body
          this.body = new CANNON.Body({
            mass: 1,
            material: new CANNON.Material('default'),
            linearDamping: 0.5,
            fixedRotation: true,
            type: CANNON.Body.DYNAMIC,
            collisionFilterGroup: 1,
            collisionFilterMask: 1,
            position: this.el.object3D.position.clone().add(new THREE.Vector3(0, 1.0, 0)) // Offset upward by half height
          });
          
          // Add the shapes to the body with proper orientation
          // Rotate cylinder to match A-Frame's orientation
          const cylinderQuat = new CANNON.Quaternion();
          cylinderQuat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
          this.body.addShape(cylinderShape, new CANNON.Vec3(0, 0, 0), cylinderQuat);
          
          // Add spheres with proper offsets
          this.body.addShape(sphereShape, new CANNON.Vec3(0, height/2, 0)); // Top sphere
          this.body.addShape(sphereShape, new CANNON.Vec3(0, -height/2, 0)); // Bottom sphere
          
          // Add contact material for better collision response
          const contactMaterial = new CANNON.ContactMaterial(
            this.body.material,
            new CANNON.Material('default'),
            {
              friction: 0.3,
              restitution: 0.2
            }
          );
          world.addContactMaterial(contactMaterial);
          
          world.addBody(this.body);
          this.initialPosition = this.el.object3D.position.clone();
          this.targetHeight = 1.0; // Target height for the player
          
          // Store reference to the entity on the body
          this.body.el = this.el;
          
          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            if (!this.data.enabled) return;
            console.log('Player collision event received:', evt.detail);
            const collider = evt.detail.withEl;
            if (collider && collider.getAttribute('simple-grab') && 
                collider.getAttribute('simple-grab').player === 'player1') {
              console.log('Player hit by bot ball!');
              // Visual feedback
              const playerSphere = this.el.querySelector('a-sphere');
              if (playerSphere) {
                playerSphere.setAttribute('color', '#0000ff');
                setTimeout(() => {
                  playerSphere.setAttribute('color', '#ffffff');
                }, 1000);
              }
              
              // Play impact effect
              const playerTarget = document.querySelector('#player-target');
              const impactEffect = playerTarget && playerTarget.components['impact-effect'];
              if (impactEffect) {
                console.log('Playing player impact effect');
                impactEffect.playEffect();
              } else {
                console.log('No impact effect component found on player-target');
              }
              
              // Update score
              const gameManager = this.el.sceneEl.querySelector('#game-manager');
              if (gameManager && gameManager.components['game-manager']) {
                gameManager.components['game-manager'].onPlayerHit();
              }
            }
          });
        },
        
        tick: function() {
          // Update player position based on physics, maintaining the height offset
          const physicsPos = this.body.position;
          
          // Keep the player at a constant height
          //physicsPos.x = this.targetX;
          physicsPos.z = this.targetZ;
          physicsPos.y = this.targetHeight;
          
          // Update the visual position
          this.el.object3D.position.set(physicsPos.x, physicsPos.y - 1.0, physicsPos.z);
          
          // Zero out any vertical velocity to prevent floating/sinking
          this.body.velocity.x = 0;
          this.body.velocity.y = 0;
          this.body.velocity.z = 0;
        }
      });

      // Bot component for AI player
      AFRAME.registerComponent('bot', {
        schema: {
          throwInterval: { type: 'number', default: 5000 }, // 5 seconds
          minThrowForce: { type: 'number', default: 5 },  // Halved from 10
          maxThrowForce: { type: 'number', default: 10 },  // Halved from 20
          enabled: { type: 'boolean', default: false }
        },
        init: function() {
          this.ball = null;
          this.lastThrowTime = 0;
          this.throwInterval = this.data.throwInterval;
          this.isHit = false;
          this.hitCooldown = 2000; // 2 seconds cooldown after being hit
          this.lastHitTime = 0;
          
          // Find the bot's ball
          this.el.sceneEl.addEventListener('loaded', () => {
            this.ball = this.el.sceneEl.querySelector('[simple-grab="player: player1"]');
          });

          // Listen for collisions
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            if (!this.data.enabled) return;
            this.onCollision(evt);
          });
        },
        
        onCollision: function(evt) {
          const now = Date.now();
          if (now - this.lastHitTime < this.hitCooldown) return;
          
          const collider = evt.detail.withEl;
          
          if (collider && collider.getAttribute('simple-grab') && 
              collider.getAttribute('simple-grab').player === 'player2') {
            this.isHit = true;
            this.lastHitTime = now;
            
            // Visual feedback
            const botSphere = this.el.querySelector('a-sphere');
            if (botSphere) {
              botSphere.setAttribute('color', '#ff0000');
              setTimeout(() => {
                botSphere.setAttribute('color', '#ff0000');
                this.isHit = false;
              }, 1000);
            }
            
            // Play impact effect
            const impactEffect = this.el.components['impact-effect'];
            if (impactEffect) {
              impactEffect.playEffect();
            }
            
            // Update score
            const gameManager = this.el.sceneEl.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].onBotHit();
            }
          }
        },
        
        tick: function(time) {
          if (!this.ball || !this.data.enabled) return;
          
          // Check if it's time to throw
          if (time - this.lastThrowTime > this.throwInterval && !this.isHit) {
            this.throwBall();
            this.lastThrowTime = time;
          }
        },
        
        throwBall: function() {
          if (!this.ball || !this.ball.components['simple-grab']) return;
          
          // Get player position
          const player = document.querySelector('#player');
          if (!player) return;
          
          const playerPos = new THREE.Vector3();
          player.object3D.getWorldPosition(playerPos);
          
          // Calculate random throw angle
          const throwAngle = this.calculateThrowAngle(playerPos);
          
          // Calculate throw force
          const throwForce = this.data.minThrowForce + 
            Math.random() * (this.data.maxThrowForce - this.data.minThrowForce);
          
          // Reset ball position
          this.ball.components['simple-grab'].resetPosition();
          
          // Apply velocity
          const ballBody = this.ball.components['simple-grab'].body;
          if (ballBody) {
            ballBody.velocity.set(
              throwAngle.x * throwForce,
              throwAngle.y * throwForce,
              throwAngle.z * throwForce
            );
          }
        },
        
        calculateThrowAngle: function(playerPos) {
          // Get bot position
          const botPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(botPos);
          
          // Use the world position of the player's target sphere (blue sphere inside camera)
          let targetPos = new THREE.Vector3();
          const playerTargetSphere = document.querySelector('#player-target');
          if (playerTargetSphere) {
            playerTargetSphere.object3D.getWorldPosition(targetPos);
          } else {
            // fallback to playerPos
            targetPos.copy(playerPos);
          }
          // Calculate direct vector to player
          const directVector = new THREE.Vector3()
            .subVectors(targetPos, botPos)
            .normalize();
          
          // Randomly choose between direct throw or bounce throw
          if (Math.random() < 0.5) {
            // Direct throw
            return directVector;
          } else {
            // Bounce throw - randomly choose a wall/floor/ceiling to bounce off
            const bounceTypes = [
              { axis: 'x', value: 2 },    // Right wall
              { axis: 'x', value: -2 },   // Left wall
              { axis: 'y', value: 4 },    // Ceiling
              { axis: 'y', value: 0 },    // Floor
              { axis: 'z', value: 8 },    // Front wall
              { axis: 'z', value: -8 }    // Back wall
            ];
            
            const bounce = bounceTypes[Math.floor(Math.random() * bounceTypes.length)];
            const bouncePoint = new THREE.Vector3();
            bouncePoint[bounce.axis] = bounce.value;
            
            // Calculate vector to bounce point
            const toBounce = new THREE.Vector3()
              .subVectors(bouncePoint, botPos)
              .normalize();
            
            // Calculate vector from bounce point to player
            const fromBounce = new THREE.Vector3()
              .subVectors(targetPos, bouncePoint)
              .normalize();
            
            // Combine vectors for final throw direction
            return new THREE.Vector3()
              .addVectors(toBounce, fromBounce)
              .normalize();
          }
        }
      });

      // Add haptic feedback on hand collision with a ball
      AFRAME.registerComponent('hand-haptics', {
        init: function() {
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            // Check if the collider is a ball (has simple-grab component)
            if (collider && collider.components && collider.components['simple-grab']) {
              // Try to get the gamepad from the controller
              const trackedControls = this.el.components['tracked-controls'];
              if (trackedControls?.controller?.gamepad?.hapticActuators?.[0]) {
                const haptics = trackedControls.controller.gamepad.hapticActuators[0];
                haptics.pulse(0.7, 100).catch(() => {}); // Silently fail if haptics not supported
              }
            }
          });
        }
      });

      // Add debug visualization component
      AFRAME.registerComponent('debug-collider', {
        init: function() {
          // Create wireframe for physics body
          const wireframe = document.createElement('a-entity');
          wireframe.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 0.1,
            segmentsWidth: 16,
            segmentsHeight: 16
          });
          wireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.5
          });
          this.el.appendChild(wireframe);
        }
      });

      // Debug visualization for controllers (disabled - Y Bot hands are used instead)
      AFRAME.registerComponent('debug-controller', {
        init: function() {
          // No-op: debug wireframe spheres disabled since rigged body hands are visible
        }
      });

      // FPS counter component
      AFRAME.registerComponent('fps-counter', {
        init: function() {
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.fps = 0;
          this.fpsHistory = [];
          this.updateInterval = 500; // Update every 500ms for smooth display
          this.lastUpdate = 0;
        },
        
        tick: function() {
          const currentTime = performance.now();
          this.frameCount++;
          
          // Update FPS every 500ms
          if (currentTime - this.lastUpdate >= this.updateInterval) {
            const deltaTime = currentTime - this.lastTime;
            const currentFPS = Math.round((this.frameCount * 1000) / deltaTime);
            
            // Keep a history of recent FPS values for smoothing
            this.fpsHistory.push(currentFPS);
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift(); // Keep only last 5 readings
            }
            
            // Calculate average FPS for smoother display
            const avgFPS = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);
            this.fps = avgFPS;
            
            // Update the version display
            this.updateVersionDisplay();
            
            // Reset counters
            this.frameCount = 0;
            this.lastTime = currentTime;
            this.lastUpdate = currentTime;
          }
        },
        
        updateVersionDisplay: function() {
          const versionDisplay = document.getElementById('version-display');
          if (versionDisplay) {
            const currentText = versionDisplay.getAttribute('text').value;
            
            // Extract version and status parts
            const parts = currentText.split(' | ');
            const version = parts[0];
            const status = parts.length > 1 ? parts[1] : '';
            
            // Update with FPS, preserving any existing status
            if (status && !status.includes('FPS')) {
              versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS | ${status}`);
            } else if (status && status.includes('FPS')) {
              // Replace existing FPS
              const statusWithoutFPS = status.replace(/\d+ FPS/, '').replace(/^\s*\|\s*/, '').replace(/\s*\|\s*$/, '');
              if (statusWithoutFPS) {
                versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS | ${statusWithoutFPS}`);
              } else {
                versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS`);
              }
            } else {
              versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS`);
            }
          }
        }
      });

      // Add custom hand controls override
      AFRAME.registerComponent('custom-hand-controls', {
        init: function() {
          // Override the problematic animation methods
          const handControls = this.el.components['hand-controls'];
          if (handControls) {
            // Store original methods
            this.originalAnimateGesture = handControls.animateGesture;
            this.originalPlayAnimation = handControls.playAnimation;
            
            // Override with no-op functions
            handControls.animateGesture = function() {};
            handControls.playAnimation = function() {};
          }
        },
        
        remove: function() {
          // Restore original methods if needed
          const handControls = this.el.components['hand-controls'];
          if (handControls && this.originalAnimateGesture && this.originalPlayAnimation) {
            handControls.animateGesture = this.originalAnimateGesture;
            handControls.playAnimation = this.originalPlayAnimation;
          }
        }
      });

      // Frame rate info component (for debugging only - do not use to limit FPS in VR!)
      AFRAME.registerComponent('frame-rate-info', {
        init: function() {
          console.log('=== FRAME RATE INFO ===');
          console.log('VR Display Refresh Rate:', this.getVRRefreshRate());
          console.log('Browser supports:', this.getBrowserCapabilities());
          console.log('Current renderer info:', this.getRendererInfo());
          console.log('======================');
        },
        
        getVRRefreshRate: function() {
          if (this.el.xrSession && this.el.xrSession.renderState) {
            return `${this.el.xrSession.renderState.baseLayer?.framebuffer ? 'VR Session Active' : 'No VR Session'}`;
          }
          return 'Not in VR mode';
        },
        
        getBrowserCapabilities: function() {
          const capabilities = [];
          if ('xr' in navigator) capabilities.push('WebXR');
          if ('getVRDisplays' in navigator) capabilities.push('WebVR (deprecated)');
          if (window.requestAnimationFrame) capabilities.push('requestAnimationFrame');
          return capabilities.join(', ');
        },
        
        getRendererInfo: function() {
          const renderer = this.el.renderer;
          if (renderer) {
            return {
              pixelRatio: renderer.getPixelRatio(),
              maxTextureSize: renderer.capabilities?.maxTextureSize || 'unknown',
              precision: renderer.capabilities?.precision || 'unknown'
            };
          }
          return 'Renderer not available';
        }
      });

      // Ball speed tracker component
      AFRAME.registerComponent('ball-speed-tracker', {
        init: function() {
          this.ballStats = {
            player1: { current: 0, fastest: 0, color: 'Red' },
            player2: { current: 0, fastest: 0, color: 'Blue' }
          };
          this.lastUpdate = 0;
          this.updateInterval = 100; // Update every 100ms for smooth display
          this.statsDisplay = null;
        },

        tick: function() {
          const now = performance.now();
          if (now - this.lastUpdate < this.updateInterval) return;
          this.lastUpdate = now;

          // Get ball entities
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          const redBall = document.querySelector('[simple-grab="player: player1"]');

          // Update speeds
          if (blueBall && blueBall.components['simple-grab']?.body) {
            const velocity = blueBall.components['simple-grab'].body.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            this.ballStats.player2.current = speed;
            if (speed > this.ballStats.player2.fastest) {
              this.ballStats.player2.fastest = speed;
            }
          }

          if (redBall && redBall.components['simple-grab']?.body) {
            const velocity = redBall.components['simple-grab'].body.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            this.ballStats.player1.current = speed;
            if (speed > this.ballStats.player1.fastest) {
              this.ballStats.player1.fastest = speed;
            }
          }

          // Update display
          this.updateDisplay();
        },

        updateDisplay: function() {
          if (!this.statsDisplay) {
            this.statsDisplay = document.querySelector('#ball-stats-text');
          }
          
          if (this.statsDisplay) {
            const blue = this.ballStats.player2;
            const red = this.ballStats.player1;
            
            const displayText = 
              `${blue.color} ball: ${blue.current.toFixed(1)} m/s (Max: ${blue.fastest.toFixed(1)})` + 
              `\n${red.color} ball: ${red.current.toFixed(1)} m/s (Max: ${red.fastest.toFixed(1)})`;
            
            this.statsDisplay.setAttribute('value', displayText);
          }
        },

        // Reset max speeds (could be called on game restart)
        resetMaxSpeeds: function() {
          this.ballStats.player1.fastest = 0;
          this.ballStats.player2.fastest = 0;
          console.log('Ball speed records reset');
        }
      });

      // =============================================
      // Mixamo Rigged Upper Body Component
      // Adapted from body-rigged.html for DodgeVR
      // Supports 'player' mode (VR-driven) and 'bot' mode (AI idle animation)
      // =============================================
      AFRAME.registerComponent('mixamo-body', {
        schema: {
          mode: { type: 'string', default: 'player' },
          color: { type: 'color', default: '#4A90E2' },
          modelPath: { type: 'string', default: '../BoltVR/assets/Y Bot.fbx' },
          botEntitySelector: { type: 'string', default: '[advanced-bot]' },
          emissiveIntensity: { type: 'number', default: 0.3 },
          rimIntensity: { type: 'number', default: 1.2 },
          rimPower: { type: 'number', default: 2.5 }
        },

        init: function() {
          this.isBot = this.data.mode === 'bot';

          if (!this.isBot) {
            // Player mode - reference VR controller entities
            this.camera = document.querySelector('[camera]');
            this.leftController = document.querySelector('#leftHand');
            this.rightController = document.querySelector('#rightHand');
            this.rig = document.querySelector('#rig');

            // Hide default hand-controls models (Y Bot has its own hands)
            // Must NOT hide racket child entities -- only the hand-controls mesh
            const hideHandModel = (controller) => {
              if (!controller) return;
              const tryHide = () => {
                const handControls = controller.components['hand-controls'];
                if (handControls && handControls.loader) {
                  // Build a set of Object3Ds that belong to child A-Frame entities (rackets, etc.)
                  const childEntityObj3Ds = new Set();
                  controller.querySelectorAll('*').forEach((childEl) => {
                    if (childEl.object3D) {
                      childEl.object3D.traverse((obj) => childEntityObj3Ds.add(obj));
                    }
                  });
                  // Only hide meshes from the hand-controls model itself
                  const handModel = controller.getObject3D('mesh');
                  if (handModel) {
                    handModel.traverse((child) => {
                      if (child.isMesh) {
                        child.visible = false;
                      }
                    });
                  }
                }
              };
              controller.addEventListener('model-loaded', tryHide);
              controller.addEventListener('object3dset', tryHide);
              tryHide();
            };
            hideHandModel(this.leftController);
            hideHandModel(this.rightController);
          } else {
            // Bot mode - reference the bot entity
            this.botEntity = document.querySelector(this.data.botEntitySelector);
            if (!this.botEntity) {
              this.el.sceneEl.addEventListener('loaded', () => {
                this.botEntity = document.querySelector(this.data.botEntitySelector);
              });
            }
            this.idleTime = 0;
          }

          this.skeleton = null;
          this.bones = {};
          this.model = null;
          this.modelLoaded = false;

          // Mixamo bone names
          this.boneNames = {
            hips: 'mixamorigHips',
            spine: 'mixamorigSpine',
            spine1: 'mixamorigSpine1',
            spine2: 'mixamorigSpine2',
            neck: 'mixamorigNeck',
            head: 'mixamorigHead',
            leftShoulder: 'mixamorigLeftShoulder',
            leftArm: 'mixamorigLeftArm',
            leftForeArm: 'mixamorigLeftForeArm',
            leftHand: 'mixamorigLeftHand',
            rightShoulder: 'mixamorigRightShoulder',
            rightArm: 'mixamorigRightArm',
            rightForeArm: 'mixamorigRightForeArm',
            rightHand: 'mixamorigRightHand',
            leftHandThumb1: 'mixamorigLeftHandThumb1',
            leftHandThumb2: 'mixamorigLeftHandThumb2',
            leftHandThumb3: 'mixamorigLeftHandThumb3',
            leftHandIndex1: 'mixamorigLeftHandIndex1',
            leftHandIndex2: 'mixamorigLeftHandIndex2',
            leftHandIndex3: 'mixamorigLeftHandIndex3',
            leftHandMiddle1: 'mixamorigLeftHandMiddle1',
            leftHandMiddle2: 'mixamorigLeftHandMiddle2',
            leftHandMiddle3: 'mixamorigLeftHandMiddle3',
            leftHandRing1: 'mixamorigLeftHandRing1',
            leftHandRing2: 'mixamorigLeftHandRing2',
            leftHandRing3: 'mixamorigLeftHandRing3',
            leftHandPinky1: 'mixamorigLeftHandPinky1',
            leftHandPinky2: 'mixamorigLeftHandPinky2',
            leftHandPinky3: 'mixamorigLeftHandPinky3',
            rightHandThumb1: 'mixamorigRightHandThumb1',
            rightHandThumb2: 'mixamorigRightHandThumb2',
            rightHandThumb3: 'mixamorigRightHandThumb3',
            rightHandIndex1: 'mixamorigRightHandIndex1',
            rightHandIndex2: 'mixamorigRightHandIndex2',
            rightHandIndex3: 'mixamorigRightHandIndex3',
            rightHandMiddle1: 'mixamorigRightHandMiddle1',
            rightHandMiddle2: 'mixamorigRightHandMiddle2',
            rightHandMiddle3: 'mixamorigRightHandMiddle3',
            rightHandRing1: 'mixamorigRightHandRing1',
            rightHandRing2: 'mixamorigRightHandRing2',
            rightHandRing3: 'mixamorigRightHandRing3',
            rightHandPinky1: 'mixamorigRightHandPinky1',
            rightHandPinky2: 'mixamorigRightHandPinky2',
            rightHandPinky3: 'mixamorigRightHandPinky3'
          };

          // IK config
          this.config = {
            shoulderWidth: 0.34,
            shoulderForward: 0.08,
            upperArmLength: 0.31,
            lowerArmLength: 0.31
          };

          // Smoothing
          this.torsoRotation = new THREE.Quaternion();
          this.bodyTilt = new THREE.Quaternion();
          this.smoothingFactor = 0.15;

          // Initialize torso rotation for bot (facing +Z toward player)
          if (this.isBot) {
            this.torsoRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
          }

          // Finger curl smoothing
          this.targetCurls = {
            left: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 },
            right: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 }
          };
          this.currentCurls = {
            left: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 },
            right: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 }
          };
          this.fingerSmoothingFactor = 0.3;

          // Breathing animation
          this.breathingPhase = 0;
          this.breathingRate = 0.25;
          this.breathingAmount = 0.015;

          // Body dynamics
          this.previousHeadPos = new THREE.Vector3();
          this.previousHeadPosInitialized = false;
          this.headVelocity = new THREE.Vector3();
          this.torsoLean = new THREE.Vector3();
          this.torsoLeanVelocity = 0.15;

          // Enable local clipping
          this.el.sceneEl.addEventListener('loaded', () => {
            const renderer = this.el.sceneEl.renderer;
            if (renderer) renderer.localClippingEnabled = true;
          });

          // Load FBX model
          const loader = new THREE.FBXLoader();
          loader.load(
            this.data.modelPath,
            (fbx) => this.onModelLoaded(fbx),
            undefined,
            (error) => console.error('[Mixamo Body] Load error:', error)
          );
        },

        onModelLoaded: function(fbx) {
          this.modelLoaded = true;
          this.model = fbx;

          // Mixamo models export at 100x scale
          fbx.scale.set(0.01, 0.01, 0.01);
          // T-pose faces +Z, rotate 180 to face -Z (forward)
          fbx.rotation.y = Math.PI;

          this.el.object3D.add(fbx);

          // Find skeleton and set up materials with Fresnel rim + emissive shader
          fbx.traverse((node) => {
            if (node.isSkinnedMesh && node.skeleton) {
              this.skeleton = node.skeleton;
              this.mapBones();
              this.skinnedMesh = node;

              // Replace with custom Fresnel + emissive shader (skinning enabled)
              node.material = this.createFresnelMaterial(true);
            }
            if (node.isMesh && !node.isSkinnedMesh) {
              // Replace with custom Fresnel + emissive shader (no skinning)
              node.material = this.createFresnelMaterial(false);
            }
          });

          // For bot body, create racket meshes attached to hand bones for multiplayer
          if (this.isBot && this.bones.leftHandBone && this.bones.rightHandBone) {
            this.botRackets = { left: null, right: null };
            const racketGeo = new THREE.BoxGeometry(0.2, 0.2, 0.02);
            const racketMat = new THREE.MeshBasicMaterial({
              color: 0xff4444,
              wireframe: true,
              transparent: true,
              opacity: 0.8
            });
            ['left', 'right'].forEach((side) => {
              const mesh = new THREE.Mesh(racketGeo, racketMat.clone());
              mesh.position.set(0, 0, -15); // Offset forward from hand (in bone local, scaled 100x)
              mesh.scale.set(100, 100, 100); // Counter the 0.01 model scale
              mesh.visible = false;
              const handBone = this.bones[`${side}HandBone`];
              if (handBone) handBone.add(mesh);
              this.botRackets[side] = mesh;
            });
          }

          console.log('[Mixamo Body]', this.data.mode, 'body loaded');
        },

        // Create Fresnel rim + emissive material using MeshStandardMaterial with onBeforeCompile
        // This preserves built-in skinning support and is compatible with all THREE.js versions
        createFresnelMaterial: function(useSkinning) {
          const bodyColor = new THREE.Color(this.data.color);
          const rimIntensity = this.data.rimIntensity;
          const rimPower = this.data.rimPower;

          const material = new THREE.MeshStandardMaterial({
            color: bodyColor,
            emissive: bodyColor,
            emissiveIntensity: this.data.emissiveIntensity,
            roughness: 0.8,
            metalness: 0.0,
            side: THREE.DoubleSide
          });

          // Inject Fresnel rim lighting into the standard shader
          const rimIntVal = rimIntensity;
          const rimPowVal = rimPower;
          material.onBeforeCompile = function(shader) {
            // Add rim uniforms
            shader.uniforms.uRimIntensity = { value: rimIntVal };
            shader.uniforms.uRimPower = { value: rimPowVal };
            shader.uniforms.uRimColor = { value: bodyColor };

            // Add varying for world normal and position to vertex shader
            shader.vertexShader = shader.vertexShader.replace(
              'void main() {',
              `varying vec3 vWorldNormalRim;
               varying vec3 vWorldPositionRim;
               void main() {`
            );
            // After all transforms, compute world normal and position
            shader.vertexShader = shader.vertexShader.replace(
              '#include <worldpos_vertex>',
              `#include <worldpos_vertex>
               vWorldNormalRim = normalize((modelMatrix * vec4(transformedNormal, 0.0)).xyz);
               vWorldPositionRim = (modelMatrix * vec4(transformed, 1.0)).xyz;`
            );

            // Add rim calculation to fragment shader
            shader.fragmentShader = shader.fragmentShader.replace(
              'void main() {',
              `uniform float uRimIntensity;
               uniform float uRimPower;
               uniform vec3 uRimColor;
               varying vec3 vWorldNormalRim;
               varying vec3 vWorldPositionRim;
               void main() {`
            );
            // Add rim glow to the final output
            shader.fragmentShader = shader.fragmentShader.replace(
              '#include <dithering_fragment>',
              `#include <dithering_fragment>
               vec3 rimViewDir = normalize(cameraPosition - vWorldPositionRim);
               vec3 rimNormal = normalize(vWorldNormalRim);
               float rim = 1.0 - max(0.0, dot(rimViewDir, rimNormal));
               rim = pow(rim, uRimPower);
               gl_FragColor.rgb += uRimColor * rim * uRimIntensity;`
            );
          };

          return material;
        },

        mapBones: function() {
          this.initialBoneRotations = {};
          this.legBones = [];

          this.skeleton.bones.forEach((bone) => {
            const name = bone.name;
            this.initialBoneRotations[name] = bone.quaternion.clone();

            // Hide legs (upper body only)
            const lowerName = name.toLowerCase();
            if (lowerName.includes('leg') || lowerName.includes('upleg') ||
                lowerName.includes('foot') || lowerName.includes('toe')) {
              this.legBones.push(bone);
              bone.scale.set(0.001, 0.001, 0.001);
            }

            if (name === this.boneNames.hips) this.bones.hips = bone;
            else if (name === this.boneNames.spine) this.bones.spine = bone;
            else if (name === this.boneNames.spine1) this.bones.spine1 = bone;
            else if (name === this.boneNames.spine2) this.bones.spine2 = bone;
            else if (name === this.boneNames.neck) this.bones.neck = bone;
            else if (name === this.boneNames.head) {
              this.bones.head = bone;
              // Hide head for local player only (blocks VR view); show for bot
              if (!this.isBot) {
                bone.scale.set(0.001, 0.001, 0.001);
              }
            }
            else if (name === this.boneNames.leftShoulder) this.bones.leftShoulder = bone;
            else if (name === this.boneNames.leftArm) this.bones.leftUpperArm = bone;
            else if (name === this.boneNames.leftForeArm) this.bones.leftForearm = bone;
            else if (name === this.boneNames.leftHand) this.bones.leftHandBone = bone;
            else if (name === this.boneNames.leftHandThumb1) this.bones.leftHandThumb1 = bone;
            else if (name === this.boneNames.leftHandThumb2) this.bones.leftHandThumb2 = bone;
            else if (name === this.boneNames.leftHandThumb3) this.bones.leftHandThumb3 = bone;
            else if (name === this.boneNames.leftHandIndex1) this.bones.leftHandIndex1 = bone;
            else if (name === this.boneNames.leftHandIndex2) this.bones.leftHandIndex2 = bone;
            else if (name === this.boneNames.leftHandIndex3) this.bones.leftHandIndex3 = bone;
            else if (name === this.boneNames.leftHandMiddle1) this.bones.leftHandMiddle1 = bone;
            else if (name === this.boneNames.leftHandMiddle2) this.bones.leftHandMiddle2 = bone;
            else if (name === this.boneNames.leftHandMiddle3) this.bones.leftHandMiddle3 = bone;
            else if (name === this.boneNames.leftHandRing1) this.bones.leftHandRing1 = bone;
            else if (name === this.boneNames.leftHandRing2) this.bones.leftHandRing2 = bone;
            else if (name === this.boneNames.leftHandRing3) this.bones.leftHandRing3 = bone;
            else if (name === this.boneNames.leftHandPinky1) this.bones.leftHandPinky1 = bone;
            else if (name === this.boneNames.leftHandPinky2) this.bones.leftHandPinky2 = bone;
            else if (name === this.boneNames.leftHandPinky3) this.bones.leftHandPinky3 = bone;
            else if (name === this.boneNames.rightShoulder) this.bones.rightShoulder = bone;
            else if (name === this.boneNames.rightArm) this.bones.rightUpperArm = bone;
            else if (name === this.boneNames.rightForeArm) this.bones.rightForearm = bone;
            else if (name === this.boneNames.rightHand) this.bones.rightHandBone = bone;
            else if (name === this.boneNames.rightHandThumb1) this.bones.rightHandThumb1 = bone;
            else if (name === this.boneNames.rightHandThumb2) this.bones.rightHandThumb2 = bone;
            else if (name === this.boneNames.rightHandThumb3) this.bones.rightHandThumb3 = bone;
            else if (name === this.boneNames.rightHandIndex1) this.bones.rightHandIndex1 = bone;
            else if (name === this.boneNames.rightHandIndex2) this.bones.rightHandIndex2 = bone;
            else if (name === this.boneNames.rightHandIndex3) this.bones.rightHandIndex3 = bone;
            else if (name === this.boneNames.rightHandMiddle1) this.bones.rightHandMiddle1 = bone;
            else if (name === this.boneNames.rightHandMiddle2) this.bones.rightHandMiddle2 = bone;
            else if (name === this.boneNames.rightHandMiddle3) this.bones.rightHandMiddle3 = bone;
            else if (name === this.boneNames.rightHandRing1) this.bones.rightHandRing1 = bone;
            else if (name === this.boneNames.rightHandRing2) this.bones.rightHandRing2 = bone;
            else if (name === this.boneNames.rightHandRing3) this.bones.rightHandRing3 = bone;
            else if (name === this.boneNames.rightHandPinky1) this.bones.rightHandPinky1 = bone;
            else if (name === this.boneNames.rightHandPinky2) this.bones.rightHandPinky2 = bone;
            else if (name === this.boneNames.rightHandPinky3) this.bones.rightHandPinky3 = bone;
          });
        },

        tick: function(time, deltaTime) {
          if (!this.modelLoaded || !this.skeleton) return;

          const dt = Math.min(deltaTime / 1000, 0.1);

          // Update breathing
          this.breathingPhase += dt * this.breathingRate * Math.PI * 2;
          if (this.breathingPhase > Math.PI * 2) this.breathingPhase -= Math.PI * 2;

          if (this.isBot) {
            this.updateBotBody(time, dt);
          } else {
            if (!this.camera || !this.leftController || !this.rightController) return;
            this.updatePlayerBody(dt);
            this.updateFingerPoses();
          }
        },

        // ---- Finger tracking (player mode only) ----

        updateFingerPoses: function() {
          const leftGamepad = this.leftController.components['tracked-controls']?.controller?.gamepad;
          const rightGamepad = this.rightController.components['tracked-controls']?.controller?.gamepad;

          if (leftGamepad && leftGamepad.buttons) {
            const trigger = leftGamepad.buttons[0]?.value || 0;
            const grip = leftGamepad.buttons[1]?.value || 0;
            let anyThumbTouch = 0;
            for (let i = 2; i <= 6; i++) {
              if (leftGamepad.buttons[i]?.touched) { anyThumbTouch = 1; break; }
            }
            this.updateTargetCurls('left', trigger, grip, anyThumbTouch);
          }

          if (rightGamepad && rightGamepad.buttons) {
            const trigger = rightGamepad.buttons[0]?.value || 0;
            const grip = rightGamepad.buttons[1]?.value || 0;
            let anyThumbTouch = 0;
            for (let i = 2; i <= 6; i++) {
              if (rightGamepad.buttons[i]?.touched) { anyThumbTouch = 1; break; }
            }
            this.updateTargetCurls('right', trigger, grip, anyThumbTouch);
          }

          ['left', 'right'].forEach(hand => {
            ['thumb', 'index', 'middle', 'ring', 'pinky'].forEach(finger => {
              const current = this.currentCurls[hand][finger];
              const target = this.targetCurls[hand][finger];
              this.currentCurls[hand][finger] = current + (target - current) * this.fingerSmoothingFactor;
            });
          });

          this.applyFingerCurls('left', this.currentCurls.left);
          this.applyFingerCurls('right', this.currentCurls.right);
        },

        updateTargetCurls: function(hand, trigger, grip, thumbTouch) {
          const restingCurls = { thumb: 0.1, index: 0.15, middle: 0.2, ring: 0.25, pinky: 0.25 };
          const activeCurls = {
            thumb: thumbTouch * 0.8,
            index: trigger,
            middle: grip * 1.1,
            ring: grip * 1.15,
            pinky: grip * 1.2
          };
          if (grip > 0.1 && trigger < 0.1) activeCurls.index = 0;
          const curls = {
            thumb: Math.max(restingCurls.thumb, activeCurls.thumb),
            index: Math.max(restingCurls.index, activeCurls.index),
            middle: Math.max(restingCurls.middle, activeCurls.middle),
            ring: Math.max(restingCurls.ring, activeCurls.ring),
            pinky: Math.max(restingCurls.pinky, activeCurls.pinky)
          };
          if (grip > 0.1 && trigger < 0.1) curls.index = 0.05;
          if (grip > 0.5 && thumbTouch < 0.5) curls.thumb = -0.15;
          this.targetCurls[hand] = curls;
        },

        applyFingerCurls: function(hand, curls) {
          const fingerBones = {
            thumb: hand === 'left' ? [this.bones.leftHandThumb1, this.bones.leftHandThumb2, this.bones.leftHandThumb3] :
                                     [this.bones.rightHandThumb1, this.bones.rightHandThumb2, this.bones.rightHandThumb3],
            index: hand === 'left' ? [this.bones.leftHandIndex1, this.bones.leftHandIndex2, this.bones.leftHandIndex3] :
                                     [this.bones.rightHandIndex1, this.bones.rightHandIndex2, this.bones.rightHandIndex3],
            middle: hand === 'left' ? [this.bones.leftHandMiddle1, this.bones.leftHandMiddle2, this.bones.leftHandMiddle3] :
                                      [this.bones.rightHandMiddle1, this.bones.rightHandMiddle2, this.bones.rightHandMiddle3],
            ring: hand === 'left' ? [this.bones.leftHandRing1, this.bones.leftHandRing2, this.bones.leftHandRing3] :
                                    [this.bones.rightHandRing1, this.bones.rightHandRing2, this.bones.rightHandRing3],
            pinky: hand === 'left' ? [this.bones.leftHandPinky1, this.bones.leftHandPinky2, this.bones.leftHandPinky3] :
                                     [this.bones.rightHandPinky1, this.bones.rightHandPinky2, this.bones.rightHandPinky3]
          };

          Object.keys(fingerBones).forEach(fingerName => {
            const bones = fingerBones[fingerName];
            const curl = curls[fingerName];
            const isThumb = fingerName === 'thumb';
            const axis = isThumb ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(1, 0, 0);
            const sign = isThumb ? (hand === 'left' ? -1 : 1) : 1;

            bones.forEach((bone, i) => {
              if (!bone) return;
              const initialRot = this.initialBoneRotations[bone.name];
              if (initialRot) bone.quaternion.copy(initialRot);
              const curlAmount = curl * (0.5 + i * 0.25);
              const curlAngle = curlAmount * Math.PI * 0.6 * sign;
              const curlQuat = new THREE.Quaternion().setFromAxisAngle(axis, curlAngle);
              bone.quaternion.multiply(curlQuat);
            });
          });
        },

        // ---- Player body update (VR-driven) ----

        updatePlayerBody: function(dt) {
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();

          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);

          // Head velocity for dynamic lean
          if (this.previousHeadPosInitialized) {
            this.headVelocity.copy(headWorldPos).sub(this.previousHeadPos).divideScalar(dt);
          } else {
            this.previousHeadPosInitialized = true;
          }
          this.previousHeadPos.copy(headWorldPos);

          // Calculate torso orientation from head + hand positions
          this.calculateTorsoOrientation(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, dt);

          // Position body so hips are at correct height
          const desiredHipsY = headWorldPos.y - 0.65;
          const modelHipsLocalY = 1.0;
          const bodyY = desiredHipsY - modelHipsLocalY;

          // 15cm backward offset in body-local space
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);

          this.el.object3D.position.set(
            headWorldPos.x + backwardOffset.x,
            bodyY,
            headWorldPos.z + backwardOffset.z
          );
          this.el.object3D.quaternion.copy(this.torsoRotation);

          // Update bones with IK
          this.updateBones(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, leftHandWorldQuat, rightHandWorldQuat);
        },

        // ---- Bot body update (AI idle animation) ----

        updateBotBody: function(time, dt) {
          // --- Multiplayer: use real remote player tracking data ---
          if (this.remoteHandData) {
            const rd = this.remoteHandData;

            const headPos = new THREE.Vector3(rd.head.x, rd.head.y, rd.head.z);
            const headQuat = (rd.head.qx !== undefined)
              ? new THREE.Quaternion(rd.head.qx, rd.head.qy, rd.head.qz, rd.head.qw)
              : new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

            // Default hand positions near body if not yet received
            const leftHandPos = rd.leftHand
              ? new THREE.Vector3(rd.leftHand.x, rd.leftHand.y, rd.leftHand.z)
              : new THREE.Vector3(headPos.x + 0.3, headPos.y - 0.5, headPos.z + 0.25);
            const rightHandPos = rd.rightHand
              ? new THREE.Vector3(rd.rightHand.x, rd.rightHand.y, rd.rightHand.z)
              : new THREE.Vector3(headPos.x - 0.3, headPos.y - 0.5, headPos.z + 0.25);

            const leftHandQuat = rd.leftHand
              ? new THREE.Quaternion(rd.leftHand.qx, rd.leftHand.qy, rd.leftHand.qz, rd.leftHand.qw)
              : new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0));
            const rightHandQuat = rd.rightHand
              ? new THREE.Quaternion(rd.rightHand.qx, rd.rightHand.qy, rd.rightHand.qz, rd.rightHand.qw)
              : new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0));

            // Head velocity for dynamic lean
            if (this.previousHeadPosInitialized) {
              this.headVelocity.copy(headPos).sub(this.previousHeadPos).divideScalar(dt || 0.016);
            } else {
              this.previousHeadPosInitialized = true;
            }
            this.previousHeadPos.copy(headPos);

            // Calculate torso from remote head + hand positions (same as player body)
            this.calculateTorsoOrientation(headPos, headQuat, leftHandPos, rightHandPos, dt);

            // Position body so hips are at correct height (same as updatePlayerBody)
            const desiredHipsY = headPos.y - 0.65;
            const modelHipsLocalY = 1.0;
            const bodyY = desiredHipsY - modelHipsLocalY;

            const backwardOffset = new THREE.Vector3(0, 0, 0.15);
            backwardOffset.applyQuaternion(this.torsoRotation);

            this.el.object3D.position.set(
              headPos.x + backwardOffset.x,
              bodyY,
              headPos.z + backwardOffset.z
            );
            this.el.object3D.quaternion.copy(this.torsoRotation);

            this.updateBones(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat);

            // Toggle remote player's racket visibility from synced racket mode state
            if (this.botRackets) {
              this.botRackets.left.visible = racketMode.player1.left;
              this.botRackets.right.visible = racketMode.player1.right;
            }
            return;
          }

          // --- Singleplayer: AI idle animation ---
          if (!this.botEntity) {
            this.botEntity = document.querySelector(this.data.botEntitySelector);
            if (!this.botEntity) return;
          }

          const botWorldPos = new THREE.Vector3();
          this.botEntity.object3D.getWorldPosition(botWorldPos);

          this.idleTime += dt;

          // Use the bot entity position as the body's anchor point
          const bodyCenter = botWorldPos.clone();

          // Head is ~0.3m above the body center
          const headPos = new THREE.Vector3(bodyCenter.x, bodyCenter.y + 0.3, bodyCenter.z);

          // Head facing +Z (toward player)
          const headQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

          // Idle hand animation with subtle sway
          const swayX = Math.sin(this.idleTime * 1.5) * 0.03;
          const swayY = Math.sin(this.idleTime * 2.0) * 0.02;
          const swayZ = Math.cos(this.idleTime * 1.2) * 0.02;

          // Hands relative to body center (ready stance)
          // Note: positions are mirrored because the model has double rotation
          // (FBX PI + entity PI), so the IK solver's left/right is flipped
          const leftHandPos = new THREE.Vector3(
            bodyCenter.x + 0.3 - swayX,
            bodyCenter.y - 0.2 + swayY,
            bodyCenter.z + 0.25 + swayZ
          );
          const rightHandPos = new THREE.Vector3(
            bodyCenter.x - 0.3 + swayX,
            bodyCenter.y - 0.2 + swayY,
            bodyCenter.z + 0.25 - swayZ
          );

          // Hand orientations (palms facing inward)
          const leftHandQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0));
          const rightHandQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0));

          // Bot is stationary - zero velocity
          this.headVelocity.set(0, 0, 0);
          if (!this.previousHeadPosInitialized) this.previousHeadPosInitialized = true;
          this.previousHeadPos.copy(headPos);

          // Torso faces +Z (toward player)
          const targetRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
          this.torsoRotation.slerp(targetRotation, this.smoothingFactor);

          // Position body so chest (model local y~1.25) aligns with bot entity center
          const modelChestLocalY = 1.25;
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);

          this.el.object3D.position.set(
            bodyCenter.x + backwardOffset.x,
            bodyCenter.y - modelChestLocalY,
            bodyCenter.z + backwardOffset.z
          );
          this.el.object3D.quaternion.copy(this.torsoRotation);

          // Update bones with IK
          this.updateBones(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat);

          // Apply relaxed finger curls for bot
          const botCurls = { thumb: 0.15, index: 0.2, middle: 0.25, ring: 0.3, pinky: 0.3 };
          this.applyFingerCurls('left', botCurls);
          this.applyFingerCurls('right', botCurls);
        },

        // ---- Torso orientation (blends head forward + shoulder line) ----

        calculateTorsoOrientation: function(headPos, headQuat, leftHandPos, rightHandPos, dt) {
          const headForwardFlat = new THREE.Vector3(0, 0, -1).applyQuaternion(headQuat);
          headForwardFlat.y = 0;
          headForwardFlat.normalize();

          const shoulderLine = rightHandPos.clone().sub(leftHandPos);
          shoulderLine.y = 0;
          const shoulderDist = shoulderLine.length();
          shoulderLine.normalize();

          const controllerForward = new THREE.Vector3().crossVectors(shoulderLine, new THREE.Vector3(0, 1, 0));
          controllerForward.normalize();

          if (controllerForward.dot(headForwardFlat) < 0) {
            controllerForward.negate();
          }

          let controllerWeight = 0.8;
          if (shoulderDist < 0.25) controllerWeight = 0.3;
          else if (shoulderDist > 0.35) controllerWeight = 1.0;

          const blendedForward = new THREE.Vector3()
            .addScaledVector(controllerForward, controllerWeight)
            .addScaledVector(headForwardFlat, 1.0 - controllerWeight)
            .normalize();

          const targetRotation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            blendedForward
          );

          this.torsoRotation.slerp(targetRotation, this.smoothingFactor);
        },

        // ---- Bone update (spine, head, IK arms) ----

        updateBones: function(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat) {
          // Reset bones to T-pose
          if (this.bones.hips) this.bones.hips.quaternion.identity();
          if (this.bones.spine) this.bones.spine.quaternion.identity();
          if (this.bones.spine1) this.bones.spine1.quaternion.identity();
          if (this.bones.spine2) this.bones.spine2.quaternion.identity();

          // Spine bending from hand positions + movement lean
          const bodyCenter = headPos.clone();
          bodyCenter.y -= 0.5;

          const leftRelative = leftHandPos.clone().sub(bodyCenter);
          const rightRelative = rightHandPos.clone().sub(bodyCenter);
          const avgHandPos = new THREE.Vector3()
            .addVectors(leftRelative, rightRelative)
            .multiplyScalar(0.5);

          const invTorsoRot = this.torsoRotation.clone().invert();
          avgHandPos.applyQuaternion(invTorsoRot);

          const handForwardLean = Math.max(-0.08, Math.min(0.05, -avgHandPos.z * 0.08));
          const handSideLean = Math.max(-0.08, Math.min(0.08, avgHandPos.x * 0.1));

          // Dynamic movement lean
          const localVelocity = this.headVelocity.clone();
          localVelocity.applyQuaternion(invTorsoRot);

          const targetLean = new THREE.Vector3(
            localVelocity.z * 0.8,
            0,
            -localVelocity.x * 0.5
          );
          this.torsoLean.lerp(targetLean, this.torsoLeanVelocity);

          const totalForwardLean = handForwardLean + this.torsoLean.x;
          const totalSideLean = handSideLean + this.torsoLean.z;

          // Breathing
          const breathingExpansion = Math.sin(this.breathingPhase) * this.breathingAmount;

          // Distribute lean across spine segments
          if (this.bones.spine || this.bones.spine1 || this.bones.spine2) {
            const spineRotations = [
              { bone: this.bones.spine, amount: 0.25, ba: 0.3 },
              { bone: this.bones.spine1, amount: 0.35, ba: 0.4 },
              { bone: this.bones.spine2, amount: 0.4, ba: 0.3 }
            ];

            spineRotations.forEach(({ bone, amount, ba }) => {
              if (bone) {
                const breathingLean = -breathingExpansion * ba;
                const euler = new THREE.Euler(
                  -totalForwardLean * amount + breathingLean,
                  0,
                  -totalSideLean * amount,
                  'YXZ'
                );
                bone.quaternion.setFromEuler(euler);
              }
            });
          }

          // Head rotation relative to body
          if (this.bones.neck) {
            const relativeHeadQuat = headQuat.clone();
            const invBodyQuat = this.torsoRotation.clone().invert();
            relativeHeadQuat.premultiply(invBodyQuat);

            // Model is rotated 180 Y - flip X and Z
            const euler = new THREE.Euler().setFromQuaternion(relativeHeadQuat, 'YXZ');
            euler.x = -euler.x;
            euler.z = -euler.z;

            const correctedQuat = new THREE.Quaternion().setFromEuler(euler);
            this.bones.neck.quaternion.copy(correctedQuat);
          }

          // Solve arm IK
          this.solveArmIK('left', leftHandPos, leftHandQuat);
          this.solveArmIK('right', rightHandPos, rightHandQuat);
        },

        // ---- Two-bone IK solver for arms ----

        solveArmIK: function(hand, handWorldPos, handWorldQuat) {
          const shoulderBone = this.bones[`${hand}Shoulder`];
          const upperArmBone = this.bones[`${hand}UpperArm`];
          const forearmBone = this.bones[`${hand}Forearm`];
          const handBone = this.bones[`${hand}HandBone`];

          if (!shoulderBone || !upperArmBone || !forearmBone) return;

          // Get shoulder world position from skeleton
          const shoulderWorldPos = new THREE.Vector3();
          shoulderBone.getWorldPosition(shoulderWorldPos);

          // Adjust hand position for hand bone offset
          const adjustedHandPos = handWorldPos.clone();
          const leftRightOffsetLocal = new THREE.Vector3(hand === 'left' ? 0.1 : -0.1, 0, 0);
          const leftRightOffsetWorld = leftRightOffsetLocal.applyQuaternion(this.el.object3D.quaternion);
          adjustedHandPos.add(leftRightOffsetWorld);

          // Clamp to reachable range
          const shoulderToHand = adjustedHandPos.clone().sub(shoulderWorldPos);
          const distance = shoulderToHand.length();
          const maxReach = (this.config.upperArmLength + this.config.lowerArmLength) * 0.999;
          const minReach = Math.abs(this.config.upperArmLength - this.config.lowerArmLength) * 1.001;

          let targetHandPos = adjustedHandPos.clone();
          if (distance > maxReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(maxReach));
          } else if (distance < minReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(minReach));
          }

          // Law of cosines for elbow angle
          const toTarget = targetHandPos.clone().sub(shoulderWorldPos);
          const targetDist = toTarget.length();
          const toTargetDir = toTarget.normalize();

          const upperSq = this.config.upperArmLength * this.config.upperArmLength;
          const lowerSq = this.config.lowerArmLength * this.config.lowerArmLength;
          const distSq = targetDist * targetDist;

          const cosAngle = (upperSq + distSq - lowerSq) / (2 * this.config.upperArmLength * targetDist);
          const clampedCos = Math.max(-0.999, Math.min(0.999, cosAngle));
          const angle = Math.acos(clampedCos);

          // Elbow bend direction
          const bodyRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.torsoRotation);
          const bodyOutward = bodyRight.clone().multiplyScalar(hand === 'left' ? -1 : 1);

          let bendDir = new THREE.Vector3()
            .addScaledVector(bodyOutward, 0.4)
            .addScaledVector(new THREE.Vector3(0, -1, 0), 0.4)
            .normalize();

          // Blend hand orientation into elbow direction
          const handUp = new THREE.Vector3(0, 1, 0).applyQuaternion(handWorldQuat);
          bendDir.addScaledVector(handUp, 0.3);
          bendDir.normalize();

          // Make bend perpendicular to shoulder-hand direction
          bendDir.addScaledVector(toTargetDir, -bendDir.dot(toTargetDir)).normalize();

          // Calculate elbow position
          const elbowDir = new THREE.Vector3()
            .addScaledVector(toTargetDir, Math.cos(angle))
            .addScaledVector(bendDir, Math.sin(angle))
            .normalize();

          let elbowWorldPos = shoulderWorldPos.clone().add(elbowDir.multiplyScalar(this.config.upperArmLength));

          // Enforce exact bone lengths
          const shoulderToElbow = elbowWorldPos.clone().sub(shoulderWorldPos);
          if (Math.abs(shoulderToElbow.length() - this.config.upperArmLength) > 0.0001) {
            elbowWorldPos.copy(shoulderWorldPos).add(shoulderToElbow.normalize().multiplyScalar(this.config.upperArmLength));
          }

          const elbowToHand = targetHandPos.clone().sub(elbowWorldPos);
          if (Math.abs(elbowToHand.length() - this.config.lowerArmLength) > 0.0001) {
            targetHandPos.copy(elbowWorldPos).add(elbowToHand.normalize().multiplyScalar(this.config.lowerArmLength));
          }

          // Convert to bone rotations in local space
          this.el.object3D.updateMatrixWorld(true);

          // Upper arm rotation
          upperArmBone.parent.updateMatrixWorld(true);
          const shoulderInParent = upperArmBone.parent.worldToLocal(shoulderWorldPos.clone());
          const elbowInParent = upperArmBone.parent.worldToLocal(elbowWorldPos.clone());
          const upperArmParentDir = shoulderInParent.clone().sub(elbowInParent).normalize();
          const tPoseDir = new THREE.Vector3(0, -1, 0);
          const upperArmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, upperArmParentDir);

          upperArmBone.quaternion.copy(upperArmQuat);
          upperArmBone.updateMatrixWorld(true);

          // Forearm rotation
          forearmBone.parent.updateMatrixWorld(true);
          const elbowInUpperArm = forearmBone.parent.worldToLocal(elbowWorldPos.clone());
          const handInUpperArm = forearmBone.parent.worldToLocal(targetHandPos.clone());
          const forearmParentDir = elbowInUpperArm.clone().sub(handInUpperArm).normalize();
          const forearmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, forearmParentDir);

          // Forearm twist (pronation/supination)
          forearmBone.updateMatrixWorld(true);
          const forearmWorldQuat = new THREE.Quaternion();
          forearmBone.getWorldQuaternion(forearmWorldQuat);

          const handRelativeForearm = handWorldQuat.clone();
          handRelativeForearm.premultiply(forearmWorldQuat.clone().invert());

          const handEuler = new THREE.Euler().setFromQuaternion(handRelativeForearm, 'YXZ');
          const twistAngle = handEuler.y;

          const forearmTwist = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0),
            twistAngle * 0.5
          );

          forearmBone.quaternion.copy(forearmQuat).multiply(forearmTwist);
          forearmBone.updateMatrixWorld(true);

          // Hand bone orientation
          if (handBone) {
            forearmBone.updateMatrixWorld(true);

            const fwq = new THREE.Quaternion();
            forearmBone.getWorldQuaternion(fwq);

            let handLocalQuat = handWorldQuat.clone();
            handLocalQuat.premultiply(fwq.clone().invert());

            // 180 X flip correction for model rotation
            const localXFlip = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI);
            handLocalQuat.multiply(localXFlip);

            // Roll correction
            const rollCorrection = new THREE.Quaternion().setFromAxisAngle(
              new THREE.Vector3(0, 1, 0),
              hand === 'left' ? Math.PI / 2 : -Math.PI / 2
            );
            handLocalQuat.multiply(rollCorrection);

            handBone.quaternion.copy(handLocalQuat);
          }
        }
      });

    </script>

    <a-scene physics-world game-manager sound-manager multiplayer-sync fps-counter frame-rate-info ball-speed-tracker
             game-modes="enabled: true; mode: bouncing-ball"
    vr-mode-ui="enabled: true"
      renderer="antialias: true; colorManagement: true; shadowMapEnabled: false; maxDeltaTime: 0.2"
    webxr="requiredFeatures: local-floor">
      
      <!-- Game room walls -->
      <!-- Floor -->
      <a-box position="0 0 0" 
             width="4" 
             height="0.1" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Ceiling -->
      <a-box position="0 4 0" 
             width="4" 
             height="0.1" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Left wall -->
      <a-box position="-2 2 0" 
             width="0.1" 
             height="4" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Right wall -->
      <a-box position="2 2 0" 
             width="0.1" 
             height="4" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Back wall -->
      <a-box position="0 2 -8" 
             width="4" 
             height="4" 
             depth="0.1" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Front wall -->
      <a-box position="0 2 8" 
             width="4" 
             height="4" 
             depth="0.1" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Player 1 zone -->
      <a-entity position="0 0.05 -6" player-zone="player: player1; radius: 1">
      </a-entity>

      <!-- Player 2 zone -->
      <a-entity position="0 0.05 6" player-zone="player: player2; radius: 1">
      </a-entity>

      <!-- Boundary lines at 4m from back wall -->
      <!-- Floor lines -->
      <a-entity position="0 0.05 -4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Wall lines -->
      <a-entity position="0 2 -4">
        <!-- Left wall vertical lines -->
        <a-box position="-1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="-1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right wall vertical lines -->
        <a-box position="1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Ceiling lines -->
      <a-entity position="0 3.95 -4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Add a second boundary at 4m from front wall -->
      <a-entity position="0 0.05 4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Wall lines for front boundary -->
      <a-entity position="0 2 4">
        <!-- Left wall vertical lines -->
        <a-box position="-1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="-1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right wall vertical lines -->
        <a-box position="1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Ceiling lines for front boundary -->
      <a-entity position="0 3.95 4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 1.5; metalness: 0; roughness: 0; opacity: 0.5"></a-box>
      </a-entity>

      <!-- Add game manager entity with score display -->
      <a-entity id="game-manager" game-manager>
        <!-- Smaller version display moved closer to ceiling -->
        <a-entity id="version-display" position="0 3.6 0" text="value: v0.20; align: center; width: 1.5; color: #ffffff"></a-entity>
        
        <!-- Large colored score display -->
        <a-entity id="score-display" position="0 3.3 0">
          <!-- Blue player score (left side) -->
          <a-entity id="blue-score" position="-0.3 0 0" text="value: 0; align: center; width: 4; color: #0099ff"></a-entity>
          <!-- Dash separator -->
          <a-entity position="0 0 0" text="value: -; align: center; width: 4; color: #ffffff"></a-entity>
          <!-- Red player score (right side) -->
          <a-entity id="red-score" position="0.3 0 0" text="value: 0; align: center; width: 4; color: #ff4444"></a-entity>
        </a-entity>
        
        <a-entity id="timer-display" position="0 3.0 0" text="value: Time: 3:00; align: center; width: 2; color: #ffff00"></a-entity>
        <a-entity id="start-message" position="0 2.7 0" text="value: Press A to Start; align: center; width: 2; color: #ffffff"></a-entity>

      </a-entity>

      <!-- Add impact sound entities -->
      <a-entity id="impact-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 2;">
      </a-entity>

      <!-- Add bounce sound entity -->
      <a-entity id="bounce-sound" sound="src: url(audio/impact-cinematic-boom-5-352465.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 8;
                                        rate: 1.5;">
      </a-entity>

      <!-- Bot (AI player) -->
      <a-entity position="0 0 -6" advanced-bot="enabled: true; difficulty: medium; debug: true">
        <a-entity id="bot-target" position="0 0.4 0"
                  geometry="primitive: sphere; radius: 0.15; segmentsWidth: 8; segmentsHeight: 6"
                  material="color: #ff0000; opacity: 0; transparent: true"
                  obb-collider impact-effect="color: #ff0000">
          <!-- Impact sphere (no declarative animations - handled in JS by impact-effect component) -->
          <a-sphere id="bot-impact" radius="0.05" visible="false"
            material="side: double; transparent: true; opacity: 0; color: #ff0000; emissive: #ff0000; emissiveIntensity: 1.5">
          </a-sphere>
        </a-entity>
        <!-- Bot body collision box (torso area) -->
        <a-box id="bot-body-collider" position="0 -0.1 0"
               width="0.4" height="0.7" depth="0.25"
               material="color: #ff0000; opacity: 0; transparent: true" visible="false"
               obb-collider>
        </a-box>
      </a-entity>

      <!-- Bot Body (rigged upper body) -->
      <a-entity id="bot-body" mixamo-body="mode: bot; color: #E24A4A"></a-entity>

      <!-- Player 1 ball spawn (AI player's ball) -->
      <a-sphere position="0 1 -5.5" 
             radius="0.1"
             color="#ff0000" 
             glow="color: #ff0000; intensity: 1.5"
             simple-grab="player: player1"
             ball-trail="color: #ff0000"
             debug-collider
             obb-collider>
        <a-entity light="type: point;
                       color: #ff0000;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2;"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff0000" material="wireframe: true; color: #ff0000; opacity: 0.5"></a-sphere>
        <a-entity id="red-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player 2 ball spawn (Human player's ball) -->
      <a-sphere position="0 1 5.5" 
             radius="0.1"
             color="#0000ff" 
             glow="color: #0000ff; intensity: 1.5"
             simple-grab="player: player2"
             ball-trail="color: #0000ff"
             debug-collider
             obb-collider>
        <a-entity light="type: point; 
                       color: #0000ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#0000ff" material="wireframe: true; color: #0000ff; opacity: 0.5"></a-sphere>
        <a-entity id="blue-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Basic Camera Rig for VR -->
      <a-entity id="player" position="0 0 6">
        <a-entity id="rig" position="0 0 0">
          <a-entity camera look-controls="pointerLockEnabled: false">
            <!-- This is the target sphere that needs to be hit -->
            <a-sphere id="player-target" radius="0.2" color="#0000ff" glow="color: #0000ff; intensity: 1.5" obb-collider material="transparent: true; opacity: 0.5" impact-effect="color: #0000ff">
              <a-entity light="type: point;
                             color: #0000ff;
                             intensity: 0.8;     
                             distance: 3;       
                             decay: 2"  
                        position="0 0 0">
              </a-entity>
              <!-- Impact sphere with animation component -->
              <!-- Impact sphere (no declarative animations - handled in JS by impact-effect component) -->
              <a-sphere id="player-impact" radius="0.05" visible="false"
                material="side: double; transparent: true; opacity: 0; color: #0000ff; emissive: #0000ff; emissiveIntensity: 1.5">
              </a-sphere>
            </a-sphere>
            <!-- Player body collision box (follows head, offset to chest) -->
            <a-box id="player-body-collider" position="0 -0.4 0"
                   width="0.4" height="0.7" depth="0.25"
                   material="color: #0000ff; opacity: 0; transparent: true" visible="false"
                   obb-collider>
            </a-box>
          </a-entity>
          
          <a-entity id="leftHand" 
                   hand-controls="hand: left"
                   oculus-touch-controls="hand: left"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Racket for left hand -->
            <a-box id="leftHandRacket"
                   width="0.2" 
                   height="0.2" 
                   depth="0.02"
                   position="0 0 -0.15"
                   rotation="0 -90 0"
                   color="#0099ff"
                   material="wireframe: true; opacity: 0.8; transparent: true"
                   static-physics="isRacket: true"
                   visible="false">
            </a-box>
            
            <!-- Stats display on arm/wrist -->
            <a-entity id="arm-stats" 
                      position="0 0.1 0.05" 
                      rotation="-45 0 0">
              <!-- Background panel -->
              <a-plane width="0.25" 
                       height="0.15" 
                       color="#000000" 
                       material="opacity: 0.8; transparent: true"
                       position="0 0 -0.001">
              </a-plane>
              
              <!-- Stats text -->
              <a-text id="ball-stats-text"
                      value="Blue ball: -- m/s&#10;Red ball: -- m/s"
                      position="0 0 0"
                      align="center"
                      width="0.25"
                      color="#00ff00"
                      font="dejavu"
                      geometry="primitive: plane; width: auto; height: auto"
                      material="color: #000000; transparent: true; opacity: 0">
              </a-text>
            </a-entity>
          </a-entity>
          
          <a-entity id="rightHand" 
                   hand-controls="hand: right"
                   oculus-touch-controls="hand: right"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Racket for right hand -->
            <a-box id="rightHandRacket"
                   width="0.2" 
                   height="0.2" 
                   depth="0.02"
                   position="0 0 -0.15"
                   rotation="0 -90 0"
                   color="#0099ff"
                   material="wireframe: true; opacity: 0.8; transparent: true"
                   static-physics="isRacket: true"
                   visible="false">
            </a-box>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Player Body (rigged upper body) -->
      <a-entity id="player-body" mixamo-body="mode: player; color: #4A90E2"></a-entity>

      <a-sky color="#000000"></a-sky>
    </a-scene>
  </body>
</html> 