<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Language Practice VR (Quest Compatible)</title>
    <meta name="description" content="Learn languages in VR with Vosk offline speech recognition">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.173.0/examples/js/loaders/FBXLoader.js"></script>
    <!-- Vosk.js for Quest compatibility -->
    <script src="https://cdn.jsdelivr.net/npm/vosk-browser@0.0.8/dist/vosk.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
      
      /* Desktop UI */
      #ui {
        position: fixed; top: 10px; left: 10px;
        background: rgba(0, 0, 0, 0.9); color: white;
        padding: 20px; border-radius: 10px;
        font-family: 'Segoe UI', sans-serif;
        z-index: 1000; max-width: 400px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }
      #ui h2 { margin: 0 0 15px 0; color: #4CAF50; font-size: 24px; }
      #ui h3 { margin: 15px 0 10px 0; color: #81C784; font-size: 18px; }
      
      .status { font-size: 12px; color: #888; margin: 5px 0; }
      .status.active { color: #4CAF50; }
      .status.error { color: #f44336; }
      
      .language-selector {
        display: flex; gap: 10px; margin: 15px 0;
      }
      
      .lang-btn {
        padding: 10px 15px; background: #2196F3; border: none;
        color: white; border-radius: 5px; cursor: pointer;
        font-size: 14px; transition: all 0.3s;
      }
      .lang-btn:hover { background: #1976D2; transform: scale(1.05); }
      .lang-btn.active { background: #4CAF50; }
      
      .scenario-list {
        display: flex; flex-direction: column; gap: 8px; margin: 10px 0;
      }
      
      .scenario-btn {
        padding: 12px; background: #424242; border: none;
        color: white; border-radius: 5px; cursor: pointer;
        text-align: left; transition: all 0.3s;
        border-left: 4px solid #2196F3;
      }
      .scenario-btn:hover { background: #616161; transform: translateX(5px); }
      .scenario-btn.active { background: #1976D2; border-left-color: #4CAF50; }
      
      #score {
        font-size: 20px; color: #FFD700; font-weight: bold;
        margin: 10px 0; padding: 10px; background: rgba(255, 215, 0, 0.1);
        border-radius: 5px; text-align: center;
      }
      
      .info { 
        font-size: 11px; color: #999; margin-top: 15px; 
        padding-top: 15px; border-top: 1px solid #333;
        line-height: 1.6;
      }
      
      #feedback-banner {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: rgba(76, 175, 80, 0.95);
        color: white; padding: 30px 50px;
        border-radius: 15px; font-size: 32px;
        font-weight: bold; z-index: 2000;
        transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        text-align: center;
      }
      
      #feedback-banner.show { transform: translate(-50%, -50%) scale(1); }
      #feedback-banner.success { background: rgba(76, 175, 80, 0.95); }
      #feedback-banner.warning { background: rgba(255, 152, 0, 0.95); }
      #feedback-banner.error { background: rgba(244, 67, 54, 0.95); }
      
      #current-phrase {
        position: fixed; top: 20px; left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85); color: white;
        padding: 20px 40px; border-radius: 10px;
        font-size: 24px; z-index: 1500;
        text-align: center; max-width: 600px;
        display: none;
      }
      
      #current-phrase.active { display: block; }
      
      #translation {
        font-size: 16px; color: #81C784;
        margin-top: 10px; font-style: italic;
      }
      
      .mic-indicator {
        display: inline-block;
        width: 12px; height: 12px;
        background: #f44336;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(1.2); }
      }

      #start-screen {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        color: white;
      }

      #start-screen.show { display: flex; }
      #start-screen.hidden { display: none; }

      .start-content {
        text-align: center;
        max-width: 600px;
        padding: 40px;
      }

      .start-content h1 {
        font-size: 48px;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }

      .start-content p {
        font-size: 18px;
        margin-bottom: 30px;
        line-height: 1.6;
      }

      #enter-vr-btn {
        padding: 20px 50px;
        font-size: 24px;
        background: #4CAF50;
        border: none;
        color: white;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      }

      #enter-vr-btn:hover {
        background: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      }
      
      #loading-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 4000;
        color: white;
        flex-direction: column;
      }
      
      #loading-overlay.hidden { display: none; }
      
      .loading-content {
        text-align: center;
        max-width: 500px;
      }
      
      .loading-content h2 {
        font-size: 32px;
        margin-bottom: 20px;
      }
      
      .progress-bar {
        width: 100%;
        height: 30px;
        background: #333;
        border-radius: 15px;
        overflow: hidden;
        margin: 20px 0;
      }
      
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #81C784);
        width: 0%;
        transition: width 0.3s;
      }
      
      .loading-status {
        font-size: 16px;
        color: #81C784;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loading-overlay">
      <div class="loading-content">
        <h2>üé§ Loading Speech Models...</h2>
        <div class="progress-bar">
          <div id="progress-fill" class="progress-fill"></div>
        </div>
        <div id="loading-status" class="loading-status">Initializing...</div>
        <p style="font-size: 14px; color: #999; margin-top: 20px;">
          First load may take 1-2 minutes<br>
          Models are cached for future visits
        </p>
      </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
      <div class="start-content">
        <h1>üó£Ô∏è Language Practice VR</h1>
        <p>Quest-compatible offline speech recognition powered by Vosk</p>
        <button id="enter-vr-btn">Enter VR Experience</button>
        <div style="margin-top: 30px; font-size: 14px; opacity: 0.8;">
          <p>‚úì Works on Meta Quest<br>
          ‚úì Offline speech recognition<br>
          ‚úì Interactive scenarios</p>
        </div>
      </div>
    </div>

    <!-- Desktop UI -->
    <div id="ui">
      <h2>üéì Language VR (Vosk)</h2>
      
      <div class="status" id="status">Ready to start</div>
      <div class="status" id="speech-status">Speech: Initializing...</div>
      
      <h3>Choose Language:</h3>
      <div class="language-selector">
        <button class="lang-btn active" data-lang="es-ES" data-name="Spanish">üá™üá∏ Spanish</button>
        <button class="lang-btn" data-lang="fr-FR" data-name="French">üá´üá∑ French</button>
        <button class="lang-btn" data-lang="de-DE" data-name="German">üá©üá™ German</button>
        <button class="lang-btn" data-lang="nl-NL" data-name="Dutch">üá≥üá± Dutch</button>
      </div>
      
      <h3>Scenarios:</h3>
      <div class="scenario-list">
        <button class="scenario-btn active" data-scenario="greetings">
          üëã Greetings & Introductions
        </button>
        <button class="scenario-btn" data-scenario="restaurant">
          üçΩÔ∏è Restaurant Conversation
        </button>
        <button class="scenario-btn" data-scenario="shopping">
          üõçÔ∏è Shopping & Prices
        </button>
        <button class="scenario-btn" data-scenario="directions">
          üó∫Ô∏è Asking for Directions
        </button>
      </div>
      
      <div id="score">Score: 0 üåü</div>
      
      <div class="info">
        <strong>Recognition:</strong> <span id="recognition-type">Detecting...</span><br>
        <strong>How to use:</strong><br>
        1. Put on your VR headset<br>
        2. Listen to the NPC speak<br>
        3. Repeat the phrase clearly<br>
        4. Get instant feedback!<br><br>
        <strong>Controls:</strong> Right thumbstick = rotate NPC
      </div>
    </div>

    <!-- Current Phrase Display -->
    <div id="current-phrase">
      <div id="phrase-text">Hola, ¬øc√≥mo est√°s?</div>
      <div id="translation">Hello, how are you?</div>
    </div>

    <!-- Feedback Banner -->
    <div id="feedback-banner"></div>

    <!-- VR Scene -->
    <a-scene background="color: #87CEEB" renderer="antialias: true; colorManagement: true">
      <!-- Lighting -->
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="2 4 2"></a-entity>
      <a-entity light="type: point; intensity: 0.5; color: #FFA500" position="0 2 -2"></a-entity>

      <!-- VR Camera Rig -->
      <a-entity id="rig" position="0 1.6 0" vr-locomotion>
        <a-entity id="camera" camera look-controls wasd-controls="acceleration: 20">
          <a-entity cursor="fuse: false; rayOrigin: mouse"
                    raycaster="objects: .clickable; far: 10"></a-entity>
        </a-entity>
        <a-entity id="left-hand" 
                  hand-controls="hand: left; handModelStyle: lowPoly"
                  laser-controls="hand: left"
                  raycaster="objects: .clickable; lineColor: red; lineOpacity: 0.5"
                  ui-toggle-controller></a-entity>
        <a-entity id="right-hand" 
                  hand-controls="hand: right; handModelStyle: lowPoly"
                  laser-controls="hand: right"
                  raycaster="objects: .clickable; lineColor: red; lineOpacity: 0.5"
                  ui-toggle-controller></a-entity>
      </a-entity>

      <!-- Player Body -->
      <a-entity id="local-body" mixamo-body="isMirror: false; modelPath: ../BoltVR/assets/Y Bot.fbx"></a-entity>

      <!-- NPC Tutor Body -->
      <a-entity id="npc-tutor" 
                mixamo-body="isMirror: true; color: #FF6B6B; modelPath: ../BoltVR/assets/Y Bot.fbx" 
                position="0 0 -2.5"
                language-npc>
        <a-text value="Mar√≠a - Spanish Tutor" 
                position="0 2.2 0" 
                align="center" 
                color="#333" 
                width="4"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                id="npc-name"></a-text>
        
        <a-entity id="speech-bubble" position="0 2 0.3" visible="false">
          <a-plane width="1.5" height="0.5" color="#FFFFFF" opacity="0.95"></a-plane>
          <a-text value="¬°Hola!" 
                  position="0 0 0.01" 
                  align="center" 
                  color="#333" 
                  width="1.3"
                  shader="msdf"
                  font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                  id="bubble-text"></a-text>
        </a-entity>
      </a-entity>

      <!-- LEFT: Language Selection Panel -->
      <a-entity id="vr-language-panel" position="-2.5 2 -2" rotation="0 30 0">
        <a-plane width="1.2" height="1.8" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <a-text value="LANGUAGE" 
                position="0 0.8 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <a-box id="vr-lang-spanish" 
               width="1" height="0.2" depth="0.05" 
               color="#4CAF50"
               position="0 0.4 0"
               class="clickable lang-button"
               data-lang="es-ES"
               data-name="Spanish"></a-box>
        <a-text value="üá™üá∏ Spanish" 
                position="0 0.4 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-french" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 0.1 0"
               class="clickable lang-button"
               data-lang="fr-FR"
               data-name="French"></a-box>
        <a-text value="üá´üá∑ French" 
                position="0 0.1 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-german" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.2 0"
               class="clickable lang-button"
               data-lang="de-DE"
               data-name="German"></a-box>
        <a-text value="üá©üá™ German" 
                position="0 -0.2 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-dutch" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.5 0"
               class="clickable lang-button"
               data-lang="nl-NL"
               data-name="Dutch"></a-box>
        <a-text value="üá≥üá± Dutch" 
                position="0 -0.5 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
      </a-entity>
      
      <!-- RIGHT: Scenario Selection Panel -->
      <a-entity id="vr-scenario-panel" position="2.5 2 -2" rotation="0 -30 0">
        <a-plane width="1.2" height="1.8" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <a-text value="SCENARIOS" 
                position="0 0.8 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <a-box id="vr-scenario-greetings" 
               width="1" height="0.2" depth="0.05" 
               color="#4CAF50"
               position="0 0.4 0"
               class="clickable scenario-button"
               data-scenario="greetings"></a-box>
        <a-text value="üëã Greetings" 
                position="0 0.4 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-restaurant" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 0.1 0"
               class="clickable scenario-button"
               data-scenario="restaurant"></a-box>
        <a-text value="üçΩÔ∏è Restaurant" 
                position="0 0.1 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-shopping" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.2 0"
               class="clickable scenario-button"
               data-scenario="shopping"></a-box>
        <a-text value="üõçÔ∏è Shopping" 
                position="0 -0.2 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-directions" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.5 0"
               class="clickable scenario-button"
               data-scenario="directions"></a-box>
        <a-text value="üó∫Ô∏è Directions" 
                position="0 -0.5 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
      </a-entity>

      <!-- CENTER: VR UI Panel -->
      <a-entity id="vr-ui-panel" position="0 2.5 -1.5">
        <a-plane width="2" height="1.2" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <a-text id="vr-phrase-text" 
                value="¬°Hola!" 
                position="0 0.45 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="30"></a-text>
        
        <a-text id="vr-translation-text" 
                value="Hello!" 
                position="0 0.3 0.01" 
                align="center" 
                color="#81C784" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="30"></a-text>
        
        <a-text id="vr-instruction-text" 
                value="üé§ Listening... Speak now!" 
                position="0 0.1 0.01" 
                align="center" 
                color="#FFD700" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="40"></a-text>
        
        <a-text id="vr-heard-text" 
                value="" 
                position="0 -0.05 0.01" 
                align="center" 
                color="#FFFFFF" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="40"></a-text>
        
        <a-text id="vr-score-text" 
                value="Score: 0" 
                position="0 -0.25 0.01" 
                align="center" 
                color="#FFD700" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <a-entity id="mic-visualizer" position="0 -0.45 0.01">
          <a-plane width="1.5" height="0.08" color="#333333"></a-plane>
          <a-plane id="mic-level-bar" 
                   width="0" 
                   height="0.08" 
                   color="#4CAF50" 
                   position="-0.75 0 0.01"></a-plane>
          <a-text value="Mic Level" 
                  position="0 -0.08 0.01" 
                  align="center" 
                  color="#888888" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
        </a-entity>
        
        <a-entity id="vr-buttons" position="0 -0.7 0.01">
          <a-box id="repeat-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#2196F3"
                 position="-0.6 0 0"
                 class="clickable"></a-box>
          <a-text value="üîä REPEAT" 
                  position="-0.6 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
          
          <a-box id="next-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#4CAF50"
                 position="-0.1 0 0"
                 class="clickable"></a-box>
          <a-text value="‚û°Ô∏è NEXT" 
                  position="-0.1 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
          
          <a-box id="play-pause-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#4CAF50"
                 position="0.4 0 0"
                 class="clickable"></a-box>
          <a-text id="play-pause-text"
                  value="‚è∏Ô∏è PAUSE" 
                  position="0.4 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
        </a-entity>
      </a-entity>

      <!-- Environments (same as index.html) -->
      <a-entity id="env-classroom" visible="true">
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="20" 
                 height="20" 
                 color="#7BC8A4"
                 shadow="receive: true"></a-plane>
        <a-box position="0 2 -8" width="20" height="4" depth="0.2" color="#F0E68C"></a-box>
        <a-box position="-10 2 0" width="0.2" height="4" depth="16" color="#F0E68C"></a-box>
        <a-box position="10 2 0" width="0.2" height="4" depth="16" color="#F0E68C"></a-box>
        <a-box position="0 2.5 -7.8" width="4" height="2" depth="0.1" color="#FFFFFF"></a-box>
        <a-text value="Language Practice" 
                position="0 3.3 -7.7" 
                align="center" 
                color="#2196F3" 
                width="3"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        <a-box position="0 0.4 -2" width="1.5" height="0.8" depth="1" color="#8B4513"></a-box>
        <a-sphere position="-3 1.5 -5" radius="0.3" color="#FF6B6B"></a-sphere>
        <a-sphere position="3 1.5 -5" radius="0.3" color="#4ECDC4"></a-sphere>
        <a-cylinder position="-4 0.5 -6" radius="0.2" height="1" color="#2ECC71"></a-cylinder>
        <a-cylinder position="4 0.5 -6" radius="0.2" height="1" color="#E74C3C"></a-cylinder>
        <a-text value="Stand here and speak clearly!" 
                position="0 0.01 0.5" 
                rotation="-90 0 0" 
                align="center" 
                color="#333" 
                width="6"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
      </a-entity>
      
      <a-entity id="env-restaurant" visible="false">
        <a-entity id="temple-model" 
                  gltf-model="url(assets/bagan_-_khayiminga_temple_interior.glb)" 
                  position="0 1 -4" 
                  rotation="0 180 0"
                  scale="2 2 2"
                  shadow="cast: true; receive: true"></a-entity>
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#8B7355"
                 opacity="0.8"
                 shadow="receive: true"></a-plane>
      </a-entity>
      
      <a-entity id="env-shopping" visible="false">
        <a-entity id="moosstock-mountain-model" 
                  gltf-model="url(https://pub-65c21cd4f13345fcb1574dc28def6a19.r2.dev/moosstock_mountain_peak_3024_m.glb)" 
                  position="0 -67 10" 
                  rotation="0 90 0"
                  scale="80 80 80"
                  shadow="cast: true; receive: true"></a-entity>
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#D2B48C"
                 opacity="0"
                 shadow="receive: true"></a-plane>
      </a-entity>
      
      <a-entity id="env-directions" visible="false">
        <a-entity id="hintze-hall-model" 
                  gltf-model="url(https://pub-65c21cd4f13345fcb1574dc28def6a19.r2.dev/hintze_hall.glb)" 
                  position="2.5 -0.5 -12.5" 
                  rotation="0 180 0"
                  scale="1 1 1"
                  shadow="cast: true; receive: true"></a-entity>
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#6B8E23"
                 opacity="0.8"
                 shadow="receive: true"></a-plane>
      </a-entity>
    </a-scene>

    <script>
      // ========================================
      // VOSK SPEECH RECOGNITION
      // ========================================
      
      const VoskRecognizer = {
        model: null,
        recognizer: null,
        audioContext: null,
        processor: null,
        isInitialized: false,
        isListening: false,
        currentLanguage: 'es',
        onResult: null,
        
        languageMap: {
          'es-ES': 'es',
          'fr-FR': 'fr',
          'de-DE': 'de',
          'nl-NL': 'nl'
        },
        
        async init(language, onProgress, onResult) {
          console.log('[Vosk] Initializing for language:', language);
          this.currentLanguage = this.languageMap[language] || 'es';
          this.onResult = onResult;
          
          try {
            // Show progress
            if (onProgress) onProgress(10, 'Loading Vosk library...');
            
            // Load model from assets
            const modelPath = `assets/vosk-models/${this.currentLanguage}`;
            console.log('[Vosk] Loading model from:', modelPath);
            
            if (onProgress) onProgress(30, `Loading ${this.currentLanguage} model...`);
            
            // Create model
            this.model = await Vosk.createModel(modelPath);
            console.log('[Vosk] ‚úì Model loaded');
            
            if (onProgress) onProgress(60, 'Creating recognizer...');
            
            // Create recognizer with 16kHz sample rate
            this.recognizer = new this.model.KaldiRecognizer(16000);
            this.recognizer.setWords(true);
            
            console.log('[Vosk] ‚úì Recognizer created');
            
            if (onProgress) onProgress(80, 'Setting up microphone...');
            
            // Setup audio processing
            await this.setupAudio();
            
            if (onProgress) onProgress(100, 'Ready!');
            
            this.isInitialized = true;
            console.log('[Vosk] ‚úì Fully initialized');
            
            return true;
          } catch (error) {
            console.error('[Vosk] Initialization error:', error);
            throw error;
          }
        },
        
        async setupAudio() {
          try {
            // Get microphone stream
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                sampleRate: 16000
              } 
            });
            
            console.log('[Vosk] Microphone access granted');
            
            // Create audio context with 16kHz sample rate (Vosk requirement)
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 16000
            });
            
            const source = this.audioContext.createMediaStreamSource(stream);
            
            // Create script processor for audio processing
            const bufferSize = 4096;
            this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
            
            this.processor.onaudioprocess = (e) => {
              if (!this.isListening || !this.recognizer) return;
              
              const inputData = e.inputBuffer.getChannelData(0);
              
              // Convert Float32 to Int16 (Vosk requirement)
              const int16Data = new Int16Array(inputData.length);
              for (let i = 0; i < inputData.length; i++) {
                const s = Math.max(-1, Math.min(1, inputData[i]));
                int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
              }
              
              // Send to Vosk
              try {
                const result = this.recognizer.acceptWaveform(int16Data);
                
                if (result) {
                  const resultObj = JSON.parse(this.recognizer.result());
                  if (resultObj.text && resultObj.text.trim()) {
                    console.log('[Vosk] Result:', resultObj.text);
                    if (this.onResult) {
                      this.onResult(resultObj.text, 1.0); // Vosk doesn't provide confidence
                    }
                  }
                }
              } catch (err) {
                console.error('[Vosk] Processing error:', err);
              }
            };
            
            // Connect audio pipeline
            source.connect(this.processor);
            this.processor.connect(this.audioContext.destination);
            
            console.log('[Vosk] ‚úì Audio pipeline ready');
          } catch (error) {
            console.error('[Vosk] Audio setup error:', error);
            throw error;
          }
        },
        
        start() {
          if (!this.isInitialized) {
            console.error('[Vosk] Not initialized');
            return;
          }
          
          this.isListening = true;
          console.log('[Vosk] Started listening');
        },
        
        stop() {
          this.isListening = false;
          
          // Get final result
          if (this.recognizer) {
            try {
              const finalResult = JSON.parse(this.recognizer.finalResult());
              if (finalResult.text && finalResult.text.trim()) {
                console.log('[Vosk] Final result:', finalResult.text);
                if (this.onResult) {
                  this.onResult(finalResult.text, 1.0);
                }
              }
            } catch (err) {
              console.error('[Vosk] Final result error:', err);
            }
          }
          
          console.log('[Vosk] Stopped listening');
        },
        
        async switchLanguage(language, onProgress) {
          console.log('[Vosk] Switching to language:', language);
          
          // Stop current recognition
          this.stop();
          
          // Clean up old model
          if (this.recognizer) {
            this.recognizer = null;
          }
          if (this.model) {
            this.model = null;
          }
          
          // Reinitialize with new language
          this.isInitialized = false;
          await this.init(language, onProgress, this.onResult);
        }
      };
      
      // ========================================
      // LANGUAGE APP CORE (Modified for Vosk)
      // ========================================
      
      const LanguageApp = {
        currentLanguage: 'es-ES',
        currentLanguageName: 'Spanish',
        currentScenario: 'greetings',
        currentPhrase: null,
        currentPhraseIndex: 0,
        score: 0,
        recognition: null,
        synthesis: window.speechSynthesis,
        isListening: false,
        isPaused: false,
        audioContext: null,
        microphone: null,
        analyser: null,
        micLevelBar: null,
        voices: [],
        selectedVoice: null,
        useVosk: false,
        
        // Phrase database (same as index.html)
        phrases: {
          'greetings': {
            'es-ES': [
              { text: '¬°Hola!', translation: 'Hello!', difficulty: 1 },
              { text: '¬øC√≥mo est√°s?', translation: 'How are you?', difficulty: 1 },
              { text: 'Me llamo Mar√≠a', translation: 'My name is Mar√≠a', difficulty: 1 },
              { text: 'Mucho gusto', translation: 'Nice to meet you', difficulty: 1 },
              { text: 'Buenos d√≠as', translation: 'Good morning', difficulty: 1 },
              { text: '¬øC√≥mo te llamas?', translation: 'What is your name?', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'Bonjour!', translation: 'Hello!', difficulty: 1 },
              { text: 'Comment allez-vous?', translation: 'How are you?', difficulty: 1 },
              { text: 'Je m\'appelle Marie', translation: 'My name is Marie', difficulty: 1 },
              { text: 'Enchant√©', translation: 'Nice to meet you', difficulty: 1 }
            ],
            'de-DE': [
              { text: 'Hallo!', translation: 'Hello!', difficulty: 1 },
              { text: 'Wie geht es dir?', translation: 'How are you?', difficulty: 1 },
              { text: 'Ich hei√üe Maria', translation: 'My name is Maria', difficulty: 1 },
              { text: 'Freut mich', translation: 'Nice to meet you', difficulty: 1 }
            ],
            'nl-NL': [
              { text: 'Hallo!', translation: 'Hello!', difficulty: 1 },
              { text: 'Hoe gaat het?', translation: 'How are you?', difficulty: 1 },
              { text: 'Ik heet Maria', translation: 'My name is Maria', difficulty: 1 },
              { text: 'Aangenaam', translation: 'Nice to meet you', difficulty: 1 },
              { text: 'Goedemorgen', translation: 'Good morning', difficulty: 1 },
              { text: 'Hoe heet je?', translation: 'What is your name?', difficulty: 2 }
            ]
          },
          'restaurant': {
            'es-ES': [
              { text: '¬øQu√© desea ordenar?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'La cuenta, por favor', translation: 'The bill, please', difficulty: 2 },
              { text: 'Una mesa para dos', translation: 'A table for two', difficulty: 2 },
              { text: '¬øTiene men√∫ del d√≠a?', translation: 'Do you have a daily menu?', difficulty: 3 }
            ],
            'fr-FR': [
              { text: 'Qu\'est-ce que vous d√©sirez?', translation: 'What would you like?', difficulty: 2 },
              { text: 'L\'addition, s\'il vous pla√Æt', translation: 'The bill, please', difficulty: 2 },
              { text: 'Une table pour deux', translation: 'A table for two', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Was m√∂chten Sie bestellen?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'Die Rechnung, bitte', translation: 'The bill, please', difficulty: 2 },
              { text: 'Ein Tisch f√ºr zwei', translation: 'A table for two', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Wat wilt u bestellen?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'De rekening, alstublieft', translation: 'The bill, please', difficulty: 2 },
              { text: 'Een tafel voor twee', translation: 'A table for two', difficulty: 2 },
              { text: 'Heeft u een dagmenu?', translation: 'Do you have a daily menu?', difficulty: 3 }
            ]
          },
          'shopping': {
            'es-ES': [
              { text: '¬øCu√°nto cuesta?', translation: 'How much does it cost?', difficulty: 2 },
              { text: '¬øTiene esto en otro color?', translation: 'Do you have this in another color?', difficulty: 3 },
              { text: 'Me gustar√≠a comprar esto', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'Combien √ßa co√ªte?', translation: 'How much does it cost?', difficulty: 2 },
              { text: 'Je voudrais acheter ceci', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Was kostet das?', translation: 'How much does it cost?', difficulty: 2 },
              { text: 'Ich m√∂chte das kaufen', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Hoeveel kost dit?', translation: 'How much does this cost?', difficulty: 2 },
              { text: 'Heeft u dit in een andere kleur?', translation: 'Do you have this in another color?', difficulty: 3 },
              { text: 'Ik wil dit graag kopen', translation: 'I would like to buy this', difficulty: 2 }
            ]
          },
          'directions': {
            'es-ES': [
              { text: '¬øD√≥nde est√° la estaci√≥n?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Gire a la derecha', translation: 'Turn right', difficulty: 2 },
              { text: 'Siga recto', translation: 'Go straight', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'O√π est la gare?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Tournez √† droite', translation: 'Turn right', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Wo ist der Bahnhof?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Biegen Sie rechts ab', translation: 'Turn right', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Waar is het station?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Ga naar rechts', translation: 'Turn right', difficulty: 2 },
              { text: 'Ga rechtdoor', translation: 'Go straight', difficulty: 2 }
            ]
          }
        },

        async init() {
          console.log('[Language App] Initializing with Vosk support...');
          
          // Detect which recognition system to use
          await this.detectRecognitionSystem();
          
          // Load voices for TTS
          this.loadVoices();
          
          // Initialize microphone visualizer
          this.initMicrophoneVisualizer();
          
          // Setup UI
          this.setupUIListeners();
          this.setupVRButtons();
          
          // Wait for scene
          const scene = document.querySelector('a-scene');
          if (scene.hasLoaded) {
            this.onSceneLoaded();
          } else {
            scene.addEventListener('loaded', () => this.onSceneLoaded());
          }
          
          console.log('[Language App] Initialization complete');
        },

        async detectRecognitionSystem() {
          const loadingOverlay = document.getElementById('loading-overlay');
          const progressFill = document.getElementById('progress-fill');
          const loadingStatus = document.getElementById('loading-status');
          
          // Check for Web Speech API
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          
          if (SpeechRecognition) {
            console.log('[Detection] Web Speech API available');
            document.getElementById('recognition-type').textContent = 'Web Speech API (Online)';
            this.useVosk = false;
            
            // Initialize Web Speech API
            this.initWebSpeechAPI();
            
            // Hide loading
            loadingOverlay.classList.add('hidden');
          } else {
            console.log('[Detection] Web Speech API not available, using Vosk');
            document.getElementById('recognition-type').textContent = 'Vosk (Offline)';
            this.useVosk = true;
            
            // Show loading and initialize Vosk
            loadingOverlay.classList.remove('hidden');
            
            try {
              await VoskRecognizer.init(
                this.currentLanguage,
                (progress, status) => {
                  progressFill.style.width = progress + '%';
                  loadingStatus.textContent = status;
                },
                (text, confidence) => {
                  this.onVoskResult(text, confidence);
                }
              );
              
              // Hide loading after success
              setTimeout(() => {
                loadingOverlay.classList.add('hidden');
              }, 500);
            } catch (error) {
              console.error('[Detection] Vosk initialization failed:', error);
              loadingStatus.textContent = '‚ùå Error loading speech models';
              loadingStatus.style.color = '#f44336';
              
              // Show error message
              alert('Could not load speech recognition models.\n\nPlease make sure you have downloaded the Vosk models to:\nlanguageVR/assets/vosk-models/\n\nSee VOSK_IMPLEMENTATION_GUIDE.md for instructions.');
            }
          }
        },

        initWebSpeechAPI() {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          
          this.recognition = new SpeechRecognition();
          this.recognition.continuous = false;
          this.recognition.interimResults = false;
          this.recognition.maxAlternatives = 3;
          this.recognition.lang = this.currentLanguage;

          console.log('[Web Speech] Initialized for:', this.currentLanguage);

          this.recognition.onstart = () => {
            this.isListening = true;
            this.updateSpeechStatus('üé§ Listening...', 'active');
            this.updateVRText('vr-instruction-text', 'üé§ SPEAK NOW!');
          };

          this.recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            const confidence = event.results[0][0].confidence;
            console.log('[Web Speech] Heard:', transcript, 'Confidence:', confidence);
            
            this.updateVRText('vr-heard-text', 'You said: "' + transcript + '"');
            this.checkAnswer(transcript, confidence);
          };

          this.recognition.onerror = (event) => {
            console.error('[Web Speech] Error:', event.error);
            
            if (!this.isListening) return;
            
            if (event.error === 'no-speech') {
              this.updateVRText('vr-instruction-text', 'üé§ NO SPEECH HEARD! Speak LOUDER');
            } else if (event.error === 'not-allowed') {
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Microphone blocked!');
            }
            
            this.isListening = false;
            
            // Retry
            if (event.error !== 'not-allowed' && event.error !== 'aborted') {
              setTimeout(() => {
                if (this.currentPhrase) this.startListening();
              }, 2000);
            }
          };

          this.recognition.onend = () => {
            this.isListening = false;
            setTimeout(() => {
              if (this.currentPhrase && !this.isListening) {
                this.startListening();
              }
            }, 1000);
          };

          this.updateSpeechStatus('Web Speech API ready', 'active');
        },

        onVoskResult(text, confidence) {
          console.log('[Vosk Result]:', text);
          this.updateVRText('vr-heard-text', 'You said: "' + text + '"');
          this.checkAnswer(text, confidence);
        },

        onSceneLoaded() {
          console.log('[Language App] Scene loaded');
          this.updateStatus('VR Scene loaded');
          
          // Start experience
          setTimeout(() => {
            this.nextPhrase();
          }, 2000);
        },

        loadVoices() {
          const loadVoicesImpl = () => {
            this.voices = this.synthesis.getVoices();
            if (this.voices.length > 0) {
              this.selectedVoice = this.voices.find(v => v.lang.startsWith('es')) || this.voices[0];
              console.log('[Voices] Selected:', this.selectedVoice.name);
            }
          };
          
          loadVoicesImpl();
          if (this.synthesis.onvoiceschanged !== undefined) {
            this.synthesis.onvoiceschanged = loadVoicesImpl;
          }
          setTimeout(loadVoicesImpl, 500);
        },

        async initMicrophoneVisualizer() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.microphone = this.audioContext.createMediaStreamSource(stream);
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 256;
            this.analyser.smoothingTimeConstant = 0.8;
            
            this.microphone.connect(this.analyser);
            
            setTimeout(() => {
              this.micLevelBar = document.getElementById('mic-level-bar');
              if (this.micLevelBar) {
                this.updateMicLevel();
              }
            }, 1000);
            
            console.log('[Mic Visualizer] ‚úì Initialized');
          } catch (error) {
            console.error('[Mic Visualizer] Error:', error);
          }
        },

        updateMicLevel() {
          if (!this.analyser || !this.micLevelBar) {
            requestAnimationFrame(() => this.updateMicLevel());
            return;
          }

          const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
          this.analyser.getByteFrequencyData(dataArray);
          
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const average = sum / dataArray.length;
          const normalized = average / 255;
          
          const barWidth = normalized * 1.5;
          this.micLevelBar.setAttribute('width', barWidth);
          
          const barX = -0.75 + (barWidth / 2);
          this.micLevelBar.setAttribute('position', barX + ' 0 0.01');
          
          if (normalized > 0.3) {
            this.micLevelBar.setAttribute('color', '#4CAF50');
          } else if (normalized > 0.1) {
            this.micLevelBar.setAttribute('color', '#FFC107');
          } else {
            this.micLevelBar.setAttribute('color', '#666666');
          }
          
          requestAnimationFrame(() => this.updateMicLevel());
        },

        setupUIListeners() {
          // Language buttons
          document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
              document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              
              const oldLang = this.currentLanguage;
              this.currentLanguage = btn.dataset.lang;
              this.currentLanguageName = btn.dataset.name;
              
              // Update recognition system
              if (this.useVosk && oldLang !== this.currentLanguage) {
                const loadingOverlay = document.getElementById('loading-overlay');
                const progressFill = document.getElementById('progress-fill');
                const loadingStatus = document.getElementById('loading-status');
                
                loadingOverlay.classList.remove('hidden');
                
                await VoskRecognizer.switchLanguage(
                  this.currentLanguage,
                  (progress, status) => {
                    progressFill.style.width = progress + '%';
                    loadingStatus.textContent = status;
                  }
                );
                
                loadingOverlay.classList.add('hidden');
              } else if (this.recognition) {
                this.recognition.lang = this.currentLanguage;
              }
              
              // Update voice
              const langPrefix = this.currentLanguage.split('-')[0];
              this.selectedVoice = this.voices.find(v => v.lang.startsWith(langPrefix)) || this.voices[0];
              
              this.updateNPCName();
              this.currentPhraseIndex = 0;
              this.nextPhrase();
            });
          });

          // Scenario buttons
          document.querySelectorAll('.scenario-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              
              this.currentScenario = btn.dataset.scenario;
              this.currentPhraseIndex = 0;
              this.switchEnvironment(this.currentScenario);
              this.nextPhrase();
            });
          });
        },

        setupVRButtons() {
          setTimeout(() => {
            const repeatBtn = document.getElementById('repeat-btn');
            const nextBtn = document.getElementById('next-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            
            if (repeatBtn) {
              repeatBtn.addEventListener('click', () => {
                if (this.currentPhrase && !this.isPaused) {
                  this.npcSpeak(this.currentPhrase.text);
                }
              });
              repeatBtn.addEventListener('mouseenter', () => repeatBtn.setAttribute('color', '#1976D2'));
              repeatBtn.addEventListener('mouseleave', () => repeatBtn.setAttribute('color', '#2196F3'));
            }
            
            if (nextBtn) {
              nextBtn.addEventListener('click', () => {
                if (!this.isPaused) this.nextPhrase();
              });
              nextBtn.addEventListener('mouseenter', () => nextBtn.setAttribute('color', '#45a049'));
              nextBtn.addEventListener('mouseleave', () => nextBtn.setAttribute('color', '#4CAF50'));
            }
            
            if (playPauseBtn) {
              playPauseBtn.addEventListener('click', () => this.togglePause());
              playPauseBtn.addEventListener('mouseenter', () => playPauseBtn.setAttribute('color', '#388E3C'));
              playPauseBtn.addEventListener('mouseleave', () => playPauseBtn.setAttribute('color', '#4CAF50'));
            }
            
            // Language selection in VR
            const langButtons = document.querySelectorAll('.lang-button');
            langButtons.forEach(btn => {
              btn.addEventListener('click', async () => {
                const lang = btn.getAttribute('data-lang');
                const langName = btn.getAttribute('data-name');
                
                langButtons.forEach(b => b.setAttribute('color', '#2196F3'));
                btn.setAttribute('color', '#4CAF50');
                
                const oldLang = this.currentLanguage;
                this.currentLanguage = lang;
                this.currentLanguageName = langName;
                
                if (this.useVosk && oldLang !== lang) {
                  this.updateVRText('vr-instruction-text', '‚è≥ Loading new language model...');
                  await VoskRecognizer.switchLanguage(lang, null);
                } else if (this.recognition) {
                  this.recognition.lang = lang;
                }
                
                const langPrefix = lang.split('-')[0];
                this.selectedVoice = this.voices.find(v => v.lang.startsWith(langPrefix)) || this.voices[0];
                
                this.updateNPCName();
                this.currentPhraseIndex = 0;
                this.nextPhrase();
              });
              
              btn.addEventListener('mouseenter', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#1976D2');
                }
              });
              btn.addEventListener('mouseleave', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#2196F3');
                }
              });
            });
            
            // Scenario selection in VR
            const scenarioButtons = document.querySelectorAll('.scenario-button');
            scenarioButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                const scenario = btn.getAttribute('data-scenario');
                
                scenarioButtons.forEach(b => b.setAttribute('color', '#2196F3'));
                btn.setAttribute('color', '#4CAF50');
                
                this.currentScenario = scenario;
                this.currentPhraseIndex = 0;
                this.switchEnvironment(scenario);
                this.nextPhrase();
              });
              
              btn.addEventListener('mouseenter', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#1976D2');
                }
              });
              btn.addEventListener('mouseleave', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#2196F3');
                }
              });
            });
          }, 2000);
        },

        updateNPCName() {
          const npcNames = {
            'es-ES': 'Mar√≠a - Spanish Tutor',
            'fr-FR': 'Marie - French Tutor',
            'de-DE': 'Maria - German Tutor',
            'nl-NL': 'Maria - Dutch Tutor'
          };
          
          const nameTag = document.getElementById('npc-name');
          if (nameTag) {
            nameTag.setAttribute('value', npcNames[this.currentLanguage]);
          }
        },

        switchEnvironment(scenario) {
          const envClassroom = document.getElementById('env-classroom');
          const envRestaurant = document.getElementById('env-restaurant');
          const envShopping = document.getElementById('env-shopping');
          const envDirections = document.getElementById('env-directions');
          
          if (!envClassroom || !envRestaurant || !envShopping || !envDirections) return;
          
          envClassroom.setAttribute('visible', 'false');
          envRestaurant.setAttribute('visible', 'false');
          envShopping.setAttribute('visible', 'false');
          envDirections.setAttribute('visible', 'false');
          
          if (scenario === 'directions') {
            envDirections.setAttribute('visible', 'true');
          } else if (scenario === 'shopping') {
            envShopping.setAttribute('visible', 'true');
          } else if (scenario === 'restaurant') {
            envRestaurant.setAttribute('visible', 'true');
          } else {
            envClassroom.setAttribute('visible', 'true');
          }
        },

        nextPhrase() {
          if (this.isPaused) return;
          
          const scenarioPhrases = this.phrases[this.currentScenario][this.currentLanguage];
          if (!scenarioPhrases || scenarioPhrases.length === 0) return;

          this.currentPhrase = scenarioPhrases[this.currentPhraseIndex];
          this.currentPhraseIndex = (this.currentPhraseIndex + 1) % scenarioPhrases.length;

          console.log('[App] Next phrase:', this.currentPhrase.text);
          
          this.displayPhrase(this.currentPhrase);
          this.npcSpeak(this.currentPhrase.text);
          
          setTimeout(() => {
            this.startListening();
          }, 3000);
        },

        displayPhrase(phrase) {
          const phraseEl = document.getElementById('current-phrase');
          const phraseText = document.getElementById('phrase-text');
          const translation = document.getElementById('translation');
          
          phraseText.textContent = phrase.text;
          translation.textContent = phrase.translation;
          phraseEl.classList.add('active');
          
          this.updateVRText('vr-phrase-text', phrase.text);
          this.updateVRText('vr-translation-text', phrase.translation);
          this.updateVRText('vr-instruction-text', 'üé§ Listening... Speak now!');
          this.updateVRText('vr-heard-text', '');
        },

        updateVRText(elementId, text) {
          const el = document.getElementById(elementId);
          if (el) {
            el.setAttribute('value', text);
          }
        },

        togglePause() {
          this.isPaused = !this.isPaused;
          const playPauseText = document.getElementById('play-pause-text');
          
          if (this.isPaused) {
            if (this.useVosk) {
              VoskRecognizer.stop();
            } else if (this.recognition && this.isListening) {
              try {
                this.recognition.stop();
              } catch (e) {}
            }
            
            if (this.synthesis.speaking) {
              this.synthesis.cancel();
            }
            
            playPauseText.setAttribute('value', '‚ñ∂Ô∏è PLAY');
            this.updateVRText('vr-instruction-text', '‚è∏Ô∏è PAUSED');
          } else {
            playPauseText.setAttribute('value', '‚è∏Ô∏è PAUSE');
            
            if (this.currentPhrase) {
              this.displayPhrase(this.currentPhrase);
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => this.startListening(), 3000);
            } else {
              this.nextPhrase();
            }
          }
        },

        npcSpeak(text) {
          if (this.isPaused) return;
          
          this.synthesis.cancel();
          this.showSpeechBubble(text);
          this.updateVRText('vr-instruction-text', 'üîä NPC is speaking...');

          setTimeout(() => {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = this.currentLanguage;
            utterance.rate = 0.85;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            if (this.selectedVoice) {
              utterance.voice = this.selectedVoice;
            }
            
            let hasStarted = false;
            
            utterance.onstart = () => {
              hasStarted = true;
              this.updateVRText('vr-instruction-text', 'üîä Listening to NPC...');
            };
            
            utterance.onend = () => {
              if (!hasStarted) {
                console.error('[NPC] Audio blocked by browser');
              }
              setTimeout(() => {
                this.hideSpeechBubble();
              }, 1000);
            };
            
            this.synthesis.speak(utterance);
          }, 100);
        },

        showSpeechBubble(text) {
          const bubble = document.getElementById('speech-bubble');
          const bubbleText = document.getElementById('bubble-text');
          
          if (bubble && bubbleText) {
            bubbleText.setAttribute('value', text);
            bubble.setAttribute('visible', 'true');
          }
        },

        hideSpeechBubble() {
          const bubble = document.getElementById('speech-bubble');
          if (bubble) {
            bubble.setAttribute('visible', 'false');
          }
        },

        startListening() {
          if (this.isPaused) return;
          
          if (this.useVosk) {
            VoskRecognizer.start();
            this.isListening = true;
            this.updateVRText('vr-instruction-text', 'üé§ SPEAK NOW!');
          } else {
            if (!this.recognition) return;
            if (this.isListening) return;

            try {
              this.recognition.start();
            } catch (e) {
              console.warn('[Speech] Could not start:', e);
            }
          }
        },

        checkAnswer(userSaid, confidence) {
          if (!this.currentPhrase) return;

          const expected = this.currentPhrase.text.toLowerCase();
          const spoken = userSaid.toLowerCase();

          console.log('[Check] Expected:', expected);
          console.log('[Check] Spoken:', spoken);

          const similarity = this.calculateSimilarity(spoken, expected);
          console.log('[Check] Similarity:', similarity);

          let feedback, points, className;

          if (similarity > 0.85) {
            feedback = '¬°Excelente! üéâ<br>Perfect!';
            points = 100;
            className = 'success';
            this.awardPoints(points);
            
            this.updateVRText('vr-instruction-text', '‚úÖ Perfect! Next phrase...');
            
            setTimeout(() => {
              if (!this.isPaused) {
                this.nextPhrase();
              }
            }, 2000);
          } else if (similarity > 0.70) {
            feedback = '¬°Bien! üëç<br>Good, try again';
            points = 50;
            className = 'warning';
            this.awardPoints(points);
            
            this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Good! Try the exact phrase...');
            
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', '');
                this.startListening();
              }, 2000);
            }, 2000);
          } else if (similarity > 0.50) {
            feedback = 'Casi... ü§î<br>Almost!';
            points = 25;
            className = 'warning';
            this.awardPoints(points);
            
            this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Close! Listen again...');
            
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', '');
                this.startListening();
              }, 2000);
            }, 2000);
          } else {
            feedback = `‚ùå No coincide<br>Try: "${this.currentPhrase.text}"`;
            points = 0;
            className = 'error';
            
            this.updateVRText('vr-instruction-text', '‚ùå Wrong. Listen carefully...');
            
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', '');
                this.startListening();
              }, 2000);
            }, 2500);
          }

          this.showFeedback(feedback, className);
        },

        calculateSimilarity(str1, str2) {
          str1 = str1.toLowerCase().replace(/[¬ø?¬°!.,]/g, '').trim();
          str2 = str2.toLowerCase().replace(/[¬ø?¬°!.,]/g, '').trim();

          if (str1 === str2) return 1.0;

          const distance = this.levenshteinDistance(str1, str2);
          const maxLength = Math.max(str1.length, str2.length);
          
          if (maxLength === 0) return 1.0;
          
          return 1.0 - (distance / maxLength);
        },

        levenshteinDistance(str1, str2) {
          const matrix = [];

          for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
          }

          for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
          }

          for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
              if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(
                  matrix[i - 1][j - 1] + 1,
                  matrix[i][j - 1] + 1,
                  matrix[i - 1][j] + 1
                );
              }
            }
          }

          return matrix[str2.length][str1.length];
        },

        awardPoints(points) {
          this.score += points;
          document.getElementById('score').textContent = `Score: ${this.score} üåü`;
          this.updateVRText('vr-score-text', `Score: ${this.score} üåü`);
        },

        showFeedback(message, className) {
          const banner = document.getElementById('feedback-banner');
          banner.innerHTML = message;
          banner.className = className;
          banner.classList.add('show');

          setTimeout(() => {
            banner.classList.remove('show');
          }, 2000);
        },

        updateStatus(message) {
          document.getElementById('status').textContent = message;
        },

        updateSpeechStatus(message, className) {
          const el = document.getElementById('speech-status');
          el.textContent = message;
          el.className = 'status ' + (className || '');
        }
      };

      // ========================================
      // A-FRAME COMPONENTS (Same as index.html)
      // ========================================
      
      AFRAME.registerComponent('ui-toggle-controller', {
        init: function() {
          this.uiVisible = true;
          
          this.el.addEventListener('abuttondown', (evt) => {
            this.toggleUI();
          });
        },
        
        toggleUI: function() {
          this.uiVisible = !this.uiVisible;
          
          const vrUIPanel = document.getElementById('vr-ui-panel');
          const vrLanguagePanel = document.getElementById('vr-language-panel');
          const vrScenarioPanel = document.getElementById('vr-scenario-panel');
          
          if (vrUIPanel) vrUIPanel.setAttribute('visible', this.uiVisible);
          if (vrLanguagePanel) vrLanguagePanel.setAttribute('visible', this.uiVisible);
          if (vrScenarioPanel) vrScenarioPanel.setAttribute('visible', this.uiVisible);
        }
      });
      
      AFRAME.registerComponent('vr-locomotion', {
        schema: {
          rotationSpeed: { type: 'number', default: 2.0 }
        },

        init: function() {
          this.npcRotationY = 0;
          this.playerRotationY = 0;
          this.thumbstickRotation = { right: 0 };
          this.npcTutor = null;
          
          setTimeout(() => {
            this.npcTutor = document.querySelector('#npc-tutor');
          }, 100);
          
          this.el.sceneEl.addEventListener('thumbstickmoved', (evt) => {
            if (!evt.target || !evt.target.object3D) return;
            const hand = evt.target;
            this.handleThumbstick(hand, evt.detail);
          });
        },
        
        handleThumbstick: function(hand, detail) {
          const isLeft = hand.id === 'left-hand';
          if (!isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.right = -detail.x;
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
        },

        tick: function(time, deltaTime) {
          const dt = Math.min(deltaTime / 1000, 0.1);
          const rotationInput = this.thumbstickRotation.right;
          
          if (Math.abs(rotationInput) > 0.1) {
            // Rotate the player rig
            this.playerRotationY += rotationInput * this.data.rotationSpeed * dt;
            this.el.object3D.rotation.y = this.playerRotationY;
            
            // Also rotate NPC to match
            this.npcRotationY += rotationInput * this.data.rotationSpeed * dt;
          }
          
          if (this.npcTutor && this.npcTutor.components['mixamo-body']) {
            this.npcTutor.components['mixamo-body'].manualRotationY = this.npcRotationY;
          }
        }
      });

      AFRAME.registerComponent('language-npc', {
        init: function() {
          console.log('[NPC] Initialized');
        }
      });

      // Mixamo VR Body Component (from body-rigged.html)
      AFRAME.registerComponent('mixamo-body', {
        schema: {
          isMirror: { type: 'boolean', default: false },
          color: { type: 'color', default: '#4A90E2' },
          modelPath: { type: 'string', default: 'BoltVR/assets/Y Bot.fbx' }
        },

        init: function() {
          this.camera = document.querySelector('#camera');
          this.leftController = document.querySelector('#left-hand');
          this.rightController = document.querySelector('#right-hand');
          this.rig = document.querySelector('#rig');
          
          this.skeleton = null;
          this.bones = {};
          this.model = null;
          this.modelLoaded = false;
          
          // Mixamo bone names
          this.boneNames = {
            hips: 'mixamorigHips',
            spine: 'mixamorigSpine',
            spine1: 'mixamorigSpine1',
            spine2: 'mixamorigSpine2',
            neck: 'mixamorigNeck',
            head: 'mixamorigHead',
            leftShoulder: 'mixamorigLeftShoulder',
            leftArm: 'mixamorigLeftArm',
            leftForeArm: 'mixamorigLeftForeArm',
            leftHand: 'mixamorigLeftHand',
            rightShoulder: 'mixamorigRightShoulder',
            rightArm: 'mixamorigRightArm',
            rightForeArm: 'mixamorigRightForeArm',
            rightHand: 'mixamorigRightHand'
          };
          
          // IK config (from body.html)
          this.config = {
            shoulderWidth: 0.34,
            shoulderForward: 0.08,
            upperArmLength: 0.31,  // Increased to 31cm (was 0.25, +6cm total)
            lowerArmLength: 0.31   // Increased to 31cm (was 0.25, +6cm total)
          };
          
          // Smoothing
          this.torsoRotation = new THREE.Quaternion();
          this.bodyTilt = new THREE.Quaternion();
          this.smoothingFactor = 0.15;
          this.mirrorDistance = 2.0;
          this.manualRotationY = 0; // Set by vr-locomotion
          
          // Breathing animation
          this.breathingPhase = 0; // Current phase of breathing cycle (0 to 2*PI)
          this.breathingRate = 0.25; // Breaths per second (15 breaths/min)
          this.breathingAmount = 0.015; // Chest expansion amount (1.5cm)
          
          // Body dynamics for natural movement
          this.previousHeadPos = new THREE.Vector3();
          this.previousHeadPosInitialized = false;
          this.headVelocity = new THREE.Vector3();
          this.torsoLean = new THREE.Vector3(); // Current torso lean (smoothed)
          this.torsoLeanVelocity = 0.15; // How fast torso reacts to movement
          
          // Enable local clipping in renderer
          this.el.sceneEl.addEventListener('loaded', () => {
            const renderer = this.el.sceneEl.renderer;
            if (renderer) {
              renderer.localClippingEnabled = true;
            }
          });
          
          // Load model
          const loader = new THREE.FBXLoader();
          loader.load(
            this.data.modelPath,
            (fbx) => this.onModelLoaded(fbx),
            undefined,
            (error) => console.error('[Mixamo Body] Load error:', error)
          );
        },

        onModelLoaded: function(fbx) {
          this.modelLoaded = true;
          this.model = fbx;
          
          // Mixamo models export at 100x scale, need 0.01 to get to meters
          fbx.scale.set(0.01, 0.01, 0.01);
          
          // Mixamo models in T-pose face +Z, rotate 180¬∞ to face -Z (forward)
          fbx.rotation.y = Math.PI;
          
          this.el.object3D.add(fbx);
          
          // Find skeleton and set up materials
          const allMaterials = [];
          fbx.traverse((node) => {
            if (node.isSkinnedMesh && node.skeleton) {
              this.skeleton = node.skeleton;
              this.mapBones();
              this.skinnedMesh = node;
              
              // Clone material so each body has its own
              node.material = node.material.clone();
              allMaterials.push(node.material);
              
              console.log('[Mixamo Body] Found mesh with material:', node.material.type, 'Color:', node.material.color);
            }
            
            // Also check for regular meshes
            if (node.isMesh && !node.isSkinnedMesh) {
              node.material = node.material.clone();
              allMaterials.push(node.material);
              console.log('[Mixamo Body] Found regular mesh with material:', node.material.type);
            }
          });
          
          console.log('[Mixamo Body]', this.data.isMirror ? 'Mirror' : 'Local', '- Found', allMaterials.length, 'materials');
        },

        mapBones: function() {
          // Store initial T-pose rotations for reference
          this.initialBoneRotations = {};
          this.loggedHandTPose = false;
          this.legBones = []; // Store leg bones to hide them
          
          this.skeleton.bones.forEach((bone) => {
            const name = bone.name;
            
            // Store initial rotation for all bones
            this.initialBoneRotations[name] = bone.quaternion.clone();
            
            // Identify and store leg bones to hide them
            const lowerName = name.toLowerCase();
            if (lowerName.includes('leg') || lowerName.includes('upleg') || 
                lowerName.includes('foot') || lowerName.includes('toe')) {
              this.legBones.push(bone);
              // Scale leg bones to zero to hide them
              bone.scale.set(0.001, 0.001, 0.001);
            }
            
            if (name === this.boneNames.hips) {
              this.bones.hips = bone;
            }
            else if (name === this.boneNames.spine) this.bones.spine = bone;
            else if (name === this.boneNames.spine1) this.bones.spine1 = bone;
            else if (name === this.boneNames.spine2) this.bones.spine2 = bone;
            else if (name === this.boneNames.neck) this.bones.neck = bone;
            else if (name === this.boneNames.head) {
              this.bones.head = bone;
              // Scale head bone to hide it for local body only
              if (!this.data.isMirror) {
                bone.scale.set(0.001, 0.001, 0.001);
              }
            }
            else if (name === this.boneNames.leftShoulder) this.bones.leftShoulder = bone;
            else if (name === this.boneNames.leftArm) this.bones.leftUpperArm = bone;
            else if (name === this.boneNames.leftForeArm) this.bones.leftForearm = bone;
            else if (name === this.boneNames.leftHand) {
              this.bones.leftHandBone = bone;
              console.log('[T-Pose] Left Hand initial quat:', bone.quaternion.toArray());
            }
            else if (name === this.boneNames.rightShoulder) this.bones.rightShoulder = bone;
            else if (name === this.boneNames.rightArm) this.bones.rightUpperArm = bone;
            else if (name === this.boneNames.rightForeArm) this.bones.rightForearm = bone;
            else if (name === this.boneNames.rightHand) {
              this.bones.rightHandBone = bone;
              console.log('[T-Pose] Right Hand initial quat:', bone.quaternion.toArray());
            }
          });
        },

        tick: function(time, deltaTime) {
          if (!this.modelLoaded || !this.skeleton) return;
          if (!this.camera || !this.leftController || !this.rightController) return;
          
          const dt = Math.min(deltaTime / 1000, 0.1);
          
          // Update breathing animation phase
          this.breathingPhase += dt * this.breathingRate * Math.PI * 2;
          if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
          }
          
          if (this.data.isMirror) {
            this.updateMirrorBody(dt);
          } else {
            this.updateLocalBody(dt);
          }
        },

        updateLocalBody: function(dt) {
          // Get world positions (from body.html lines 1351-1356)
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();
          
          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);
          
          // Calculate head velocity for dynamic body movement
          if (this.previousHeadPosInitialized) {
            this.headVelocity.copy(headWorldPos).sub(this.previousHeadPos).divideScalar(dt);
          } else {
            this.previousHeadPosInitialized = true;
          }
          this.previousHeadPos.copy(headWorldPos);
          
          // Calculate torso orientation
          this.calculateTorsoOrientation(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, dt);
          this.calculateBodyTilt(headWorldPos, leftHandWorldPos, rightHandWorldPos, dt);
          
          // Position body so HIPS are at correct height
          // Hips should be ~1.0m below head (or headY - 0.65 to keep feet on ground)
          // Model's hips bone is at Y=1.0m in local space
          // So entity Y position should be: (desired hips Y) - (model hips local Y)
          const desiredHipsY = headWorldPos.y - 0.65; // Hips 0.65m below head (lowered by 5cm)
          const modelHipsLocalY = 1.0; // From FBX: 99.79cm ‚âà 1.0m after scaling
          const bodyY = desiredHipsY - modelHipsLocalY; // Entity position
          
          // Apply 15cm backward offset in the body's local space (so it rotates with the body)
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);
          
          this.el.object3D.position.set(
            headWorldPos.x + backwardOffset.x, 
            bodyY, 
            headWorldPos.z + backwardOffset.z
          );
          
          // Apply rotation
          const combinedRotation = new THREE.Quaternion()
            .copy(this.torsoRotation)
            .multiply(this.bodyTilt);
          this.el.object3D.quaternion.copy(combinedRotation);
          
          // Update bones
          this.updateBones(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, leftHandWorldQuat, rightHandWorldQuat);
        },

        updateMirrorBody: function(dt) {
          // Get player positions (from body.html lines 1836-1849)
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();
          
          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);
          
          // Calculate head velocity for dynamic body movement (same as local body)
          if (this.previousHeadPosInitialized) {
            this.headVelocity.copy(headWorldPos).sub(this.previousHeadPos).divideScalar(dt);
          } else {
            this.previousHeadPosInitialized = true;
          }
          this.previousHeadPos.copy(headWorldPos);
          
          // Mirror center point (from body.html line 1852)
          const mirrorCenter = new THREE.Vector3(headWorldPos.x, headWorldPos.y - 0.3, headWorldPos.z - this.mirrorDistance);
          
          // Apply offset (from body.html lines 1855-1858)
          const offset = new THREE.Vector3(0, 0, -this.mirrorDistance);
          let mirrorHeadPos = headWorldPos.clone().add(offset);
          let mirrorLeftHandPos = leftHandWorldPos.clone().add(offset);
          let mirrorRightHandPos = rightHandWorldPos.clone().add(offset);
          
          // Apply manual rotation (from body.html lines 1861-1884)
          if (this.manualRotationY !== 0) {
            const rotationMatrix = new THREE.Matrix4().makeRotationY(this.manualRotationY);
            
            mirrorHeadPos.sub(mirrorCenter);
            mirrorHeadPos.applyMatrix4(rotationMatrix);
            mirrorHeadPos.add(mirrorCenter);
            
            mirrorLeftHandPos.sub(mirrorCenter);
            mirrorLeftHandPos.applyMatrix4(rotationMatrix);
            mirrorLeftHandPos.add(mirrorCenter);
            
            mirrorRightHandPos.sub(mirrorCenter);
            mirrorRightHandPos.applyMatrix4(rotationMatrix);
            mirrorRightHandPos.add(mirrorCenter);
            
            const manualQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.manualRotationY);
            headWorldQuat.premultiply(manualQuat);
            leftHandWorldQuat.premultiply(manualQuat);
            rightHandWorldQuat.premultiply(manualQuat);
          }
          
          // Calculate torso orientation
          this.calculateTorsoOrientation(mirrorHeadPos, headWorldQuat, mirrorLeftHandPos, mirrorRightHandPos, dt);
          this.calculateBodyTilt(mirrorHeadPos, mirrorLeftHandPos, mirrorRightHandPos, dt);
          
          // Position body so hips are at correct height
          const desiredHipsY = mirrorHeadPos.y - 0.65; // Lowered by 5cm (was 0.6)
          const modelHipsLocalY = 1.0;
          const torsoY = desiredHipsY - modelHipsLocalY;
          
          // Apply 15cm backward offset in the body's local space (so it rotates with the body)
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);
          
          this.el.object3D.position.set(
            mirrorHeadPos.x + backwardOffset.x, 
            torsoY, 
            mirrorHeadPos.z + backwardOffset.z
          );
          
          // Apply rotation
          const combinedRotation = new THREE.Quaternion()
            .copy(this.torsoRotation)
            .multiply(this.bodyTilt);
          this.el.object3D.quaternion.copy(combinedRotation);
          
          // Update bones
          this.updateBones(mirrorHeadPos, headWorldQuat, mirrorLeftHandPos, mirrorRightHandPos, leftHandWorldQuat, rightHandWorldQuat);
        },

        calculateTorsoOrientation: function(headPos, headQuat, leftHandPos, rightHandPos, dt) {
          // Simplified from body.html lines 1407-1486
          const headForwardFlat = new THREE.Vector3(0, 0, -1).applyQuaternion(headQuat);
          headForwardFlat.y = 0;
          headForwardFlat.normalize();
          
          const shoulderLine = rightHandPos.clone().sub(leftHandPos);
          shoulderLine.y = 0;
          const shoulderDist = shoulderLine.length();
          shoulderLine.normalize();
          
          const controllerForward = new THREE.Vector3().crossVectors(shoulderLine, new THREE.Vector3(0, 1, 0));
          controllerForward.normalize();
          
          if (controllerForward.dot(headForwardFlat) < 0) {
            controllerForward.negate();
          }
          
          // Weight adjustment based on hand distance
          let controllerWeight = 0.8;
          if (shoulderDist < 0.25) {
            controllerWeight = 0.3;
          } else if (shoulderDist > 0.35) {
            controllerWeight = 1.0;
          }
          
          const blendedForward = new THREE.Vector3()
            .addScaledVector(controllerForward, controllerWeight)
            .addScaledVector(headForwardFlat, 1.0 - controllerWeight)
            .normalize();
          
          const targetRotation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            blendedForward
          );
          
          this.torsoRotation.slerp(targetRotation, this.smoothingFactor);
        },

        calculateBodyTilt: function(headPos, leftHandPos, rightHandPos, dt) {
          // Disabled body tilt at entity level to prevent body movement
          // Spine bending is now handled entirely through individual spine bones
          this.bodyTilt.identity();
        },

        updateBones: function(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat) {
          // Reset bones to T-pose
          if (this.bones.hips) this.bones.hips.quaternion.identity();
          if (this.bones.spine) this.bones.spine.quaternion.identity();
          if (this.bones.spine1) this.bones.spine1.quaternion.identity();
          if (this.bones.spine2) this.bones.spine2.quaternion.identity();
          
          // SPINE BENDING: Combine hand-based lean with dynamic movement lean
          const bodyCenter = headPos.clone();
          bodyCenter.y -= 0.5;
          
          const leftRelative = leftHandPos.clone().sub(bodyCenter);
          const rightRelative = rightHandPos.clone().sub(bodyCenter);
          const avgHandPos = new THREE.Vector3()
            .addVectors(leftRelative, rightRelative)
            .multiplyScalar(0.5);
          
          // Convert to body-local space
          const invTorsoRot = this.torsoRotation.clone().invert();
          avgHandPos.applyQuaternion(invTorsoRot);
          
          // Hand-based lean (subtle, only at extreme reaches)
          const handForwardLean = Math.max(-0.08, Math.min(0.05, -avgHandPos.z * 0.08));
          const handSideLean = Math.max(-0.08, Math.min(0.08, avgHandPos.x * 0.1));
          
          // DYNAMIC MOVEMENT LEAN: Convert head velocity to body-local space
          const localVelocity = this.headVelocity.clone();
          localVelocity.applyQuaternion(invTorsoRot);
          
          // Calculate target lean based on velocity (opposite direction of movement)
          // When moving forward, lean back slightly; when moving sideways, lean opposite
          // Moderate sensitivity for natural movement
          const targetLean = new THREE.Vector3(
            localVelocity.z * 0.8,   // Forward/backward movement -> X rotation
            0,
            -localVelocity.x * 0.5   // Sideways movement -> Z rotation (reduced for less extreme lean)
          );
          
          // Smooth the torso lean toward target
          this.torsoLean.lerp(targetLean, this.torsoLeanVelocity);
          
          // Combine all lean sources
          const totalForwardLean = handForwardLean + this.torsoLean.x;
          const totalSideLean = handSideLean + this.torsoLean.z;
          
          // Calculate breathing animation (chest expansion)
          const breathingExpansion = Math.sin(this.breathingPhase) * this.breathingAmount;
          
          // Distribute rotation across spine segments
          if (this.bones.spine || this.bones.spine1 || this.bones.spine2) {
            // Each segment gets a portion of the total lean
            const spineRotations = [
              { bone: this.bones.spine, amount: 0.25, breathingAmount: 0.3 },
              { bone: this.bones.spine1, amount: 0.35, breathingAmount: 0.4 },
              { bone: this.bones.spine2, amount: 0.4, breathingAmount: 0.3 }
            ];
            
            spineRotations.forEach(({ bone, amount, breathingAmount }) => {
              if (bone) {
                // Add breathing to forward lean (negative X is backward arch)
                const breathingLean = -breathingExpansion * breathingAmount;
                
                const euler = new THREE.Euler(
                  -totalForwardLean * amount + breathingLean, // X-axis (flip for model rotation) + breathing
                  0,
                  -totalSideLean * amount,    // Z-axis (flip for model rotation)
                  'YXZ'
                );
                bone.quaternion.setFromEuler(euler);
              }
            });
          }
          
          // Head rotation (relative to body)
          // Model is rotated 180¬∞ at fbx level, which affects bone rotations
          if (this.bones.neck) {
            // Get relative head rotation (head relative to torso)
            const relativeHeadQuat = headQuat.clone();
            const invBodyQuat = this.torsoRotation.clone().invert();
            relativeHeadQuat.premultiply(invBodyQuat);
            
            // Model is rotated 180¬∞ around Y, which inverts X and Z rotations
            // Extract euler, flip X and Z, then rebuild quaternion
            const euler = new THREE.Euler().setFromQuaternion(relativeHeadQuat, 'YXZ');
            euler.x = -euler.x; // Flip pitch (nod)
            euler.z = -euler.z; // Flip roll (tilt)
            // Y (yaw/turn) stays the same
            
            const correctedQuat = new THREE.Quaternion().setFromEuler(euler);
            this.bones.neck.quaternion.copy(correctedQuat);
          }
          
          // Arms (with forearm twist)
          this.solveArmIK('left', leftHandPos, leftHandQuat);
          this.solveArmIK('right', rightHandPos, rightHandQuat);
        },

        solveArmIK: function(hand, handWorldPos, handWorldQuat) {
          const shoulderBone = this.bones[`${hand}Shoulder`];
          const upperArmBone = this.bones[`${hand}UpperArm`];
          const forearmBone = this.bones[`${hand}Forearm`];
          const handBone = this.bones[`${hand}HandBone`];
          
          if (!shoulderBone || !upperArmBone || !forearmBone) {
            return;
          }
          
          // Get actual shoulder bone world position (not calculated, but from the skeleton)
          const shoulderWorldPos = new THREE.Vector3();
          shoulderBone.getWorldPosition(shoulderWorldPos);
          
          // Adjust hand position to account for hand bone offset in the skeleton
          // The VR controllers are positioned differently than the hand bones
          const adjustedHandPos = handWorldPos.clone();
          
          // Add the left/right offset correction IN BODY LOCAL SPACE
          // This ensures the offset is correct even when the body is rotated (mirror body)
          const leftRightOffsetLocal = new THREE.Vector3(hand === 'left' ? 0.1 : -0.1, 0, 0);
          const leftRightOffsetWorld = leftRightOffsetLocal.applyQuaternion(this.el.object3D.quaternion);
          adjustedHandPos.add(leftRightOffsetWorld);
          
          // Two-bone IK (from body.html lines 1608-1627)
          const shoulderToHand = adjustedHandPos.clone().sub(shoulderWorldPos);
          const distance = shoulderToHand.length();
          const maxReach = (this.config.upperArmLength + this.config.lowerArmLength) * 0.999;
          const minReach = Math.abs(this.config.upperArmLength - this.config.lowerArmLength) * 1.001;
          
          let targetHandPos = adjustedHandPos.clone();
          if (distance > maxReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(maxReach));
          } else if (distance < minReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(minReach));
          }
          
          // Law of cosines (from body.html lines 1629-1641)
          const toTarget = targetHandPos.clone().sub(shoulderWorldPos);
          const targetDist = toTarget.length();
          const toTargetDir = toTarget.normalize();
          
          const upperSq = this.config.upperArmLength * this.config.upperArmLength;
          const lowerSq = this.config.lowerArmLength * this.config.lowerArmLength;
          const distSq = targetDist * targetDist;
          
          const cosAngle = (upperSq + distSq - lowerSq) / (2 * this.config.upperArmLength * targetDist);
          const clampedCos = Math.max(-0.999, Math.min(0.999, cosAngle));
          const angle = Math.acos(clampedCos);
          
          // Elbow bend direction - Enhanced with hand orientation influence
          const bodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          const bodyRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.torsoRotation);
          const bodyOutward = bodyRight.clone().multiplyScalar(hand === 'left' ? -1 : 1);
          
          // Base bend direction: outward and down
          let bendDir = new THREE.Vector3()
            .addScaledVector(bodyOutward, 0.4)
            .addScaledVector(new THREE.Vector3(0, -1, 0), 0.4)
            .normalize();
          
          // IMPROVED ELBOW ORIENTATION: Adjust bend direction based on hand rotation
          // Extract the "palm down" vector from hand orientation
          const handUp = new THREE.Vector3(0, 1, 0).applyQuaternion(handWorldQuat);
          const handForward = new THREE.Vector3(0, 0, -1).applyQuaternion(handWorldQuat);
          
          // Blend hand's up vector into bend direction (palms facing inward = elbows out)
          // This makes the elbow naturally follow wrist rotation
          bendDir.addScaledVector(handUp, 0.3);
          bendDir.normalize();
          
          // Make bend perpendicular to shoulder-hand direction
          bendDir.addScaledVector(toTargetDir, -bendDir.dot(toTargetDir)).normalize();
          
          // Calculate elbow (from body.html lines 1667-1673)
          const elbowDir = new THREE.Vector3()
            .addScaledVector(toTargetDir, Math.cos(angle))
            .addScaledVector(bendDir, Math.sin(angle))
            .normalize();
          
          let elbowWorldPos = shoulderWorldPos.clone().add(elbowDir.multiplyScalar(this.config.upperArmLength));
          
          // Enforce exact lengths (from body.html lines 1676-1697)
          const shoulderToElbow = elbowWorldPos.clone().sub(shoulderWorldPos);
          if (Math.abs(shoulderToElbow.length() - this.config.upperArmLength) > 0.0001) {
            elbowWorldPos.copy(shoulderWorldPos).add(shoulderToElbow.normalize().multiplyScalar(this.config.upperArmLength));
          }
          
          const elbowToHand = targetHandPos.clone().sub(elbowWorldPos);
          if (Math.abs(elbowToHand.length() - this.config.lowerArmLength) > 0.0001) {
            targetHandPos.copy(elbowWorldPos).add(elbowToHand.normalize().multiplyScalar(this.config.lowerArmLength));
          }
          
          // Convert to bone rotations (local space)
          // The key insight: bones are hierarchical, we need to set rotations relative to PARENT bone
          this.el.object3D.updateMatrixWorld(true);
          
          // Upper Arm: rotate from shoulder to elbow
          upperArmBone.parent.updateMatrixWorld(true);
          
          // Get the direction in world space
          const upperArmWorldDir = elbowWorldPos.clone().sub(shoulderWorldPos).normalize();
          
          // Convert shoulder and elbow to parent bone's local space
          const shoulderInParent = upperArmBone.parent.worldToLocal(shoulderWorldPos.clone());
          const elbowInParent = upperArmBone.parent.worldToLocal(elbowWorldPos.clone());
          
          // Direction in parent's local space
          // Bone direction should point FROM parent (shoulder) TO child (elbow)
          // But we're getting inverted results, so flip the subtraction
          const upperArmParentDir = shoulderInParent.clone().sub(elbowInParent).normalize();
          
          // T-pose direction: Mixamo bones often use Y-down for limbs in T-pose
          // Try negative Y (pointing down)
          const tPoseDir = new THREE.Vector3(0, -1, 0);
          
          // Calculate rotation from T-pose to target direction
          const upperArmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, upperArmParentDir);
          
          upperArmBone.quaternion.copy(upperArmQuat);
          upperArmBone.updateMatrixWorld(true);
          
          // Forearm: rotate from elbow to hand
          forearmBone.parent.updateMatrixWorld(true);
          
          // Convert to parent (upperArm) local space
          const elbowInUpperArm = forearmBone.parent.worldToLocal(elbowWorldPos.clone());
          const handInUpperArm = forearmBone.parent.worldToLocal(targetHandPos.clone());
          
          // Direction in parent's local space (flipped like upper arm)
          const forearmParentDir = elbowInUpperArm.clone().sub(handInUpperArm).normalize();
          
          // Forearm also uses same T-pose direction
          const forearmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, forearmParentDir);
          
          // FOREARM TWIST: Add pronation/supination based on wrist rotation
          // Extract the twist component from hand rotation
          forearmBone.updateMatrixWorld(true);
          
          // Get hand rotation relative to forearm's natural alignment
          const forearmWorldQuat = new THREE.Quaternion();
          forearmBone.getWorldQuaternion(forearmWorldQuat);
          
          // Hand rotation relative to forearm
          const handRelativeForearm = handWorldQuat.clone();
          handRelativeForearm.premultiply(forearmWorldQuat.clone().invert());
          
          // Extract twist angle around forearm axis (Y-axis in local space)
          // This represents pronation (palm down) vs supination (palm up)
          const handEuler = new THREE.Euler().setFromQuaternion(handRelativeForearm, 'YXZ');
          const twistAngle = handEuler.y; // Y-axis rotation = twist
          
          // Apply 50% of the twist to the forearm (rest stays in hand)
          // This creates natural forearm rotation
          const forearmTwist = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0), // Local Y-axis (along forearm)
            twistAngle * 0.5 // 50% of hand twist
          );
          
          // Combine direction rotation with twist
          forearmBone.quaternion.copy(forearmQuat).multiply(forearmTwist);
          
          forearmBone.updateMatrixWorld(true);
          
          // Hand orientation
          if (handBone) {
            forearmBone.updateMatrixWorld(true);
            
            // Just use the controller's world quaternion directly, like we do for arms
            // Convert from world space to forearm's local space
            const forearmWorldQuat = new THREE.Quaternion();
            forearmBone.getWorldQuaternion(forearmWorldQuat);
            
            let handLocalQuat = handWorldQuat.clone();
            handLocalQuat.premultiply(forearmWorldQuat.clone().invert());
            
            // Apply 180¬∞ correction around X axis in LOCAL bone space to flip the hand direction
            // This accounts for the model's 180¬∞ rotation
            const localXFlip = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI);
            handLocalQuat.multiply(localXFlip);
            
            // Add 90¬∞ roll correction (left clockwise = +90¬∞, right counterclockwise = -90¬∞)
            // Roll is around Y axis in local bone space (forearm direction)
            const rollCorrection = new THREE.Quaternion().setFromAxisAngle(
              new THREE.Vector3(0, 1, 0),
              hand === 'left' ? Math.PI / 2 : -Math.PI / 2
            );
            handLocalQuat.multiply(rollCorrection);
            
            handBone.quaternion.copy(handLocalQuat);
          }
        }
      });

      // Initialize app
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => LanguageApp.init());
      } else {
        LanguageApp.init();
      }
    </script>
  </body>
</html>

