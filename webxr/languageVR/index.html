<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Language Practice VR</title>
    <meta name="description" content="Learn languages in VR with interactive NPCs">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.173.0/examples/js/loaders/FBXLoader.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
      
      /* Desktop UI */
      #ui {
        position: fixed; top: 10px; left: 10px;
        background: rgba(0, 0, 0, 0.9); color: white;
        padding: 20px; border-radius: 10px;
        font-family: 'Segoe UI', sans-serif;
        z-index: 1000; max-width: 400px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }
      #ui h2 { margin: 0 0 15px 0; color: #4CAF50; font-size: 24px; }
      #ui h3 { margin: 15px 0 10px 0; color: #81C784; font-size: 18px; }
      
      .status { font-size: 12px; color: #888; margin: 5px 0; }
      .status.active { color: #4CAF50; }
      .status.error { color: #f44336; }
      
      .language-selector {
        display: flex; gap: 10px; margin: 15px 0;
      }
      
      .lang-btn {
        padding: 10px 15px; background: #2196F3; border: none;
        color: white; border-radius: 5px; cursor: pointer;
        font-size: 14px; transition: all 0.3s;
      }
      .lang-btn:hover { background: #1976D2; transform: scale(1.05); }
      .lang-btn.active { background: #4CAF50; }
      
      .scenario-list {
        display: flex; flex-direction: column; gap: 8px; margin: 10px 0;
      }
      
      .scenario-btn {
        padding: 12px; background: #424242; border: none;
        color: white; border-radius: 5px; cursor: pointer;
        text-align: left; transition: all 0.3s;
        border-left: 4px solid #2196F3;
      }
      .scenario-btn:hover { background: #616161; transform: translateX(5px); }
      .scenario-btn.active { background: #1976D2; border-left-color: #4CAF50; }
      
      #score {
        font-size: 20px; color: #FFD700; font-weight: bold;
        margin: 10px 0; padding: 10px; background: rgba(255, 215, 0, 0.1);
        border-radius: 5px; text-align: center;
      }
      
      .info { 
        font-size: 11px; color: #999; margin-top: 15px; 
        padding-top: 15px; border-top: 1px solid #333;
        line-height: 1.6;
      }
      
      #feedback-banner {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: rgba(76, 175, 80, 0.95);
        color: white; padding: 30px 50px;
        border-radius: 15px; font-size: 32px;
        font-weight: bold; z-index: 2000;
        transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        text-align: center;
      }
      
      #feedback-banner.show { transform: translate(-50%, -50%) scale(1); }
      #feedback-banner.success { background: rgba(76, 175, 80, 0.95); }
      #feedback-banner.warning { background: rgba(255, 152, 0, 0.95); }
      #feedback-banner.error { background: rgba(244, 67, 54, 0.95); }
      
      #current-phrase {
        position: fixed; top: 20px; left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85); color: white;
        padding: 20px 40px; border-radius: 10px;
        font-size: 24px; z-index: 1500;
        text-align: center; max-width: 600px;
        display: none;
      }
      
      #current-phrase.active { display: block; }
      
      #translation {
        font-size: 16px; color: #81C784;
        margin-top: 10px; font-style: italic;
      }
      
      .mic-indicator {
        display: inline-block;
        width: 12px; height: 12px;
        background: #f44336;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(1.2); }
      }

      #start-screen {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: none; /* CHANGED: Hidden by default so VR works immediately */
        align-items: center;
        justify-content: center;
        z-index: 3000;
        color: white;
      }

      #start-screen.show { display: flex; }
      #start-screen.hidden { display: none; }

      .start-content {
        text-align: center;
        max-width: 600px;
        padding: 40px;
      }

      .start-content h1 {
        font-size: 48px;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }

      .start-content p {
        font-size: 18px;
        margin-bottom: 30px;
        line-height: 1.6;
      }

      #enter-vr-btn {
        padding: 20px 50px;
        font-size: 24px;
        background: #4CAF50;
        border: none;
        color: white;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      }

      #enter-vr-btn:hover {
        background: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div id="start-screen">
      <div class="start-content">
        <h1>üó£Ô∏è Language Practice VR</h1>
        <p>Step into virtual reality and practice real conversations with AI tutors. Improve your speaking skills in Spanish, French, German, or Dutch!</p>
        <button id="enter-vr-btn">Enter VR Experience</button>
        <div style="margin-top: 30px; font-size: 14px; opacity: 0.8;">
          <p>‚úì Speech recognition powered<br>
          ‚úì Interactive scenarios<br>
          ‚úì Real-time feedback</p>
        </div>
      </div>
    </div>

    <!-- Desktop UI -->
    <div id="ui">
      <h2>üéì Language VR</h2>
      
      <div class="status" id="status">Ready to start</div>
      <div class="status" id="speech-status">Speech: Initializing...</div>
      
      <h3>Choose Language:</h3>
      <div class="language-selector">
        <button class="lang-btn active" data-lang="es-ES" data-name="Spanish">üá™üá∏ Spanish</button>
        <button class="lang-btn" data-lang="fr-FR" data-name="French">üá´üá∑ French</button>
        <button class="lang-btn" data-lang="de-DE" data-name="German">üá©üá™ German</button>
        <button class="lang-btn" data-lang="nl-NL" data-name="Dutch">üá≥üá± Dutch</button>
      </div>
      
      <h3>Scenarios:</h3>
      <div class="scenario-list">
        <button class="scenario-btn active" data-scenario="greetings">
          üëã Greetings & Introductions
        </button>
        <button class="scenario-btn" data-scenario="restaurant">
          üçΩÔ∏è Restaurant Conversation
        </button>
        <button class="scenario-btn" data-scenario="shopping">
          üõçÔ∏è Shopping & Prices
        </button>
        <button class="scenario-btn" data-scenario="directions">
          üó∫Ô∏è Asking for Directions
        </button>
      </div>
      
      <div id="score">Score: 0 üåü</div>
      
      <div class="info">
        <strong>How to use:</strong><br>
        1. Put on your VR headset<br>
        2. Listen to the NPC speak<br>
        3. Repeat the phrase clearly<br>
        4. Get instant feedback!<br><br>
        <strong>Controls:</strong> Right thumbstick = rotate NPC
      </div>
    </div>

    <!-- Current Phrase Display -->
    <div id="current-phrase">
      <div id="phrase-text">Hola, ¬øc√≥mo est√°s?</div>
      <div id="translation">Hello, how are you?</div>
    </div>

    <!-- Feedback Banner -->
    <div id="feedback-banner"></div>

    <!-- VR Scene -->
    <a-scene background="color: #87CEEB" renderer="antialias: true; colorManagement: true">
      <!-- Lighting -->
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="2 4 2"></a-entity>
      <a-entity light="type: point; intensity: 0.5; color: #FFA500" position="0 2 -2"></a-entity>

      <!-- VR Camera Rig -->
      <a-entity id="rig" position="0 1.6 0" vr-locomotion>
        <a-entity id="camera" camera look-controls wasd-controls="acceleration: 20">
          <!-- Raycaster for clicking buttons -->
          <a-entity cursor="fuse: false; rayOrigin: mouse"
                    raycaster="objects: .clickable; far: 10"></a-entity>
        </a-entity>
        <a-entity id="left-hand" 
                  hand-controls="hand: left; handModelStyle: lowPoly"
                  laser-controls="hand: left"
                  raycaster="objects: .clickable; lineColor: red; lineOpacity: 0.5"
                  ui-toggle-controller></a-entity>
        <a-entity id="right-hand" 
                  hand-controls="hand: right; handModelStyle: lowPoly"
                  laser-controls="hand: right"
                  raycaster="objects: .clickable; lineColor: red; lineOpacity: 0.5"
                  ui-toggle-controller></a-entity>
      </a-entity>

      <!-- Player Body (local - head hidden) -->
      <a-entity id="local-body" mixamo-body="isMirror: false"></a-entity>

      <!-- NPC Tutor Body -->
      <a-entity id="npc-tutor" 
                mixamo-body="isMirror: true; color: #FF6B6B" 
                position="0 0 -2.5"
                language-npc>
        <!-- NPC Name Tag -->
        <a-text value="Mar√≠a - Spanish Tutor" 
                position="0 2.2 0" 
                align="center" 
                color="#333" 
                width="4"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                id="npc-name"></a-text>
        
        <!-- Speech Bubble -->
        <a-entity id="speech-bubble" position="0 2 0.3" visible="false">
          <a-plane width="1.5" height="0.5" color="#FFFFFF" opacity="0.95"></a-plane>
          <a-text value="¬°Hola!" 
                  position="0 0 0.01" 
                  align="center" 
                  color="#333" 
                  width="1.3"
                  shader="msdf"
                  font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                  id="bubble-text"></a-text>
        </a-entity>
      </a-entity>

      <!-- LEFT: Language Selection Panel in VR -->
      <a-entity id="vr-language-panel" position="-2.5 2 -2" rotation="0 30 0">
        <!-- Background -->
        <a-plane width="1.2" height="1.8" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <!-- Title -->
        <a-text value="LANGUAGE" 
                position="0 0.8 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <!-- Language Buttons -->
        <a-box id="vr-lang-spanish" 
               width="1" height="0.2" depth="0.05" 
               color="#4CAF50"
               position="0 0.4 0"
               class="clickable lang-button"
               data-lang="es-ES"
               data-name="Spanish"></a-box>
        <a-text value="üá™üá∏ Spanish" 
                position="0 0.4 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-french" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 0.1 0"
               class="clickable lang-button"
               data-lang="fr-FR"
               data-name="French"></a-box>
        <a-text value="üá´üá∑ French" 
                position="0 0.1 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-german" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.2 0"
               class="clickable lang-button"
               data-lang="de-DE"
               data-name="German"></a-box>
        <a-text value="üá©üá™ German" 
                position="0 -0.2 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-lang-dutch" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.5 0"
               class="clickable lang-button"
               data-lang="nl-NL"
               data-name="Dutch"></a-box>
        <a-text value="üá≥üá± Dutch" 
                position="0 -0.5 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
      </a-entity>
      
      <!-- RIGHT: Scenario Selection Panel in VR -->
      <a-entity id="vr-scenario-panel" position="2.5 2 -2" rotation="0 -30 0">
        <!-- Background -->
        <a-plane width="1.2" height="1.8" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <!-- Title -->
        <a-text value="SCENARIOS" 
                position="0 0.8 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <!-- Scenario Buttons -->
        <a-box id="vr-scenario-greetings" 
               width="1" height="0.2" depth="0.05" 
               color="#4CAF50"
               position="0 0.4 0"
               class="clickable scenario-button"
               data-scenario="greetings"></a-box>
        <a-text value="üëã Greetings" 
                position="0 0.4 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-restaurant" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 0.1 0"
               class="clickable scenario-button"
               data-scenario="restaurant"></a-box>
        <a-text value="üçΩÔ∏è Restaurant" 
                position="0 0.1 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-shopping" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.2 0"
               class="clickable scenario-button"
               data-scenario="shopping"></a-box>
        <a-text value="üõçÔ∏è Shopping" 
                position="0 -0.2 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
        
        <a-box id="vr-scenario-directions" 
               width="1" height="0.2" depth="0.05" 
               color="#2196F3"
               position="0 -0.5 0"
               class="clickable scenario-button"
               data-scenario="directions"></a-box>
        <a-text value="üó∫Ô∏è Directions" 
                position="0 -0.5 0.03" 
                align="center" 
                color="#FFFFFF" 
                width="0.9"
                scale="0.6 0.6 0.6"></a-text>
      </a-entity>

      <!-- CENTER: VR UI Panel (visible in VR) -->
      <a-entity id="vr-ui-panel" position="0 2.5 -1.5">
        <!-- Background panel -->
        <a-plane width="2" height="1.2" color="#1a1a1a" opacity="0.9"></a-plane>
        
        <!-- Current phrase display -->
        <a-text id="vr-phrase-text" 
                value="¬°Hola!" 
                position="0 0.45 0.01" 
                align="center" 
                color="#4CAF50" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="30"></a-text>
        
        <!-- Translation -->
        <a-text id="vr-translation-text" 
                value="Hello!" 
                position="0 0.3 0.01" 
                align="center" 
                color="#81C784" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="30"></a-text>
        
        <!-- Instruction text -->
        <a-text id="vr-instruction-text" 
                value="üé§ Listening... Speak now!" 
                position="0 0.1 0.01" 
                align="center" 
                color="#FFD700" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="40"></a-text>
        
        <!-- What you said -->
        <a-text id="vr-heard-text" 
                value="" 
                position="0 -0.05 0.01" 
                align="center" 
                color="#FFFFFF" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                wrap-count="40"></a-text>
        
        <!-- Score display -->
        <a-text id="vr-score-text" 
                value="Score: 0" 
                position="0 -0.25 0.01" 
                align="center" 
                color="#FFD700" 
                width="1.8"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <!-- Microphone visualizer -->
        <a-entity id="mic-visualizer" position="0 -0.45 0.01">
          <!-- Background bar -->
          <a-plane width="1.5" height="0.08" color="#333333"></a-plane>
          <!-- Active level bar -->
          <a-plane id="mic-level-bar" 
                   width="0" 
                   height="0.08" 
                   color="#4CAF50" 
                   position="-0.75 0 0.01"></a-plane>
          <a-text value="Mic Level" 
                  position="0 -0.08 0.01" 
                  align="center" 
                  color="#888888" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
        </a-entity>
        
        <!-- Control Buttons -->
        <a-entity id="vr-buttons" position="0 -0.7 0.01">
          <!-- Repeat button -->
          <a-box id="repeat-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#2196F3"
                 position="-0.6 0 0"
                 class="clickable"></a-box>
          <a-text value="üîä REPEAT" 
                  position="-0.6 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
          
          <!-- Next button -->
          <a-box id="next-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#4CAF50"
                 position="-0.1 0 0"
                 class="clickable"></a-box>
          <a-text value="‚û°Ô∏è NEXT" 
                  position="-0.1 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
          
          <!-- Play/Pause button -->
          <a-box id="play-pause-btn" 
                 width="0.5" height="0.15" depth="0.05" 
                 color="#4CAF50"
                 position="0.4 0 0"
                 class="clickable"></a-box>
          <a-text id="play-pause-text"
                  value="‚è∏Ô∏è PAUSE" 
                  position="0.4 0 0.03" 
                  align="center" 
                  color="#FFFFFF" 
                  width="1"
                  scale="0.5 0.5 0.5"></a-text>
        </a-entity>
      </a-entity>

      <!-- Environment -->
      <!-- Default Environment (Classroom) - for greetings -->
      <a-entity id="env-classroom" visible="true">
        <!-- Floor -->
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="20" 
                 height="20" 
                 color="#7BC8A4"
                 shadow="receive: true"></a-plane>
        
        <!-- Classroom Setting -->
        <!-- Walls -->
        <a-box position="0 2 -8" width="20" height="4" depth="0.2" color="#F0E68C"></a-box>
        <a-box position="-10 2 0" width="0.2" height="4" depth="16" color="#F0E68C"></a-box>
        <a-box position="10 2 0" width="0.2" height="4" depth="16" color="#F0E68C"></a-box>
        
        <!-- Whiteboard -->
        <a-box position="0 2.5 -7.8" width="4" height="2" depth="0.1" color="#FFFFFF"></a-box>
        <a-text value="Language Practice" 
                position="0 3.3 -7.7" 
                align="center" 
                color="#2196F3" 
                width="3"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
        
        <!-- Desk -->
        <a-box position="0 0.4 -2" width="1.5" height="0.8" depth="1" color="#8B4513"></a-box>
        
        <!-- Decorative elements -->
        <a-sphere position="-3 1.5 -5" radius="0.3" color="#FF6B6B"></a-sphere>
        <a-sphere position="3 1.5 -5" radius="0.3" color="#4ECDC4"></a-sphere>
        <a-cylinder position="-4 0.5 -6" radius="0.2" height="1" color="#2ECC71"></a-cylinder>
        <a-cylinder position="4 0.5 -6" radius="0.2" height="1" color="#E74C3C"></a-cylinder>
        
        <!-- Instructions on floor -->
        <a-text value="Stand here and speak clearly!" 
                position="0 0.01 0.5" 
                rotation="-90 0 0" 
                align="center" 
                color="#333" 
                width="6"
                shader="msdf"
                font="https://cdn.aframe.io/fonts/Roboto-msdf.json"></a-text>
      </a-entity>
      
      <!-- Restaurant Environment (Bagan Temple) -->
      <a-entity id="env-restaurant" visible="false">
        <!-- Bagan Temple Interior GLB - rotated 180 degrees, scaled 2x, moved 4m forward, 1m up -->
        <a-entity id="temple-model" 
                  gltf-model="url(assets/bagan_-_khayiminga_temple_interior.glb)" 
                  position="0 1 -4" 
                  rotation="0 180 0"
                  scale="2 2 2"
                  shadow="cast: true; receive: true"></a-entity>
        
        <!-- Simple floor backup -->
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#8B7355"
                 opacity="0.8"
                 shadow="receive: true"></a-plane>
      </a-entity>
      
      <!-- Shopping Environment (Library of Celsus) -->
      <a-entity id="env-shopping" visible="false">
        <!-- Library of Celsus GLB - moved 30m forward, 12m up, scaled 2x -->
        <a-entity id="library-model" 
                  gltf-model="url(assets/library_of_celsus_-_crowdsourced_photogrammetry.glb)" 
                  position="0 12 -30" 
                  scale="2 2 2"
                  shadow="cast: true; receive: true"></a-entity>
        
        <!-- Simple floor backup -->
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#D2B48C"
                 opacity="0.8"
                 shadow="receive: true"></a-plane>
      </a-entity>
      
      <!-- Directions Environment (Mansion Garden) -->
      <a-entity id="env-directions" visible="false">
        <!-- Mansion Garden GLB - lowered by 50m, scaled 4x, moved 5m right and 5m forward -->
        <a-entity id="mansion-garden-model" 
                  gltf-model="url(assets/mansion_garden_scene.glb)" 
                  position="5 -50 -5" 
                  scale="4 4 4"
                  shadow="cast: true; receive: true"
                  mansion-garden-inspector></a-entity>
        
        <!-- Simple floor backup in case GLB doesn't have one -->
        <a-plane position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="50" 
                 color="#6B8E23"
                 opacity="0.8"
                 shadow="receive: true"></a-plane>
      </a-entity>
    </a-scene>

    <script>
      // ========================================
      // LANGUAGE APP CORE
      // ========================================
      
      const LanguageApp = {
        currentLanguage: 'es-ES',
        currentLanguageName: 'Spanish',
        currentScenario: 'greetings',
        currentPhrase: null,
        currentPhraseIndex: 0,
        score: 0,
        recognition: null,
        synthesis: window.speechSynthesis,
        isListening: false,
        isPaused: false,
        audioContext: null,
        microphone: null,
        analyser: null,
        micLevelBar: null,
        voices: [],
        selectedVoice: null,
        
        // Phrase database
        phrases: {
          'greetings': {
            'es-ES': [
              { text: '¬°Hola!', translation: 'Hello!', difficulty: 1 },
              { text: '¬øC√≥mo est√°s?', translation: 'How are you?', difficulty: 1 },
              { text: 'Me llamo Mar√≠a', translation: 'My name is Mar√≠a', difficulty: 1 },
              { text: 'Mucho gusto', translation: 'Nice to meet you', difficulty: 1 },
              { text: 'Buenos d√≠as', translation: 'Good morning', difficulty: 1 },
              { text: '¬øC√≥mo te llamas?', translation: 'What is your name?', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'Bonjour!', translation: 'Hello!', difficulty: 1 },
              { text: 'Comment allez-vous?', translation: 'How are you?', difficulty: 1 },
              { text: 'Je m\'appelle Marie', translation: 'My name is Marie', difficulty: 1 },
              { text: 'Enchant√©', translation: 'Nice to meet you', difficulty: 1 }
            ],
            'de-DE': [
              { text: 'Hallo!', translation: 'Hello!', difficulty: 1 },
              { text: 'Wie geht es dir?', translation: 'How are you?', difficulty: 1 },
              { text: 'Ich hei√üe Maria', translation: 'My name is Maria', difficulty: 1 },
              { text: 'Freut mich', translation: 'Nice to meet you', difficulty: 1 }
            ],
            'nl-NL': [
              { text: 'Hallo!', translation: 'Hello!', difficulty: 1 },
              { text: 'Hoe gaat het?', translation: 'How are you?', difficulty: 1 },
              { text: 'Ik heet Maria', translation: 'My name is Maria', difficulty: 1 },
              { text: 'Aangenaam', translation: 'Nice to meet you', difficulty: 1 },
              { text: 'Goedemorgen', translation: 'Good morning', difficulty: 1 },
              { text: 'Hoe heet je?', translation: 'What is your name?', difficulty: 2 }
            ]
          },
          'restaurant': {
            'es-ES': [
              { text: '¬øQu√© desea ordenar?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'La cuenta, por favor', translation: 'The bill, please', difficulty: 2 },
              { text: 'Una mesa para dos', translation: 'A table for two', difficulty: 2 },
              { text: '¬øTiene men√∫ del d√≠a?', translation: 'Do you have a daily menu?', difficulty: 3 }
            ],
            'fr-FR': [
              { text: 'Qu\'est-ce que vous d√©sirez?', translation: 'What would you like?', difficulty: 2 },
              { text: 'L\'addition, s\'il vous pla√Æt', translation: 'The bill, please', difficulty: 2 },
              { text: 'Une table pour deux', translation: 'A table for two', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Was m√∂chten Sie bestellen?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'Die Rechnung, bitte', translation: 'The bill, please', difficulty: 2 },
              { text: 'Ein Tisch f√ºr zwei', translation: 'A table for two', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Wat wilt u bestellen?', translation: 'What would you like to order?', difficulty: 2 },
              { text: 'De rekening, alstublieft', translation: 'The bill, please', difficulty: 2 },
              { text: 'Een tafel voor twee', translation: 'A table for two', difficulty: 2 },
              { text: 'Heeft u een dagmenu?', translation: 'Do you have a daily menu?', difficulty: 3 }
            ]
          },
          'shopping': {
            'es-ES': [
              { text: '¬øCu√°nto cuesta?', translation: 'How much does it cost?', difficulty: 2 },
              { text: '¬øTiene esto en otro color?', translation: 'Do you have this in another color?', difficulty: 3 },
              { text: 'Me gustar√≠a comprar esto', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'Combien √ßa co√ªte?', translation: 'How much does it cost?', difficulty: 2 },
              { text: 'Je voudrais acheter ceci', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Was kostet das?', translation: 'How much does it cost?', difficulty: 2 },
              { text: 'Ich m√∂chte das kaufen', translation: 'I would like to buy this', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Hoeveel kost dit?', translation: 'How much does this cost?', difficulty: 2 },
              { text: 'Heeft u dit in een andere kleur?', translation: 'Do you have this in another color?', difficulty: 3 },
              { text: 'Ik wil dit graag kopen', translation: 'I would like to buy this', difficulty: 2 }
            ]
          },
          'directions': {
            'es-ES': [
              { text: '¬øD√≥nde est√° la estaci√≥n?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Gire a la derecha', translation: 'Turn right', difficulty: 2 },
              { text: 'Siga recto', translation: 'Go straight', difficulty: 2 }
            ],
            'fr-FR': [
              { text: 'O√π est la gare?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Tournez √† droite', translation: 'Turn right', difficulty: 2 }
            ],
            'de-DE': [
              { text: 'Wo ist der Bahnhof?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Biegen Sie rechts ab', translation: 'Turn right', difficulty: 2 }
            ],
            'nl-NL': [
              { text: 'Waar is het station?', translation: 'Where is the station?', difficulty: 2 },
              { text: 'Ga naar rechts', translation: 'Turn right', difficulty: 2 },
              { text: 'Ga rechtdoor', translation: 'Go straight', difficulty: 2 }
            ]
          }
        },

        init() {
          console.log('[Language App] Initializing...');
          console.log('[Language App] Testing console output...');
          
          // Wait for scene to load
          const scene = document.querySelector('a-scene');
          if (scene.hasLoaded) {
            this.onSceneLoaded();
          } else {
            scene.addEventListener('loaded', () => this.onSceneLoaded());
          }
          
          // Load voices first
          this.loadVoices();
          
          // Initialize Speech Recognition
          this.initSpeechRecognition();
          
          // Initialize microphone visualizer (won't conflict if done right)
          this.initMicrophoneVisualizer();
          
          // Setup UI event listeners
          this.setupUIListeners();
          
          // Setup VR button listeners
          this.setupVRButtons();
          
          // Auto-start without blocking screen
          this.setupStartScreen();
          
          console.log('[Language App] Initialization complete');
        },

        setupStartScreen() {
          // Auto-start without blocking screen
          console.log('[Language App] Auto-starting (no start screen)');
          this.startExperience();
        },

        startExperience() {
          console.log('[Language App] Starting experience');
          this.updateStatus('Ready! Listen to the NPC and repeat');
          
          // Start with first phrase after a moment
          setTimeout(() => {
            console.log('[Language App] Starting first phrase...');
            this.nextPhrase();
          }, 3000);
        },

        onSceneLoaded() {
          console.log('[Language App] Scene loaded');
          this.updateStatus('VR Scene loaded');
          
          // Test audio on scene load
          this.testAudio();
        },
        
        testAudio() {
          console.log('[Audio] Testing audio output...');
          console.log('[Audio] Speech synthesis available:', 'speechSynthesis' in window);
          console.log('[Audio] Voices loaded:', this.voices.length);
          
          if (this.voices.length > 0) {
            console.log('[Audio] Available voices:', this.voices.map(v => v.name).join(', '));
          }
        },
        
        loadVoices() {
          // Load available voices
          const loadVoicesImpl = () => {
            this.voices = this.synthesis.getVoices();
            console.log('[Voices] Loaded', this.voices.length, 'voices');
            
            if (this.voices.length > 0) {
              // Try to find a Spanish voice
              this.selectedVoice = this.voices.find(v => v.lang.startsWith('es')) || this.voices[0];
              console.log('[Voices] Selected voice:', this.selectedVoice.name, this.selectedVoice.lang);
            } else {
              console.warn('[Voices] No voices loaded yet, will retry...');
            }
          };
          
          // Voices might load asynchronously
          loadVoicesImpl();
          
          if (this.synthesis.onvoiceschanged !== undefined) {
            this.synthesis.onvoiceschanged = loadVoicesImpl;
          }
          
          // Also try after a delay
          setTimeout(loadVoicesImpl, 500);
          setTimeout(loadVoicesImpl, 1500);
        },

        initSpeechRecognition() {
          // Check for browser support
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          
          if (!SpeechRecognition) {
            this.updateSpeechStatus('Speech recognition not supported in this browser', 'error');
            console.error('[Speech] Web Speech API not supported');
            return;
          }

          this.recognition = new SpeechRecognition();
          this.recognition.continuous = false;
          this.recognition.interimResults = false;
          this.recognition.maxAlternatives = 3;
          this.recognition.lang = this.currentLanguage;

          console.log('[Speech] Recognition initialized for language:', this.currentLanguage);

          this.recognition.onstart = () => {
            this.isListening = true;
            this.updateSpeechStatus('üé§ Listening...', 'active');
            this.updateVRText('vr-instruction-text', 'üé§ SPEAK NOW! Say: "' + (this.currentPhrase?.text || '...') + '"');
            console.log('[Speech] Started listening for language:', this.recognition.lang);
          };

          this.recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            const confidence = event.results[0][0].confidence;
            console.log('[Speech] Heard:', transcript, 'Confidence:', confidence);
            
            // Show what was heard in VR UI
            this.updateVRText('vr-heard-text', 'You said: "' + transcript + '"');
            
            this.checkAnswer(transcript, confidence);
          };

          this.recognition.onerror = (event) => {
            console.error('[Speech] Error:', event.error);
            
            // Don't process errors if we're not supposed to be listening
            if (!this.isListening) {
              console.log('[Speech] Ignoring error - not actively listening');
              return;
            }
            
            if (event.error === 'aborted') {
              console.log('[Speech] Recognition aborted (likely stopped intentionally)');
              return; // Don't retry on abort
            }
            
            if (event.error === 'no-speech') {
              console.log('[Speech] No speech detected - MIC IS WORKING but heard nothing');
              console.log('[Speech] Recognition language:', this.recognition.lang);
              console.log('[Speech] Expected phrase:', this.currentPhrase?.text);
              console.log('[Speech] TIP: Speak VERY LOUD and CLEAR in', this.currentLanguageName);
              this.updateVRText('vr-instruction-text', 'üé§ NO SPEECH HEARD! Speak LOUDER in ' + this.currentLanguageName);
              this.updateVRText('vr-heard-text', '‚ö†Ô∏è Microphone working but too quiet or wrong language');
            } else if (event.error === 'not-allowed') {
              this.updateSpeechStatus('Microphone permission denied', 'error');
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Microphone blocked! Allow access.');
            } else if (event.error === 'audio-capture') {
              console.error('[Speech] Audio capture failed - microphone not available');
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Microphone not found!');
              this.updateVRText('vr-heard-text', 'Check microphone connection');
            } else if (event.error === 'network') {
              console.error('[Speech] Network error - speech recognition needs internet');
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è No internet connection');
            } else {
              this.updateSpeechStatus(`Error: ${event.error}`, 'error');
              this.updateVRText('vr-instruction-text', `‚ö†Ô∏è Error: ${event.error}`);
            }
            
            this.isListening = false;
            
            // Retry listening after error (except permission/hardware errors)
            if (event.error !== 'not-allowed' && event.error !== 'audio-capture' && event.error !== 'aborted') {
              setTimeout(() => {
                if (this.currentPhrase) {
                  console.log('[Speech] Retrying...');
                  this.startListening();
                }
              }, 2000);
            }
          };

          this.recognition.onend = () => {
            this.isListening = false;
            this.updateSpeechStatus('Ready to listen', '');
            console.log('[Speech] Stopped listening');
            
            // Auto-restart listening if we have a current phrase
            setTimeout(() => {
              if (this.currentPhrase && !this.isListening) {
                this.startListening();
              }
            }, 1000);
          };

          this.updateSpeechStatus('Speech recognition ready!', 'active');
        },

        async initMicrophoneVisualizer() {
          try {
            console.log('[Mic Visualizer] Initializing...');
            
            // Request microphone access (same stream speech recognition uses)
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log('[Mic Visualizer] Microphone access granted');
            
            // Create audio context
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.microphone = this.audioContext.createMediaStreamSource(stream);
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 256;
            this.analyser.smoothingTimeConstant = 0.8;
            
            // IMPORTANT: Connect to analyser but NOT to destination
            // This allows us to analyze without creating audio feedback
            this.microphone.connect(this.analyser);
            // DO NOT: this.analyser.connect(this.audioContext.destination);
            
            // Get reference to VR mic level bar
            setTimeout(() => {
              this.micLevelBar = document.getElementById('mic-level-bar');
              if (this.micLevelBar) {
                console.log('[Mic Visualizer] Found mic level bar element');
                this.updateMicLevel(); // Start updating
              } else {
                console.error('[Mic Visualizer] Could not find mic-level-bar element');
              }
            }, 1000);
            
            console.log('[Mic Visualizer] ‚úì Initialized successfully');
          } catch (error) {
            console.error('[Mic Visualizer] Could not access microphone:', error);
            this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Microphone access denied');
          }
        },

        updateMicLevel() {
          if (!this.analyser || !this.micLevelBar) {
            // Keep trying until elements are ready
            requestAnimationFrame(() => this.updateMicLevel());
            return;
          }

          const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
          this.analyser.getByteFrequencyData(dataArray);
          
          // Calculate average volume
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const average = sum / dataArray.length;
          const normalized = average / 255; // 0 to 1
          
          // Update bar width (0 to 1.5 width)
          const barWidth = normalized * 1.5;
          this.micLevelBar.setAttribute('width', barWidth);
          
          // Also update position so it grows from left
          const barX = -0.75 + (barWidth / 2);
          this.micLevelBar.setAttribute('position', barX + ' 0 0.01');
          
          // Change color based on level
          if (normalized > 0.3) {
            this.micLevelBar.setAttribute('color', '#4CAF50'); // Green - good level
          } else if (normalized > 0.1) {
            this.micLevelBar.setAttribute('color', '#FFC107'); // Yellow - speak louder
          } else {
            this.micLevelBar.setAttribute('color', '#666666'); // Gray - too quiet
          }
          
          // Continue updating
          requestAnimationFrame(() => this.updateMicLevel());
        },

        setupUIListeners() {
          // Language buttons
          document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              
              this.currentLanguage = btn.dataset.lang;
              this.currentLanguageName = btn.dataset.name;
              
              if (this.recognition) {
                this.recognition.lang = this.currentLanguage;
              }
              
              // Update selected voice
              const langPrefix = this.currentLanguage.split('-')[0];
              this.selectedVoice = this.voices.find(v => v.lang.startsWith(langPrefix)) || this.voices[0];
              console.log('[UI] Changed to:', this.currentLanguageName, 'Voice:', this.selectedVoice?.name);
              
              // Update NPC name
              this.updateNPCName();
              
              // Reset to first phrase of current scenario
              this.currentPhraseIndex = 0;
              this.nextPhrase();
            });
          });

          // Scenario buttons
          document.querySelectorAll('.scenario-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              
              this.currentScenario = btn.dataset.scenario;
              this.currentPhraseIndex = 0;
              
              // Switch environment
              this.switchEnvironment(this.currentScenario);
              
              this.nextPhrase();
            });
          });
        },

        updateNPCName() {
          const npcNames = {
            'es-ES': 'Mar√≠a - Spanish Tutor',
            'fr-FR': 'Marie - French Tutor',
            'de-DE': 'Maria - German Tutor',
            'nl-NL': 'Maria - Dutch Tutor'
          };
          
          const nameTag = document.getElementById('npc-name');
          if (nameTag) {
            nameTag.setAttribute('value', npcNames[this.currentLanguage]);
          }
        },
        
        switchEnvironment(scenario) {
          console.log('[Environment] Switching to scenario:', scenario);
          
          // Get all environments
          const envClassroom = document.getElementById('env-classroom');
          const envRestaurant = document.getElementById('env-restaurant');
          const envShopping = document.getElementById('env-shopping');
          const envDirections = document.getElementById('env-directions');
          
          if (!envClassroom || !envRestaurant || !envShopping || !envDirections) {
            console.warn('[Environment] Environment entities not found yet');
            return;
          }
          
          // Hide all environments first
          envClassroom.setAttribute('visible', 'false');
          envRestaurant.setAttribute('visible', 'false');
          envShopping.setAttribute('visible', 'false');
          envDirections.setAttribute('visible', 'false');
          
          // Show appropriate environment based on scenario
          if (scenario === 'directions') {
            envDirections.setAttribute('visible', 'true');
            console.log('[Environment] ‚úì Switched to Mansion Garden');
          } else if (scenario === 'shopping') {
            envShopping.setAttribute('visible', 'true');
            console.log('[Environment] ‚úì Switched to Library of Celsus');
          } else if (scenario === 'restaurant') {
            envRestaurant.setAttribute('visible', 'true');
            console.log('[Environment] ‚úì Switched to Bagan Temple');
          } else {
            // Default classroom for greetings
            envClassroom.setAttribute('visible', 'true');
            console.log('[Environment] ‚úì Switched to Classroom');
          }
        },

        nextPhrase() {
          const scenarioPhrases = this.phrases[this.currentScenario][this.currentLanguage];
          
          if (!scenarioPhrases || scenarioPhrases.length === 0) {
            this.updateStatus('No phrases available for this combination');
            return;
          }

          // Get next phrase (cycle through)
          this.currentPhrase = scenarioPhrases[this.currentPhraseIndex];
          this.currentPhraseIndex = (this.currentPhraseIndex + 1) % scenarioPhrases.length;

          console.log('[App] Next phrase:', this.currentPhrase.text);
          
          // Update UI
          this.displayPhrase(this.currentPhrase);
          
          // NPC speaks the phrase
          this.npcSpeak(this.currentPhrase.text);
          
          // Wait a moment, then start listening
          setTimeout(() => {
            this.startListening();
          }, 3000);
        },

        displayPhrase(phrase) {
          const phraseEl = document.getElementById('current-phrase');
          const phraseText = document.getElementById('phrase-text');
          const translation = document.getElementById('translation');
          
          // Desktop UI
          phraseText.textContent = phrase.text;
          translation.textContent = phrase.translation;
          phraseEl.classList.add('active');
          
          // VR UI
          this.updateVRText('vr-phrase-text', phrase.text);
          this.updateVRText('vr-translation-text', phrase.translation);
          this.updateVRText('vr-instruction-text', 'üé§ Listening... Speak now!');
          this.updateVRText('vr-heard-text', ''); // Clear previous
        },

        updateVRText(elementId, text) {
          const el = document.getElementById(elementId);
          if (el) {
            el.setAttribute('value', text);
          }
        },
        
        setupVRButtons() {
          console.log('[VR Buttons] Setting up clickable buttons...');
          
          // Wait for scene to load
          setTimeout(() => {
            const repeatBtn = document.getElementById('repeat-btn');
            const nextBtn = document.getElementById('next-btn');
            const testEnglishBtn = document.getElementById('test-english-btn');
            
            if (repeatBtn) {
              repeatBtn.addEventListener('click', () => {
                console.log('[VR] Repeat button clicked!');
                if (this.currentPhrase && !this.isPaused) {
                  this.npcSpeak(this.currentPhrase.text);
                } else if (this.isPaused) {
                  console.log('[VR] Cannot repeat while paused');
                  this.updateVRText('vr-instruction-text', '‚è∏Ô∏è App is paused - click PLAY first');
                }
              });
              
              // Also listen for mouseenter from controllers
              repeatBtn.addEventListener('mouseenter', () => {
                repeatBtn.setAttribute('color', '#1976D2');
              });
              repeatBtn.addEventListener('mouseleave', () => {
                repeatBtn.setAttribute('color', '#2196F3');
              });
              
              console.log('[VR] Repeat button listener added');
            }
            
            if (nextBtn) {
              nextBtn.addEventListener('click', () => {
                console.log('[VR] Next button clicked!');
                if (!this.isPaused) {
                  this.nextPhrase();
                } else {
                  console.log('[VR] Cannot advance while paused');
                  this.updateVRText('vr-instruction-text', '‚è∏Ô∏è App is paused - click PLAY first');
                }
              });
              
              nextBtn.addEventListener('mouseenter', () => {
                nextBtn.setAttribute('color', '#45a049');
              });
              nextBtn.addEventListener('mouseleave', () => {
                nextBtn.setAttribute('color', '#4CAF50');
              });
              
              console.log('[VR] Next button listener added');
            }
            
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playPauseText = document.getElementById('play-pause-text');
            
            if (playPauseBtn && playPauseText) {
              playPauseBtn.addEventListener('click', () => {
                console.log('[VR] Play/Pause button clicked!');
                this.togglePause();
              });
              
              playPauseBtn.addEventListener('mouseenter', () => {
                if (this.isPaused) {
                  playPauseBtn.setAttribute('color', '#66BB6A');
                } else {
                  playPauseBtn.setAttribute('color', '#388E3C');
                }
              });
              playPauseBtn.addEventListener('mouseleave', () => {
                if (this.isPaused) {
                  playPauseBtn.setAttribute('color', '#4CAF50');
                } else {
                  playPauseBtn.setAttribute('color', '#4CAF50');
                }
              });
              
              console.log('[VR] Play/Pause button listener added');
            }
            
            // Language selection buttons
            const langButtons = document.querySelectorAll('.lang-button');
            langButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                const lang = btn.getAttribute('data-lang');
                const langName = btn.getAttribute('data-name');
                console.log('[VR] Language button clicked:', langName);
                
                // Update all buttons to inactive color
                langButtons.forEach(b => b.setAttribute('color', '#2196F3'));
                // Set this button to active color
                btn.setAttribute('color', '#4CAF50');
                
                // Update language
                this.currentLanguage = lang;
                this.currentLanguageName = langName;
                
                // Update speech recognition language
                if (this.recognition) {
                  this.recognition.lang = lang;
                }
                
                // Update selected voice
                const langPrefix = lang.split('-')[0];
                this.selectedVoice = this.voices.find(v => v.lang.startsWith(langPrefix)) || this.voices[0];
                console.log('[VR] Changed to:', langName, 'Voice:', this.selectedVoice?.name);
                
                // Update NPC name
                this.updateNPCName();
                
                // Reset to first phrase of current scenario
                this.currentPhraseIndex = 0;
                this.nextPhrase();
              });
              
              // Hover effects
              btn.addEventListener('mouseenter', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#1976D2');
                }
              });
              btn.addEventListener('mouseleave', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#2196F3');
                }
              });
            });
            
            // Scenario selection buttons
            const scenarioButtons = document.querySelectorAll('.scenario-button');
            scenarioButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                const scenario = btn.getAttribute('data-scenario');
                console.log('[VR] Scenario button clicked:', scenario);
                
                // Update all buttons to inactive color
                scenarioButtons.forEach(b => b.setAttribute('color', '#2196F3'));
                // Set this button to active color
                btn.setAttribute('color', '#4CAF50');
                
                // Update scenario
                this.currentScenario = scenario;
                this.currentPhraseIndex = 0;
                
                // Switch environment
                this.switchEnvironment(scenario);
                
                this.nextPhrase();
              });
              
              // Hover effects
              btn.addEventListener('mouseenter', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#1976D2');
                }
              });
              btn.addEventListener('mouseleave', () => {
                if (btn.getAttribute('color') !== '#4CAF50') {
                  btn.setAttribute('color', '#2196F3');
                }
              });
            });
            
            console.log('[VR] All VR buttons initialized!');
          }, 2000);
        },
        
        togglePause() {
          this.isPaused = !this.isPaused;
          console.log('[App] Pause state:', this.isPaused ? 'PAUSED' : 'PLAYING');
          
          const playPauseBtn = document.getElementById('play-pause-btn');
          const playPauseText = document.getElementById('play-pause-text');
          
          if (this.isPaused) {
            // PAUSED - Stop everything
            console.log('[App] Pausing app...');
            
            // Stop listening
            if (this.recognition && this.isListening) {
              try {
                this.recognition.stop();
              } catch (e) {
                console.log('[App] Recognition already stopped');
              }
            }
            
            // Stop speaking
            if (this.synthesis.speaking) {
              this.synthesis.cancel();
            }
            
            // Update UI
            playPauseText.setAttribute('value', '‚ñ∂Ô∏è PLAY');
            playPauseBtn.setAttribute('color', '#FFC107'); // Amber when paused
            this.updateVRText('vr-instruction-text', '‚è∏Ô∏è PAUSED - Click Play to continue');
            this.updateVRText('vr-heard-text', 'App is paused');
            
          } else {
            // PLAYING - Resume
            console.log('[App] Resuming app...');
            
            // Update UI
            playPauseText.setAttribute('value', '‚è∏Ô∏è PAUSE');
            playPauseBtn.setAttribute('color', '#4CAF50'); // Green when playing
            
            // Resume with current phrase
            if (this.currentPhrase) {
              this.displayPhrase(this.currentPhrase);
              this.npcSpeak(this.currentPhrase.text);
              
              // Start listening after NPC speaks
              setTimeout(() => {
                this.startListening();
              }, 3000);
            } else {
              // No current phrase, start fresh
              this.nextPhrase();
            }
          }
        },
        
        testMicrophoneEnglish() {
          console.log('[Mic Test] Starting microphone test in ENGLISH...');
          
          // CRITICAL: Stop and disable main recognition completely
          this.isListening = false;
          if (this.recognition) {
            try {
              this.recognition.stop();
              console.log('[Mic Test] Stopped main recognition');
            } catch (e) {
              console.log('[Mic Test] Main recognition already stopped');
            }
          }
          
          // Update UI
          this.updateVRText('vr-phrase-text', 'MICROPHONE TEST');
          this.updateVRText('vr-translation-text', 'Say "Hello" or "Test" in English');
          this.updateVRText('vr-instruction-text', 'üé§ SAY "HELLO" NOW (in English)');
          this.updateVRText('vr-heard-text', 'Listening for ANY English words...');
          
          // Wait for main recognition to fully stop, then start test
          setTimeout(() => {
            console.log('[Mic Test] Starting English recognition...');
            
            // Create temporary English recognition
            const tempRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            tempRecognition.continuous = false;
            tempRecognition.interimResults = false;
            tempRecognition.lang = 'en-US'; // ENGLISH!
            
            let retryCount = 0;
            const maxRetries = 3;
            
            tempRecognition.onresult = (event) => {
              const transcript = event.results[0][0].transcript;
              const confidence = event.results[0][0].confidence;
              
              console.log('[Mic Test] ‚úÖ‚úÖ‚úÖ MICROPHONE WORKS! ‚úÖ‚úÖ‚úÖ');
              console.log('[Mic Test] Heard in English:', transcript);
              console.log('[Mic Test] Confidence:', confidence);
              
              this.updateVRText('vr-instruction-text', '‚úÖ MICROPHONE WORKING!');
              this.updateVRText('vr-heard-text', 'You said: "' + transcript + '"');
              
              // Show success message
              this.showFeedback('‚úÖ Microphone Works!<br>Heard: "' + transcript + '"', 'success');
              
              // Return to normal phrase after 3 seconds
              setTimeout(() => {
                this.nextPhrase();
              }, 3000);
            };
            
            tempRecognition.onerror = (event) => {
              console.error('[Mic Test] Error:', event.error);
              
              if (event.error === 'aborted') {
                console.log('[Mic Test] Recognition was aborted (conflict)');
                return; // Don't retry on abort
              }
              
              if (event.error === 'no-speech') {
                retryCount++;
                console.log('[Mic Test] No speech detected (attempt ' + retryCount + '/' + maxRetries + ')');
                
                if (retryCount < maxRetries) {
                  this.updateVRText('vr-instruction-text', 'üé§ Try ' + (retryCount + 1) + '/' + maxRetries + ': Say "HELLO" LOUDER!');
                  
                  // Retry
                  setTimeout(() => {
                    console.log('[Mic Test] Retrying...');
                    try {
                      tempRecognition.start();
                    } catch (e) {
                      console.error('[Mic Test] Could not restart:', e);
                    }
                  }, 1500);
                } else {
                  console.log('[Mic Test] ‚ùå Failed after ' + maxRetries + ' attempts');
                  console.log('[Mic Test] Windows microphone input level is likely TOO LOW');
                  
                  this.updateVRText('vr-instruction-text', '‚ùå NO SPEECH DETECTED');
                  this.updateVRText('vr-heard-text', 'Fix: Windows Settings > Sound > Input Volume to 80%');
                  
                  // Go back to normal after showing error
                  setTimeout(() => {
                    this.nextPhrase();
                  }, 5000);
                }
              } else {
                this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Mic error: ' + event.error);
              }
            };
            
            tempRecognition.onend = () => {
              console.log('[Mic Test] Recognition ended');
            };
            
            // Start listening in English
            try {
              tempRecognition.start();
              console.log('[Mic Test] ‚úì English recognition started');
            } catch (e) {
              console.error('[Mic Test] Failed to start:', e);
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Could not start test: ' + e.message);
            }
          }, 500); // Wait 500ms for main recognition to fully stop
        },

        npcSpeak(text) {
          // Don't speak if paused
          if (this.isPaused) {
            console.log('[NPC] Skipping speak (app is paused)');
            return;
          }
          
          console.log('[NPC] Attempting to speak:', text);
          
          // CRITICAL FIX: Cancel and wait before speaking
          this.synthesis.cancel();
          
          // Show speech bubble
          this.showSpeechBubble(text);
          
          // Update VR UI
          this.updateVRText('vr-instruction-text', 'üîä NPC is speaking...');

          // Wait for cancel to complete, then speak
          setTimeout(() => {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = this.currentLanguage;
            utterance.rate = 0.85;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            // Use selected voice if available
            if (this.selectedVoice) {
              utterance.voice = this.selectedVoice;
              console.log('[NPC] Using voice:', this.selectedVoice.name);
            }
            
            let hasStarted = false;
            let speakingCheckInterval = null;
            
            utterance.onstart = () => {
              hasStarted = true;
              console.log('[NPC] ‚úÖ AUDIO PLAYING:', text);
              this.updateVRText('vr-instruction-text', 'üîä Listening to NPC...');
            };
            
            utterance.onend = () => {
              console.log('[NPC] ‚úì Speaking ended, hasStarted:', hasStarted);
              
              if (speakingCheckInterval) {
                clearInterval(speakingCheckInterval);
              }
              
              if (!hasStarted) {
                console.error('[NPC] ‚ùå Audio never started playing!');
                console.log('[NPC] This is likely a browser autoplay policy issue');
                console.log('[NPC] Try: 1) Click anywhere on page, 2) Unmute browser, 3) Check volume');
                this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Audio blocked. Check browser volume/mute');
              } else {
                // Audio played successfully, start listening
                setTimeout(() => {
                  this.updateVRText('vr-instruction-text', 'üé§ Your turn! Repeat the phrase...');
                }, 500);
              }
              
              // Hide speech bubble
              setTimeout(() => {
                this.hideSpeechBubble();
              }, 1000);
            };
            
            utterance.onerror = (e) => {
              console.error('[NPC] ‚ùå Speech error:', e.error, e);
              this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Audio error: ' + e.error);
              
              if (speakingCheckInterval) {
                clearInterval(speakingCheckInterval);
              }
            };

            // Speak
            console.log('[NPC] Calling synthesis.speak() NOW...');
            console.log('[NPC] Queue before speak:', this.synthesis.pending, this.synthesis.speaking);
            
            this.synthesis.speak(utterance);
            
            console.log('[NPC] Queue after speak:', this.synthesis.pending, this.synthesis.speaking);
            
            // Workaround for Chrome bug: Check if actually speaking
            let checkCount = 0;
            speakingCheckInterval = setInterval(() => {
              checkCount++;
              console.log(`[NPC] Check ${checkCount}: speaking=${this.synthesis.speaking}, pending=${this.synthesis.pending}`);
              
              if (this.synthesis.speaking) {
                hasStarted = true;
                console.log('[NPC] ‚úÖ Confirmed audio is playing!');
                clearInterval(speakingCheckInterval);
              } else if (checkCount >= 10) {
                // After 1 second, give up
                console.error('[NPC] ‚ùå Audio never started after 1 second');
                clearInterval(speakingCheckInterval);
                
                // Try to trigger it again
                console.log('[NPC] Attempting to resume synthesis...');
                this.synthesis.resume();
              }
            }, 100);
          }, 100); // Wait 100ms after cancel
        },

        showSpeechBubble(text) {
          const bubble = document.getElementById('speech-bubble');
          const bubbleText = document.getElementById('bubble-text');
          
          if (bubble && bubbleText) {
            bubbleText.setAttribute('value', text);
            bubble.setAttribute('visible', 'true');
          }
        },

        hideSpeechBubble() {
          const bubble = document.getElementById('speech-bubble');
          if (bubble) {
            bubble.setAttribute('visible', 'false');
          }
        },

        startListening() {
          // Don't listen if paused
          if (this.isPaused) {
            console.log('[Speech] Skipping listen (app is paused)');
            return;
          }
          
          if (!this.recognition) {
            console.error('[Speech] Recognition not initialized');
            return;
          }

          if (this.isListening) {
            console.log('[Speech] Already listening, skipping');
            return;
          }

          try {
            this.recognition.start();
          } catch (e) {
            console.warn('[Speech] Could not start recognition:', e);
          }
        },

        checkAnswer(userSaid, confidence) {
          if (!this.currentPhrase) return;

          const expected = this.currentPhrase.text.toLowerCase();
          const spoken = userSaid.toLowerCase();

          console.log('[Check] Expected:', expected);
          console.log('[Check] Spoken:', spoken);
          console.log('[Check] Confidence:', confidence);

          const similarity = this.calculateSimilarity(spoken, expected);
          console.log('[Check] Similarity:', similarity);

          let feedback, points, className;

          // FIXED: Require GOOD similarity (not just confidence)
          // Confidence just means API is sure what it heard, not that it's correct
          if (similarity > 0.85) {
            // Excellent! Very close match
            feedback = '¬°Excelente! üéâ<br>Perfect!';
            points = 100;
            className = 'success';
            this.awardPoints(points);
            
            // Update VR UI
            this.updateVRText('vr-instruction-text', '‚úÖ Perfect! Next phrase coming...');
            
            // Move to next phrase after success (if not paused)
            setTimeout(() => {
              if (!this.isPaused) {
                this.nextPhrase();
              }
            }, 2000);
          } else if (similarity > 0.70) {
            // Good attempt - give partial credit
            feedback = '¬°Bien! üëç<br>Good, but try to match exactly';
            points = 50;
            className = 'warning';
            this.awardPoints(points);
            
            // Update VR UI
            this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Good! But try to say the complete phrase...');
            
            // Let them try again
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', ''); // Clear previous
                this.startListening();
              }, 2000);
            }, 2000);
          } else if (similarity > 0.50) {
            // Close but not quite
            feedback = 'Casi... ü§î<br>Almost! Listen again';
            points = 25;
            className = 'warning';
            this.awardPoints(points);
            
            // Update VR UI
            this.updateVRText('vr-instruction-text', '‚ö†Ô∏è Close! Listen and try again...');
            
            // Repeat the phrase
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', ''); // Clear previous
                this.startListening();
              }, 2000);
            }, 2000);
          } else {
            // Wrong answer
            feedback = `‚ùå No coincide<br>Try: "${this.currentPhrase.text}"`;
            points = 0;
            className = 'error';
            
            // Update VR UI
            this.updateVRText('vr-instruction-text', '‚ùå Wrong phrase. Listen carefully...');
            
            // Repeat the phrase
            setTimeout(() => {
              this.npcSpeak(this.currentPhrase.text);
              setTimeout(() => {
                this.updateVRText('vr-heard-text', ''); // Clear previous
                this.startListening();
              }, 2000);
            }, 2500);
          }

          this.showFeedback(feedback, className);
        },

        calculateSimilarity(str1, str2) {
          // Normalize strings
          str1 = str1.toLowerCase().replace(/[¬ø?¬°!.,]/g, '').trim();
          str2 = str2.toLowerCase().replace(/[¬ø?¬°!.,]/g, '').trim();

          // Exact match
          if (str1 === str2) return 1.0;

          // Levenshtein distance
          const distance = this.levenshteinDistance(str1, str2);
          const maxLength = Math.max(str1.length, str2.length);
          
          if (maxLength === 0) return 1.0;
          
          return 1.0 - (distance / maxLength);
        },

        levenshteinDistance(str1, str2) {
          const matrix = [];

          for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
          }

          for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
          }

          for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
              if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(
                  matrix[i - 1][j - 1] + 1,
                  matrix[i][j - 1] + 1,
                  matrix[i - 1][j] + 1
                );
              }
            }
          }

          return matrix[str2.length][str1.length];
        },

        awardPoints(points) {
          this.score += points;
          document.getElementById('score').textContent = `Score: ${this.score} üåü`;
          
          // Update VR score
          this.updateVRText('vr-score-text', `Score: ${this.score} üåü`);
        },

        showFeedback(message, className) {
          const banner = document.getElementById('feedback-banner');
          banner.innerHTML = message;
          banner.className = className;
          banner.classList.add('show');

          setTimeout(() => {
            banner.classList.remove('show');
          }, 2000);
        },

        updateStatus(message) {
          document.getElementById('status').textContent = message;
        },

        updateSpeechStatus(message, className) {
          const el = document.getElementById('speech-status');
          el.textContent = message;
          el.className = 'status ' + (className || '');
        }
      };

      // ========================================
      // A-FRAME COMPONENTS
      // ========================================
      
      // Mansion Garden Inspector - Find objects in the GLB
      AFRAME.registerComponent('mansion-garden-inspector', {
        init: function() {
          console.log('[Mansion Inspector] Waiting for model to load...');
          
          this.el.addEventListener('model-loaded', () => {
            console.log('[Mansion Inspector] ‚úì Model loaded! Inspecting objects...');
            
            const model = this.el.getObject3D('mesh');
            if (!model) {
              console.error('[Mansion Inspector] No mesh found');
              return;
            }
            
            console.log('[Mansion Inspector] === MANSION GARDEN OBJECT LIST ===');
            let objectCount = 0;
            
            model.traverse((node) => {
              if (node.isMesh || node.isGroup || node.isObject3D) {
                objectCount++;
                
                // Get world position
                const worldPos = new THREE.Vector3();
                node.getWorldPosition(worldPos);
                
                const name = node.name || 'unnamed';
                const type = node.type || 'unknown';
                
                // Log all objects
                console.log(`[${objectCount}] ${name} (${type})`);
                console.log(`   Position: x=${worldPos.x.toFixed(2)}, y=${worldPos.y.toFixed(2)}, z=${worldPos.z.toFixed(2)}`);
                
                // Check if name contains "fountain" or "water"
                const lowerName = name.toLowerCase();
                if (lowerName.includes('fountain') || lowerName.includes('water') || 
                    lowerName.includes('basin') || lowerName.includes('pond')) {
                  console.log(`   üåä *** POSSIBLE FOUNTAIN/WATER FEATURE ***`);
                }
                
                // Check for geometry size (fountains are usually large)
                if (node.geometry) {
                  node.geometry.computeBoundingBox();
                  const bbox = node.geometry.boundingBox;
                  if (bbox) {
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    if (size.x > 2 || size.y > 2 || size.z > 2) {
                      console.log(`   üìè Large object: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);
                    }
                  }
                }
              }
            });
            
            console.log(`[Mansion Inspector] === Total objects: ${objectCount} ===`);
            console.log('[Mansion Inspector] Check console above for fountain coordinates!');
          });
        }
      });
      
      // UI Toggle Controller - Press A button to toggle UI
      AFRAME.registerComponent('ui-toggle-controller', {
        init: function() {
          this.uiVisible = true;
          
          this.el.addEventListener('abuttondown', (evt) => {
            console.log('[UI Toggle] A button pressed');
            this.toggleUI();
          });
        },
        
        toggleUI: function() {
          this.uiVisible = !this.uiVisible;
          
          const vrUIPanel = document.getElementById('vr-ui-panel');
          const vrLanguagePanel = document.getElementById('vr-language-panel');
          const vrScenarioPanel = document.getElementById('vr-scenario-panel');
          
          if (vrUIPanel) {
            vrUIPanel.setAttribute('visible', this.uiVisible);
          }
          if (vrLanguagePanel) {
            vrLanguagePanel.setAttribute('visible', this.uiVisible);
          }
          if (vrScenarioPanel) {
            vrScenarioPanel.setAttribute('visible', this.uiVisible);
          }
          
          console.log('[UI Toggle] UI is now:', this.uiVisible ? 'VISIBLE' : 'HIDDEN');
        }
      });
      
      // ========================================
      // MIXAMO BODY COMPONENT
      // ========================================

      // VR Locomotion component - handles NPC rotation
      AFRAME.registerComponent('vr-locomotion', {
        schema: {
          rotationSpeed: { type: 'number', default: 2.0 }
        },

        init: function() {
          this.npcRotationY = 0;
          this.thumbstickRotation = { right: 0 };
          this.npcTutor = null;
          
          setTimeout(() => {
            this.npcTutor = document.querySelector('#npc-tutor');
          }, 100);
          
          this.el.sceneEl.addEventListener('thumbstickmoved', (evt) => {
            if (!evt.target || !evt.target.object3D) return;
            const hand = evt.target;
            this.handleThumbstick(hand, evt.detail);
          });
        },
        
        handleThumbstick: function(hand, detail) {
          const isLeft = hand.id === 'left-hand';
          if (!isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.right = -detail.x;
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
        },

        tick: function(time, deltaTime) {
          const dt = Math.min(deltaTime / 1000, 0.1);
          const rotationInput = this.thumbstickRotation.right;
          
          if (Math.abs(rotationInput) > 0.1) {
            this.npcRotationY += rotationInput * this.data.rotationSpeed * dt;
          }
          
          if (this.npcTutor && this.npcTutor.components['mixamo-body']) {
            this.npcTutor.components['mixamo-body'].manualRotationY = this.npcRotationY;
          }
        }
      });

      // Language NPC component
      AFRAME.registerComponent('language-npc', {
        init: function() {
          console.log('[NPC] Language NPC initialized');
        }
      });

      // Mixamo VR Body component (simplified version from body-rigged.html)
      AFRAME.registerComponent('mixamo-body', {
        schema: {
          isMirror: { type: 'boolean', default: false },
          color: { type: 'color', default: '#4A90E2' },
          modelPath: { type: 'string', default: '../BoltVR/assets/Y Bot.fbx' }
        },

        init: function() {
          console.log('[Mixamo Body] Initializing body component, isMirror:', this.data.isMirror);
          
          this.camera = document.querySelector('#camera');
          this.leftController = document.querySelector('#left-hand');
          this.rightController = document.querySelector('#right-hand');
          this.rig = document.querySelector('#rig');
          
          console.log('[Mixamo Body] Found camera:', !!this.camera);
          console.log('[Mixamo Body] Found controllers:', !!this.leftController, !!this.rightController);
          
          this.skeleton = null;
          this.bones = {};
          this.model = null;
          this.modelLoaded = false;
          
          // Mixamo bone names
          this.boneNames = {
            hips: 'mixamorigHips',
            spine: 'mixamorigSpine',
            spine1: 'mixamorigSpine1',
            spine2: 'mixamorigSpine2',
            neck: 'mixamorigNeck',
            head: 'mixamorigHead',
            leftShoulder: 'mixamorigLeftShoulder',
            leftArm: 'mixamorigLeftArm',
            leftForeArm: 'mixamorigLeftForeArm',
            leftHand: 'mixamorigLeftHand',
            rightShoulder: 'mixamorigRightShoulder',
            rightArm: 'mixamorigRightArm',
            rightForeArm: 'mixamorigRightForeArm',
            rightHand: 'mixamorigRightHand'
          };
          
          // IK config
          this.config = {
            shoulderWidth: 0.34,
            shoulderForward: 0.08,
            upperArmLength: 0.31,
            lowerArmLength: 0.31
          };
          
          // Smoothing
          this.torsoRotation = new THREE.Quaternion();
          this.bodyTilt = new THREE.Quaternion();
          this.smoothingFactor = 0.15;
          this.mirrorDistance = 2.5;
          this.manualRotationY = 0;
          
          // Breathing animation
          this.breathingPhase = 0;
          this.breathingRate = 0.25;
          this.breathingAmount = 0.015;
          
          // Load model
          console.log('[Mixamo Body] Loading model from:', this.data.modelPath);
          const loader = new THREE.FBXLoader();
          loader.load(
            this.data.modelPath,
            (fbx) => this.onModelLoaded(fbx),
            (progress) => {
              console.log('[Mixamo Body] Loading progress:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
            },
            (error) => {
              console.error('[Mixamo Body] Load error:', error);
              console.log('[Mixamo Body] Tried to load from:', this.data.modelPath);
              console.log('[Mixamo Body] Make sure the model exists at this path');
            }
          );
        },

        onModelLoaded: function(fbx) {
          console.log('[Mixamo Body] Model loaded successfully');
          this.modelLoaded = true;
          this.model = fbx;
          
          fbx.scale.set(0.01, 0.01, 0.01);
          fbx.rotation.y = Math.PI;
          
          this.el.object3D.add(fbx);
          
          fbx.traverse((node) => {
            if (node.isSkinnedMesh && node.skeleton) {
              this.skeleton = node.skeleton;
              this.mapBones();
              this.skinnedMesh = node;
              
              node.material = node.material.clone();
              node.material.color.set(this.data.color);
            }
            
            if (node.isMesh && !node.isSkinnedMesh) {
              node.material = node.material.clone();
              node.material.color.set(this.data.color);
            }
          });
        },

        mapBones: function() {
          this.initialBoneRotations = {};
          
          this.skeleton.bones.forEach((bone) => {
            const name = bone.name;
            this.initialBoneRotations[name] = bone.quaternion.clone();
            
            // Hide legs
            const lowerName = name.toLowerCase();
            if (lowerName.includes('leg') || lowerName.includes('upleg') || 
                lowerName.includes('foot') || lowerName.includes('toe')) {
              bone.scale.set(0.001, 0.001, 0.001);
            }
            
            // Map important bones
            if (name === this.boneNames.hips) this.bones.hips = bone;
            else if (name === this.boneNames.spine) this.bones.spine = bone;
            else if (name === this.boneNames.spine1) this.bones.spine1 = bone;
            else if (name === this.boneNames.spine2) this.bones.spine2 = bone;
            else if (name === this.boneNames.neck) this.bones.neck = bone;
            else if (name === this.boneNames.head) {
              this.bones.head = bone;
              if (!this.data.isMirror) {
                bone.scale.set(0.001, 0.001, 0.001);
              }
            }
            else if (name === this.boneNames.leftArm) this.bones.leftUpperArm = bone;
            else if (name === this.boneNames.leftForeArm) this.bones.leftForearm = bone;
            else if (name === this.boneNames.leftHand) this.bones.leftHandBone = bone;
            else if (name === this.boneNames.rightArm) this.bones.rightUpperArm = bone;
            else if (name === this.boneNames.rightForeArm) this.bones.rightForearm = bone;
            else if (name === this.boneNames.rightHand) this.bones.rightHandBone = bone;
          });
        },

        tick: function(time, deltaTime) {
          if (!this.modelLoaded || !this.skeleton) return;
          if (!this.camera || !this.leftController || !this.rightController) return;
          
          const dt = Math.min(deltaTime / 1000, 0.1);
          
          this.breathingPhase += dt * this.breathingRate * Math.PI * 2;
          if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
          }
          
          if (this.data.isMirror) {
            this.updateNPCBody(dt);
          } else {
            this.updateLocalBody(dt);
          }
        },

        updateLocalBody: function(dt) {
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();
          
          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);
          
          this.calculateTorsoOrientation(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, dt);
          
          const desiredHipsY = headWorldPos.y - 0.65;
          const modelHipsLocalY = 1.0;
          const bodyY = desiredHipsY - modelHipsLocalY;
          
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);
          
          this.el.object3D.position.set(
            headWorldPos.x + backwardOffset.x, 
            bodyY, 
            headWorldPos.z + backwardOffset.z
          );
          
          this.el.object3D.quaternion.copy(this.torsoRotation);
          
          this.updateBones(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, leftHandWorldQuat, rightHandWorldQuat);
        },

        updateNPCBody: function(dt) {
          // NPC stays in fixed position with idle animation
          // Don't follow player - just breathe and face forward
          
          // Simple idle pose - face forward
          const forwardQuat = new THREE.Quaternion(); // Identity = facing forward
          this.torsoRotation.slerp(forwardQuat, 0.05);
          
          // Keep NPC at fixed height
          const currentPos = this.el.object3D.position;
          this.el.object3D.position.set(currentPos.x, 0.6, currentPos.z);
          
          this.el.object3D.quaternion.copy(this.torsoRotation);
          
          // Simple idle pose for NPC
          this.updateNPCBones();
        },

        calculateTorsoOrientation: function(headPos, headQuat, leftHandPos, rightHandPos, dt) {
          const headForwardFlat = new THREE.Vector3(0, 0, -1).applyQuaternion(headQuat);
          headForwardFlat.y = 0;
          headForwardFlat.normalize();
          
          const targetRotation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            headForwardFlat
          );
          
          this.torsoRotation.slerp(targetRotation, this.smoothingFactor);
        },

        updateBones: function(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat) {
          if (this.bones.hips) this.bones.hips.quaternion.identity();
          if (this.bones.spine) this.bones.spine.quaternion.identity();
          if (this.bones.spine1) this.bones.spine1.quaternion.identity();
          if (this.bones.spine2) this.bones.spine2.quaternion.identity();
          
          // Head rotation
          if (this.bones.neck) {
            const relativeHeadQuat = headQuat.clone();
            const invBodyQuat = this.torsoRotation.clone().invert();
            relativeHeadQuat.premultiply(invBodyQuat);
            
            const euler = new THREE.Euler().setFromQuaternion(relativeHeadQuat, 'YXZ');
            euler.x = -euler.x;
            euler.z = -euler.z;
            
            const correctedQuat = new THREE.Quaternion().setFromEuler(euler);
            this.bones.neck.quaternion.copy(correctedQuat);
          }
          
          // Simple arm IK
          this.solveSimpleArmIK('left', leftHandPos, leftHandQuat);
          this.solveSimpleArmIK('right', rightHandPos, rightHandQuat);
        },

        updateNPCBones: function() {
          // Reset bones
          if (this.bones.hips) this.bones.hips.quaternion.identity();
          if (this.bones.spine) this.bones.spine.quaternion.identity();
          if (this.bones.spine1) this.bones.spine1.quaternion.identity();
          if (this.bones.spine2) this.bones.spine2.quaternion.identity();
          if (this.bones.neck) this.bones.neck.quaternion.identity();
          
          // Breathing animation
          const breathingExpansion = Math.sin(this.breathingPhase) * this.breathingAmount;
          
          if (this.bones.spine1) {
            const euler = new THREE.Euler(-breathingExpansion * 0.4, 0, 0, 'YXZ');
            this.bones.spine1.quaternion.setFromEuler(euler);
          }
          
          // Idle arm pose - relaxed at sides
          if (this.bones.leftUpperArm) {
            const euler = new THREE.Euler(0.2, 0, 0.1, 'YXZ');
            this.bones.leftUpperArm.quaternion.setFromEuler(euler);
          }
          if (this.bones.rightUpperArm) {
            const euler = new THREE.Euler(0.2, 0, -0.1, 'YXZ');
            this.bones.rightUpperArm.quaternion.setFromEuler(euler);
          }
          if (this.bones.leftForearm) {
            const euler = new THREE.Euler(0.3, 0, 0, 'YXZ');
            this.bones.leftForearm.quaternion.setFromEuler(euler);
          }
          if (this.bones.rightForearm) {
            const euler = new THREE.Euler(0.3, 0, 0, 'YXZ');
            this.bones.rightForearm.quaternion.setFromEuler(euler);
          }
        },

        solveSimpleArmIK: function(hand, handWorldPos, handWorldQuat) {
          // Simplified IK for arms
          const upperArmBone = this.bones[`${hand}UpperArm`];
          const forearmBone = this.bones[`${hand}Forearm`];
          const handBone = this.bones[`${hand}HandBone`];
          
          if (!upperArmBone || !forearmBone) return;
          
          // Simple rotation toward hand
          const shoulderWorldPos = new THREE.Vector3();
          upperArmBone.getWorldPosition(shoulderWorldPos);
          
          const toHand = handWorldPos.clone().sub(shoulderWorldPos).normalize();
          const targetQuat = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, -1, 0),
            toHand
          );
          
          upperArmBone.quaternion.slerp(targetQuat, 0.3);
        }
      });

      // Initialize app when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => LanguageApp.init());
      } else {
        LanguageApp.init();
      }
    </script>
  </body>
</html>

