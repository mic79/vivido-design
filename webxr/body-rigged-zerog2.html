<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR - Zero-G Body with Thrusters</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.173.0/examples/js/loaders/FBXLoader.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #ui {
        position: fixed; top: 10px; left: 10px;
        background: rgba(0, 0, 0, 0.8); color: white;
        padding: 15px; border-radius: 5px;
        font-family: monospace; z-index: 1000; max-width: 400px;
      }
      #ui h3 { margin-top: 0; color: #4CAF50; }
      .info { font-size: 11px; color: #888; margin-top: 10px; line-height: 1.5; }
    </style>
  </head>
  <body>
    <div id="ui">
      <h3>ðŸš€ Zero-G Body with Thrusters</h3>
      <div class="info">
        <strong>Controls:</strong> B/Y = Thrust | L-Click = Boost | R-Click = Brake<br>
        <strong>Debug:</strong> Press A = Log leg rotation limits<br>
        <strong>Status:</strong> <span id="status">Loading...</span>
      </div>
    </div>

    <a-scene background="color: #000011">
      <a-entity id="rig" position="0 1.6 0" zerog-thruster-movement>
        <a-entity id="camera" camera look-controls></a-entity>
        <a-entity id="left-hand" hand-controls="hand: left; handModelStyle: lowPoly" visible="false"></a-entity>
        <a-entity id="right-hand" hand-controls="hand: right; handModelStyle: lowPoly" visible="false"></a-entity>
      </a-entity>

      <!-- Local Player Body (Zero-G) -->
      <a-entity id="local-body" mixamo-zerog-body="isMirror: false"></a-entity>

      <!-- Mirror Body (Zero-G) - stays in front of camera -->
      <a-entity id="mirror-body" mixamo-zerog-body="isMirror: true; color: #66BB6A"></a-entity>

      <!-- Space environment -->
      <a-sky color="#000011"></a-sky>
      <a-entity light="type: ambient; intensity: 0.4"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="2 4 2"></a-entity>
      
      <!-- Grid floor for reference -->
      <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" color="#112233" opacity="0.5"></a-plane>
      <a-text value="Zero-G Mirror" position="0 2.5 -2" align="center" color="#66BB6A" width="4"></a-text>
    </a-scene>

    <script>
      // Zero-G Thruster Movement Component
      AFRAME.registerComponent('zerog-thruster-movement', {
        schema: {
          thrusterForce: { type: 'number', default: 0.8 },
          maxSpeed: { type: 'number', default: 8 },
          damping: { type: 'number', default: 0.996 },
          minVelocity: { type: 'number', default: 0.01 },
          rotationSpeed: { type: 'number', default: 4.0 },
          boostForce: { type: 'number', default: 2.0 },  // Instant velocity boost
          brakeForce: { type: 'number', default: 0.92 }
        },
        
        init: function() {
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.thrusterActive = { left: false, right: false };
          this.isBraking = false;
          this.camera = this.el.querySelector('#camera');
          this.leftHand = this.el.querySelector('#left-hand');
          this.rightHand = this.el.querySelector('#right-hand');
          this.mirrorBody = document.querySelector('#mirror-body');
          
          // Hide the white hand models after they load
          setTimeout(() => {
            if (this.leftHand && this.leftHand.object3D) {
              this.leftHand.object3D.traverse((node) => {
                if (node.isMesh) {
                  node.visible = false;
                }
              });
            }
            if (this.rightHand && this.rightHand.object3D) {
              this.rightHand.object3D.traverse((node) => {
                if (node.isMesh) {
                  node.visible = false;
                }
              });
            }
          }, 1000);
          
          // Mirror rotation control
          this.thumbstickRotation = { right: 0 };
          
          // Bind event handlers
          this.onBButtonDown = this.onBButtonDown.bind(this);
          this.onBButtonUp = this.onBButtonUp.bind(this);
          this.onYButtonDown = this.onYButtonDown.bind(this);
          this.onYButtonUp = this.onYButtonUp.bind(this);
          this.onThumbstickMoved = this.onThumbstickMoved.bind(this);
          this.onThumbstickDown = this.onThumbstickDown.bind(this);
          this.onThumbstickUp = this.onThumbstickUp.bind(this);
          this.onAButtonDown = this.onAButtonDown.bind(this);
          
          // Listen for controller events
          this.el.sceneEl.addEventListener('bbuttondown', this.onBButtonDown);
          this.el.sceneEl.addEventListener('bbuttonup', this.onBButtonUp);
          this.el.sceneEl.addEventListener('ybuttondown', this.onYButtonDown);
          this.el.sceneEl.addEventListener('ybuttonup', this.onYButtonUp);
          this.el.sceneEl.addEventListener('thumbstickmoved', this.onThumbstickMoved);
          this.el.sceneEl.addEventListener('thumbstickdown', this.onThumbstickDown);
          this.el.sceneEl.addEventListener('thumbstickup', this.onThumbstickUp);
          this.el.sceneEl.addEventListener('abuttondown', this.onAButtonDown);
        },
        
        onBButtonDown: function(evt) {
          this.thrusterActive.right = true;
        },
        
        onBButtonUp: function(evt) {
          this.thrusterActive.right = false;
        },
        
        onYButtonDown: function(evt) {
          this.thrusterActive.left = true;
        },
        
        onYButtonUp: function(evt) {
          this.thrusterActive.left = false;
        },
        
        onThumbstickMoved: function(evt) {
          if (!evt.target || !evt.target.object3D) return;
          const hand = evt.target;
          const handId = hand.id || hand.getAttribute('id');
          const isLeft = handId === 'left-hand';
          
          // Right thumbstick controls mirror rotation
          if (!isLeft && Math.abs(evt.detail.x) > 0.1) {
            this.thumbstickRotation.right = -evt.detail.x;
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
        },
        
        onThumbstickDown: function(evt) {
          if (!evt.target || !evt.target.object3D) return;
          const hand = evt.target;
          const handId = hand.id || hand.getAttribute('id');
          const isLeft = handId === 'left-hand';
          
          if (isLeft) {
            // Left thumbstick click: INSTANT Speed boost in the direction you're looking
            if (this.camera) {
              // Get camera's forward direction
              const boostDirection = new THREE.Vector3(0, 0, -1);
              const cameraWorldQuat = new THREE.Quaternion();
              this.camera.object3D.getWorldQuaternion(cameraWorldQuat);
              boostDirection.applyQuaternion(cameraWorldQuat);
              
              // Apply instant velocity boost
              const boostVelocity = boostDirection.multiplyScalar(this.data.boostForce);
              this.velocity.add(boostVelocity);
            }
          } else {
            // Right thumbstick click: Air brake
            this.isBraking = true;
          }
        },
        
        onThumbstickUp: function(evt) {
          if (!evt.target || !evt.target.object3D) return;
          const hand = evt.target;
          const handId = hand.id || hand.getAttribute('id');
          const isLeft = handId === 'left-hand';
          
          if (!isLeft) {
            // Right thumbstick release: Stop air brake
            this.isBraking = false;
          }
        },
        
        onAButtonDown: function(evt) {
          // Log rotation extremes from mirror body
          if (this.mirrorBody && this.mirrorBody.components['mixamo-zerog-body']) {
            this.mirrorBody.components['mixamo-zerog-body'].logRotationExtremes();
          }
        },
        
        tick: function(time, deltaTime) {
          if (!deltaTime || deltaTime > 100) return; // Skip large deltas
          const dt = deltaTime / 1000; // Convert to seconds
          
          // Apply thruster forces (B and Y buttons only) - DOWNWARD from controllers like DodgeVR
          if (this.thrusterActive.left && this.leftHand) {
            const handWorldQuat = new THREE.Quaternion();
            this.leftHand.object3D.getWorldQuaternion(handWorldQuat);
            const thrustDir = new THREE.Vector3(0, -1, 0).applyQuaternion(handWorldQuat); // DOWN from controller
            this.velocity.addScaledVector(thrustDir, this.data.thrusterForce * dt);
          }
          
          if (this.thrusterActive.right && this.rightHand) {
            const handWorldQuat = new THREE.Quaternion();
            this.rightHand.object3D.getWorldQuaternion(handWorldQuat);
            const thrustDir = new THREE.Vector3(0, -1, 0).applyQuaternion(handWorldQuat); // DOWN from controller
            this.velocity.addScaledVector(thrustDir, this.data.thrusterForce * dt);
          }
          
          // Apply braking or damping
          if (this.isBraking) {
            this.velocity.multiplyScalar(this.data.brakeForce); // Stronger braking
          } else {
            this.velocity.multiplyScalar(this.data.damping); // Normal damping
          }
          
          // Stop very slow movement
          if (this.velocity.length() < this.data.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
          
          // Clamp to max speed
          if (this.velocity.length() > this.data.maxSpeed) {
            this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
          }
          
          // Apply velocity to position
          const currentPos = this.el.object3D.position;
          currentPos.add(this.velocity.clone().multiplyScalar(dt));
          
          // Rotate player rig from right thumbstick
          const rotationInput = this.thumbstickRotation.right;
          if (Math.abs(rotationInput) > 0.1) {
            const rotationDelta = rotationInput * this.data.rotationSpeed * dt;
            const currentRotation = this.el.object3D.rotation.y;
            this.el.object3D.rotation.y = currentRotation + rotationDelta;
          }
          
          // Update mirror body to stay 2m in front of camera
          if (this.mirrorBody && this.camera) {
            const cameraWorldQuat = new THREE.Quaternion();
            this.camera.object3D.getWorldQuaternion(cameraWorldQuat);
            
            // Position 2m in front of camera
            const forwardOffset = new THREE.Vector3(0, 0, -2);
            forwardOffset.applyQuaternion(cameraWorldQuat);
            
            const cameraWorldPos = new THREE.Vector3();
            this.camera.object3D.getWorldPosition(cameraWorldPos);
            
            const mirrorPos = cameraWorldPos.clone().add(forwardOffset);
            this.mirrorBody.object3D.position.copy(mirrorPos);
            
            // Make mirror face camera (180Â°)
            const cameraWorldEuler = new THREE.Euler();
            cameraWorldEuler.setFromQuaternion(cameraWorldQuat, 'YXZ');
            this.mirrorBody.object3D.rotation.set(0, cameraWorldEuler.y + Math.PI, 0);
          }
        },
        
        remove: function() {
          this.el.sceneEl.removeEventListener('bbuttondown', this.onBButtonDown);
          this.el.sceneEl.removeEventListener('bbuttonup', this.onBButtonUp);
          this.el.sceneEl.removeEventListener('ybuttondown', this.onYButtonDown);
          this.el.sceneEl.removeEventListener('ybuttonup', this.onYButtonUp);
          this.el.sceneEl.removeEventListener('thumbstickmoved', this.onThumbstickMoved);
          this.el.sceneEl.removeEventListener('thumbstickdown', this.onThumbstickDown);
          this.el.sceneEl.removeEventListener('thumbstickup', this.onThumbstickUp);
          this.el.sceneEl.removeEventListener('abuttondown', this.onAButtonDown);
        }
      });

      // Zero-G Body component with procedural leg animation
      AFRAME.registerComponent('mixamo-zerog-body', {
        schema: {
          isMirror: { type: 'boolean', default: false },
          color: { type: 'color', default: '#4A90E2' },
          modelPath: { type: 'string', default: 'BoltVR/assets/Y Bot.fbx' }
        },

        init: function() {
          this.camera = document.querySelector('#camera');
          this.leftController = document.querySelector('#left-hand');
          this.rightController = document.querySelector('#right-hand');
          this.rig = document.querySelector('#rig');
          
          this.skeleton = null;
          this.bones = {};
          this.model = null;
          this.modelLoaded = false;
          
          // Mixamo bone names (including legs!)
          this.boneNames = {
            hips: 'mixamorigHips',
            spine: 'mixamorigSpine',
            spine1: 'mixamorigSpine1',
            spine2: 'mixamorigSpine2',
            neck: 'mixamorigNeck',
            head: 'mixamorigHead',
            // Arms
            leftShoulder: 'mixamorigLeftShoulder',
            leftArm: 'mixamorigLeftArm',
            leftForeArm: 'mixamorigLeftForeArm',
            leftHand: 'mixamorigLeftHand',
            rightShoulder: 'mixamorigRightShoulder',
            rightArm: 'mixamorigRightArm',
            rightForeArm: 'mixamorigRightForeArm',
            rightHand: 'mixamorigRightHand',
            // Legs (NEW!)
            leftUpLeg: 'mixamorigLeftUpLeg',
            leftLeg: 'mixamorigLeftLeg',
            leftFoot: 'mixamorigLeftFoot',
            rightUpLeg: 'mixamorigRightUpLeg',
            rightLeg: 'mixamorigRightLeg',
            rightFoot: 'mixamorigRightFoot',
            // Fingers
            leftHandThumb1: 'mixamorigLeftHandThumb1',
            leftHandThumb2: 'mixamorigLeftHandThumb2',
            leftHandThumb3: 'mixamorigLeftHandThumb3',
            leftHandIndex1: 'mixamorigLeftHandIndex1',
            leftHandIndex2: 'mixamorigLeftHandIndex2',
            leftHandIndex3: 'mixamorigLeftHandIndex3',
            leftHandMiddle1: 'mixamorigLeftHandMiddle1',
            leftHandMiddle2: 'mixamorigLeftHandMiddle2',
            leftHandMiddle3: 'mixamorigLeftHandMiddle3',
            leftHandRing1: 'mixamorigLeftHandRing1',
            leftHandRing2: 'mixamorigLeftHandRing2',
            leftHandRing3: 'mixamorigLeftHandRing3',
            leftHandPinky1: 'mixamorigLeftHandPinky1',
            leftHandPinky2: 'mixamorigLeftHandPinky2',
            leftHandPinky3: 'mixamorigLeftHandPinky3',
            rightHandThumb1: 'mixamorigRightHandThumb1',
            rightHandThumb2: 'mixamorigRightHandThumb2',
            rightHandThumb3: 'mixamorigRightHandThumb3',
            rightHandIndex1: 'mixamorigRightHandIndex1',
            rightHandIndex2: 'mixamorigRightHandIndex2',
            rightHandIndex3: 'mixamorigRightHandIndex3',
            rightHandMiddle1: 'mixamorigRightHandMiddle1',
            rightHandMiddle2: 'mixamorigRightHandMiddle2',
            rightHandMiddle3: 'mixamorigRightHandMiddle3',
            rightHandRing1: 'mixamorigRightHandRing1',
            rightHandRing2: 'mixamorigRightHandRing2',
            rightHandRing3: 'mixamorigRightHandRing3',
            rightHandPinky1: 'mixamorigRightHandPinky1',
            rightHandPinky2: 'mixamorigRightHandPinky2',
            rightHandPinky3: 'mixamorigRightHandPinky3'
          };
          
          // IK config
          this.config = {
            shoulderWidth: 0.34,
            upperArmLength: 0.31,
            lowerArmLength: 0.31,
            upperLegLength: 0.45,  // Thigh
            lowerLegLength: 0.45   // Shin
          };
          
          // Smoothing
          this.torsoRotation = new THREE.Quaternion();
          this.bodyTilt = new THREE.Quaternion();
          this.smoothingFactor = 0.15;
          this.mirrorDistance = 2.0;
          
          // Finger curl smoothing
          this.targetCurls = {
            left: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 },
            right: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 }
          };
          this.currentCurls = {
            left: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 },
            right: { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 }
          };
          this.fingerSmoothingFactor = 0.3;
          
          // Breathing animation
          this.breathingPhase = 0;
          this.breathingRate = 0.25;
          this.breathingAmount = 0.015;
          
          // Rotation tracking for debugging constraints
          this.rotationExtremes = {
            // Legs
            leftUpLeg: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            leftLeg: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            leftFoot: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightUpLeg: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightLeg: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightFoot: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            // Arms
            leftArm: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            leftForeArm: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            leftHand: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightArm: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightForeArm: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            rightHand: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            // Torso
            spine: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            spine1: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            spine2: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            neck: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } },
            head: { x: { min: Infinity, max: -Infinity }, y: { min: Infinity, max: -Infinity }, z: { min: Infinity, max: -Infinity } }
          };
          this.manualRotationY = 0;
          
          // Body dynamics
          this.previousHeadPos = new THREE.Vector3();
          this.previousHeadPosInitialized = false;
          this.headVelocity = new THREE.Vector3();
          this.headAcceleration = new THREE.Vector3();
          this.previousHeadVelocity = new THREE.Vector3();
          this.torsoLean = new THREE.Vector3();
          this.torsoLeanVelocity = 0.15;
          
          // Leg idle animation (subtle floating motion)
          this.legIdlePhase = 0;
          this.legIdleRate = 0.3; // Slow, gentle motion
          this.legIdleAmount = 3; // Degrees of variation
          
          // Smoothed leg pose to reduce jitter
          this.smoothedLegPose = {
            left: { hipFlex: 0, hipSpread: 0, kneeBend: 0, ankleFlex: 0, ankleSway: 0 },
            right: { hipFlex: 0, hipSpread: 0, kneeBend: 0, ankleFlex: 0, ankleSway: 0 }
          };
          this.legSmoothingFactor = 0.15; // Smooth out jitter
          
          // Pose transition hysteresis to prevent rapid switching
          this.currentDominantDirection = 'rest'; // Track which direction is dominant
          this.directionSwitchThreshold = 0.35; // Need this much velocity to switch
          this.directionMaintainThreshold = 0.15; // Stay in current direction until below this
          
          // Leg pose-based animation (no IK, just predefined poses)
          // Using Z-rotation in applyLegPose to flip direction, X-rotation for flex
          this.legPoses = {
            rest: { hipFlex: -10, hipSpread: 8, kneeBend: 20, ankleFlex: 15 },       // Legs hanging down naturally
            forward: { hipFlex: 20, hipSpread: 6, kneeBend: 10, ankleFlex: 5 },      // Moving forward = legs trail back, straighter
            backward: { hipFlex: -60, hipSpread: 10, kneeBend: 100, ankleFlex: 110 }, // Moving back = knees tuck up very high
            up: { hipFlex: 20, hipSpread: 10, kneeBend: 35, ankleFlex: 40 },         // Legs tucked up
            down: { hipFlex: -55, hipSpread: 8, kneeBend: 95, ankleFlex: 105 },      // Moving down = knees tuck up high
            sideways: { hipFlex: -5, hipSpread: 4, kneeBend: 25, ankleFlex: 25 }     // Legs closer together, slight bend
          };
          this.currentLegPose = { ...this.legPoses.rest };
          this.legPoseBlendSpeed = 0.1;
          
          // ZERO-G LEG PHYSICS
          this.legTargetPositions = {
            left: new THREE.Vector3(),
            right: new THREE.Vector3()
          };
          this.legCurrentPositions = {
            left: new THREE.Vector3(),
            right: new THREE.Vector3()
          };
            this.legVelocities = {
              left: new THREE.Vector3(),
              right: new THREE.Vector3()
            };
            this.legDamping = 0.85; // Increased damping to reduce oscillation (was 0.92)
            this.legSpringStrength = 0.06; // Reduced spring strength for smoother movement (was 0.08)
            this.legSeparation = 0.15; // Distance between feet (left/right)
          
          // Load model
          const loader = new THREE.FBXLoader();
          loader.load(
            this.data.modelPath,
            (fbx) => this.onModelLoaded(fbx),
            undefined,
            (error) => console.error('[Zero-G Body] Load error:', error)
          );
        },

        onModelLoaded: function(fbx) {
          this.modelLoaded = true;
          this.model = fbx;
          
          fbx.scale.set(0.01, 0.01, 0.01);
          fbx.rotation.y = Math.PI;
          
          this.el.object3D.add(fbx);
          
          // Set up materials
          fbx.traverse((node) => {
            if (node.isSkinnedMesh && node.skeleton) {
              this.skeleton = node.skeleton;
              this.mapBones();
              this.skinnedMesh = node;
              node.material = node.material.clone();
              console.log('[Zero-G Body] Found mesh');
            }
            if (node.isMesh && !node.isSkinnedMesh) {
              node.material = node.material.clone();
            }
          });
          
          document.querySelector('#status').textContent = 'Active (Zero-G)';
          document.querySelector('#status').style.color = '#4CAF50';
        },

        mapBones: function() {
          this.initialBoneRotations = {};
          
          this.skeleton.bones.forEach((bone) => {
            const name = bone.name;
            this.initialBoneRotations[name] = bone.quaternion.clone();
            
            // Map all bones (including legs)
            if (name === this.boneNames.hips) this.bones.hips = bone;
            else if (name === this.boneNames.spine) this.bones.spine = bone;
            else if (name === this.boneNames.spine1) this.bones.spine1 = bone;
            else if (name === this.boneNames.spine2) this.bones.spine2 = bone;
            else if (name === this.boneNames.neck) this.bones.neck = bone;
            else if (name === this.boneNames.head) {
              this.bones.head = bone;
              // Hide head for local body only
              if (!this.data.isMirror) {
                bone.scale.set(0.001, 0.001, 0.001);
              }
            }
            // Arms
            else if (name === this.boneNames.leftShoulder) this.bones.leftShoulder = bone;
            else if (name === this.boneNames.leftArm) this.bones.leftUpperArm = bone;
            else if (name === this.boneNames.leftForeArm) this.bones.leftForearm = bone;
            else if (name === this.boneNames.leftHand) this.bones.leftHandBone = bone;
            else if (name === this.boneNames.rightShoulder) this.bones.rightShoulder = bone;
            else if (name === this.boneNames.rightArm) this.bones.rightUpperArm = bone;
            else if (name === this.boneNames.rightForeArm) this.bones.rightForearm = bone;
            else if (name === this.boneNames.rightHand) this.bones.rightHandBone = bone;
            // Legs (NEW!)
            else if (name === this.boneNames.leftUpLeg) this.bones.leftUpLeg = bone;
            else if (name === this.boneNames.leftLeg) this.bones.leftLeg = bone;
            else if (name === this.boneNames.leftFoot) this.bones.leftFoot = bone;
            else if (name === this.boneNames.rightUpLeg) this.bones.rightUpLeg = bone;
            else if (name === this.boneNames.rightLeg) this.bones.rightLeg = bone;
            else if (name === this.boneNames.rightFoot) this.bones.rightFoot = bone;
            // Fingers
            else if (name === this.boneNames.leftHandThumb1) this.bones.leftHandThumb1 = bone;
            else if (name === this.boneNames.leftHandThumb2) this.bones.leftHandThumb2 = bone;
            else if (name === this.boneNames.leftHandThumb3) this.bones.leftHandThumb3 = bone;
            else if (name === this.boneNames.leftHandIndex1) this.bones.leftHandIndex1 = bone;
            else if (name === this.boneNames.leftHandIndex2) this.bones.leftHandIndex2 = bone;
            else if (name === this.boneNames.leftHandIndex3) this.bones.leftHandIndex3 = bone;
            else if (name === this.boneNames.leftHandMiddle1) this.bones.leftHandMiddle1 = bone;
            else if (name === this.boneNames.leftHandMiddle2) this.bones.leftHandMiddle2 = bone;
            else if (name === this.boneNames.leftHandMiddle3) this.bones.leftHandMiddle3 = bone;
            else if (name === this.boneNames.leftHandRing1) this.bones.leftHandRing1 = bone;
            else if (name === this.boneNames.leftHandRing2) this.bones.leftHandRing2 = bone;
            else if (name === this.boneNames.leftHandRing3) this.bones.leftHandRing3 = bone;
            else if (name === this.boneNames.leftHandPinky1) this.bones.leftHandPinky1 = bone;
            else if (name === this.boneNames.leftHandPinky2) this.bones.leftHandPinky2 = bone;
            else if (name === this.boneNames.leftHandPinky3) this.bones.leftHandPinky3 = bone;
            else if (name === this.boneNames.rightHandThumb1) this.bones.rightHandThumb1 = bone;
            else if (name === this.boneNames.rightHandThumb2) this.bones.rightHandThumb2 = bone;
            else if (name === this.boneNames.rightHandThumb3) this.bones.rightHandThumb3 = bone;
            else if (name === this.boneNames.rightHandIndex1) this.bones.rightHandIndex1 = bone;
            else if (name === this.boneNames.rightHandIndex2) this.bones.rightHandIndex2 = bone;
            else if (name === this.boneNames.rightHandIndex3) this.bones.rightHandIndex3 = bone;
            else if (name === this.boneNames.rightHandMiddle1) this.bones.rightHandMiddle1 = bone;
            else if (name === this.boneNames.rightHandMiddle2) this.bones.rightHandMiddle2 = bone;
            else if (name === this.boneNames.rightHandMiddle3) this.bones.rightHandMiddle3 = bone;
            else if (name === this.boneNames.rightHandRing1) this.bones.rightHandRing1 = bone;
            else if (name === this.boneNames.rightHandRing2) this.bones.rightHandRing2 = bone;
            else if (name === this.boneNames.rightHandRing3) this.bones.rightHandRing3 = bone;
            else if (name === this.boneNames.rightHandPinky1) this.bones.rightHandPinky1 = bone;
            else if (name === this.boneNames.rightHandPinky2) this.bones.rightHandPinky2 = bone;
            else if (name === this.boneNames.rightHandPinky3) this.bones.rightHandPinky3 = bone;
          });
        },

        tick: function(time, deltaTime) {
          if (!this.modelLoaded || !this.skeleton) return;
          if (!this.camera || !this.leftController || !this.rightController) return;
          
          const dt = Math.min(deltaTime / 1000, 0.1);
          
          // Update breathing
          this.breathingPhase += dt * this.breathingRate * Math.PI * 2;
          if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
          }
          
          if (this.data.isMirror) {
            this.updateMirrorBody(dt);
          } else {
            this.updateLocalBody(dt);
          }
          
          this.updateFingerPoses();
        },

        updateLocalBody: function(dt) {
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();
          
          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);
          
          // Calculate head velocity AND acceleration (for zero-g physics)
          if (this.previousHeadPosInitialized) {
            const newVelocity = headWorldPos.clone().sub(this.previousHeadPos).divideScalar(dt);
            this.headAcceleration.copy(newVelocity).sub(this.previousHeadVelocity).divideScalar(dt);
            this.headVelocity.copy(newVelocity);
            this.previousHeadVelocity.copy(newVelocity);
          } else {
            this.previousHeadPosInitialized = true;
          }
          this.previousHeadPos.copy(headWorldPos);
          
          this.calculateTorsoOrientation(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos, dt);
          this.calculateBodyTilt(headWorldPos, leftHandWorldPos, rightHandWorldPos, dt);
          
          // Position body
          const desiredHipsY = headWorldPos.y - 0.65;
          const modelHipsLocalY = 1.0;
          const bodyY = desiredHipsY - modelHipsLocalY;
          
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);
          
          this.el.object3D.position.set(
            headWorldPos.x + backwardOffset.x,
            bodyY,
            headWorldPos.z + backwardOffset.z
          );
          
          const combinedRotation = new THREE.Quaternion()
            .copy(this.torsoRotation)
            .multiply(this.bodyTilt);
          this.el.object3D.quaternion.copy(combinedRotation);
          
          // Update bones (including legs!)
          this.updateBones(headWorldPos, headWorldQuat, leftHandWorldPos, rightHandWorldPos,
                          leftHandWorldQuat, rightHandWorldQuat, dt);
        },

        updateMirrorBody: function(dt) {
          // Mirror body logic (same as local but with mirror transforms)
          const headWorldPos = new THREE.Vector3();
          const headWorldQuat = new THREE.Quaternion();
          const leftHandWorldPos = new THREE.Vector3();
          const leftHandWorldQuat = new THREE.Quaternion();
          const rightHandWorldPos = new THREE.Vector3();
          const rightHandWorldQuat = new THREE.Quaternion();
          
          this.camera.object3D.getWorldPosition(headWorldPos);
          this.camera.object3D.getWorldQuaternion(headWorldQuat);
          this.leftController.object3D.getWorldPosition(leftHandWorldPos);
          this.leftController.object3D.getWorldQuaternion(leftHandWorldQuat);
          this.rightController.object3D.getWorldPosition(rightHandWorldPos);
          this.rightController.object3D.getWorldQuaternion(rightHandWorldQuat);
          
          if (this.previousHeadPosInitialized) {
            const newVelocity = headWorldPos.clone().sub(this.previousHeadPos).divideScalar(dt);
            this.headAcceleration.copy(newVelocity).sub(this.previousHeadVelocity).divideScalar(dt);
            this.headVelocity.copy(newVelocity);
            this.previousHeadVelocity.copy(newVelocity);
          } else {
            this.previousHeadPosInitialized = true;
          }
          this.previousHeadPos.copy(headWorldPos);
          
          const mirrorCenter = new THREE.Vector3(headWorldPos.x, headWorldPos.y - 0.3, headWorldPos.z - this.mirrorDistance);
          const offset = new THREE.Vector3(0, 0, -this.mirrorDistance);
          let mirrorHeadPos = headWorldPos.clone().add(offset);
          let mirrorLeftHandPos = leftHandWorldPos.clone().add(offset);
          let mirrorRightHandPos = rightHandWorldPos.clone().add(offset);
          
          this.calculateTorsoOrientation(mirrorHeadPos, headWorldQuat, mirrorLeftHandPos, mirrorRightHandPos, dt);
          this.calculateBodyTilt(mirrorHeadPos, mirrorLeftHandPos, mirrorRightHandPos, dt);
          
          const desiredHipsY = mirrorHeadPos.y - 0.65;
          const modelHipsLocalY = 1.0;
          const torsoY = desiredHipsY - modelHipsLocalY;
          
          const backwardOffset = new THREE.Vector3(0, 0, 0.15);
          backwardOffset.applyQuaternion(this.torsoRotation);
          
          this.el.object3D.position.set(
            mirrorHeadPos.x + backwardOffset.x,
            torsoY,
            mirrorHeadPos.z + backwardOffset.z
          );
          
          const combinedRotation = new THREE.Quaternion()
            .copy(this.torsoRotation)
            .multiply(this.bodyTilt);
          this.el.object3D.quaternion.copy(combinedRotation);
          
          this.updateBones(mirrorHeadPos, headWorldQuat, mirrorLeftHandPos, mirrorRightHandPos,
                          leftHandWorldQuat, rightHandWorldQuat, dt);
        },

        calculateTorsoOrientation: function(headPos, headQuat, leftHandPos, rightHandPos, dt) {
          const headForwardFlat = new THREE.Vector3(0, 0, -1).applyQuaternion(headQuat);
          headForwardFlat.y = 0;
          headForwardFlat.normalize();
          
          const shoulderLine = rightHandPos.clone().sub(leftHandPos);
          shoulderLine.y = 0;
          const shoulderDist = shoulderLine.length();
          shoulderLine.normalize();
          
          const controllerForward = new THREE.Vector3().crossVectors(shoulderLine, new THREE.Vector3(0, 1, 0));
          controllerForward.normalize();
          
          // Prevent 180Â° flips - only accept controller direction if it's not opposite to current body direction
          const currentBodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          currentBodyForward.y = 0;
          currentBodyForward.normalize();
          
          // If controller forward is more than 90Â° away, prefer head direction
          const controllerDot = controllerForward.dot(currentBodyForward);
          if (controllerDot < 0) {
            controllerForward.negate();
          }
          
          // Reduce controller influence when hands are close (ambiguous direction)
          let controllerWeight = 0.8;
          if (shoulderDist < 0.25) {
            controllerWeight = 0.2; // Reduced from 0.3 - prefer head when hands close
          } else if (shoulderDist > 0.35) {
            controllerWeight = 0.9; // Reduced from 1.0 - still keep some head influence
          }
          
          const blendedForward = new THREE.Vector3()
            .addScaledVector(controllerForward, controllerWeight)
            .addScaledVector(headForwardFlat, 1.0 - controllerWeight)
            .normalize();
          
          const targetRotation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            blendedForward
          );
          
          // Reduced smoothing factor for even more stability
          this.torsoRotation.slerp(targetRotation, this.smoothingFactor * 0.7);
        },

        calculateBodyTilt: function(headPos, leftHandPos, rightHandPos, dt) {
          // Disable rig-level tilt - spine bending handles the visual reaction to thrust
          // This keeps the chest/neck/shoulders stable as the pivot point
          this.bodyTilt.identity();
        },

        updateBones: function(headPos, headQuat, leftHandPos, rightHandPos, leftHandQuat, rightHandQuat, dt) {
          // Reset bones
          if (this.bones.hips) this.bones.hips.quaternion.identity();
          if (this.bones.spine) this.bones.spine.quaternion.identity();
          if (this.bones.spine1) this.bones.spine1.quaternion.identity();
          if (this.bones.spine2) this.bones.spine2.quaternion.identity();
          
          // Spine bending (with velocity-based lean + breathing)
          const bodyCenter = headPos.clone();
          bodyCenter.y -= 0.5;
          
          const leftRelative = leftHandPos.clone().sub(bodyCenter);
          const rightRelative = rightHandPos.clone().sub(bodyCenter);
          const avgHandPos = new THREE.Vector3()
            .addVectors(leftRelative, rightRelative)
            .multiplyScalar(0.5);
          
          const invTorsoRot = this.torsoRotation.clone().invert();
          avgHandPos.applyQuaternion(invTorsoRot);
          
          const handForwardLean = Math.max(-0.08, Math.min(0.05, -avgHandPos.z * 0.08));
          const handSideLean = Math.max(-0.08, Math.min(0.08, avgHandPos.x * 0.1));
          
          const localVelocity = this.headVelocity.clone();
          localVelocity.applyQuaternion(invTorsoRot);
          
          // Calculate torso lean as REACTION to movement (trailing motion)
          // The thrusters push the chest/shoulders, lower body trails behind
          // Positive localVelocity.z = moving backward, negative = moving forward
          const targetLean = new THREE.Vector3(
            localVelocity.z * 0.6,   // Increased - moving forward = lower body trails back more
            0,
            -localVelocity.x * 0.5    // Increased - sideways sway
          );
          
          // Clamp to prevent seeing your own back, but allow more movement
          targetLean.x = Math.max(-0.35, Math.min(0.35, targetLean.x)); // Increased for more sway
          targetLean.z = Math.max(-0.3, Math.min(0.3, targetLean.z));   // Increased for sideways sway
          
          // Smoothly interpolate toward target (this prevents accumulation)
          this.torsoLean.x = THREE.MathUtils.lerp(this.torsoLean.x, targetLean.x, this.torsoLeanVelocity);
          this.torsoLean.y = THREE.MathUtils.lerp(this.torsoLean.y, targetLean.y, this.torsoLeanVelocity);
          this.torsoLean.z = THREE.MathUtils.lerp(this.torsoLean.z, targetLean.z, this.torsoLeanVelocity);
          
          const totalForwardLean = handForwardLean + this.torsoLean.x;
          const totalSideLean = handSideLean + this.torsoLean.z;
          
          const breathingExpansion = Math.sin(this.breathingPhase) * this.breathingAmount;
          
          if (this.bones.spine || this.bones.spine1 || this.bones.spine2) {
            // Strategy: Tilt HIPS (which tilts legs), then counter-rotate spine bones to keep chest stable
            const spineRotations = [
              { bone: this.bones.hips, amount: 1.5, breathingAmount: 0.0 },     // Hips - increased tilt for more leg sway
              { bone: this.bones.spine, amount: -1.0, breathingAmount: 0.3 },   // Lower spine - counter-rotate more
              { bone: this.bones.spine1, amount: -0.3, breathingAmount: 0.4 },  // Mid spine - slight counter
              { bone: this.bones.spine2, amount: -0.2, breathingAmount: 0.3 }   // Chest - counter to stay upright
            ];
            
            spineRotations.forEach(({ bone, amount, breathingAmount }) => {
              if (bone) {
                const breathingLean = -breathingExpansion * breathingAmount;
                const euler = new THREE.Euler(
                  -totalForwardLean * amount + breathingLean,
                  0,
                  -totalSideLean * amount,
                  'YXZ'
                );
                bone.quaternion.setFromEuler(euler);
              }
            });
          }
          
          // Head
          if (this.bones.neck) {
            const relativeHeadQuat = headQuat.clone();
            const invBodyQuat = this.torsoRotation.clone().invert();
            relativeHeadQuat.premultiply(invBodyQuat);
            
            const euler = new THREE.Euler().setFromQuaternion(relativeHeadQuat, 'YXZ');
            euler.x = -euler.x;
            euler.z = -euler.z;
            
            const correctedQuat = new THREE.Quaternion().setFromEuler(euler);
            this.bones.neck.quaternion.copy(correctedQuat);
          }
          
          // Arms (reuse existing IK)
          this.solveArmIK('left', leftHandPos, leftHandQuat);
          this.solveArmIK('right', rightHandPos, rightHandQuat);
          
          // ZERO-G LEGS (procedural animation)
          this.updateZeroGLegs(headPos, leftHandPos, rightHandPos, dt);
        },

        updateZeroGLegs: function(headPos, leftHandPos, rightHandPos, dt) {
          // Get velocity in body-local space to determine movement direction
          const invTorsoRot = this.torsoRotation.clone().invert();
          const localVel = this.headVelocity.clone().applyQuaternion(invTorsoRot);
          
          // Store sideways velocity for torso lean
          this.sidewaysVelocity = localVel.x;
          
          // Determine target pose based on velocity
          const speed = localVel.length();
          const targetPose = { ...this.legPoses.rest };
          
          if (speed > 0.1) {
            // Normalize velocity to get direction
            const velNorm = localVel.clone().normalize();
            
            // Calculate direction strengths
            const forwardAmount = Math.max(0, -velNorm.z); // Moving forward (negative Z in body space)
            const backwardAmount = Math.max(0, velNorm.z);  // Moving backward
            const upAmount = Math.max(0, velNorm.y);       // Moving up
            const downAmount = Math.max(0, -velNorm.y);    // Moving down
            const sidewaysAmount = Math.abs(velNorm.x);    // Moving sideways
            
            // Find strongest direction
            const directions = [
              { name: 'forward', amount: forwardAmount },
              { name: 'backward', amount: backwardAmount },
              { name: 'up', amount: upAmount },
              { name: 'down', amount: downAmount },
              { name: 'sideways', amount: sidewaysAmount }
            ];
            const strongest = directions.reduce((max, d) => d.amount > max.amount ? d : max);
            
            // Hysteresis: Only switch direction if new direction is strong enough
            const threshold = (this.currentDominantDirection === strongest.name) 
              ? this.directionMaintainThreshold  // Lower threshold to stay in current direction
              : this.directionSwitchThreshold;    // Higher threshold to switch to new direction
            
            if (strongest.amount > threshold || speed < 0.2) {
              this.currentDominantDirection = strongest.name;
            }
            // If speed is very low, return to rest
            if (speed < 0.2) {
              this.currentDominantDirection = 'rest';
            }
            
            // Blend poses (weighted average) but give extra weight to dominant direction
            const poseWeights = [
              { pose: this.legPoses.forward, weight: forwardAmount * (this.currentDominantDirection === 'forward' ? 1.3 : 1.0) },
              { pose: this.legPoses.backward, weight: backwardAmount * (this.currentDominantDirection === 'backward' ? 1.3 : 1.0) },
              { pose: this.legPoses.up, weight: upAmount * (this.currentDominantDirection === 'up' ? 1.3 : 1.0) },
              { pose: this.legPoses.down, weight: downAmount * (this.currentDominantDirection === 'down' ? 1.3 : 1.0) },
              { pose: this.legPoses.sideways, weight: sidewaysAmount * (this.currentDominantDirection === 'sideways' ? 1.3 : 1.0) }
            ];
            
            // Reset target pose
            targetPose.hipFlex = 0;
            targetPose.hipSpread = 0;
            targetPose.kneeBend = 0;
            targetPose.ankleFlex = 0;
            
            let totalWeight = 0;
            poseWeights.forEach(({ pose, weight }) => {
              if (weight > 0) {
                targetPose.hipFlex += pose.hipFlex * weight;
                targetPose.hipSpread += pose.hipSpread * weight;
                targetPose.kneeBend += pose.kneeBend * weight;
                targetPose.ankleFlex += pose.ankleFlex * weight;
                totalWeight += weight;
              }
            });
            
            // Normalize by total weight
            if (totalWeight > 0) {
              targetPose.hipFlex /= totalWeight;
              targetPose.hipSpread /= totalWeight;
              targetPose.kneeBend /= totalWeight;
              targetPose.ankleFlex /= totalWeight;
            }
            
            // Blend with rest pose based on speed
            const speedFactor = Math.min(1.0, speed);
            targetPose.hipFlex = THREE.MathUtils.lerp(this.legPoses.rest.hipFlex, targetPose.hipFlex, speedFactor);
            targetPose.hipSpread = THREE.MathUtils.lerp(this.legPoses.rest.hipSpread, targetPose.hipSpread, speedFactor);
            targetPose.kneeBend = THREE.MathUtils.lerp(this.legPoses.rest.kneeBend, targetPose.kneeBend, speedFactor);
            targetPose.ankleFlex = THREE.MathUtils.lerp(this.legPoses.rest.ankleFlex, targetPose.ankleFlex, speedFactor);
          }
          
          // Smoothly blend current pose toward target
          this.currentLegPose.hipFlex = THREE.MathUtils.lerp(this.currentLegPose.hipFlex, targetPose.hipFlex, this.legPoseBlendSpeed);
          this.currentLegPose.hipSpread = THREE.MathUtils.lerp(this.currentLegPose.hipSpread, targetPose.hipSpread, this.legPoseBlendSpeed);
          this.currentLegPose.kneeBend = THREE.MathUtils.lerp(this.currentLegPose.kneeBend, targetPose.kneeBend, this.legPoseBlendSpeed);
          this.currentLegPose.ankleFlex = THREE.MathUtils.lerp(this.currentLegPose.ankleFlex, targetPose.ankleFlex, this.legPoseBlendSpeed);
          
          // Add asymmetric leg poses for sideways movement and ankle sway
          const leftPose = { ...this.currentLegPose };
          const rightPose = { ...this.currentLegPose };
          
          const sidewaysVel = localVel.x;
          const sidewaysAmount = Math.abs(sidewaysVel);
          
          // Update idle animation phase
          this.legIdlePhase += dt * this.legIdleRate;
          
          // Add idle motion when stationary or moving slowly
          const idleInfluence = Math.max(0, 1.0 - speed * 2.0); // Fade out when moving
          const leftIdleOffset = Math.sin(this.legIdlePhase) * this.legIdleAmount * idleInfluence;
          const rightIdleOffset = Math.sin(this.legIdlePhase + Math.PI) * this.legIdleAmount * idleInfluence; // Opposite phase
          
          // Apply idle motion
          leftPose.hipFlex += leftIdleOffset * 0.5;
          leftPose.kneeBend += leftIdleOffset;
          leftPose.ankleFlex += leftIdleOffset * 0.3;
          rightPose.hipFlex += rightIdleOffset * 0.5;
          rightPose.kneeBend += rightIdleOffset;
          rightPose.ankleFlex += rightIdleOffset * 0.3;
          
          if (sidewaysAmount > 0.1) {
            if (sidewaysVel < 0) {
              // Moving left - left leg extends more, right leg bends more
              leftPose.kneeBend *= 0.6;  // Straighter
              rightPose.kneeBend *= 1.4;  // More bent
              leftPose.ankleSway = -15;   // Ankle tilts left
              rightPose.ankleSway = 10;
            } else {
              // Moving right - right leg extends more, left leg bends more
              rightPose.kneeBend *= 0.6;  // Straighter
              leftPose.kneeBend *= 1.4;   // More bent
              rightPose.ankleSway = 15;   // Ankle tilts right
              leftPose.ankleSway = -10;
            }
          } else {
            leftPose.ankleSway = 0;
            rightPose.ankleSway = 0;
          }
          
          // Smooth the poses to reduce jitter
          ['hipFlex', 'hipSpread', 'kneeBend', 'ankleFlex', 'ankleSway'].forEach(prop => {
            this.smoothedLegPose.left[prop] = THREE.MathUtils.lerp(
              this.smoothedLegPose.left[prop],
              leftPose[prop] || 0,
              this.legSmoothingFactor
            );
            this.smoothedLegPose.right[prop] = THREE.MathUtils.lerp(
              this.smoothedLegPose.right[prop],
              rightPose[prop] || 0,
              this.legSmoothingFactor
            );
          });
          
          // Apply smoothed poses to each leg
          this.applyLegPose('left', this.smoothedLegPose.left);
          this.applyLegPose('right', this.smoothedLegPose.right);
          
          // Track rotations for debugging (only mirror body)
          if (this.data.isMirror) {
            this.trackBoneRotation('leftUpLeg', this.bones.leftUpLeg);
            this.trackBoneRotation('leftLeg', this.bones.leftLeg);
            this.trackBoneRotation('leftFoot', this.bones.leftFoot);
            this.trackBoneRotation('rightUpLeg', this.bones.rightUpLeg);
            this.trackBoneRotation('rightLeg', this.bones.rightLeg);
            this.trackBoneRotation('rightFoot', this.bones.rightFoot);
          }
        },

        applyLegPose: function(side, pose) {
          const upLegBone = this.bones[`${side}UpLeg`];
          const legBone = this.bones[`${side}Leg`];
          const footBone = this.bones[`${side}Foot`];
          
          if (!upLegBone || !legBone || !footBone) return;
          
          // Convert degrees to radians
          const hipFlexRad = THREE.MathUtils.degToRad(pose.hipFlex);
          const hipSpreadRad = THREE.MathUtils.degToRad(pose.hipSpread) * (side === 'left' ? 1 : -1); // Flip mirroring
          const kneeBendRad = THREE.MathUtils.degToRad(pose.kneeBend);
          const ankleFlexRad = THREE.MathUtils.degToRad(pose.ankleFlex);
          const ankleSwayRad = THREE.MathUtils.degToRad(pose.ankleSway || 0); // Sway in Z-axis
          
          // HIP: Apply flex (X) and spread (Z in parent space)
          // Mixamo: Upper leg Y-axis points down the leg
          // Need 180Â° Z-rotation to flip legs to point down
          const hipZRot = Math.PI + hipSpreadRad; // 180 degrees base + spread
          upLegBone.rotation.set(hipFlexRad, 0, hipZRot, 'XYZ');
          
          // KNEE: Simple bend (X rotation)
          // Negative X = bend backward (natural knee direction)
          legBone.rotation.set(-kneeBendRad, 0, 0, 'XYZ');
          
          // ANKLE: Flex (X rotation) + Sway (Z rotation for sideways tilt)
          footBone.rotation.set(ankleFlexRad, 0, ankleSwayRad, 'XYZ');
        },

        solveLegIK: function(side, footTargetPos) {
          const upLegBone = this.bones[`${side}UpLeg`];
          const legBone = this.bones[`${side}Leg`];
          const footBone = this.bones[`${side}Foot`];
          
          if (!upLegBone || !legBone || !footBone) return;
          
          // Get hip position
          const hipPos = new THREE.Vector3();
          upLegBone.getWorldPosition(hipPos);
          
          // Two-bone IK (same as arms)
          const hipToFoot = footTargetPos.clone().sub(hipPos);
          const distance = hipToFoot.length();
          const maxReach = (this.config.upperLegLength + this.config.lowerLegLength) * 0.999;
          const minReach = Math.abs(this.config.upperLegLength - this.config.lowerLegLength) * 1.001;
          
          let targetFootPos = footTargetPos.clone();
          if (distance > maxReach) {
            targetFootPos = hipPos.clone().add(hipToFoot.normalize().multiplyScalar(maxReach));
          } else if (distance < minReach) {
            targetFootPos = hipPos.clone().add(hipToFoot.normalize().multiplyScalar(minReach));
          }
          
          // Law of cosines for knee angle
          const toTarget = targetFootPos.clone().sub(hipPos);
          const targetDist = toTarget.length();
          const toTargetDir = toTarget.normalize();
          
          const upperSq = this.config.upperLegLength * this.config.upperLegLength;
          const lowerSq = this.config.lowerLegLength * this.config.lowerLegLength;
          const distSq = targetDist * targetDist;
          
          const cosAngle = (upperSq + distSq - lowerSq) / (2 * this.config.upperLegLength * targetDist);
          const clampedCos = Math.max(-0.999, Math.min(0.999, cosAngle));
          const angle = Math.acos(clampedCos);
          
          // Knee bend direction (forward for legs)
          const bodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          let bendDir = bodyForward.clone().multiplyScalar(0.7);
          bendDir.addScaledVector(new THREE.Vector3(0, -1, 0), 0.3);
          bendDir.normalize();
          
          bendDir.addScaledVector(toTargetDir, -bendDir.dot(toTargetDir)).normalize();
          
          // Calculate knee position
          const kneeDir = new THREE.Vector3()
            .addScaledVector(toTargetDir, Math.cos(angle))
            .addScaledVector(bendDir, Math.sin(angle))
            .normalize();
          
          const kneeWorldPos = hipPos.clone().add(kneeDir.multiplyScalar(this.config.upperLegLength));
          
          // Convert to bone rotations
          this.el.object3D.updateMatrixWorld(true);
          
          // Upper leg (thigh) - COMPLETELY LOCK TWIST using lookAt approach
          upLegBone.parent.updateMatrixWorld(true);
          
          // Get positions in world space
          const hipWorldPos = new THREE.Vector3();
          upLegBone.getWorldPosition(hipWorldPos);
          
          // We want the bone to point at the knee
          const boneDir = kneeWorldPos.clone().sub(hipWorldPos).normalize();
          
          // Get the "up" direction - this prevents twist
          // For legs, "up" should be FORWARD (knees face forward, not sideways)
          const upDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          
          // Create rotation matrix that points bone at target with no twist
          // For Mixamo T-pose: legs point DOWN (Y-), so we map our direction to Y-axis
          const yAxis = boneDir.clone(); // Bone's Y points from hip to knee (positive direction)
          const zAxis = upDir.clone(); // Z axis = forward (knees face forward)
          
          // Make sure Z is perpendicular to Y
          zAxis.addScaledVector(yAxis, -zAxis.dot(yAxis)).normalize();
          
          // X axis completes the right-handed system
          const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
          
          // Build rotation matrix
          const rotMatrix = new THREE.Matrix4();
          rotMatrix.makeBasis(xAxis, yAxis, zAxis);
          
          // Convert to quaternion in parent's local space
          const worldQuat = new THREE.Quaternion().setFromRotationMatrix(rotMatrix);
          const parentWorldQuat = new THREE.Quaternion();
          upLegBone.parent.getWorldQuaternion(parentWorldQuat);
          
          const localQuat = worldQuat.clone().premultiply(parentWorldQuat.clone().invert());
          upLegBone.quaternion.copy(localQuat);
          upLegBone.updateMatrixWorld(true);
          
          // Lower leg (shin) - same twist-lock approach
          legBone.parent.updateMatrixWorld(true);
          
          const kneeWorldPosActual = new THREE.Vector3();
          legBone.getWorldPosition(kneeWorldPosActual);
          
          const shinDir = targetFootPos.clone().sub(kneeWorldPosActual).normalize();
          const shinUpDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          
          // Same mapping for shin
          const shinY = shinDir.clone(); // Positive direction
          const shinZ = shinUpDir.clone();
          shinZ.addScaledVector(shinY, -shinZ.dot(shinY)).normalize();
          const shinX = new THREE.Vector3().crossVectors(shinY, shinZ).normalize();
          
          const shinRotMatrix = new THREE.Matrix4();
          shinRotMatrix.makeBasis(shinX, shinY, shinZ);
          
          const shinWorldQuat = new THREE.Quaternion().setFromRotationMatrix(shinRotMatrix);
          const shinParentWorldQuat = new THREE.Quaternion();
          legBone.parent.getWorldQuaternion(shinParentWorldQuat);
          
          const shinLocalQuat = shinWorldQuat.clone().premultiply(shinParentWorldQuat.clone().invert());
          legBone.quaternion.copy(shinLocalQuat);
          legBone.updateMatrixWorld(true);
          
          // Foot (dynamic ankle flex based on momentum)
          if (footBone) {
            legBone.updateMatrixWorld(true);
            
            // Get body's forward direction
            const bodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
            
            // Get velocity in body-local space for momentum calculation
            const invTorsoRot = this.torsoRotation.clone().invert();
            const localVel = this.headVelocity.clone().applyQuaternion(invTorsoRot);
            
            // Calculate ankle flex based on momentum
            // When moving forward fast: feet point more forward (streamlined)
            // When stationary: feet relax more downward
            const forwardSpeed = Math.abs(localVel.z); // Forward/backward speed
            const flexAmount = Math.min(1.0, forwardSpeed * 2.0); // 0-1, max at 0.5 m/s
            
            // Calculate target foot angle
            // At rest: 90Â° (pointing down) = 0 radians from down
            // Moving: ~45Â° (pointing forward-down) = blend toward forward
            const downDir = new THREE.Vector3(0, -1, 0); // Straight down
            const forwardDownDir = new THREE.Vector3()
              .addScaledVector(bodyForward, 1.0)
              .addScaledVector(downDir, 1.0)
              .normalize(); // 45Â° between down and forward
            
            // Interpolate
            const footTargetDir = new THREE.Vector3()
              .addScaledVector(downDir, 1.0 - flexAmount)
              .addScaledVector(forwardDownDir, flexAmount)
              .normalize();
            
            // Apply using rotation matrix to prevent twist (same approach as legs)
            footBone.parent.updateMatrixWorld(true);
            
            const footWorldPos = new THREE.Vector3();
            footBone.getWorldPosition(footWorldPos);
            
            // Foot's Y-axis should point in target direction (Mixamo foot Y points forward in T-pose)
            const footY = footTargetDir.clone();
            
            // Z-axis should be body's up (prevent foot twist)
            const footZ = new THREE.Vector3(0, 1, 0); // World up
            footZ.addScaledVector(footY, -footZ.dot(footY)).normalize();
            
            // X completes the system
            const footX = new THREE.Vector3().crossVectors(footY, footZ).normalize();
            
            // Build rotation matrix
            const footRotMatrix = new THREE.Matrix4();
            footRotMatrix.makeBasis(footX, footY, footZ);
            
            // Convert to local space
            const footWorldQuat = new THREE.Quaternion().setFromRotationMatrix(footRotMatrix);
            const footParentWorldQuat = new THREE.Quaternion();
            footBone.parent.getWorldQuaternion(footParentWorldQuat);
            
            const footLocalQuat = footWorldQuat.clone().premultiply(footParentWorldQuat.clone().invert());
            footBone.quaternion.copy(footLocalQuat);
          }
          
          // Track bone rotations for debugging (only for mirror body to avoid double logging)
          if (this.data.isMirror) {
            this.trackBoneRotation('leftUpLeg', this.bones.leftUpLeg);
            this.trackBoneRotation('leftLeg', this.bones.leftLeg);
            this.trackBoneRotation('leftFoot', this.bones.leftFoot);
            this.trackBoneRotation('rightUpLeg', this.bones.rightUpLeg);
            this.trackBoneRotation('rightLeg', this.bones.rightLeg);
            this.trackBoneRotation('rightFoot', this.bones.rightFoot);
          }
        },

        // Track bone rotations for constraint debugging
        trackBoneRotation: function(boneName, bone) {
          if (!bone || !this.rotationExtremes[boneName]) return;
          
          const euler = new THREE.Euler().setFromQuaternion(bone.quaternion, 'XYZ');
          const degX = THREE.MathUtils.radToDeg(euler.x);
          const degY = THREE.MathUtils.radToDeg(euler.y);
          const degZ = THREE.MathUtils.radToDeg(euler.z);
          
          const track = this.rotationExtremes[boneName];
          track.x.min = Math.min(track.x.min, degX);
          track.x.max = Math.max(track.x.max, degX);
          track.y.min = Math.min(track.y.min, degY);
          track.y.max = Math.max(track.y.max, degY);
          track.z.min = Math.min(track.z.min, degZ);
          track.z.max = Math.max(track.z.max, degZ);
        },

        // Log all tracked rotation extremes (called by A button)
        logRotationExtremes: function() {
          console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
          console.log('LEG ROTATION EXTREMES (degrees) - for constraint implementation');
          console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
          
          const format = (val) => val === Infinity || val === -Infinity ? 'N/A' : val.toFixed(1);
          
          // Upper Legs (Hips)
          console.log('ðŸ¦µ UPPER LEGS (HIP JOINTS):');
          console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
          ['leftUpLeg', 'rightUpLeg'].forEach(bone => {
            const r = this.rotationExtremes[bone];
            console.log(`${bone}:`);
            console.log(`  X (flexion/extension - forward/back): ${format(r.x.min)}Â° to ${format(r.x.max)}Â°`);
            console.log(`  Y (internal/external rotation): ${format(r.y.min)}Â° to ${format(r.y.max)}Â°`);
            console.log(`  Z (abduction/adduction - spread/close): ${format(r.z.min)}Â° to ${format(r.z.max)}Â°`);
            console.log('');
          });
          
          // Lower Legs (Knees)
          console.log('\nðŸ¦µ LOWER LEGS (KNEE JOINTS):');
          console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
          ['leftLeg', 'rightLeg'].forEach(bone => {
            const r = this.rotationExtremes[bone];
            console.log(`${bone}:`);
            console.log(`  X (knee flexion - bend): ${format(r.x.min)}Â° to ${format(r.x.max)}Â°`);
            console.log(`  Y (knee rotation): ${format(r.y.min)}Â° to ${format(r.y.max)}Â°`);
            console.log(`  Z (knee twist): ${format(r.z.min)}Â° to ${format(r.z.max)}Â°`);
            console.log('');
          });
          
          // Feet (Ankles)
          console.log('\nðŸ¦¶ FEET (ANKLE JOINTS):');
          console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
          ['leftFoot', 'rightFoot'].forEach(bone => {
            const r = this.rotationExtremes[bone];
            console.log(`${bone}:`);
            console.log(`  X (dorsiflexion/plantarflexion - up/down): ${format(r.x.min)}Â° to ${format(r.x.max)}Â°`);
            console.log(`  Y (ankle rotation): ${format(r.y.min)}Â° to ${format(r.y.max)}Â°`);
            console.log(`  Z (inversion/eversion - roll): ${format(r.z.min)}Â° to ${format(r.z.max)}Â°`);
            console.log('');
          });
          
          console.log('\nðŸ’¡ HUMAN REFERENCE RANGES:');
          console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
          console.log('Hip Flexion: 0Â° to 125Â°');
          console.log('Hip Abduction: 0Â° to 45Â°');
          console.log('Hip Rotation: -45Â° to 45Â°');
          console.log('Knee Flexion: 0Â° to 135Â°');
          console.log('Ankle Dorsiflexion: -20Â° to 0Â°');
          console.log('Ankle Plantarflexion: 0Â° to 50Â°');
          console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        },

        solveArmIK: function(hand, handWorldPos, handWorldQuat) {
          const shoulderBone = this.bones[`${hand}Shoulder`];
          const upperArmBone = this.bones[`${hand}UpperArm`];
          const forearmBone = this.bones[`${hand}Forearm`];
          const handBone = this.bones[`${hand}HandBone`];
          
          if (!shoulderBone || !upperArmBone || !forearmBone) {
            return;
          }
          
          const shoulderWorldPos = new THREE.Vector3();
          shoulderBone.getWorldPosition(shoulderWorldPos);
          
          const adjustedHandPos = handWorldPos.clone();
          const leftRightOffsetLocal = new THREE.Vector3(hand === 'left' ? 0.1 : -0.1, 0, 0);
          const leftRightOffsetWorld = leftRightOffsetLocal.applyQuaternion(this.el.object3D.quaternion);
          adjustedHandPos.add(leftRightOffsetWorld);
          
          // Two-bone IK
          const shoulderToHand = adjustedHandPos.clone().sub(shoulderWorldPos);
          const distance = shoulderToHand.length();
          const maxReach = (this.config.upperArmLength + this.config.lowerArmLength) * 0.999;
          const minReach = Math.abs(this.config.upperArmLength - this.config.lowerArmLength) * 1.001;
          
          let targetHandPos = adjustedHandPos.clone();
          if (distance > maxReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(maxReach));
          } else if (distance < minReach) {
            targetHandPos = shoulderWorldPos.clone().add(shoulderToHand.normalize().multiplyScalar(minReach));
          }
          
          // Law of cosines
          const toTarget = targetHandPos.clone().sub(shoulderWorldPos);
          const targetDist = toTarget.length();
          const toTargetDir = toTarget.normalize();
          
          const upperSq = this.config.upperArmLength * this.config.upperArmLength;
          const lowerSq = this.config.lowerArmLength * this.config.lowerArmLength;
          const distSq = targetDist * targetDist;
          
          const cosAngle = (upperSq + distSq - lowerSq) / (2 * this.config.upperArmLength * targetDist);
          const clampedCos = Math.max(-0.999, Math.min(0.999, cosAngle));
          const angle = Math.acos(clampedCos);
          
          // Elbow bend direction
          const bodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.torsoRotation);
          const bodyRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.torsoRotation);
          const bodyOutward = bodyRight.clone().multiplyScalar(hand === 'left' ? -1 : 1);
          
          let bendDir = new THREE.Vector3()
            .addScaledVector(bodyOutward, 0.4)
            .addScaledVector(new THREE.Vector3(0, -1, 0), 0.4)
            .normalize();
          
          const handUp = new THREE.Vector3(0, 1, 0).applyQuaternion(handWorldQuat);
          bendDir.addScaledVector(handUp, 0.3);
          bendDir.normalize();
          bendDir.addScaledVector(toTargetDir, -bendDir.dot(toTargetDir)).normalize();
          
          // Calculate elbow
          const elbowDir = new THREE.Vector3()
            .addScaledVector(toTargetDir, Math.cos(angle))
            .addScaledVector(bendDir, Math.sin(angle))
            .normalize();
          
          let elbowWorldPos = shoulderWorldPos.clone().add(elbowDir.multiplyScalar(this.config.upperArmLength));
          
          // Enforce exact lengths
          const shoulderToElbow = elbowWorldPos.clone().sub(shoulderWorldPos);
          if (Math.abs(shoulderToElbow.length() - this.config.upperArmLength) > 0.0001) {
            elbowWorldPos.copy(shoulderWorldPos).add(shoulderToElbow.normalize().multiplyScalar(this.config.upperArmLength));
          }
          
          const elbowToHand = targetHandPos.clone().sub(elbowWorldPos);
          if (Math.abs(elbowToHand.length() - this.config.lowerArmLength) > 0.0001) {
            targetHandPos.copy(elbowWorldPos).add(elbowToHand.normalize().multiplyScalar(this.config.lowerArmLength));
          }
          
          // Convert to bone rotations
          this.el.object3D.updateMatrixWorld(true);
          
          // Upper Arm
          upperArmBone.parent.updateMatrixWorld(true);
          const shoulderInParent = upperArmBone.parent.worldToLocal(shoulderWorldPos.clone());
          const elbowInParent = upperArmBone.parent.worldToLocal(elbowWorldPos.clone());
          const upperArmParentDir = shoulderInParent.clone().sub(elbowInParent).normalize();
          const tPoseDir = new THREE.Vector3(0, -1, 0);
          const upperArmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, upperArmParentDir);
          upperArmBone.quaternion.copy(upperArmQuat);
          upperArmBone.updateMatrixWorld(true);
          
          // Forearm
          forearmBone.parent.updateMatrixWorld(true);
          const elbowInUpperArm = forearmBone.parent.worldToLocal(elbowWorldPos.clone());
          const handInUpperArm = forearmBone.parent.worldToLocal(targetHandPos.clone());
          const forearmParentDir = elbowInUpperArm.clone().sub(handInUpperArm).normalize();
          const forearmQuat = new THREE.Quaternion().setFromUnitVectors(tPoseDir, forearmParentDir);
          
          // Forearm twist
          forearmBone.updateMatrixWorld(true);
          const forearmWorldQuat = new THREE.Quaternion();
          forearmBone.getWorldQuaternion(forearmWorldQuat);
          const handRelativeForearm = handWorldQuat.clone();
          handRelativeForearm.premultiply(forearmWorldQuat.clone().invert());
          const handEuler = new THREE.Euler().setFromQuaternion(handRelativeForearm, 'YXZ');
          const twistAngle = handEuler.y;
          const forearmTwist = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0),
            twistAngle * 0.5
          );
          forearmBone.quaternion.copy(forearmQuat).multiply(forearmTwist);
          forearmBone.updateMatrixWorld(true);
          
          // Hand orientation
          if (handBone) {
            forearmBone.updateMatrixWorld(true);
            const forearmWorldQuat2 = new THREE.Quaternion();
            forearmBone.getWorldQuaternion(forearmWorldQuat2);
            let handLocalQuat = handWorldQuat.clone();
            handLocalQuat.premultiply(forearmWorldQuat2.clone().invert());
            const localXFlip = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI);
            handLocalQuat.multiply(localXFlip);
            const rollCorrection = new THREE.Quaternion().setFromAxisAngle(
              new THREE.Vector3(0, 1, 0),
              hand === 'left' ? Math.PI / 2 : -Math.PI / 2
            );
            handLocalQuat.multiply(rollCorrection);
            handBone.quaternion.copy(handLocalQuat);
          }
        },

        updateFingerPoses: function() {
          const leftGamepad = this.leftController.components['tracked-controls']?.controller?.gamepad;
          const rightGamepad = this.rightController.components['tracked-controls']?.controller?.gamepad;
          
          if (!this.fingerDebugLogged) {
            console.log('[Finger Tracking] Left gamepad buttons:', leftGamepad?.buttons?.length);
            if (leftGamepad && leftGamepad.buttons) {
              console.log('[Finger Tracking] Button details:');
              leftGamepad.buttons.forEach((btn, i) => {
                if (btn.touched || btn.pressed) {
                  console.log(`  Button ${i}: pressed=${btn.pressed}, touched=${btn.touched}, value=${btn.value}`);
                }
              });
              console.log('[Finger Tracking] Touch any button/surface and check console to see which index it is');
            }
            this.fingerDebugLogged = true;
          }
          
          if (leftGamepad && leftGamepad.buttons) {
            const trigger = leftGamepad.buttons[0]?.value || 0;
            const grip = leftGamepad.buttons[1]?.value || 0;
            
            let anyThumbTouch = 0;
            for (let i = 2; i <= 6; i++) {
              if (leftGamepad.buttons[i]?.touched) {
                anyThumbTouch = 1;
                break;
              }
            }
            
            this.updateTargetCurls('left', trigger, grip, anyThumbTouch);
          }
          
          if (rightGamepad && rightGamepad.buttons) {
            const trigger = rightGamepad.buttons[0]?.value || 0;
            const grip = rightGamepad.buttons[1]?.value || 0;
            
            let anyThumbTouch = 0;
            for (let i = 2; i <= 6; i++) {
              if (rightGamepad.buttons[i]?.touched) {
                anyThumbTouch = 1;
                break;
              }
            }
            
            this.updateTargetCurls('right', trigger, grip, anyThumbTouch);
          }
          
          ['left', 'right'].forEach(hand => {
            ['thumb', 'index', 'middle', 'ring', 'pinky'].forEach(finger => {
              const current = this.currentCurls[hand][finger];
              const target = this.targetCurls[hand][finger];
              this.currentCurls[hand][finger] = current + (target - current) * this.fingerSmoothingFactor;
            });
          });
          
          this.applyFingerCurls('left', this.currentCurls.left);
          this.applyFingerCurls('right', this.currentCurls.right);
        },

        updateTargetCurls: function(hand, trigger, grip, thumbTouch) {
          const restingCurls = {
            thumb: 0.1,
            index: 0.15,
            middle: 0.2,
            ring: 0.25,
            pinky: 0.25
          };
          
          const activeCurls = {
            thumb: thumbTouch * 0.8,
            index: trigger,
            middle: grip * 1.1,
            ring: grip * 1.15,
            pinky: grip * 1.2
          };
          
          if (grip > 0.1 && trigger < 0.1) {
            activeCurls.index = 0;
          }
          
          const curls = {
            thumb: Math.max(restingCurls.thumb, activeCurls.thumb),
            index: Math.max(restingCurls.index, activeCurls.index),
            middle: Math.max(restingCurls.middle, activeCurls.middle),
            ring: Math.max(restingCurls.ring, activeCurls.ring),
            pinky: Math.max(restingCurls.pinky, activeCurls.pinky)
          };
          
          if (grip > 0.1 && trigger < 0.1) {
            curls.index = 0.05;
          }
          
          if (grip > 0.5 && thumbTouch < 0.5) {
            curls.thumb = -0.15;
          }
          
          this.targetCurls[hand] = curls;
        },

        applyFingerCurls: function(hand, curls) {
          const fingerBones = {
            thumb: hand === 'left' ? [this.bones.leftHandThumb1, this.bones.leftHandThumb2, this.bones.leftHandThumb3] : 
                                     [this.bones.rightHandThumb1, this.bones.rightHandThumb2, this.bones.rightHandThumb3],
            index: hand === 'left' ? [this.bones.leftHandIndex1, this.bones.leftHandIndex2, this.bones.leftHandIndex3] :
                                     [this.bones.rightHandIndex1, this.bones.rightHandIndex2, this.bones.rightHandIndex3],
            middle: hand === 'left' ? [this.bones.leftHandMiddle1, this.bones.leftHandMiddle2, this.bones.leftHandMiddle3] :
                                      [this.bones.rightHandMiddle1, this.bones.rightHandMiddle2, this.bones.rightHandMiddle3],
            ring: hand === 'left' ? [this.bones.leftHandRing1, this.bones.leftHandRing2, this.bones.leftHandRing3] :
                                    [this.bones.rightHandRing1, this.bones.rightHandRing2, this.bones.rightHandRing3],
            pinky: hand === 'left' ? [this.bones.leftHandPinky1, this.bones.leftHandPinky2, this.bones.leftHandPinky3] :
                                     [this.bones.rightHandPinky1, this.bones.rightHandPinky2, this.bones.rightHandPinky3]
          };
          
          Object.keys(fingerBones).forEach(fingerName => {
            const bones = fingerBones[fingerName];
            const curl = curls[fingerName];
            
            const isThumb = fingerName === 'thumb';
            const axis = isThumb ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(1, 0, 0);
            const sign = isThumb ? (hand === 'left' ? -1 : 1) : 1;
            
            bones.forEach((bone, i) => {
              if (!bone) return;
              
              const initialRot = this.initialBoneRotations[bone.name];
              if (initialRot) {
                bone.quaternion.copy(initialRot);
              }
              
              const curlAmount = curl * (0.5 + i * 0.25);
              const curlAngle = curlAmount * Math.PI * 0.6 * sign;
              
              const curlQuat = new THREE.Quaternion().setFromAxisAngle(axis, curlAngle);
              bone.quaternion.multiply(curlQuat);
            });
          });
        }
      });
    </script>
  </body>
</html>

