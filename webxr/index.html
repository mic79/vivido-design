<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Environment</title>
    <meta name="description" content="Basic WebXR environment using A-Frame">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://unpkg.com/aframe-glow-component@1.0.0/dist/aframe-glow-component.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="advanced-bot.js"></script>
  </head>
  <body>
    <script>
      // Physics world setup
      const world = new CANNON.World();
      world.gravity.set(0, 0, 0); // Zero gravity for the world
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // Create materials
      const defaultMaterial = new CANNON.Material('default');
      const ballMaterial = new CANNON.Material('ball');
      const floorMaterial = new CANNON.Material('floor');
      const racketMaterial = new CANNON.Material('racket');
      const backWallMaterial = new CANNON.Material('backWall');

      // Create contact materials
      const ballFloorContact = new CANNON.ContactMaterial(
        ballMaterial,
        floorMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballFloorContact);

      // Add contact material for ball vs. default (walls/ceiling)
      const ballDefaultContact = new CANNON.ContactMaterial(
        ballMaterial,
        defaultMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballDefaultContact);

      // Add contact material for ball vs. ball
      const ballBallContact = new CANNON.ContactMaterial(
        ballMaterial,
        ballMaterial,
        {
          friction: 0.0,
          restitution: 1.0
        }
      );
      world.addContactMaterial(ballBallContact);

      // Add contact material for ball vs. racket (with friction for spin)
      const ballRacketContact = new CANNON.ContactMaterial(
        ballMaterial,
        racketMaterial,
        {
          friction: 0.8,  // Very high friction for spin transfer
          restitution: 0.85,  // Slightly less bouncy than walls
          contactEquationStiffness: 1e8,  // Stiffer contact for better spin transfer
          contactEquationRelaxation: 3    // Better contact resolution
        }
      );
      world.addContactMaterial(ballRacketContact);

      // Add contact material for ball vs. back walls (no bounce - should respawn)
      const ballBackWallContact = new CANNON.ContactMaterial(
        ballMaterial,
        backWallMaterial,
        {
          friction: 0.0,
          restitution: 0.0  // No bounce - ball should respawn instead
        }
      );
      world.addContactMaterial(ballBackWallContact);

      // Add collision event handling to the physics world
      world.addEventListener('beginContact', function(event) {
        const bodyA = event.bodyA;
        const bodyB = event.bodyB;
        
        // Get the A-Frame entities associated with these bodies
        const entityA = bodyA.el;
        const entityB = event.bodyB.el;
        
        // Physics world collision detection (for ball-ball and ball-wall collisions)
        
        if (entityA && entityB) {
          // Check if either entity is a ball
          const isBallA = entityA.hasAttribute('simple-grab');
          const isBallB = entityB.hasAttribute('simple-grab');
          
          // If both are balls, play bounce sound at collision point
          if (isBallA && isBallB) {
            const bounceSound = document.querySelector('#bounce-sound');
            if (bounceSound) {
              // Calculate collision point as midpoint between balls
              const collisionPoint = new THREE.Vector3();
              collisionPoint.addVectors(bodyA.position, bodyB.position).multiplyScalar(0.5);
              bounceSound.object3D.position.copy(collisionPoint);
              // Stop any currently playing sound before starting a new one
              bounceSound.components.sound.stopSound();
              bounceSound.components.sound.playSound();
            }
          }
          
          // Create and dispatch collision events for both entities
          const eventA = new CustomEvent('collision', {
            detail: { body: bodyB, bodyEl: entityB }
          });
          const eventB = new CustomEvent('collision', {
            detail: { body: bodyA, bodyEl: entityA }
          });
          
          entityA.dispatchEvent(eventA);
          entityB.dispatchEvent(eventB);
        }
      });

      // Add end contact event handling
      world.addEventListener('endContact', function(event) {
        const bodyA = event.bodyA;
        const bodyB = event.bodyB;
        
        // Check for racket-ball contact ending
        if (bodyA.isRacket) {
          bodyA.isInContact = false;
          bodyA.contactBall = null;
        }
        if (bodyB.isRacket) {
          bodyB.isInContact = false;
          bodyB.contactBall = null;
        }
      });

      // Game state
      const gameState = {
        score: { player1: 0, player2: 0 },
        timeRemaining: 120, // 2 minutes in seconds
        isPlaying: false,
        isReady: { player1: false, player2: false },
        ballSpawned: { player1: false, player2: false }
      };

      // Racket mode state - independent per player
      const racketMode = {
        player1: false, // Red player / opponent in multiplayer
        player2: false  // Blue player / local player
      };

      // Multiplayer state
      let isMultiplayer = false;
      let isHost = false;
      let peer = null;
      let conn = null;
      let multiplayerSlot = null;
      let multiplayerStatus = 'Singleplayer';
      let hasConnected = false;
      const MAX_LOBBIES = 10;
      let multiplayerStartType = 'dodgeball';
      let sessionID = null;
      let connectionState = 'disconnected';
      let lastMultiplayerToggle = 0;
      let remotePlayerState = null;
      let remoteBallState = null;
      let multiplayerCleanup = null;
      let isSearchingForMatch = false;

      // Helper: update version display with status
      function updateMultiplayerStatus(text) {
        const versionDisplay = document.getElementById('version-display');
        if (versionDisplay) {
          versionDisplay.setAttribute('text', 'value', `v0.20 | ${text}`);
        }
      }

      // Listen for Y button to toggle multiplayer
      AFRAME.registerComponent('multiplayer-toggle', {
        init: function() {
          this.el.sceneEl.addEventListener('ybuttondown', () => {
            const now = Date.now();
            if (now - lastMultiplayerToggle < 1000) return; // debounce
            lastMultiplayerToggle = now;
            if (!isMultiplayer) {
              updateMultiplayerStatus('Searching for match...');
              isSearchingForMatch = true;
              startMultiplayerConnection();
            } else {
              updateMultiplayerStatus('Returning to singleplayer...');
              isSearchingForMatch = false;
              endMultiplayer();
            }
          });

          // Listen for B button to toggle racket mode with debounce
          let lastBButtonTime = 0;
          this.el.sceneEl.addEventListener('bbuttondown', () => {
            const now = Date.now();
            if (now - lastBButtonTime < 500) return; // 500ms debounce
            lastBButtonTime = now;
            toggleRacketMode();
          });
        }
      });

      // Racket mode toggle function - per player
      function toggleRacketMode() {
        // Determine which player is toggling (local player is always player2)
        const player = isMultiplayer ? 'player2' : 'player2'; // Local player controls player2 rackets
        
        racketMode[player] = !racketMode[player];
        
        // Get racket elements for the local player (always left/right hand)
        const leftRacket = document.querySelector('#leftHandRacket');
        const rightRacket = document.querySelector('#rightHandRacket');
        
        // Show/hide local player's rackets
        if (racketMode[player]) {
          if (leftRacket) leftRacket.setAttribute('visible', true);
          if (rightRacket) rightRacket.setAttribute('visible', true);
          console.log('Racket mode activated for', player);
        } else {
          if (leftRacket) leftRacket.setAttribute('visible', false);
          if (rightRacket) rightRacket.setAttribute('visible', false);
          console.log('Racket mode deactivated for', player);
        }
        
        // Send racket mode state to opponent in multiplayer
        if (isMultiplayer && conn && conn.open) {
          conn.send({ type: 'racket-mode', player: player, active: racketMode[player] });
        }
      }

      // Multiplayer connection logic (slot-based, PeerJS, TURN support)
      async function startMultiplayerConnection() {
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        // Keep bot enabled during connection phase
        isMultiplayer = false;
        try {
          const slot = await findAvailableSlot(multiplayerStartType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupHost(multiplayerSlot);
          } else {
            await setupPeer(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      async function checkPeerAvailability(id) {
        return new Promise((resolve) => {
          const tempPeer = new Peer(id, { host: "0.peerjs.com", port: 443, secure: true });
          const timeout = setTimeout(() => {
            tempPeer.destroy();
            resolve(false);
          }, 2000);
          tempPeer.on("open", () => {
            clearTimeout(timeout);
            tempPeer.destroy();
            resolve(true);
          });
          tempPeer.on("error", (err) => {
            clearTimeout(timeout);
            tempPeer.destroy();
            if (err.type === 'unavailable-id') {
              resolve(false);
            } else {
              resolve(true);
            }
          });
        });
      }

      async function findAvailableSlot(desiredStartType) {
        for (let i = 1; i <= MAX_LOBBIES; i++) {
          const hostId = `dot-host-${desiredStartType}-${i}`;
          const peerId = `dot-peer-${desiredStartType}-${i}`;
          const hostAvailable = await checkPeerAvailability(hostId);
          if (hostAvailable) {
            return { slotNumber: i, role: 'host' };
          } else {
            const peerAvailable = await checkPeerAvailability(peerId);
            if (peerAvailable) {
              return { slotNumber: i, role: 'peer' };
            }
          }
        }
        return null;
      }

      async function setupPeer(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = false;
        sessionID = `dot-peer-${multiplayerStartType}-${slotNumber}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Connecting to host...');
          const hostID = `dot-host-${multiplayerStartType}-${slotNumber}`;
          conn = peer.connect(hostID);
          conn.on("open", function() {
            setupConnectionHandlers(conn);
            onMultiplayerStart();
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      async function setupHost(slotNumber) {
        cleanupMultiplayer();
        isMultiplayer = true;
        isHost = true;
        sessionID = `dot-host-${multiplayerStartType}-${slotNumber}`;
        let iceServersConfig = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        try {
          const response = await fetch("https://dotmination-turn-proxy.odd-bird-4c2c.workers.dev/");
          if (response.ok) {
            iceServersConfig = await response.json();
          }
        } catch (e) {}
        peer = new Peer(sessionID, {
          host: "0.peerjs.com",
          port: 443,
          secure: true,
          config: { 'iceServers': iceServersConfig }
        });
        peer.on("open", function() {
          updateMultiplayerStatus('Waiting for opponent...');
          peer.on("connection", function(newConn) {
            if (conn) {
              newConn.close();
            } else {
              conn = newConn;
              conn.on("open", function() {
                setupConnectionHandlers(conn);
                onMultiplayerStart();
              });
            }
          });
        });
        peer.on("error", function(err) {
          updateMultiplayerStatus(`Peer error: ${err.type}`);
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function setupConnectionHandlers(conn) {
        conn.on('data', (data) => {
          if (data.type === 'player-state') {
            remotePlayerState = data.state;
          } else if (data.type === 'ball-state') {
            remoteBallState = data.state;
          } else if (data.type === 'score-update') {
            // Mirror remote/local for display
            multiplayerScore.remote = data.score.local;
            multiplayerScore.local = data.score.remote;
            updateScoreDisplayMultiplayer();
          } else if (data.type === 'racket-mode') {
            // Sync opponent's racket mode state
            racketMode.player1 = data.active; // Remote player becomes player1
            console.log('Opponent racket mode:', data.active ? 'ON' : 'OFF');
          }
        });
        conn.on('close', () => {
          updateMultiplayerStatus('Connection lost. Returning to singleplayer.');
          setTimeout(() => {
            endMultiplayer();
          }, 100); // Small delay to ensure proper cleanup
        });
        conn.on('error', (err) => {
          updateMultiplayerStatus('Connection error. Returning to singleplayer.');
          setTimeout(() => {
            endMultiplayer();
          }, 100);
        });
      }

      function sendPlayerState(state) {
        if (conn && conn.open) {
          conn.send({ type: 'player-state', state });
        }
      }
      function sendBallState(state) {
        if (conn && conn.open) {
          conn.send({ type: 'ball-state', state });
        }
      }

      function onMultiplayerStart() {
        // Only fully start multiplayer when connection is established
        if (conn && conn.open) {
          // Hide bot, disable bot logic
          const bot = document.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          isMultiplayer = true;
          multiplayerStatus = 'Multiplayer Connected';
          updateMultiplayerStatus('Multiplayer Connected');
          isSearchingForMatch = false;
          
          // Switch to multiplayer score display immediately
          multiplayerScore = { local: 0, remote: 0 };
          updateScoreDisplayMultiplayer();
        }
      }
      function endMultiplayer() {
        isMultiplayer = false;
        multiplayerStatus = 'Singleplayer';
        updateMultiplayerStatus('Singleplayer');
        cleanupMultiplayer();
        // Re-enable bot
        const bot = document.querySelector('[advanced-bot]');
        if (bot) bot.setAttribute('advanced-bot', 'enabled', true);
        remotePlayerState = null;
        remoteBallState = null;
        multiplayerScore = { local: 0, remote: 0 };
        
        // Reset the actual game manager scores
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].playerScore = 0;
          gameManager.components['game-manager'].botScore = 0;
        }
        
        // Restore singleplayer score display
        const scoreDisplay = document.getElementById('score-display');
        if (scoreDisplay) {
          scoreDisplay.setAttribute('text', 'value', 'Player: 0 - Bot: 0');
        }
        isSearchingForMatch = false;
        // Set bot to default singleplayer position (head height)
        const botEntity = document.querySelector('[advanced-bot]');
        if (botEntity) {
          botEntity.object3D.position.set(0, 1.6, -6);
          botEntity.object3D.rotation.set(0, 0, 0);
        }
      }
      function cleanupMultiplayer() {
        if (conn) { try { conn.close(); } catch(e){} }
        if (peer) { try { peer.destroy(); } catch(e){} }
        conn = null;
        peer = null;
        multiplayerSlot = null;
        hasConnected = false;
      }

      // Attach multiplayer-toggle to scene
      document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene && !scene.hasAttribute('multiplayer-toggle')) {
          scene.setAttribute('multiplayer-toggle', '');
        }
        // Wait for the scene to load, then set bot to default singleplayer position (head height) at startup
        function setBotToDefaultPosition() {
          const botEntity = document.querySelector('[advanced-bot]');
          if (botEntity) {
            botEntity.object3D.position.set(0, 1.6, -6);
            botEntity.object3D.rotation.set(0, 0, 0);
          } else {
            setTimeout(setBotToDefaultPosition, 50);
          }
        }
        if (scene) {
          scene.addEventListener('loaded', setBotToDefaultPosition);
        } else {
          setBotToDefaultPosition();
        }
      });

      // --- GAME STATE SYNC ---
      // In tick, send local player2 (blue) and ball state; apply mirrored remote to player1 (red)
      AFRAME.registerComponent('multiplayer-sync', {
        tick: function() {
          // In multiplayer, send the local camera's world position/rotation as player state
          if (isMultiplayer && conn && conn.open) {
            const camera = document.querySelector('[camera]');
            if (camera) {
              const worldPos = new THREE.Vector3();
              camera.object3D.getWorldPosition(worldPos);
              const worldQuat = new THREE.Quaternion();
              camera.object3D.getWorldQuaternion(worldQuat);
              const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
              sendPlayerState({
                x: worldPos.x, y: worldPos.y, z: worldPos.z,
                rx: worldRot.x, ry: worldRot.y, rz: worldRot.z
              });
            }
          }
          // In multiplayer, update the red player (bot) with the mirrored remote player state
          if (isMultiplayer && remotePlayerState) {
            const mirroredX = -remotePlayerState.x;
            const mirroredZ = -remotePlayerState.z;
            const mirroredRy = -remotePlayerState.ry;
            const player1 = document.querySelector('[advanced-bot]');
            if (player1) {
              player1.object3D.position.set(mirroredX, remotePlayerState.y, mirroredZ);
              player1.object3D.rotation.set(remotePlayerState.rx, mirroredRy, 0);
            }
          }
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          if (blueBall) {
            const pos = blueBall.object3D.position;
            const rot = blueBall.components['simple-grab']?.body?.velocity || {x:0,y:0,z:0};
            sendBallState({ x: pos.x, y: pos.y, z: pos.z, rx: rot.x, ry: rot.y, rz: rot.z, vx: rot.x, vy: rot.y, vz: rot.z });
          }
          // --- REMOTE PLAYER (ALWAYS RED, MIRRORED X/Z) ---
          if (remotePlayerState) {
            const mirroredX = -remotePlayerState.x;
            const mirroredZ = -remotePlayerState.z;
            const mirroredVx = -remotePlayerState.vx;
            const mirroredVz = -remotePlayerState.vz;
            const mirroredRy = -remotePlayerState.ry;
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall) {
              redBall.object3D.position.set(mirroredX, remotePlayerState.y, mirroredZ);
              redBall.object3D.rotation.set(remotePlayerState.rx, mirroredRy, remotePlayerState.rz);
              if (redBall.components['simple-grab']?.body) {
                redBall.components['simple-grab'].body.position.set(mirroredX, remotePlayerState.y, mirroredZ);
                redBall.components['simple-grab'].body.velocity.set(mirroredVx, remotePlayerState.vy, mirroredVz);
              }
            }
          }
          // --- REMOTE BALL (ALWAYS RED, MIRRORED X/Z) ---
          if (remoteBallState) {
            const mirroredX = -remoteBallState.x;
            const mirroredZ = -remoteBallState.z;
            const mirroredVx = -remoteBallState.vx;
            const mirroredVz = -remoteBallState.vz;
            const mirroredRy = -remoteBallState.ry;
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall) {
              redBall.object3D.position.set(mirroredX, remoteBallState.y, mirroredZ);
              redBall.object3D.rotation.set(remoteBallState.rx, mirroredRy, remoteBallState.rz);
              if (redBall.components['simple-grab']?.body) {
                redBall.components['simple-grab'].body.position.set(mirroredX, remoteBallState.y, mirroredZ);
                redBall.components['simple-grab'].body.velocity.set(mirroredVx, remoteBallState.vy, mirroredVz);
              }
            }
          }
          // Prevent local input from affecting Player 1 (red) and their ball in multiplayer
          if (isMultiplayer && conn && conn.open) {
            const redBall = document.querySelector('[simple-grab="player: player1"]');
            if (redBall && redBall.components['simple-grab']) {
              redBall.components['simple-grab'].isGrabbed = false;
              redBall.components['simple-grab'].grabbingHand = null;
            }
          }
        }
      });

      // --- MULTIPLAYER SCORE SYNC ---
      // Multiplayer score state
      let multiplayerScore = { local: 0, remote: 0 };
      function sendScoreUpdate() {
        if (conn && conn.open) {
          conn.send({ type: 'score-update', score: multiplayerScore });
        }
      }
      function updateScoreDisplayMultiplayer() {
        const scoreDisplay = document.getElementById('score-display');
        if (scoreDisplay) {
          scoreDisplay.setAttribute('text', 'value', `You: ${multiplayerScore.local} - Opponent: ${multiplayerScore.remote}`);
        }
      }
      // Patch game manager to sync score in multiplayer, but only after A-Frame and the component are loaded
      function patchGameManagerScoreSync() {
        const gm = AFRAME.components['game-manager'];
        if (!gm || !gm.Component) return false;
        if (gm.Component.prototype._multiplayerPatched) return true;
        const origOnBotHit = gm.Component.prototype.onBotHit;
        const origOnPlayerHit = gm.Component.prototype.onPlayerHit;
        gm.Component.prototype.onBotHit = function() {
          if (isMultiplayer && conn && conn.open) {
            // Always increment local score when you hit the opponent
            multiplayerScore.local += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            // Use singleplayer scoring when not in active multiplayer connection
            origOnBotHit.call(this);
          }
        };
        gm.Component.prototype.onPlayerHit = function() {
          if (isMultiplayer && conn && conn.open) {
            // Always increment remote score when opponent hits you
            multiplayerScore.remote += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            // Use singleplayer scoring when not in active multiplayer connection
            origOnPlayerHit.call(this);
          }
        };
        gm.Component.prototype._multiplayerPatched = true;
        return true;
      }
      // Wait for A-Frame and scene to be loaded before patching
      function tryPatchGameManager() {
        if (!patchGameManagerScoreSync()) {
          setTimeout(tryPatchGameManager, 100);
        }
      }
      document.addEventListener('DOMContentLoaded', () => {
        if (document.querySelector('a-scene')) {
          document.querySelector('a-scene').addEventListener('loaded', tryPatchGameManager);
        } else {
          setTimeout(tryPatchGameManager, 100);
        }
      });

      // Hand collider component - 144Hz optimized for Quest 3
      AFRAME.registerComponent('hand-collider', {
        init: function() {
          this.el.addEventListener('triggerdown', this.onGripDown.bind(this));
          this.el.addEventListener('triggerup', this.onGripUp.bind(this));
          
          // Create a collision body for the hand
          const shape = new CANNON.Sphere(0.1); // Increased from 0.05 to 0.1
          this.body = new CANNON.Body({
            mass: 0, // Static body
            shape: shape,
            material: defaultMaterial,
            collisionFilterGroup: 2, // Use a different collision group
            collisionFilterMask: 0, // Don't collide with anything
            type: CANNON.Body.KINEMATIC // Use kinematic body to prevent physical interactions
          });
          
          // Store reference to the entity on the body
          this.body.el = this.el;
          
          world.addBody(this.body);
          
          // Track if trigger is held
          this.isTriggerHeld = false;
          this.lastGrabCheck = 0;

          // Determine which player this hand belongs to
          this.isLeftHand = this.el.id === 'leftHand';
          this.player = this.isLeftHand ? 'player2' : 'player2'; // Both hands control player2's ball
        },
        
        tick: function() {
          // Update physics body position to match hand position at full framerate
          const handWorldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(handWorldPos);
          this.body.position.copy(handWorldPos);
          
          // If trigger is held, check for grabbable objects at 144Hz
          if (this.isTriggerHeld) {
            const now = Date.now();
            if (now - this.lastGrabCheck > 7) { // 144Hz - 6.94ms for Quest 3 optimization
              this.checkForGrabbableObjects();
              this.lastGrabCheck = now;
            }
          }
        },
        
        checkForGrabbableObjects: function() {
          const grabbableObjects = this.el.sceneEl.querySelectorAll('[simple-grab]');
          
          grabbableObjects.forEach(obj => {
            if (!obj.components['simple-grab']) return;
            
            // Check if the ball belongs to this player
            const ballPlayer = obj.components['simple-grab'].data.player;
            if (ballPlayer !== this.player) return;
            
            const ballBody = obj.components['simple-grab'].body;
            if (!ballBody) return;
            
            // Check if bodies are colliding
            const distance = this.body.position.distanceTo(ballBody.position);
            const minDistance = this.body.shapes[0].radius + ballBody.shapes[0].radius;
            
            if (distance <= minDistance && !obj.components['simple-grab'].isGrabbed) {
              obj.components['simple-grab'].onGripDown({ target: this.el });
            }
          });
        },
        
        onGripDown: function(evt) {
          this.isTriggerHeld = true;
          this.checkForGrabbableObjects();
        },
        
        onGripUp: function(evt) {
          this.isTriggerHeld = false;
          const grabbableObjects = this.el.sceneEl.querySelectorAll('[simple-grab]');
          grabbableObjects.forEach(obj => {
            if (obj.components['simple-grab'].isGrabbed) {
              obj.components['simple-grab'].onGripUp({ target: this.el });
            }
          });
        }
      });

      // Simple grab component
      AFRAME.registerComponent('simple-grab', {
        schema: {
          player: { type: 'string', default: 'player1' }  // Add player ownership
        },
        init: function() {
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.body = null;
          
          // Set initial position based on player
          const spawnZ = this.data.player === 'player1' ? -5.5 : 5.5;
          this.initialPosition = new CANNON.Vec3(0, 1.0, spawnZ);
          
          const shape = new CANNON.Sphere(0.1);
          this.body = new CANNON.Body({
            mass: 1,
            shape: shape,
            position: this.initialPosition,
            material: ballMaterial,
            linearDamping: 0.0,
            angularDamping: 0.0,
            collisionFilterGroup: 1,
            collisionFilterMask: 1
          });
          this.body.gravity = new CANNON.Vec3(0, 0, 0);
          world.addBody(this.body);

          // Store reference to the entity on the body
          this.body.el = this.el;
          
          // Track previous rotation for spin calculation
          this.lastRotation = new THREE.Quaternion();
          this.lastPosition = new THREE.Vector3();
          this.lastPositionTime = 0;
          
          // Velocity smoothing for consistent throwing
          this.velocityHistory = [];
          this.maxHistorySize = 5;

          // Listen for A button press on the scene
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            // Get the hand that pressed the button
            const hand = evt.target;
            const isLeftHand = hand.id === 'leftHand';
            const isRightHand = hand.id === 'rightHand';
            
            // Check if this ball belongs to the player who pressed the button
            const isPlayer1Ball = this.data.player === 'player1';
            const isPlayer2Ball = this.data.player === 'player2';
            
            // Left hand controls player1's ball, right hand controls player2's ball
            if ((isLeftHand && isPlayer1Ball) || (isRightHand && isPlayer2Ball)) {
              this.resetPosition();
            }
          });

          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            // Helper to respawn this ball
            const respawn = () => {
              this.resetPosition();
            };
            // Player2's ball (blue) hits bot's target sphere
            if (this.data.player === 'player2' && collider && collider.id === 'bot-target') {
              const bot = document.querySelector('[bot]');
              const impactEffect = bot && bot.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              respawn();
              return;
            }
            // Player1's ball (red) hits player target sphere (blue, id="player-target")
            if (this.data.player === 'player1' && collider && collider.id === 'player-target') {
              const impactEffect = document.querySelector('#player').components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              respawn();
              return;
            }
            // Any ball hits back wall (z = 8 or z = -8)
            if (collider && collider.getAttribute && collider.getAttribute('geometry')) {
              const geom = collider.getAttribute('geometry');
              const pos = collider.getAttribute('position');
              // Check for back wall by position and geometry
              if (pos && geom && geom.width === 4 && geom.height === 4 && (Math.abs(pos.z - 8) < 0.01 || Math.abs(pos.z + 8) < 0.01)) {
                respawn();
                return;
              }
            }
          });
        },
        
        resetPosition: function() {
          if (this.constraint) {
            world.removeConstraint(this.constraint);
            this.constraint = null;
          }
          if (this.handBody) {
            world.removeBody(this.handBody);
            this.handBody = null;
          }
          this.body.position.copy(this.initialPosition);
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          this.body.quaternion.set(0, 0, 0, 1);
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
        },
        
        tick: function() {
          if (this.body) {
            if (this.isGrabbed && this.grabbingHand) {
              // When grabbed, directly update position and rotation
              const handWorldPos = new THREE.Vector3();
              const handWorldQuat = new THREE.Quaternion();
              this.grabbingHand.object3D.getWorldPosition(handWorldPos);
              this.grabbingHand.object3D.getWorldQuaternion(handWorldQuat);
              
              // Store previous position and rotation for velocity calculation
              const currentTime = performance.now();
              const currentPos = new THREE.Vector3();
              this.el.object3D.getWorldPosition(currentPos);
              
              // Calculate instantaneous velocity for history
              if (this.lastPositionTime > 0) {
                const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.001);
                const displacement = new THREE.Vector3().subVectors(currentPos, this.lastPosition);
                const instantVelocity = displacement.divideScalar(deltaTime);
                
                // Add to velocity history for smoothing
                this.velocityHistory.push(instantVelocity.clone());
                if (this.velocityHistory.length > this.maxHistorySize) {
                  this.velocityHistory.shift();
                }
              }
              
              this.lastPosition.copy(currentPos);
              this.lastRotation.copy(this.el.object3D.quaternion);
              this.lastPositionTime = currentTime;
              
              // Update visual position and rotation
              this.el.object3D.position.copy(handWorldPos);
              this.el.object3D.quaternion.copy(handWorldQuat);
              
              // Update physics body
              this.body.position.copy(handWorldPos);
              this.body.quaternion.copy(handWorldQuat);
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              
              // Keep zero gravity
              this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
            } else {
              // When not grabbed, update visual position from physics
              this.el.object3D.position.copy(this.body.position);
              this.el.object3D.quaternion.copy(this.body.quaternion);

              // Apply minimal Magnus effect only for very high spin
              if (this.body.velocity.length() > 0.1) {
                const velocity = new THREE.Vector3(
                  this.body.velocity.x,
                  this.body.velocity.y,
                  this.body.velocity.z
                );

                const angularVelocity = new THREE.Vector3(
                  this.body.angularVelocity.x,
                  this.body.angularVelocity.y,
                  this.body.angularVelocity.z
                );

                const angularSpeed = angularVelocity.length();
                const linearSpeed = velocity.length();
                
                // Debug: Always log spin and speed when ball is moving to see what we're working with
                if (linearSpeed > 0.5) {
                  console.log('Ball moving - Speed:', linearSpeed.toFixed(2), 'm/s, Spin:', angularSpeed.toFixed(2), 'rad/s');
                }
                
                // Apply Magnus effect - subtle curve to existing motion
                if (angularSpeed > 0.1 && linearSpeed > 0.5) { // Much lower thresholds
                  // Calculate Magnus force as acceleration (not velocity change)
                  const magnusAcceleration = new THREE.Vector3()
                    .crossVectors(angularVelocity, velocity);
                  
                  // Small but noticeable effect - frame rate independent acceleration
                  const frameTime = 1/72; // Assume 72fps for consistent effect
                  const magnusStrength = 0.005; // Very subtle Magnus effect - just barely visible
                  
                  // Scale acceleration by frame time and strength
                  magnusAcceleration.multiplyScalar(magnusStrength * frameTime);
                  
                  // Apply as acceleration (small velocity change per frame)
                  this.body.velocity.x += magnusAcceleration.x;
                  this.body.velocity.y += magnusAcceleration.y;
                  this.body.velocity.z += magnusAcceleration.z;
                  
                  // Log Magnus effect occasionally (not every frame)
                  if (Math.random() < 0.01) { // 1% chance per frame (~0.7 times per second at 72fps)
                    console.log('Magnus ACTIVE - Accel:', magnusAcceleration.length().toFixed(6), 
                               'Spin:', angularSpeed.toFixed(2), 'Speed:', linearSpeed.toFixed(2));
                  }
                }

                // Add minimal damping only for very slow balls to prevent infinite bouncing
                const speed = velocity.length();
                const currentAngularSpeed = angularVelocity.length();
                if (speed < 0.5 && currentAngularSpeed < 1.0) { // Only damp if both linear and angular are slow
                  const damping = 0.995;
                  this.body.velocity.x *= damping;
                  this.body.velocity.y *= damping;
                  this.body.velocity.z *= damping;
                  this.body.angularVelocity.x *= damping;
                  this.body.angularVelocity.y *= damping;
                  this.body.angularVelocity.z *= damping;
                }
              }
            }
          }
        },
        
        onGripDown: function(evt) {
          if (this.isGrabbed) return;
          
          this.grabbingHand = evt.target;
          this.isGrabbed = true;
          // Keep zero gravity
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));

          // Robust haptic feedback on grab (Meta Quest compatible)
          if (this.grabbingHand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = this.grabbingHand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.7, 100).catch(() => {}); // Silently fail if haptics not supported
          }
        },
        
        onGripUp: function(evt) {
          if (!this.isGrabbed || evt.target !== this.grabbingHand) return;
          
          // Use smoothed velocity from history for more consistent throws
          let velocity = new THREE.Vector3(0, 0, 0);
          
          if (this.velocityHistory.length > 0) {
            // Calculate weighted average of recent velocities (more recent = higher weight)
            let totalWeight = 0;
            for (let i = 0; i < this.velocityHistory.length; i++) {
              const weight = (i + 1) / this.velocityHistory.length; // Linear weighting towards recent
              velocity.add(this.velocityHistory[i].clone().multiplyScalar(weight));
              totalWeight += weight;
            }
            velocity.divideScalar(totalWeight);
            
            // Apply reasonable velocity scaling for better game feel
            const throwMultiplier = 1.5; // Slight boost for satisfying throws
            velocity.multiplyScalar(throwMultiplier);
            
            // Cap maximum throw speed for gameplay balance
            const maxThrowSpeed = 25; // m/s
            if (velocity.length() > maxThrowSpeed) {
              velocity.normalize().multiplyScalar(maxThrowSpeed);
            }
          } else {
            // Fallback to single-frame calculation if no history
            const currentTime = performance.now();
            const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.008); // Min 8ms (125fps)
            
            const currentPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(currentPos);
            const displacement = new THREE.Vector3().subVectors(currentPos, this.lastPosition);
            
            velocity = displacement.divideScalar(deltaTime).multiplyScalar(1.5);
          }
          
          // Calculate angular velocity based on rotation change
          const currentRot = new THREE.Quaternion();
          this.el.object3D.getWorldQuaternion(currentRot);
          const deltaRot = new THREE.Quaternion().multiplyQuaternions(
            currentRot,
            this.lastRotation.invert()
          );
          
          // Convert quaternion to angular velocity
          const axis = new THREE.Vector3();
          const angle = 2 * Math.acos(Math.abs(deltaRot.w));
          if (angle > 0.0001) {
            axis.set(deltaRot.x, deltaRot.y, deltaRot.z).normalize();
            // Balanced angular velocity for noticeable but controlled Magnus effect
            axis.multiplyScalar(angle * 40); // Moderate spin amount
          }
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          this.body.angularVelocity.set(axis.x, axis.y, axis.z);
          this.body.gravity.copy(new CANNON.Vec3(0, 0, 0));
          
          console.log('Throw velocity:', velocity.length().toFixed(2), 'm/s (smoothed)');
          
          // Clear velocity history for next throw
          this.velocityHistory = [];
          
          this.isGrabbed = false;
          this.grabbingHand = null;
        }
      });

      // Physics update loop - Anti-tunneling optimized
      AFRAME.registerComponent('physics-world', {
        init: function() {
          this.lastTime = 0;
        },
        tick: function(time) {
          // Use much smaller, more frequent physics steps to prevent tunneling
          const deltaTime = (time - this.lastTime) / 1000;
          if (deltaTime > 0) {
            const maxStep = 1/240; // Even smaller timestep (240Hz) for fast racket movements
            const steps = Math.ceil(deltaTime / maxStep);
            const stepSize = deltaTime / steps;
            
            // Clamp to reasonable step count to prevent performance issues
            const clampedSteps = Math.min(steps, 8);
            const clampedStepSize = deltaTime / clampedSteps;
            
            for (let i = 0; i < clampedSteps; i++) {
              world.step(clampedStepSize);
            }
          }
          this.lastTime = time;
        }
      });

      // Add glow component
      AFRAME.registerComponent('glow', {
        schema: {
          color: {default: '#ffffff', type: 'color'},
          intensity: {default: 1.0}
        },
        init: function () {
          this.el.addEventListener('object3dset', this.update.bind(this));
          this.el.addEventListener('material-loaded', this.update.bind(this));
        },
        update: function () {
          const data = this.data;
          if (!this.el.object3D) return;
          
          this.el.object3D.traverse(function (node) {
            if (node.isMesh && node.material) {
              if (!node.material.emissive) {
                node.material.emissive = new THREE.Color(data.color);
              } else {
                node.material.emissive.copy(new THREE.Color(data.color));
              }
              node.material.emissiveIntensity = data.intensity;
            }
          });
        }
      });

      // Player zone component
      AFRAME.registerComponent('player-zone', {
        schema: {
          player: { type: 'string', default: 'player1' },
          radius: { type: 'number', default: 1 }
        },
        init: function() {
          // Create zone indicator
          this.zoneIndicator = document.createElement('a-ring');
          this.zoneIndicator.setAttribute('radius-inner', this.data.radius - 0.1);
          this.zoneIndicator.setAttribute('radius-outer', this.data.radius);
          this.zoneIndicator.setAttribute('color', this.data.player === 'player1' ? '#ff0000' : '#0000ff');
          this.zoneIndicator.setAttribute('opacity', 0.5);
          this.zoneIndicator.setAttribute('rotation', '-90 0 0');
          this.zoneIndicator.setAttribute('position', '0 0.01 0'); // Slightly above floor to prevent z-fighting
          this.el.appendChild(this.zoneIndicator);
          
          // Create dark overlay
          this.darkOverlay = document.createElement('a-entity');
          this.darkOverlay.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 100,
            phiLength: 180
          });
          this.darkOverlay.setAttribute('material', {
            color: '#000000',
            opacity: 0.8,
            side: 'back'
          });
          this.darkOverlay.setAttribute('visible', false);
          this.el.sceneEl.appendChild(this.darkOverlay);
        },
        
        tick: function() {
          const player = document.querySelector(`#${this.data.player}`);
          if (!player) return;
          
          const playerPos = player.object3D.position;
          const zonePos = this.el.object3D.position;
          const distance = playerPos.distanceTo(zonePos);
          
          // Update zone indicator position
          this.zoneIndicator.object3D.position.copy(zonePos);
          this.zoneIndicator.object3D.position.y = 0.01;
          
          // Check if player is in zone
          if (distance > this.data.radius) {
            this.darkOverlay.setAttribute('visible', true);
            this.zoneIndicator.setAttribute('color', '#ff0000');
          } else {
            this.darkOverlay.setAttribute('visible', false);
            this.zoneIndicator.setAttribute('color', this.data.player === 'player1' ? '#ff0000' : '#0000ff');
          }
        }
      });

      // Add sound manager component
      AFRAME.registerComponent('sound-manager', {
        init: function() {
          this.ballSounds = [];
          this.soundsInitialized = false;
          
          // Get all ball sounds
          this.el.sceneEl.querySelectorAll('[simple-grab]').forEach(ball => {
            const sound = ball.querySelector('[sound]');
            if (sound) {
              this.ballSounds.push(sound);
              // Initially pause all sounds
              sound.components.sound.pauseSound();
            }
          });
          
          // Get bounce sound
          this.bounceSound = this.el.sceneEl.querySelector('#bounce-sound');
          if (this.bounceSound) {
            this.bounceSound.components.sound.pauseSound();
          }
          
          // Listen for game start
          this.el.sceneEl.addEventListener('gameStarted', () => {
            this.initializeSounds();
          });
        },
        
        initializeSounds: function() {
          if (this.soundsInitialized) return;
          
          // Resume AudioContext
          const audioContext = this.el.sceneEl.audioContext;
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          // Start all ball hum sounds
          this.ballSounds.forEach(sound => {
            if (sound.id && (sound.id === 'red-ball-hum' || sound.id === 'blue-ball-hum')) {
              sound.components.sound.playSound();
            }
          });
          
          // Initialize bounce sound
          if (this.bounceSound) {
            this.bounceSound.components.sound.playSound();
            this.bounceSound.components.sound.pauseSound();
          }
          
          this.soundsInitialized = true;
        }
      });

      // Game manager component
      AFRAME.registerComponent('game-manager', {
        schema: {
          playerScore: { type: 'number', default: 0 },
          botScore: { type: 'number', default: 0 },
          gameStarted: { type: 'boolean', default: false }
        },
        init: function() {
          this.playerScore = 0;
          this.botScore = 0;
          this.gameStarted = false;
          
          // Match states: WAITING, COUNTDOWN, PLAYING, OVERTIME, ENDED
          this.matchState = 'WAITING';
          this.matchDuration = 180; // 3 minutes in seconds
          this.matchStartTime = 0;
          this.countdownTime = 3;
          this.countdownStartTime = 0;
          
          // Get references to the displays
          this.scoreDisplay = this.el.querySelector('#score-display');
          this.startMessage = this.el.querySelector('#start-message');
          this.timerDisplay = this.el.querySelector('#timer-display');
          
          // Hide score and timer displays initially
          this.scoreDisplay.setAttribute('visible', false);
          this.timerDisplay.setAttribute('visible', false);
          
          // Listen for A button press on both controllers
          this.el.sceneEl.addEventListener('abuttondown', (evt) => {
            if (this.matchState === 'WAITING') {
              this.startCountdown();
            } else if (this.matchState === 'ENDED') {
              this.resetMatch();
            }
          });
        },

        tick: function() {
          const currentTime = Date.now();
          
          if (this.matchState === 'COUNTDOWN') {
            const elapsed = (currentTime - this.countdownStartTime) / 1000;
            const remaining = Math.ceil(this.countdownTime - elapsed);
            
            if (remaining > 0) {
              this.startMessage.setAttribute('text', 'value', remaining.toString());
            } else {
              this.startMessage.setAttribute('text', 'value', 'GO!');
              setTimeout(() => {
                this.startMatch();
              }, 500);
            }
          } else if (this.matchState === 'PLAYING') {
            this.updateTimer();
          }
        },

        startCountdown: function() {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = Date.now();
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', '3');
          
          // Reset and respawn balls
          this.respawnBalls();
          
          console.log('Match countdown started');
        },

        startMatch: function() {
          this.matchState = 'PLAYING';
          this.matchStartTime = Date.now();
          this.gameStarted = true;
          
          // Hide start message, show game UI
          this.startMessage.setAttribute('visible', false);
          this.scoreDisplay.setAttribute('visible', true);
          this.timerDisplay.setAttribute('visible', true);
          
          // Reset scores
          this.playerScore = 0;
          this.botScore = 0;
          this.updateScore();
          
          // Enable bot and player collision
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          const player = this.el.sceneEl.querySelector('#player');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', true);
          if (player) player.setAttribute('player-collision', 'enabled', true);
          
          // Dispatch game started event
          this.el.sceneEl.emit('gameStarted');
          
          console.log('Match started - 3 minutes');
        },

        updateTimer: function() {
          const currentTime = Date.now();
          const elapsed = (currentTime - this.matchStartTime) / 1000;
          const remaining = Math.max(0, this.matchDuration - elapsed);
          
          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.timerDisplay.setAttribute('text', 'value', `Time: ${timeString}`);
          
          // Check if time is up
          if (remaining <= 0 && this.matchState === 'PLAYING') {
            if (this.playerScore === this.botScore) {
              this.startOvertime();
            } else {
              this.endMatch();
            }
          }
        },

        startOvertime: function() {
          this.matchState = 'OVERTIME';
          this.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next goal wins!');
          console.log('Match went to overtime - sudden death');
        },

        endMatch: function() {
          this.matchState = 'ENDED';
          this.gameStarted = false;
          
          // Disable bot
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          
          // Determine winner
          let winner;
          if (isMultiplayer && conn && conn.open) {
            winner = multiplayerScore.local > multiplayerScore.remote ? 'You win!' : 'Opponent wins!';
          } else {
            winner = this.playerScore > this.botScore ? 'Player wins!' : 'Bot wins!';
          }
          
          // Show end message
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', `${winner}\nPress A to play again`);
          this.timerDisplay.setAttribute('text', 'value', 'Match ended');
          
          console.log(`Match ended: ${winner}`);
        },

        resetMatch: function() {
          this.matchState = 'WAITING';
          this.playerScore = 0;
          this.botScore = 0;
          this.gameStarted = false;
          
          // Reset multiplayer scores too
          if (isMultiplayer) {
            multiplayerScore.local = 0;
            multiplayerScore.remote = 0;
          }
          
          // Hide game UI, show start message
          this.scoreDisplay.setAttribute('visible', false);
          this.timerDisplay.setAttribute('visible', false);
          this.startMessage.setAttribute('visible', true);
          this.startMessage.setAttribute('text', 'value', 'Press A to Start');
          
          // Disable bot
          const bot = this.el.sceneEl.querySelector('[advanced-bot]');
          if (bot) bot.setAttribute('advanced-bot', 'enabled', false);
          
          console.log('Match reset to waiting state');
        },

        respawnBalls: function() {
          // Reset both balls to their spawn positions
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          const redBall = document.querySelector('[simple-grab="player: player1"]');
          
          if (blueBall && blueBall.components['simple-grab']) {
            blueBall.components['simple-grab'].resetPosition();
          }
          if (redBall && redBall.components['simple-grab']) {
            redBall.components['simple-grab'].resetPosition();
          }
          
          console.log('Balls respawned');
        },

        onBotHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') return;
          
          if (isMultiplayer && conn && conn.open) {
            multiplayerScore.local += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            this.playerScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        onPlayerHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') return;
          
          if (isMultiplayer && conn && conn.open) {
            multiplayerScore.remote += 1;
            updateScoreDisplayMultiplayer();
            sendScoreUpdate();
          } else {
            this.botScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.endMatch();
          }
        },

        updateScore: function() {
          if (isMultiplayer && conn && conn.open) {
            updateScoreDisplayMultiplayer();
          } else {
            this.scoreDisplay.setAttribute('text', {
              value: `Player: ${this.playerScore} - Bot: ${this.botScore}`
            });
          }
        }
      });

      // Impact effect component
      AFRAME.registerComponent('impact-effect', {
        schema: {
          color: { type: 'color', default: '#ffffff' }
        },
        init: function() {
          // Find the impact sphere within this entity
          this.impactSphere = this.el.querySelector('a-sphere[id$="-impact"]');
          if (!this.impactSphere) {
            console.warn('Impact sphere not found for:', this.el.id);
            return;
          }

          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            if (!collider || !collider.hasAttribute('simple-grab')) return;

            // Check if this is the player target
            const isPlayerTarget = this.el.id === 'player-target';
            const isBotTarget = this.el.id === 'bot-target';
            
            // Get the ball's player
            const ballPlayer = collider.getAttribute('simple-grab').player;
            
            // Only play effect if:
            // - Player target is hit by player1's ball (bot's ball)
            // - Bot target is hit by player2's ball (player's ball)
            const shouldPlayEffect = (isPlayerTarget && ballPlayer === 'player1') || 
                                   (isBotTarget && ballPlayer === 'player2');

            if (shouldPlayEffect) {
              this.playEffect();
            }
          });
        },
        
        playEffect: function() {
          if (!this.impactSphere) {
            console.warn('Cannot play effect - impact sphere not found');
            return;
          }
          
          // Play impact sound
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            impactSound.object3D.position.copy(this.el.object3D.position);
            impactSound.components.sound.playSound();
          }
          
          // Reset impact sphere state
          this.impactSphere.setAttribute('radius', 0.1);
          this.impactSphere.setAttribute('material', 'opacity', 0.5);
          this.impactSphere.setAttribute('visible', true);
          
          // Trigger the animations
          this.impactSphere.emit('impact');
          
          // Reset after animation completes
          setTimeout(() => {
            this.impactSphere.setAttribute('visible', false);
            this.impactSphere.setAttribute('material', 'opacity', 0);
            this.impactSphere.setAttribute('radius', 0.1);
          }, 1000);
        }
      });

      // Static physics component for non-grabbable objects
      AFRAME.registerComponent('static-physics', {
        init: function() {
          let shape;
          const geometry = this.el.getAttribute('geometry');
          
          // Check if this is a racket (has id ending with "Racket")
          const isRacket = this.el.id && this.el.id.endsWith('Racket');
          
          // For rackets, don't create physics bodies - handle collision manually
          if (isRacket) {
            this.body = null;
            this.lastHitTime = 0; // Track last hit to prevent multiple rapid hits
            this.lastRacketPos = null; // Initialize as null to detect first frame
            this.lastRacketTime = 0;
            this.tick = function() {
              const worldPos = new THREE.Vector3();
              const worldQuat = new THREE.Quaternion();
              this.el.object3D.getWorldPosition(worldPos);
              this.el.object3D.getWorldQuaternion(worldQuat);
              
              // Initialize position tracking on first frame
              if (!this.lastRacketPos) {
                this.lastRacketPos = worldPos.clone();
                this.lastRacketTime = performance.now();
                console.log('Initialized racket tracking for', this.el.id);
                return;
              }
              
              // Eleven Table Tennis style: Check for ball collision along movement path
              const movement = worldPos.distanceTo(this.lastRacketPos);
              if (movement > 0.00001) { // Extreme sensitivity - detect micro-movements
                this.checkSweptCollision(this.lastRacketPos, worldPos);
              }
              
              // Update position tracking
              this.lastRacketPos.copy(worldPos);
              this.lastRacketTime = performance.now();
            };
          } else {
                      // For non-racket objects, create normal physics bodies
          if (geometry && geometry.primitive === 'box') {
            const width = geometry.width || 1;
            const height = geometry.height || 1;
            const depth = geometry.depth || 1;
            shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
          } else if (geometry && geometry.primitive === 'sphere') {
            shape = new CANNON.Sphere(geometry.radius || 0.2);
          } else if (geometry && geometry.primitive === 'cylinder') {
            const radius = geometry.radius || 0.5;
            const height = geometry.height || 1;
            shape = new CANNON.Cylinder(radius, radius, height, 16);
            
            // Rotate to match A-Frame's orientation
            const quat = new CANNON.Quaternion();
            quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            shape.transformAllPoints(new CANNON.Vec3(), quat);
          } else {
            // Default to sphere shape for bot
            shape = new CANNON.Sphere(0.2);
          }
          
                    // Check if this is a back wall (z = 8 or z = -8)
          const wallPosition = this.el.getAttribute('position');
          const isBackWall = wallPosition && (Math.abs(wallPosition.z - 8) < 0.01 || Math.abs(wallPosition.z + 8) < 0.01);
          
          const body = new CANNON.Body({
            mass: 0,
            shape: shape,
            material: isBackWall ? backWallMaterial : defaultMaterial,
            type: CANNON.Body.STATIC,
            collisionFilterGroup: 1,
            collisionFilterMask: 1
          });
          
          const position = this.el.getAttribute('position');
            const rotation = this.el.getAttribute('rotation');
            body.position.set(position.x, position.y, position.z);
            
            if (rotation) {
              const rad = Math.PI / 180;
              body.quaternion.setFromEuler(
                rotation.x * rad,
                rotation.y * rad,
                rotation.z * rad
              );
            }
            
            // Store reference to the entity on the body
            body.el = this.el;
            body.isRacket = false;
            
            // Add collision event listener for non-rackets
            this.el.addEventListener('obbcollisionstarted', (evt) => {
              const collider = evt.detail.withEl;
              if (collider && collider.hasAttribute('simple-grab')) {
                // Regular wall/obstacle collision
                const bounceSound = document.querySelector('#bounce-sound');
                if (bounceSound) {
                  const ballPos = collider.object3D.position;
                  bounceSound.object3D.position.copy(ballPos);
                  bounceSound.components.sound.stopSound();
                  bounceSound.components.sound.playSound();
                }
              }
            });
            
            world.addBody(body);
            this.body = body;
          }
        },
        
        // Plane-based collision detection - only one surface!
        checkSweptCollision: function(startPos, endPos) {
          // Only check collision if racket mode is active for this player
          // Local player (hands) always controls player2's rackets
          if (!racketMode.player2) {
            return;
          }
          
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          if (!blueBall || !blueBall.components['simple-grab']?.body) {
            return;
          }
          
          // Much shorter cooldown to allow rapid hits
          const now = Date.now();
          if (now - this.lastHitTime < 16) { // ~60fps - allow very rapid hits
            return;
          }
          
          const ballPos = new THREE.Vector3().copy(blueBall.components['simple-grab'].body.position);
          const ballRadius = 0.1;
          
          // Get racket position and orientation
          const racketWorldPos = new THREE.Vector3();
          const racketWorldQuat = new THREE.Quaternion();
          this.el.object3D.getWorldPosition(racketWorldPos);
          this.el.object3D.getWorldQuaternion(racketWorldQuat);
          
          // Calculate distance from racket to ball
          const distanceToBall = racketWorldPos.distanceTo(ballPos);
          
          // Dynamic proximity check - larger threshold for faster movements to prevent tunneling
          const movementVector = new THREE.Vector3().subVectors(endPos, startPos);
          const movementSpeed = movementVector.length();
          
          // Increase collision radius based on movement speed to catch fast hits
          const dynamicRadius = ballRadius + 0.01 + (movementSpeed * 2.0); // Base + speed-based expansion
          
          // For fast movements, check multiple points along the path to prevent tunneling
          if (movementSpeed > 0.05) { // For fast movements
            let hitDetected = false;
            const numSteps = Math.min(Math.ceil(movementSpeed * 20), 10); // More steps for faster movement, max 10
            
            for (let i = 0; i <= numSteps; i++) {
              const t = i / numSteps;
              const interpPos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
              const distanceAtStep = interpPos.distanceTo(ballPos);
              
              if (distanceAtStep <= ballRadius + 0.05) { // Slightly larger threshold for swept detection
                hitDetected = true;
                break;
              }
            }
            
            if (!hitDetected) {
              return; // No collision detected along path
            }
          } else {
            // For slow movements, use direct distance check
            if (distanceToBall > dynamicRadius) {
              return; // Too far away
            }
          }
          
          // No minimum speed requirement - allow static contact and pushing
          
          // Record hit time to enforce cooldown
          this.lastHitTime = now;
          
          // Calculate velocity at point of contact using actual time elapsed
          const currentTime = performance.now();
          const deltaTime = Math.max((currentTime - this.lastRacketTime) / 1000, 0.001); // Convert to seconds, prevent division by zero
          const contactVelocity = new THREE.Vector3()
            .subVectors(endPos, startPos)
            .divideScalar(deltaTime);
          
          // Apply impact with proper contact velocity
          this.applySweptImpact(blueBall, contactVelocity, ballPos);
        },
        
        applySweptImpact: function(ballEl, racketVelocity, contactPoint) {
          const ballBody = ballEl.components['simple-grab'].body;
          if (!ballBody) return;
          
          // Primary: Apply linear velocity transfer (ball movement)
          const velocityMultiplier = 0.8; // How much racket velocity transfers to ball
          const newVelocity = {
            x: racketVelocity.x * velocityMultiplier,
            y: racketVelocity.y * velocityMultiplier,
            z: racketVelocity.z * velocityMultiplier
          };
          
          // Add to existing ball velocity (don't replace completely)
          ballBody.velocity.x += newVelocity.x;
          ballBody.velocity.y += newVelocity.y;
          ballBody.velocity.z += newVelocity.z;
          
          // Cap maximum ball speed at 10 m/s for controlled gameplay
          const currentSpeed = Math.sqrt(
            ballBody.velocity.x * ballBody.velocity.x +
            ballBody.velocity.y * ballBody.velocity.y +
            ballBody.velocity.z * ballBody.velocity.z
          );
          
          if (currentSpeed > 10) {
            const scale = 10 / currentSpeed;
            ballBody.velocity.x *= scale;
            ballBody.velocity.y *= scale;
            ballBody.velocity.z *= scale;
            console.log('Ball speed capped at 10 m/s (was', currentSpeed.toFixed(1), 'm/s)');
          }
          
          // Secondary: Apply spin based on racket velocity at contact point
          const spinMultiplier = 1.0; // Reduced since we now have primary velocity transfer
          const newSpin = {
            x: -racketVelocity.y * spinMultiplier, // Up/Down movement creates topspin/backspin
            y: racketVelocity.x * spinMultiplier,  // Left/Right movement creates sidespin
            z: racketVelocity.z * spinMultiplier   // Forward/Back movement
          };
          
          ballBody.angularVelocity.x += newSpin.x;
          ballBody.angularVelocity.y += newSpin.y;
          ballBody.angularVelocity.z += newSpin.z;
          
          console.log('Racket impact applied - Velocity:', racketVelocity.length().toFixed(2), 'm/s (frame-rate independent)',
                     'Ball velocity added:', newVelocity.x.toFixed(2), newVelocity.y.toFixed(2), newVelocity.z.toFixed(2));
          
          // Play feedback
          const bounceSound = document.querySelector('#bounce-sound');
          if (bounceSound) {
            bounceSound.object3D.position.copy(contactPoint);
            bounceSound.components.sound.stopSound();
            bounceSound.components.sound.playSound();
          }
          
          // Haptic feedback
          const hand = this.el.parentEl;
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.6, 100).catch(() => {}); // Lighter haptic for more precise feel
          }
        },

        // Removed handleRacketHit function - using only swept collision detection now
      });

      // Player collision component
      AFRAME.registerComponent('player-collision', {
        schema: {
          enabled: { type: 'boolean', default: false }
        },
        init: function() {
          // Create a capsule shape for the player (better than sphere for character collision)
          const radius = 0.2; // Slightly smaller radius
          const height = 1.6; // Approximate player height
          const segments = 8; // Number of segments for the capsule
          
          // Create a cylinder for the main body
          const cylinderShape = new CANNON.Cylinder(radius, radius, height, segments);
          
          // Create spheres for the top and bottom
          const sphereShape = new CANNON.Sphere(radius);
          
          // Create the physics body
          this.body = new CANNON.Body({
            mass: 1,
            material: new CANNON.Material('default'),
            linearDamping: 0.5,
            fixedRotation: true,
            type: CANNON.Body.DYNAMIC,
            collisionFilterGroup: 1,
            collisionFilterMask: 1,
            position: this.el.object3D.position.clone().add(new THREE.Vector3(0, 1.0, 0)) // Offset upward by half height
          });
          
          // Add the shapes to the body with proper orientation
          // Rotate cylinder to match A-Frame's orientation
          const cylinderQuat = new CANNON.Quaternion();
          cylinderQuat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
          this.body.addShape(cylinderShape, new CANNON.Vec3(0, 0, 0), cylinderQuat);
          
          // Add spheres with proper offsets
          this.body.addShape(sphereShape, new CANNON.Vec3(0, height/2, 0)); // Top sphere
          this.body.addShape(sphereShape, new CANNON.Vec3(0, -height/2, 0)); // Bottom sphere
          
          // Add contact material for better collision response
          const contactMaterial = new CANNON.ContactMaterial(
            this.body.material,
            new CANNON.Material('default'),
            {
              friction: 0.3,
              restitution: 0.2
            }
          );
          world.addContactMaterial(contactMaterial);
          
          world.addBody(this.body);
          this.initialPosition = this.el.object3D.position.clone();
          this.targetHeight = 1.0; // Target height for the player
          
          // Store reference to the entity on the body
          this.body.el = this.el;
          
          // Add collision event listener
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            if (!this.data.enabled) return;
            console.log('Player collision event received:', evt.detail);
            const collider = evt.detail.withEl;
            if (collider && collider.getAttribute('simple-grab') && 
                collider.getAttribute('simple-grab').player === 'player1') {
              console.log('Player hit by bot ball!');
              // Visual feedback
              const playerSphere = this.el.querySelector('a-sphere');
              if (playerSphere) {
                playerSphere.setAttribute('color', '#0000ff');
                setTimeout(() => {
                  playerSphere.setAttribute('color', '#ffffff');
                }, 1000);
              }
              
              // Play impact effect
              const playerTarget = document.querySelector('#player-target');
              const impactEffect = playerTarget && playerTarget.components['impact-effect'];
              if (impactEffect) {
                console.log('Playing player impact effect');
                impactEffect.playEffect();
              } else {
                console.log('No impact effect component found on player-target');
              }
              
              // Update score
              const gameManager = this.el.sceneEl.querySelector('#game-manager');
              if (gameManager && gameManager.components['game-manager']) {
                gameManager.components['game-manager'].onPlayerHit();
              }
            }
          });
        },
        
        tick: function() {
          // Update player position based on physics, maintaining the height offset
          const physicsPos = this.body.position;
          
          // Keep the player at a constant height
          //physicsPos.x = this.targetX;
          physicsPos.z = this.targetZ;
          physicsPos.y = this.targetHeight;
          
          // Update the visual position
          this.el.object3D.position.set(physicsPos.x, physicsPos.y - 1.0, physicsPos.z);
          
          // Zero out any vertical velocity to prevent floating/sinking
          this.body.velocity.x = 0;
          this.body.velocity.y = 0;
          this.body.velocity.z = 0;
        }
      });

      // Bot component for AI player
      AFRAME.registerComponent('bot', {
        schema: {
          throwInterval: { type: 'number', default: 5000 }, // 5 seconds
          minThrowForce: { type: 'number', default: 5 },  // Halved from 10
          maxThrowForce: { type: 'number', default: 10 },  // Halved from 20
          enabled: { type: 'boolean', default: false }
        },
        init: function() {
          this.ball = null;
          this.lastThrowTime = 0;
          this.throwInterval = this.data.throwInterval;
          this.isHit = false;
          this.hitCooldown = 2000; // 2 seconds cooldown after being hit
          this.lastHitTime = 0;
          
          // Find the bot's ball
          this.el.sceneEl.addEventListener('loaded', () => {
            this.ball = this.el.sceneEl.querySelector('[simple-grab="player: player1"]');
          });

          // Listen for collisions
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            if (!this.data.enabled) return;
            this.onCollision(evt);
          });
        },
        
        onCollision: function(evt) {
          const now = Date.now();
          if (now - this.lastHitTime < this.hitCooldown) return;
          
          const collider = evt.detail.withEl;
          
          if (collider && collider.getAttribute('simple-grab') && 
              collider.getAttribute('simple-grab').player === 'player2') {
            this.isHit = true;
            this.lastHitTime = now;
            
            // Visual feedback
            const botSphere = this.el.querySelector('a-sphere');
            if (botSphere) {
              botSphere.setAttribute('color', '#ff0000');
              setTimeout(() => {
                botSphere.setAttribute('color', '#ff0000');
                this.isHit = false;
              }, 1000);
            }
            
            // Play impact effect
            const impactEffect = this.el.components['impact-effect'];
            if (impactEffect) {
              impactEffect.playEffect();
            }
            
            // Update score
            const gameManager = this.el.sceneEl.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].onBotHit();
            }
          }
        },
        
        tick: function(time) {
          if (!this.ball || !this.data.enabled) return;
          
          // Check if it's time to throw
          if (time - this.lastThrowTime > this.throwInterval && !this.isHit) {
            this.throwBall();
            this.lastThrowTime = time;
          }
        },
        
        throwBall: function() {
          if (!this.ball || !this.ball.components['simple-grab']) return;
          
          // Get player position
          const player = document.querySelector('#player');
          if (!player) return;
          
          const playerPos = new THREE.Vector3();
          player.object3D.getWorldPosition(playerPos);
          
          // Calculate random throw angle
          const throwAngle = this.calculateThrowAngle(playerPos);
          
          // Calculate throw force
          const throwForce = this.data.minThrowForce + 
            Math.random() * (this.data.maxThrowForce - this.data.minThrowForce);
          
          // Reset ball position
          this.ball.components['simple-grab'].resetPosition();
          
          // Apply velocity
          const ballBody = this.ball.components['simple-grab'].body;
          if (ballBody) {
            ballBody.velocity.set(
              throwAngle.x * throwForce,
              throwAngle.y * throwForce,
              throwAngle.z * throwForce
            );
          }
        },
        
        calculateThrowAngle: function(playerPos) {
          // Get bot position
          const botPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(botPos);
          
          // Use the world position of the player's target sphere (blue sphere inside camera)
          let targetPos = new THREE.Vector3();
          const playerTargetSphere = document.querySelector('#player-target');
          if (playerTargetSphere) {
            playerTargetSphere.object3D.getWorldPosition(targetPos);
          } else {
            // fallback to playerPos
            targetPos.copy(playerPos);
          }
          // Calculate direct vector to player
          const directVector = new THREE.Vector3()
            .subVectors(targetPos, botPos)
            .normalize();
          
          // Randomly choose between direct throw or bounce throw
          if (Math.random() < 0.5) {
            // Direct throw
            return directVector;
          } else {
            // Bounce throw - randomly choose a wall/floor/ceiling to bounce off
            const bounceTypes = [
              { axis: 'x', value: 2 },    // Right wall
              { axis: 'x', value: -2 },   // Left wall
              { axis: 'y', value: 4 },    // Ceiling
              { axis: 'y', value: 0 },    // Floor
              { axis: 'z', value: 8 },    // Front wall
              { axis: 'z', value: -8 }    // Back wall
            ];
            
            const bounce = bounceTypes[Math.floor(Math.random() * bounceTypes.length)];
            const bouncePoint = new THREE.Vector3();
            bouncePoint[bounce.axis] = bounce.value;
            
            // Calculate vector to bounce point
            const toBounce = new THREE.Vector3()
              .subVectors(bouncePoint, botPos)
              .normalize();
            
            // Calculate vector from bounce point to player
            const fromBounce = new THREE.Vector3()
              .subVectors(targetPos, bouncePoint)
              .normalize();
            
            // Combine vectors for final throw direction
            return new THREE.Vector3()
              .addVectors(toBounce, fromBounce)
              .normalize();
          }
        }
      });

      // Add haptic feedback on hand collision with a ball
      AFRAME.registerComponent('hand-haptics', {
        init: function() {
          this.el.addEventListener('obbcollisionstarted', (evt) => {
            const collider = evt.detail.withEl;
            // Check if the collider is a ball (has simple-grab component)
            if (collider && collider.components && collider.components['simple-grab']) {
              // Try to get the gamepad from the controller
              const trackedControls = this.el.components['tracked-controls'];
              if (trackedControls?.controller?.gamepad?.hapticActuators?.[0]) {
                const haptics = trackedControls.controller.gamepad.hapticActuators[0];
                haptics.pulse(0.7, 100).catch(() => {}); // Silently fail if haptics not supported
              }
            }
          });
        }
      });

      // Add debug visualization component
      AFRAME.registerComponent('debug-collider', {
        init: function() {
          // Create wireframe for physics body
          const wireframe = document.createElement('a-entity');
          wireframe.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 0.1,
            segmentsWidth: 16,
            segmentsHeight: 16
          });
          wireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.5
          });
          this.el.appendChild(wireframe);
        }
      });

      // Add debug visualization for controllers
      AFRAME.registerComponent('debug-controller', {
        init: function() {
          // Create wireframe for controller collision
          const wireframe = document.createElement('a-entity');
          wireframe.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 0.05,
            segmentsWidth: 16,
            segmentsHeight: 16
          });
          wireframe.setAttribute('material', {
            color: '#ff00ff',
            wireframe: true,
            opacity: 0.5
          });
          this.el.appendChild(wireframe);
        }
      });

      // FPS counter component
      AFRAME.registerComponent('fps-counter', {
        init: function() {
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.fps = 0;
          this.fpsHistory = [];
          this.updateInterval = 500; // Update every 500ms for smooth display
          this.lastUpdate = 0;
        },
        
        tick: function() {
          const currentTime = performance.now();
          this.frameCount++;
          
          // Update FPS every 500ms
          if (currentTime - this.lastUpdate >= this.updateInterval) {
            const deltaTime = currentTime - this.lastTime;
            const currentFPS = Math.round((this.frameCount * 1000) / deltaTime);
            
            // Keep a history of recent FPS values for smoothing
            this.fpsHistory.push(currentFPS);
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift(); // Keep only last 5 readings
            }
            
            // Calculate average FPS for smoother display
            const avgFPS = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);
            this.fps = avgFPS;
            
            // Update the version display
            this.updateVersionDisplay();
            
            // Reset counters
            this.frameCount = 0;
            this.lastTime = currentTime;
            this.lastUpdate = currentTime;
          }
        },
        
        updateVersionDisplay: function() {
          const versionDisplay = document.getElementById('version-display');
          if (versionDisplay) {
            const currentText = versionDisplay.getAttribute('text').value;
            
            // Extract version and status parts
            const parts = currentText.split(' | ');
            const version = parts[0];
            const status = parts.length > 1 ? parts[1] : '';
            
            // Update with FPS, preserving any existing status
            if (status && !status.includes('FPS')) {
              versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS | ${status}`);
            } else if (status && status.includes('FPS')) {
              // Replace existing FPS
              const statusWithoutFPS = status.replace(/\d+ FPS/, '').replace(/^\s*\|\s*/, '').replace(/\s*\|\s*$/, '');
              if (statusWithoutFPS) {
                versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS | ${statusWithoutFPS}`);
              } else {
                versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS`);
              }
            } else {
              versionDisplay.setAttribute('text', 'value', `${version} | ${this.fps} FPS`);
            }
          }
        }
      });

      // Add custom hand controls override
      AFRAME.registerComponent('custom-hand-controls', {
        init: function() {
          // Override the problematic animation methods
          const handControls = this.el.components['hand-controls'];
          if (handControls) {
            // Store original methods
            this.originalAnimateGesture = handControls.animateGesture;
            this.originalPlayAnimation = handControls.playAnimation;
            
            // Override with no-op functions
            handControls.animateGesture = function() {};
            handControls.playAnimation = function() {};
          }
        },
        
        remove: function() {
          // Restore original methods if needed
          const handControls = this.el.components['hand-controls'];
          if (handControls && this.originalAnimateGesture && this.originalPlayAnimation) {
            handControls.animateGesture = this.originalAnimateGesture;
            handControls.playAnimation = this.originalPlayAnimation;
          }
        }
      });

      // Frame rate info component (for debugging only - do not use to limit FPS in VR!)
      AFRAME.registerComponent('frame-rate-info', {
        init: function() {
          console.log('=== FRAME RATE INFO ===');
          console.log('VR Display Refresh Rate:', this.getVRRefreshRate());
          console.log('Browser supports:', this.getBrowserCapabilities());
          console.log('Current renderer info:', this.getRendererInfo());
          console.log('======================');
        },
        
        getVRRefreshRate: function() {
          if (this.el.xrSession && this.el.xrSession.renderState) {
            return `${this.el.xrSession.renderState.baseLayer?.framebuffer ? 'VR Session Active' : 'No VR Session'}`;
          }
          return 'Not in VR mode';
        },
        
        getBrowserCapabilities: function() {
          const capabilities = [];
          if ('xr' in navigator) capabilities.push('WebXR');
          if ('getVRDisplays' in navigator) capabilities.push('WebVR (deprecated)');
          if (window.requestAnimationFrame) capabilities.push('requestAnimationFrame');
          return capabilities.join(', ');
        },
        
        getRendererInfo: function() {
          const renderer = this.el.renderer;
          if (renderer) {
            return {
              pixelRatio: renderer.getPixelRatio(),
              maxTextureSize: renderer.capabilities?.maxTextureSize || 'unknown',
              precision: renderer.capabilities?.precision || 'unknown'
            };
          }
          return 'Renderer not available';
        }
      });

      // Ball speed tracker component
      AFRAME.registerComponent('ball-speed-tracker', {
        init: function() {
          this.ballStats = {
            player1: { current: 0, fastest: 0, color: 'Red' },
            player2: { current: 0, fastest: 0, color: 'Blue' }
          };
          this.lastUpdate = 0;
          this.updateInterval = 100; // Update every 100ms for smooth display
          this.statsDisplay = null;
        },

        tick: function() {
          const now = performance.now();
          if (now - this.lastUpdate < this.updateInterval) return;
          this.lastUpdate = now;

          // Get ball entities
          const blueBall = document.querySelector('[simple-grab="player: player2"]');
          const redBall = document.querySelector('[simple-grab="player: player1"]');

          // Update speeds
          if (blueBall && blueBall.components['simple-grab']?.body) {
            const velocity = blueBall.components['simple-grab'].body.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            this.ballStats.player2.current = speed;
            if (speed > this.ballStats.player2.fastest) {
              this.ballStats.player2.fastest = speed;
            }
          }

          if (redBall && redBall.components['simple-grab']?.body) {
            const velocity = redBall.components['simple-grab'].body.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            this.ballStats.player1.current = speed;
            if (speed > this.ballStats.player1.fastest) {
              this.ballStats.player1.fastest = speed;
            }
          }

          // Update display
          this.updateDisplay();
        },

        updateDisplay: function() {
          if (!this.statsDisplay) {
            this.statsDisplay = document.querySelector('#ball-stats-text');
          }
          
          if (this.statsDisplay) {
            const blue = this.ballStats.player2;
            const red = this.ballStats.player1;
            
            const displayText = 
              `${blue.color} ball: ${blue.current.toFixed(1)} m/s (Max: ${blue.fastest.toFixed(1)})` + 
              `\n${red.color} ball: ${red.current.toFixed(1)} m/s (Max: ${red.fastest.toFixed(1)})`;
            
            this.statsDisplay.setAttribute('value', displayText);
          }
        },

        // Reset max speeds (could be called on game restart)
        resetMaxSpeeds: function() {
          this.ballStats.player1.fastest = 0;
          this.ballStats.player2.fastest = 0;
          console.log('Ball speed records reset');
        }
      });

    </script>

    <a-scene physics-world game-manager sound-manager multiplayer-sync fps-counter frame-rate-info ball-speed-tracker
    vr-mode-ui="enabled: true"
      renderer="antialias: true; colorManagement: true; shadowMapEnabled: false; maxDeltaTime: 0.2"
    webxr="requiredFeatures: local-floor">
      
      <!-- Game room walls -->
      <!-- Floor -->
      <a-box position="0 0 0" 
             width="4" 
             height="0.1" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Ceiling -->
      <a-box position="0 4 0" 
             width="4" 
             height="0.1" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Left wall -->
      <a-box position="-2 2 0" 
             width="0.1" 
             height="4" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Right wall -->
      <a-box position="2 2 0" 
             width="0.1" 
             height="4" 
             depth="16" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Back wall -->
      <a-box position="0 2 -8" 
             width="4" 
             height="4" 
             depth="0.1" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>
      
      <!-- Front wall -->
      <a-box position="0 2 8" 
             width="4" 
             height="4" 
             depth="0.1" 
             color="#808080"
             material="shader: standard; metalness: 0; roughness: 1"
             static-physics
             obb-collider
             class="collidable">
      </a-box>

      <!-- Player 1 zone -->
      <a-entity position="0 0.05 -6" player-zone="player: player1; radius: 1">
      </a-entity>

      <!-- Player 2 zone -->
      <a-entity position="0 0.05 6" player-zone="player: player2; radius: 1">
      </a-entity>

      <!-- Boundary lines at 4m from back wall -->
      <!-- Floor lines -->
      <a-entity position="0 0.05 -4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Wall lines -->
      <a-entity position="0 2 -4">
        <!-- Left wall vertical lines -->
        <a-box position="-1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="-1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right wall vertical lines -->
        <a-box position="1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Ceiling lines -->
      <a-entity position="0 3.95 -4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Add a second boundary at 4m from front wall -->
      <a-entity position="0 0.05 4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Wall lines for front boundary -->
      <a-entity position="0 2 4">
        <!-- Left wall vertical lines -->
        <a-box position="-1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="-1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right wall vertical lines -->
        <a-box position="1.95 0 0" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <a-box position="1.95 0 -4" width="0.001" height="4" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
      </a-entity>

      <!-- Ceiling lines for front boundary -->
      <a-entity position="0 3.95 4">
        <!-- Front line -->
        <a-box position="0 0 0" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Back line -->
        <a-box position="0 0 -4" width="4" height="0.001" depth="0.001" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Left line -->
        <a-box position="-2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 0; metalness: 1; roughness: 0; opacity: 1"></a-box>
        <!-- Right line -->
        <a-box position="2 0 -2" width="0.001" height="0.001" depth="4" color="#ffffff" material="shader: standard; emissive: #ffffff; emissiveIntensity: 1.5; metalness: 0; roughness: 0; opacity: 0.5"></a-box>
      </a-entity>

      <!-- Add game manager entity with score display -->
      <a-entity id="game-manager" game-manager>
        <a-entity id="version-display" position="0 2.8 0" text="value: v0.20; align: center; width: 2; color: #ffffff"></a-entity>
        <a-entity id="score-display" position="0 2.5 0" text="value: Player: 0 - Bot: 0; align: center; width: 2; color: #ffffff"></a-entity>
        <a-entity id="timer-display" position="0 2.2 0" text="value: Time: 3:00; align: center; width: 2; color: #ffff00"></a-entity>
        <a-entity id="start-message" position="0 2.5 0" text="value: Press A to Start; align: center; width: 2; color: #ffffff"></a-entity>

      </a-entity>

      <!-- Add impact sound entities -->
      <a-entity id="impact-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 2;">
      </a-entity>

      <!-- Add bounce sound entity -->
      <a-entity id="bounce-sound" sound="src: url(audio/impact-cinematic-boom-5-352465.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 8;
                                        rate: 1.5;">
      </a-entity>

      <!-- Bot (AI player) -->
      <a-entity position="0 0 -6" advanced-bot="enabled: true; difficulty: medium; debug: true">
        <a-sphere id="bot-target" radius="0.2" color="#ff0000" position="0 0 0" obb-collider material="wireframe: true; color: #ff0000; opacity: 0.5" glow="color: #ff0000; intensity: 1.5" impact-effect="color: #ff0000">
          <a-entity light="type: point;
                         color: #ff0000;
                         intensity: 0.8;     
                         distance: 3;       
                         decay: 2"  
                    position="0 0 0">
          </a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Player 1 ball spawn (AI player's ball) -->
      <a-sphere position="0 1 -5.5" 
             radius="0.1"
             color="#ff0000" 
             glow="color: #ff0000; intensity: 1.5"
             simple-grab="player: player1"
             debug-collider
             obb-collider>
        <a-entity light="type: point;
                       color: #ff0000;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2;"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff0000" material="wireframe: true; color: #ff0000; opacity: 0.5"></a-sphere>
        <a-entity id="red-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Player 2 ball spawn (Human player's ball) -->
      <a-sphere position="0 1 5.5" 
             radius="0.1"
             color="#0000ff" 
             glow="color: #0000ff; intensity: 1.5"
             simple-grab="player: player2"
             debug-collider
             obb-collider>
        <a-entity light="type: point; 
                       color: #0000ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#0000ff" material="wireframe: true; color: #0000ff; opacity: 0.5"></a-sphere>
        <a-entity id="blue-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Basic Camera Rig for VR -->
      <a-entity id="player" position="0 0 6">
        <a-entity id="rig" position="0 0 0">
          <a-entity camera look-controls="pointerLockEnabled: false">
            <!-- This is the target sphere that needs to be hit -->
            <a-sphere id="player-target" radius="0.2" color="#0000ff" glow="color: #0000ff; intensity: 1.5" obb-collider material="transparent: true; opacity: 0.5" impact-effect="color: #0000ff">
              <a-entity light="type: point;
                             color: #0000ff;
                             intensity: 0.8;     
                             distance: 3;       
                             decay: 2"  
                        position="0 0 0">
              </a-entity>
              <!-- Impact sphere with animation component -->
              <a-sphere id="player-impact" radius="0.1" color="#0000ff" opacity="0" visible="false" material="side: double; transparent: true"
                animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
                animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
              </a-sphere>
            </a-sphere>
          </a-entity>
          
          <a-entity id="leftHand" 
                   hand-controls="hand: left"
                   oculus-touch-controls="hand: left"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Racket for left hand -->
            <a-box id="leftHandRacket"
                   width="0.2" 
                   height="0.2" 
                   depth="0.02"
                   position="0 0 -0.15"
                   rotation="0 -90 0"
                   color="#00ff00"
                   material="opacity: 0.7; transparent: true; emissive: #004400; emissiveIntensity: 0.3"
                   static-physics="isRacket: true"
                   visible="false">
            </a-box>
            
            <!-- Stats display on arm/wrist -->
            <a-entity id="arm-stats" 
                      position="0 0.1 0.05" 
                      rotation="-45 0 0">
              <!-- Background panel -->
              <a-plane width="0.25" 
                       height="0.15" 
                       color="#000000" 
                       material="opacity: 0.8; transparent: true"
                       position="0 0 -0.001">
              </a-plane>
              
              <!-- Stats text -->
              <a-text id="ball-stats-text"
                      value="Blue ball: -- m/s&#10;Red ball: -- m/s"
                      position="0 0 0"
                      align="center"
                      width="0.25"
                      color="#00ff00"
                      font="dejavu"
                      geometry="primitive: plane; width: auto; height: auto"
                      material="color: transparent; transparent: true">
              </a-text>
            </a-entity>
          </a-entity>
          
          <a-entity id="rightHand" 
                   hand-controls="hand: right"
                   oculus-touch-controls="hand: right"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   >
            <!-- Racket for right hand -->
            <a-box id="rightHandRacket"
                   width="0.2" 
                   height="0.2" 
                   depth="0.02"
                   position="0 0 -0.15"
                   rotation="0 -90 0"
                   color="#00ff00"
                   material="opacity: 0.7; transparent: true; emissive: #004400; emissiveIntensity: 0.3"
                   static-physics="isRacket: true"
                   visible="false">
            </a-box>
          </a-entity>
        </a-entity>
      </a-entity>

      <a-sky color="#000000"></a-sky>
    </a-scene>
  </body>
</html> 