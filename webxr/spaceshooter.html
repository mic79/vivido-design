<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR Space Shooter</title>
    <meta name="description" content="Zero-gravity space shooter with 6DOF movement inspired by Overload">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="importmap">
      {
        "imports": {
          "aframe": "https://raw.githack.com/aframevr/aframe/gh-pages/dist/aframe-master.module.min.js",
          "three": "https://cdn.jsdelivr.net/npm/super-three@0.173.5/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/super-three@0.173.5/examples/jsm/"
        }
      }
    </script>
        <script type="module">
          import AFRAME from 'aframe';
          // Make AFRAME and THREE globally available for other scripts
          window.AFRAME = AFRAME;
          window.THREE = AFRAME.THREE;
          
          // Also make them available without window prefix
          globalThis.AFRAME = AFRAME;
          globalThis.THREE = AFRAME.THREE;
          
          console.log('AFRAME globally exposed:', !!window.AFRAME);
        </script>
    <script src="https://raw.githack.com/aframevr/aframe/gh-pages/examples/showcase/post-processing/bloom.js" type="module"></script>
    
    <!-- Wait for modules to load before loading other scripts -->
    <script>
      // Wait for AFRAME to be available globally before loading other components
      function waitForAFrame() {
        if (typeof AFRAME !== 'undefined' && typeof THREE !== 'undefined') {
          // Load other scripts dynamically after AFRAME is ready
          const scripts = [
            'https://cdn.jsdelivr.net/gh/c-frame/aframe-particle-system-component@1.2.0/dist/aframe-particle-system-component.min.js',
            'https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js',
            'https://unpkg.com/three-mesh-bvh@0.7.8/build/index.umd.cjs',
            'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js'
          ];
          
          let loadedCount = 0;
          scripts.forEach(src => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => {
              loadedCount++;
              if (loadedCount === scripts.length) {
                console.log('All external scripts loaded successfully');
              }
            };
            document.head.appendChild(script);
          });
        } else {
          setTimeout(waitForAFrame, 50);
        }
      }
      waitForAFrame();
    </script>
    
    <!-- Custom components that depend on AFRAME -->
    <script>
      // Wait for AFRAME before registering custom components
      function initCustomComponents() {
        if (typeof AFRAME === 'undefined') {
          setTimeout(initCustomComponents, 50);
          return;
        }
        
        // Enhanced emissive materials for better bloom visibility
        
        // === BULLET SHOOTING SYSTEM ===
        // This system handles rapid-fire projectile weapons with impact animations
        // Separate from ball throwing mechanics used by bots
        
        // Bullet Manager - Handles cleanup and optimization
        AFRAME.registerComponent('bullet-manager', {
          init: function() {
            this.activeBullets = new Map(); // Track bullets by ID
            this.maxBullets = 50; // Maximum bullets per player
            this.cleanupInterval = 5000; // Cleanup every 5 seconds
            
            // Start cleanup timer
            this.cleanupTimer = setInterval(() => {
              this.cleanupOldBullets();
            }, this.cleanupInterval);
          },
          
          remove: function() {
            if (this.cleanupTimer) {
              clearInterval(this.cleanupTimer);
            }
          },
          
          registerBullet: function(bulletId, bulletElement) {
            this.activeBullets.set(bulletId, {
              element: bulletElement,
              timestamp: Date.now()
            });
            
            // Enforce bullet limit
            if (this.activeBullets.size > this.maxBullets) {
              this.removeOldestBullet();
            }
          },
          
          unregisterBullet: function(bulletId) {
            this.activeBullets.delete(bulletId);
          },
          
          removeOldestBullet: function() {
            let oldestTime = Infinity;
            let oldestId = null;
            
            for (const [id, data] of this.activeBullets) {
              if (data.timestamp < oldestTime) {
                oldestTime = data.timestamp;
                oldestId = id;
              }
            }
            
            if (oldestId) {
              const bulletData = this.activeBullets.get(oldestId);
              if (bulletData.element && bulletData.element.parentNode) {
                bulletData.element.parentNode.removeChild(bulletData.element);
              }
              this.activeBullets.delete(oldestId);
            }
          },
          
          cleanupOldBullets: function() {
            const now = Date.now();
            const maxAge = 10000; // 10 seconds max age
            
            for (const [id, data] of this.activeBullets) {
              if (now - data.timestamp > maxAge) {
                if (data.element && data.element.parentNode) {
                  data.element.parentNode.removeChild(data.element);
                }
                this.activeBullets.delete(id);
              }
            }
          }
        });
        
        // Bullet Component - Real bullets with collision detection
        AFRAME.registerComponent('bullet', {
          schema: {
            speed: { type: 'number', default: 10 },
            damage: { type: 'number', default: 10 },
            lifetime: { type: 'number', default: 5000 },
            shooter: { type: 'string', default: '' },
            hand: { type: 'string', default: 'right' },
            directionX: { type: 'number', default: 0 },
            directionY: { type: 'number', default: 0 },
            directionZ: { type: 'number', default: -1 },
            bulletId: { type: 'string', default: '' },
            isRemote: { type: 'boolean', default: false },
            isHoming: { type: 'boolean', default: false },
            targetId: { type: 'string', default: '' },
            homingForce: { type: 'number', default: 20 },
            explosionRadius: { type: 'number', default: 1.0 },
            explosionDamage: { type: 'number', default: 50 },
            bulletHits: { type: 'number', default: 0 },
            maxBulletHits: { type: 'number', default: 5 }
          },
          
          init: function() {
            this.startTime = Date.now();
            this.velocity = new THREE.Vector3();
            this.lastPosition = new THREE.Vector3();
            
            // Generate unique bullet ID if not provided (for local bullets)
            if (!this.data.bulletId) {
              this.data.bulletId = `bullet_${this.data.shooter}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              this.el.setAttribute('bulletId', this.data.bulletId);
            }
            
            // Initialize homing missile properties
            if (this.data.isHoming) {
              this.target = null;
              this.lastTargetUpdate = 0;
              this.targetUpdateInterval = 100; // Update target every 100ms
              this.spawnTime = Date.now(); // Track when missile was spawned
              this.collisionDelay = 200; // Disable collision detection for first 200ms
            }
            
            // Use the direction passed from the gun component
            const direction = new THREE.Vector3(
              this.data.directionX, 
              this.data.directionY, 
              this.data.directionZ
            );
            
            // Normalize and set velocity
            direction.normalize();
            this.velocity.copy(direction).multiplyScalar(this.data.speed);
            
            // Store starting position for CCD - initialize after position is set
            this.lastPosition = new THREE.Vector3();
            
            // Send bullet creation to other players (only for local bullets)
            if (!this.data.isRemote && isMultiplayer) {
              this.sendBulletCreate();
            }
            
            // Register with bullet manager for cleanup
            const bulletManager = document.querySelector('[bullet-manager]');
            if (bulletManager && bulletManager.components['bullet-manager']) {
              bulletManager.components['bullet-manager'].registerBullet(this.data.bulletId, this.el);
            }
            
            // Only set visual properties if not already set (for remote bullets)
            if (!this.el.getAttribute('geometry')) {
              // Create bullet visual - set radius based on bullet type
              let bulletRadius = 0.02; // Default for regular bullets
              if (this.data.isHoming) {
                bulletRadius = 0.1; // Missiles are larger
              }
              
            this.el.setAttribute('geometry', {
              primitive: 'sphere',
                radius: bulletRadius
              });
            }
            
            if (!this.el.getAttribute('material')) {
              // Set color based on bullet type
              if (this.data.isHoming) {
                // This is a missile - red color
                this.el.setAttribute('material', {
                  color: '#ff0000',
                  emissive: '#ff0000',
                  emissiveIntensity: 2
                });
              } else {
                // This is a regular bullet - yellow color
            this.el.setAttribute('material', {
              color: '#ffff00',
              emissive: '#ffff00',
              emissiveIntensity: 2
            });
              }
            }
          },
          
          tick: function(time, timeDelta) {
            const dt = timeDelta / 1000;
            
            // Check lifetime
            if (Date.now() - this.startTime > this.data.lifetime) {
              this.destroyBullet();
              return;
            }
            
            // Initialize lastPosition on first tick (after position is properly set)
            if (this.lastPosition.length() === 0) {
              this.lastPosition.copy(this.el.object3D.position);
            }
            
            // Store current position before moving
            this.lastPosition.copy(this.el.object3D.position);
            
            // For homing missiles, ensure lastPosition is updated even during collision delay
            if (this.data.isHoming && (Date.now() - this.spawnTime) < this.collisionDelay) {
              // During collision delay, keep lastPosition updated so when collision detection starts,
              // it uses the correct previous position (from the previous frame)
              // This prevents a long raycast from spawn position to current position
            }
            
            // Homing missile logic
            if (this.data.isHoming) {
              this.updateHomingTarget(time);
              this.applyHomingForce(dt);
            }
            
            // Move bullet
            const movement = this.velocity.clone().multiplyScalar(dt);
            this.el.object3D.position.add(movement);
            
            // For homing missiles during collision delay, update lastPosition to prevent long raycasts
            if (this.data.isHoming && (Date.now() - this.spawnTime) < this.collisionDelay) {
              // Update lastPosition to current position to prevent long raycasts when collision detection starts
              this.lastPosition.copy(this.el.object3D.position);
            }
            
            // Continuous collision detection - check path from last position to current
            // Skip collision detection for homing missiles during spawn delay
            if (this.data.isHoming && (Date.now() - this.spawnTime) < this.collisionDelay) {
              // Skip collision detection during spawn delay
            } else {
            this.checkContinuousCollision();
            }
          },
          
          checkContinuousCollision: function() {
            const currentPos = this.el.object3D.position.clone();
            const lastPos = this.lastPosition.clone();
            
            // Get all collidable meshes - only from visible models using the same filtering as other systems
            const allMeshes = [];
            const models = [
              document.querySelector('#model-level'),
              document.querySelector('#model-spaceship'),
              document.querySelector('#model-asteroid-42')
            ];
            
            // Collect all meshes first
            models.forEach(model => {
              if (model && model.object3D) {
                model.object3D.traverse(child => {
                  if (child.isMesh && child.geometry) {
                    allMeshes.push(child);
                  }
                });
              }
            });
            
            // Filter to only visible meshes using the same logic as other systems
            const meshes = this.getVisibleMeshes(allMeshes);
            
            // Debug logging for homing missiles - removed console spam
            
            // Performance logging for bullet collision optimization with throttling
            if (allMeshes.length > 0 && meshes.length < allMeshes.length) {
              const hiddenCount = allMeshes.length - meshes.length;
              
              // Initialize throttling if not exists
              if (!this._bulletOptimizationLog) {
                this._bulletOptimizationLog = {
                  lastCount: -1,
                  lastLogTime: 0,
                  logInterval: 5000 // 5 seconds
                };
              }
              
              const now = Date.now();
              const shouldLog = hiddenCount !== this._bulletOptimizationLog.lastCount || 
                              (now - this._bulletOptimizationLog.lastLogTime) > this._bulletOptimizationLog.logInterval;
              
              if (shouldLog) {
                // Removed console spam - optimization working correctly
                this._bulletOptimizationLog.lastCount = hiddenCount;
                this._bulletOptimizationLog.lastLogTime = now;
              }
            }
            
            // Add grab-surface objects (only if visible)
            const surfaces = document.querySelectorAll('[grab-surface]');
            surfaces.forEach(surface => {
              if (surface.object3D && surface.getAttribute('visible') !== false && surface.getAttribute('visible') !== 'false') {
                surface.object3D.traverse(child => {
                  if (child.isMesh && child.geometry) {
                    meshes.push(child);
                  }
                });
              }
            });
            
            // CCD - Raycast from last position to current position
            const raycaster = new THREE.Raycaster();
            const direction = new THREE.Vector3().subVectors(currentPos, lastPos);
            const distance = direction.length();
            
            if (distance > 0) {
              direction.normalize();
              raycaster.set(lastPos, direction);
              raycaster.far = distance + 0.02; // Add small buffer
              
          const intersects = raycaster.intersectObjects(meshes, false);
          
          if (intersects.length > 0) {
            const hit = intersects[0];
            if (hit.distance <= distance + 0.01) {
              
              // Debug logging for collision - removed console spam
              
              // Create impact effects at hit point
              const impactManager = document.querySelector('[impact-effects-manager]');
              if (impactManager && impactManager.components['impact-effects-manager']) {
                impactManager.components['impact-effects-manager'].createImpactEffect(hit.point);
              }
              
              // Play random metal hit sound at impact location
              const metalHitSounds = [
                document.querySelector('#metal-hit-sound-1'),
                document.querySelector('#metal-hit-sound-2'),
                document.querySelector('#metal-hit-sound-3')
              ];
              const randomSound = metalHitSounds[Math.floor(Math.random() * metalHitSounds.length)];
              if (randomSound) {
                randomSound.object3D.position.copy(hit.point);
                randomSound.components.sound.playSound();
              }
              
              this.destroyBullet();
              return;
            }
          }
            }
            
            // Check entity collisions
            this.checkEntityCollisions(currentPos);
          },
          
          checkEntityCollisions: function(bulletPos) {
            const hitRadius = 0.5; // Hit detection radius - increased for better detection
            
            // Check collision with homing missiles first (but not with self)
            const homingMissiles = document.querySelectorAll('[bullet]');
            homingMissiles.forEach(missile => {
              if (missile.components['bullet'] && missile.components['bullet'].data.isHoming && missile !== this.el) {
                const missilePos = new THREE.Vector3();
                missile.object3D.getWorldPosition(missilePos);
                const distance = bulletPos.distanceTo(missilePos);

                if (distance < hitRadius) {
                  // Hit the homing missile
                  missile.components['bullet'].hitByBullet();

                  // Create impact effects
                  const impactManager = document.querySelector('[impact-effects-manager]');
                  if (impactManager && impactManager.components['impact-effects-manager']) {
                    impactManager.components['impact-effects-manager'].createImpactEffect(missilePos);
                  }

                  this.destroyBullet();
                  return;
                }
              }
            });
            
            // Check collision with local player target (only if bullet is from another player)
            const playerTarget = document.querySelector('#player-target');
            if (playerTarget && this.data.shooter !== 'player' && this.data.shooter !== myPlayerId) {
              const playerPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(playerPos);
              const distance = bulletPos.distanceTo(playerPos);
              
              if (distance < hitRadius) {
                this.hitPlayer(playerTarget);
                return;
              }
            }
            
            // Check collision with remote players in multiplayer
            if (isMultiplayer && this.data.shooter !== myPlayerId) {
              for (let i = 0; i < 4; i++) {
                const remoteTarget = document.querySelector(`#remote-target-${i}`);
                const playerId = `player_${i}`;
                
                // Skip if this is the shooter or if target doesn't exist
                if (this.data.shooter === playerId || !remoteTarget) continue;
                
                // Check if remote player is visible and active
                const remotePlayer = document.querySelector(`#remote-player-${i}`);
                if (!remotePlayer || remotePlayer.getAttribute('visible') === 'false') continue;
                
                const targetPos = new THREE.Vector3();
                remoteTarget.object3D.getWorldPosition(targetPos);
                const distance = bulletPos.distanceTo(targetPos);
                
                if (distance < hitRadius) {
                  this.hitRemotePlayer(remoteTarget, playerId);
                  return;
                }
              }
            }
            
            // Check collision with bots
            const bots = document.querySelectorAll('[zerog-bot]');
            bots.forEach(bot => {
              if (this.data.shooter === bot.id) return; // Don't hit self
              
              const botPos = new THREE.Vector3();
              bot.object3D.getWorldPosition(botPos);
              const distance = bulletPos.distanceTo(botPos);
              
              
              if (distance < hitRadius) {
                this.hitBot(bot);
              }
            });
          },
          
          hitPlayer: function(player) {
            // Don't create impact effects for individual hits - only for damage milestones or death
            // The player damage system will handle individual hit effects and sounds
            
            // Call player's damage system if this is a missile
            if (this.data.isHoming) {
            const playerTarget = document.querySelector('#player-target');
              if (playerTarget && playerTarget.components['player-damage']) {
                playerTarget.components['player-damage'].hitByMissile();
              }
            }
            
            // Vibrate both controllers when player is hit
            const leftHand = document.querySelector('#leftHand');
            const rightHand = document.querySelector('#rightHand');
            if (leftHand && leftHand.components['hand-controls'] && leftHand.components['hand-controls'].gamepad) {
              const gamepad = leftHand.components['hand-controls'].gamepad;
              if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
                gamepad.hapticActuators[0].pulse(0.3, 200); // 30% intensity, 200ms
              }
            }
            if (rightHand && rightHand.components['hand-controls'] && rightHand.components['hand-controls'].gamepad) {
              const gamepad = rightHand.components['hand-controls'].gamepad;
              if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
                gamepad.hapticActuators[0].pulse(0.3, 200); // 30% intensity, 200ms
              }
            }
            
            // Broadcast hit effect to all other players (same as ball system)
            if (isMultiplayer && activePlayers.size > 1) {
              sendHitEffect(myPlayerId); // Send hit effect for local player
            }
            
            this.destroyBullet();
          },
          
          hitBot: function(bot) {
            // Don't create impact effects for individual hits - only for damage milestones or death
            // The bot damage system will handle individual hit effects and sounds
            
            // Call bot's damage system using event dispatch
            bot.dispatchEvent(new CustomEvent('bot-hit-by-bullet', {
              detail: { bullet: this.el }
            }));
            
            // Visual feedback - make bot flash red briefly (local only)
            const originalColor = bot.getAttribute('color') || '#ffffff';
            bot.setAttribute('color', '#ff0000');
            setTimeout(() => {
              bot.setAttribute('color', originalColor);
            }, 200);
            
            // Broadcast hit effect to all other players (same as ball system)
            // Map bot entity ID to the format used by ball system
            let botTargetId = 'bot-red'; // Default
            if (bot.id === 'zerog-bot-red') {
              botTargetId = 'bot-red';
            } else if (bot.id === 'zerog-bot-blue') {
              botTargetId = 'bot-blue';
            } else if (bot.id === 'zerog-bot-green') {
              botTargetId = 'bot-green';
            }
            
            if (isMultiplayer && activePlayers.size > 1) {
              sendHitEffect(botTargetId); // Send hit effect using ball system format
            }
            
            this.destroyBullet();
          },
          
          hitRemotePlayer: function(remoteTarget, playerId) {
            // Don't create impact effects for individual hits - only for damage milestones or death
            // The remote player's damage system will handle individual hit effects and sounds
            
            // Broadcast hit effect to all other players (same as ball system)
            if (isMultiplayer && activePlayers.size > 1) {
              sendHitEffect(playerId); // Send hit effect for the remote player
            }
            
            this.destroyBullet();
          },
          
          sendBulletCreate: function() {
            const bulletData = {
              type: 'bullet-create',
              bulletId: this.data.bulletId,
              shooterPlayerId: this.data.shooter,
              position: {
                x: this.el.object3D.position.x,
                y: this.el.object3D.position.y,
                z: this.el.object3D.position.z
              },
              direction: {
                x: this.data.directionX,
                y: this.data.directionY,
                z: this.data.directionZ
              },
              speed: this.data.speed,
              hand: this.data.hand,
              isHoming: this.data.isHoming,
              targetId: this.data.targetId,
              homingForce: this.data.homingForce,
              explosionRadius: this.data.explosionRadius,
              explosionDamage: this.data.explosionDamage,
              bulletHits: this.data.bulletHits,
              maxBulletHits: this.data.maxBulletHits
            };
            
            if (isHost) {
              // Host sends to all clients
              connections.forEach((conn, connectionKey) => {
                if (conn && conn.open) {
                  conn.send(bulletData);
                }
              });
            } else {
              // Client sends to host
              const hostConn = connections.get('host');
              if (hostConn && hostConn.open) {
                hostConn.send(bulletData);
              }
            }
          },
          
          destroyBullet: function() {
            // Debug logging for missile destruction - removed console spam
            
            // Stop and clean up sound component for homing missiles
            if (this.data.isHoming && this.el.components.sound) {
              this.el.components.sound.stopSound();
            }
            
            // Unregister from bullet manager
            const bulletManager = document.querySelector('[bullet-manager]');
            if (bulletManager && bulletManager.components['bullet-manager']) {
              bulletManager.components['bullet-manager'].unregisterBullet(this.data.bulletId);
            }
            
            // Send bullet destroy notification to other players
            if (!this.data.isRemote && isMultiplayer && (isHost || connections.size > 0)) {
              const destroyData = {
                type: 'bullet-destroy',
                bulletId: this.data.bulletId,
                shooterPlayerId: this.data.shooter
              };
              
              if (isHost) {
                // Host sends to all clients
                connections.forEach((conn, connectionKey) => {
                  if (conn && conn.open) {
                    conn.send(destroyData);
                  }
                });
              } else {
                // Client sends to host
                const hostConn = connections.get('host');
                if (hostConn && hostConn.open) {
                  hostConn.send(destroyData);
                }
              }
            }
            
            if (this.el.parentNode) {
              this.el.parentNode.removeChild(this.el);
            }
          },
          
          // Helper function to filter meshes from visible models only (same as other systems)
          getVisibleMeshes: function(meshes) {
            const visibleMeshes = meshes.filter(mesh => {
              // Check if mesh belongs to a visible model entity
              let isFromVisibleModel = true;
              let currentParent = mesh.parent;
              
              // Traverse up the hierarchy to find the model entity
              while (currentParent) {
                if (currentParent.el && currentParent.el.getAttribute) {
                  const visible = currentParent.el.getAttribute('visible');
                  if (visible === false || visible === 'false') {
                    isFromVisibleModel = false;
                    break;
                  }
                }
                currentParent = currentParent.parent;
              }
              
              return isFromVisibleModel;
            });
            
            return visibleMeshes;
          },
          
          // Homing missile methods - using tractor beam logic
          updateHomingMissile: function(time, timeDelta) {
            // Check lifetime
            if (Date.now() - this.startTime > this.lifetime) {
              this.explodeMissile();
              return;
            }
            
            // Update target periodically
            if (time - this.lastTargetUpdate > this.targetUpdateInterval) {
              this.updateTarget();
              this.lastTargetUpdate = time;
            }
            
            if (!this.target) return;
            
            // Apply homing force using tractor beam logic
            this.applyHomingForce();
          },
          
          updateTarget: function() {
            // Find the best target (same logic as bot targeting)
            const targets = [];
            
            // Add human player as potential target
            const playerTarget = document.querySelector('#player-target');
            if (playerTarget) {
              const targetPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(targetPos);
              targets.push({
                type: 'human player',
                position: targetPos,
                element: playerTarget,
                distance: new THREE.Vector3().copy(this.body.position).distanceTo(targetPos)
              });
            }
            
            // Add remote players in multiplayer
            if (isMultiplayer) {
              for (let i = 0; i < 4; i++) {
                const remoteTarget = document.querySelector(`#remote-target-${i}`);
                const remotePlayer = document.querySelector(`#remote-player-${i}`);
                
                if (remoteTarget && remotePlayer && remotePlayer.getAttribute('visible') !== 'false') {
                  const targetPos = new THREE.Vector3();
                  remoteTarget.object3D.getWorldPosition(targetPos);
                  targets.push({
                    type: `remote player ${i}`,
                    position: targetPos,
                    element: remoteTarget,
                    distance: new THREE.Vector3().copy(this.body.position).distanceTo(targetPos)
                  });
                }
              }
            }
            
            // Select closest target
            if (targets.length > 0) {
              targets.sort((a, b) => a.distance - b.distance);
              this.target = targets[0].element;
              this.targetPosition = targets[0].position.clone();
            }
          },
          
          applyHomingForce: function() {
            if (!this.body || !this.target) return;
            
            // Get target position
            const targetPos = new THREE.Vector3();
            this.target.object3D.getWorldPosition(targetPos);
            
            // Calculate attraction force toward target position (same as tractor beam)
            const ballPos = new THREE.Vector3().copy(this.body.position);
            const attractionVector = new THREE.Vector3().subVectors(targetPos, ballPos);
            const distance = attractionVector.length();
            
            if (distance > 0.01) { // Only apply force if not already at target
              // Normalize and apply force - stronger when farther away
              attractionVector.normalize();
              
              // Adaptive force: stronger for distant objects, gentler when close
              let forceMultiplier;
              if (distance > 2.0) {
                forceMultiplier = 20.0; // Strong force for distant targets
              } else if (distance > 0.5) {
                forceMultiplier = 15.0; // Medium force for medium distance
              } else {
                forceMultiplier = 10.0;  // Gentle force when close
              }
              
              // Apply force to physics body
              const force = attractionVector.multiplyScalar(forceMultiplier);
              this.body.velocity.add(force);
              
              // Limit maximum velocity
              const maxVelocity = this.data.maxVelocity;
              if (this.body.velocity.length() > maxVelocity) {
                this.body.velocity.normalize().multiplyScalar(maxVelocity);
              }
            }
          },
          
          explodeMissile: function() {
            const explosionPos = new THREE.Vector3().copy(this.body.position);
            
            // Create impact effects
            const impactManager = document.querySelector('[impact-effects-manager]');
            if (impactManager && impactManager.components['impact-effects-manager']) {
              impactManager.components['impact-effects-manager'].createImpactEffect(explosionPos);
            }
            
            // Apply damage to nearby players
            this.applyExplosionDamage(explosionPos);
            
            // Reset the missile
            this.resetPosition();
            
            console.log('💥 Homing missile exploded at', explosionPos);
          },
          
          applyExplosionDamage: function(explosionPos) {
            const explosionRadius = this.data.explosionRadius;
            const maxDamage = this.data.explosionDamage;
            
            // Check damage to local player
            const playerTarget = document.querySelector('#player-target');
            if (playerTarget) {
              const playerPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(playerPos);
              const distance = explosionPos.distanceTo(playerPos);
              
              if (distance <= explosionRadius) {
                const damageRatio = 1 - (distance / explosionRadius); // 1.0 at center, 0.0 at edge
                const damage = maxDamage * damageRatio;
                
                // Apply damage (50% damage within 1m)
                if (damage >= maxDamage * 0.5) {
                  
                  // Vibrate both controllers when hit by missile explosion
                  const leftHand = document.querySelector('#left-hand');
                  const rightHand = document.querySelector('#right-hand');
                  if (leftHand && leftHand.components['hand-controls'] && leftHand.components['hand-controls'].gamepad) {
                    const gamepad = leftHand.components['hand-controls'].gamepad;
                    if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
                      gamepad.hapticActuators[0].pulse(0.4, 300); // 40% intensity, 300ms
                    }
                  }
                  if (rightHand && rightHand.components['hand-controls'] && rightHand.components['hand-controls'].gamepad) {
                    const gamepad = rightHand.components['hand-controls'].gamepad;
                    if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
                      gamepad.hapticActuators[0].pulse(0.4, 300); // 40% intensity, 300ms
                    }
                  }
                  
                  // TODO: Implement player damage system
                }
              }
            }
            
            // Check damage to remote players in multiplayer
            if (isMultiplayer) {
              for (let i = 0; i < 4; i++) {
                const remoteTarget = document.querySelector(`#remote-target-${i}`);
                const remotePlayer = document.querySelector(`#remote-player-${i}`);
                
                if (remoteTarget && remotePlayer && remotePlayer.getAttribute('visible') !== 'false') {
                  const targetPos = new THREE.Vector3();
                  remoteTarget.object3D.getWorldPosition(targetPos);
                  const distance = explosionPos.distanceTo(targetPos);
                  
                  if (distance <= explosionRadius) {
                    const damageRatio = 1 - (distance / explosionRadius);
                    const damage = maxDamage * damageRatio;
                    
                    if (damage >= maxDamage * 0.5) {
                      console.log(`💥 Remote player ${i} hit by missile explosion! Damage: ${damage.toFixed(1)}%`);
                      // TODO: Implement remote player damage system
                    }
                  }
                }
              }
            }
          },
          
          hitByBullet: function() {
            if (!this.data.isHoming) return;
            
            this.data.bulletHits++;
            // Don't explode bullet when it hits something - just track hits
            // The bullet will be destroyed by the collision system
          },
          
          updateHomingTarget: function(time) {
            // Update target periodically
            if (time - this.lastTargetUpdate > this.targetUpdateInterval) {
              // Find the best target (same logic as bot targeting)
              const targets = [];
              
              // Add human player as potential target
              const playerTarget = document.querySelector('#player-target');
              if (playerTarget) {
                const targetPos = new THREE.Vector3();
                playerTarget.object3D.getWorldPosition(targetPos);
                targets.push({
                  type: 'human player',
                  position: targetPos,
                  element: playerTarget,
                  distance: new THREE.Vector3().copy(this.el.object3D.position).distanceTo(targetPos)
                });
              }
              
              // Add remote players in multiplayer
              if (isMultiplayer) {
                for (let i = 0; i < 4; i++) {
                  const remoteTarget = document.querySelector(`#remote-target-${i}`);
                  const remotePlayer = document.querySelector(`#remote-player-${i}`);
                  
                  if (remoteTarget && remotePlayer && remotePlayer.getAttribute('visible') !== 'false') {
                    const targetPos = new THREE.Vector3();
                    remoteTarget.object3D.getWorldPosition(targetPos);
                    targets.push({
                      type: `remote player ${i}`,
                      position: targetPos,
                      element: remoteTarget,
                      distance: new THREE.Vector3().copy(this.el.object3D.position).distanceTo(targetPos)
                    });
                  }
                }
              }
              
              // Select closest target
              if (targets.length > 0) {
                targets.sort((a, b) => a.distance - b.distance);
                this.target = targets[0].element;
              }
              
              this.lastTargetUpdate = time;
            }
          },
          
          applyHomingForce: function(dt) {
            if (!this.target) return;
            
            // Get target position
            const targetPos = new THREE.Vector3();
            this.target.object3D.getWorldPosition(targetPos);
            
            // Calculate attraction force toward target position (same as tractor beam)
            const bulletPos = new THREE.Vector3().copy(this.el.object3D.position);
            const attractionVector = new THREE.Vector3().subVectors(targetPos, bulletPos);
            const distance = attractionVector.length();
            
            if (distance > 0.01) { // Only apply force if not already at target
              // Normalize and apply force - stronger when farther away
              attractionVector.normalize();
              
              // Adaptive force: stronger for distant objects, gentler when close
              let forceMultiplier;
              if (distance > 2.0) {
                forceMultiplier = this.data.homingForce; // Strong force for distant targets
              } else if (distance > 0.5) {
                forceMultiplier = this.data.homingForce * 0.75; // Medium force for medium distance
              } else {
                forceMultiplier = this.data.homingForce * 0.5;  // Gentle force when close
              }
              
              // Apply force to velocity
              const force = attractionVector.multiplyScalar(forceMultiplier * dt);
              this.velocity.add(force);
              
              // Limit maximum velocity
              const maxVelocity = this.data.speed;
              if (this.velocity.length() > maxVelocity) {
                this.velocity.normalize().multiplyScalar(maxVelocity);
              }
            }
          },
          
          explodeMissile: function() {
            const explosionPos = new THREE.Vector3().copy(this.el.object3D.position);
            
            // Create impact effects
            const impactManager = document.querySelector('[impact-effects-manager]');
            if (impactManager && impactManager.components['impact-effects-manager']) {
              impactManager.components['impact-effects-manager'].createImpactEffect(explosionPos);
            }
            
            // Play random metal hit sound at explosion location
            const metalHitSounds = [
              document.querySelector('#metal-hit-sound-1'),
              document.querySelector('#metal-hit-sound-2'),
              document.querySelector('#metal-hit-sound-3')
            ];
            const randomSound = metalHitSounds[Math.floor(Math.random() * metalHitSounds.length)];
            if (randomSound) {
              randomSound.object3D.position.copy(explosionPos);
              randomSound.components.sound.playSound();
            }
            
            // Apply damage to nearby players
            this.applyExplosionDamage(explosionPos);
            
            // Destroy the bullet
            this.destroyBullet();
          },
          
          applyExplosionDamage: function(explosionPos) {
            const explosionRadius = this.data.explosionRadius;
            const maxDamage = this.data.explosionDamage;
            
            // Check damage to local player
            const playerTarget = document.querySelector('#player-target');
            if (playerTarget) {
              const playerPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(playerPos);
              const distance = explosionPos.distanceTo(playerPos);
              
              if (distance <= explosionRadius) {
                const damageRatio = 1 - (distance / explosionRadius); // 1.0 at center, 0.0 at edge
                const damage = maxDamage * damageRatio;
                
                // Apply damage (50% damage within 1m)
                if (damage >= maxDamage * 0.5) {
                  // TODO: Implement player damage system
                }
              }
            }
            
            // Check damage to remote players in multiplayer
            if (isMultiplayer) {
              for (let i = 0; i < 4; i++) {
                const remoteTarget = document.querySelector(`#remote-target-${i}`);
                const remotePlayer = document.querySelector(`#remote-player-${i}`);
                
                if (remoteTarget && remotePlayer && remotePlayer.getAttribute('visible') !== 'false') {
                  const targetPos = new THREE.Vector3();
                  remoteTarget.object3D.getWorldPosition(targetPos);
                  const distance = explosionPos.distanceTo(targetPos);
                  
                  if (distance <= explosionRadius) {
                    const damageRatio = 1 - (distance / explosionRadius);
                    const damage = maxDamage * damageRatio;
                    
                    if (damage >= maxDamage * 0.5) {
                      // TODO: Implement remote player damage system
                    }
                  }
                }
              }
            }
          }
        });
        
        // Gun Component - Power management and automatic firing for both controllers
        AFRAME.registerComponent('gun', {
          schema: {
            maxPower: { type: 'number', default: 100 },
            fireRate: { type: 'number', default: 8 }, // 8 bullets per second (32 in 4 seconds)
            powerDrainRate: { type: 'number', default: 25 }, // power per second when firing
            rechargeRate: { type: 'number', default: 25 }, // power per second when not firing
            bulletSpeed: { type: 'number', default: 10 } // Reduced for better collision
          },
          
          init: function() {
            this.currentPower = this.data.maxPower;
            this.isFiring = { left: false, right: false, camera: false };
            this.lastFireTime = { left: 0, right: 0, camera: 0 };
            this.triggerPressed = false;
            
            // Multiplayer rate limiting
            this.bulletsSentThisSecond = 0;
            this.maxBulletsPerSecond = isMultiplayer ? 6 : 8; // Reduced rate for multiplayer
            this.lastSecondReset = Date.now();
            
            // Determine which hand this gun component belongs to
            this.handType = 'unknown';
            if (this.el.id === 'leftHand') {
              this.handType = 'left';
            } else if (this.el.id === 'rightHand') {
              this.handType = 'right';
            }
            
            // Listen for trigger events from this specific controller
            this.el.addEventListener('triggerdown', () => this.startFiring(this.handType));
            this.el.addEventListener('triggerup', () => this.stopFiring(this.handType));
            
            // Desktop controls (space for right hand only to avoid duplication)
            if (this.handType === 'right') {
              document.addEventListener('keydown', (evt) => {
                if (evt.code === 'Space' && !this.triggerPressed && !isMenuVisible) {
                  this.triggerPressed = true;
                  this.startFiring('camera');
                }
              });
              
              document.addEventListener('keyup', (evt) => {
                if (evt.code === 'Space' && this.triggerPressed) {
                  this.triggerPressed = false;
                  this.stopFiring('camera');
                }
              });
            }
          },
          
          tick: function(time, timeDelta) {
            const dt = timeDelta / 1000; // Convert to seconds
            
            const isFiring = this.isFiring[this.handType] || (this.handType === 'right' && this.isFiring.camera);
            
            if (isFiring && this.currentPower > 0) {
              // Drain power while firing
              this.currentPower -= this.data.powerDrainRate * dt;
              if (this.currentPower < 0) this.currentPower = 0;
              
              // Fire bullets at specified rate
              const fireInterval = 1000 / this.data.fireRate; // ms between shots
              
              const handKey = this.handType === 'right' && this.isFiring.camera ? 'camera' : this.handType;
              if (time - this.lastFireTime[handKey] >= fireInterval) {
                this.fireBullet(handKey);
                this.lastFireTime[handKey] = time;
              }
              
              // Stop firing if out of power
              if (this.currentPower <= 0) {
                this.stopFiring(this.handType);
                if (this.handType === 'right') {
                  this.stopFiring('camera');
                }
              }
            } else if (!isFiring && this.currentPower < this.data.maxPower) {
              // Recharge power when not firing
              this.currentPower += this.data.rechargeRate * dt;
              if (this.currentPower > this.data.maxPower) {
                this.currentPower = this.data.maxPower;
              }
            }
            
            // Update power display for this specific hand
            this.updatePowerDisplay();
          },
          
          startFiring: function(hand) {
            // Don't start firing if menu is visible
            if (isMenuVisible) {
              return;
            }
            
            if (this.currentPower > 0) {
              this.isFiring[hand] = true;
            }
          },
          
          stopFiring: function(hand) {
            this.isFiring[hand] = false;
          },
          
          fireBullet: function(hand) {
            // Check multiplayer rate limiting
            const now = Date.now();
            if (now - this.lastSecondReset > 1000) {
              this.bulletsSentThisSecond = 0;
              this.lastSecondReset = now;
            }
            
            if (this.bulletsSentThisSecond >= this.maxBulletsPerSecond) {
              return; // Rate limited
            }
            
            // Create bullet entity
            const bullet = document.createElement('a-entity');
            
            let gunPos = new THREE.Vector3();
            let forwardDirection = new THREE.Vector3();
            let controller = null;
            
            // Get position and FORWARD DIRECTION based on hand
            if (hand === 'left') {
              controller = document.querySelector('#leftHand');
            } else if (hand === 'right') {
              controller = document.querySelector('#rightHand');
            } else {
              controller = document.querySelector('[camera]');
            }
            
            if (controller) {
              // EXACT COPY FROM WORKING PLAYER BALLS (lines 10781-10788)
              const controllerPos = new THREE.Vector3();
              const controllerQuat = new THREE.Quaternion();
              controller.object3D.getWorldPosition(controllerPos);
              controller.object3D.getWorldQuaternion(controllerQuat);
              
              // Calculate shooting direction (same as thruster - pointing down from controller)
              const direction = new THREE.Vector3(0, -1, 0);
              direction.applyQuaternion(controllerQuat);
              
              gunPos.copy(controllerPos);
              forwardDirection.copy(direction);
            }
            
            // Position bullet at gun position
            bullet.object3D.position.copy(gunPos);
            
            // Add bullet component with the calculated direction
            bullet.setAttribute('bullet', {
              speed: this.data.bulletSpeed,
              shooter: isMultiplayer && myPlayerId ? myPlayerId : 'player',
              hand: hand,
              directionX: forwardDirection.x,
              directionY: forwardDirection.y,
              directionZ: forwardDirection.z
            });
            
            // Add to scene
            this.el.sceneEl.appendChild(bullet);
            
            // Play laser sound from the controller that fired
            if (controller) {
              let soundEntity = null;
              if (hand === 'left') {
                soundEntity = document.querySelector('#left-hand-laser-sound');
              } else if (hand === 'right') {
                soundEntity = document.querySelector('#right-hand-laser-sound');
              }
              
              if (soundEntity && soundEntity.components.sound) {
                // Stop any currently playing sound and restart it to allow overlapping
                soundEntity.components.sound.stopSound();
                soundEntity.components.sound.playSound();
              }
            }
            
            // Vibrate the controller that shot the bullet
            if (controller && controller.components['hand-controls'] && controller.components['hand-controls'].gamepad) {
              const gamepad = controller.components['hand-controls'].gamepad;
              if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
                gamepad.hapticActuators[0].pulse(0.1, 50); // 10% intensity, 50ms
              }
            }
            
            // Increment rate limiting counter
            this.bulletsSentThisSecond++;
          },
          
          updatePowerDisplay: function() {
            // Update power bar for this specific hand
            const powerBarId = this.handType === 'left' ? '#power-bar-left' : '#power-bar-right';
            const powerBar = document.querySelector(powerBarId);
            if (powerBar) {
              const percentage = (this.currentPower / this.data.maxPower) * 100;
              const maxWidth = 0.1; // 10cm maximum width
              powerBar.setAttribute('geometry', {
                primitive: 'plane',
                width: maxWidth * (percentage / 100),
                height: 0.02
              });
              
              // Color based on power level
              let color = '#00ff00'; // Green
              if (percentage < 30) color = '#ff0000'; // Red
              else if (percentage < 60) color = '#ffff00'; // Yellow
              
              powerBar.setAttribute('material', { color: color });
            }
          }
        });
        
        AFRAME.registerComponent('enhanced-emissive', {
          schema: {
            intensity: { type: 'number', default: 2.0 },
            color: { type: 'color', default: '#ffffff' }
          },
          
          init: function() {
            this.el.addEventListener('materialtextureloaded', () => {
              this.applyEnhancement();
            });
            
            // Also apply immediately if material exists
            setTimeout(() => this.applyEnhancement(), 100);
          },
          
          applyEnhancement: function() {
            const mesh = this.el.getObject3D('mesh');
            if (mesh && mesh.material) {
              // Significantly boost emissive properties for bloom
              const emissiveColor = new THREE.Color(this.data.color);
              mesh.material.emissive = emissiveColor;
              mesh.material.emissiveIntensity = this.data.intensity;
              
              // Make material appear brighter
              if (mesh.material.type === 'MeshStandardMaterial') {
                mesh.material.emissiveMap = null;
              }
              
              mesh.material.needsUpdate = true;
              console.log('Enhanced emissive applied for bloom - intensity:', this.data.intensity);
            }
          },
          
          update: function() {
            this.applyEnhancement();
          }
        });
        
        // Enhanced particle system for better spark visibility
        AFRAME.registerComponent('enhanced-particles', {
        init: function() {
          setTimeout(() => {
            const particleSystem = this.el.components['particle-system'];
            
            if (particleSystem && particleSystem.particleGroup) {
              const group = particleSystem.particleGroup;
              
              if (group.material) {
                // Make particles much brighter and more visible
                group.material.blending = THREE.AdditiveBlending;
                group.material.transparent = true;
                
                // Boost opacity and size significantly
                if (group.material.uniforms) {
                  if (group.material.uniforms.opacity) {
                    group.material.uniforms.opacity.value = Math.min(group.material.uniforms.opacity.value * 5.0, 1.0);
                  }
                  if (group.material.uniforms.scale) {
                    group.material.uniforms.scale.value *= 1.0; // No scaling to prevent huge sparks
                  }
                }
                
                group.material.needsUpdate = true;
              }
            } else {
              // Retry after another second
              setTimeout(() => {
                this.init();
              }, 1000);
            }
          }, 1000);
        }
        });
        
        // Register all main components here where AFRAME is guaranteed available
        registerMainComponents();
      }
      
      function registerMainComponents() {
        // Billboard component to make particles always face the camera
        AFRAME.registerComponent('billboard', {
          tick: function() {
            const camera = document.querySelector('[camera]');
            if (camera) {
              this.el.object3D.lookAt(camera.object3D.position);
            }
          }
        });
        
        // All other components will be registered from main script after timeout
        // This prevents timing issues with the main script
        
        // Set flag to indicate components are ready
        window.componentsReady = true;
      }
      
      // Initialize custom components
      initCustomComponents();
    </script>
  </head>
  <body>
    <script>
      // Multiplayer state for 1-4 players (global scope)
      let isMultiplayer = false;
      let isHost = false;
      let peer = null;
      let connections = new Map();
      let activePlayers = new Set();
      let selectedLobby = 1; // Start with lobby 1 (number, not letter)
      let playerId = null;
      let playerNumber = 1;
      let gameMode = 'solo';
      const MAX_LOBBIES = 26; // A-Z lobbies
      
      // Wait for all dependencies to load before initializing physics
      function initializeApp() {
        if (typeof CANNON === 'undefined' || typeof AFRAME === 'undefined') {
          setTimeout(initializeApp, 100);
          return;
        }
        
        
      // Physics world setup for zero-gravity
      const world = new CANNON.World();
      world.gravity.set(0, 0, 0); // Zero gravity for space environment
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // Make physics world globally accessible for components
      window.world = world;

      // Create materials for zero-g environment (moved inside initializeApp)
      const defaultMaterial = new CANNON.Material('default');
      const playerMaterial = new CANNON.Material('player');
      const surfaceMaterial = new CANNON.Material('surface');
      const ballMaterial = new CANNON.Material('ball');
      
      // Make materials globally accessible for components
      window.defaultMaterial = defaultMaterial;
      window.playerMaterial = playerMaterial;
      window.surfaceMaterial = surfaceMaterial;
      window.ballMaterial = ballMaterial;
      
      // Contact materials for physics interactions
      const playerSurfaceContact = new CANNON.ContactMaterial(
        playerMaterial,
        surfaceMaterial,
        {
          friction: 0.3,
          restitution: 0.3
        }
      );
      world.addContactMaterial(playerSurfaceContact);

      const ballSurfaceContact = new CANNON.ContactMaterial(
        ballMaterial,
        surfaceMaterial,
        {
          friction: 0.3,
          restitution: 0.9
        }
      );
      world.addContactMaterial(ballSurfaceContact);

      // Initialize multiplayer system
      initMultiplayer();

      // Global error handler to suppress Meta Touch Controls thumbstick errors
      window.addEventListener('error', (event) => {
        if (event.error && event.error.message && 
            event.error.message.includes('thumbstick') && 
            event.error.message.includes('Cannot read properties of undefined')) {
          // Suppress Meta Touch Controls thumbstick errors
          event.preventDefault();
          return false;
        }
      });

      } // End of initializeApp function
      
      // Additional multiplayer variables (keeping only what's needed)
      let connectionToPlayer = new Map(); // Track which player ID is assigned to each connection
      let players = new Map();
      let botPlayers = new Set();
      let playerSlots = [
        { name: 'Player 0', color: '#ff0000', position: '-2 0 -2', rotation: '0 45 0' },
        { name: 'Player 1', color: '#00ff00', position: '2 0 -2', rotation: '0 -45 0' },
        { name: 'Player 2', color: '#ff00ff', position: '-2 0 2', rotation: '0 135 0' },
        { name: 'Player 3', color: '#ffff00', position: '2 0 2', rotation: '0 -135 0' }
      ];
      let sessionID = null;
      let multiplayerSlot = null;
      let myPlayerId = null;
      let myReadyState = false;
      let readyStates = [false, false, false, false];
      let lastMultiplayerToggle = 0;
      let multiplayerStartType = 'dodgevr';
      let connectionState = 'disconnected';
      let isSearchingForMatch = false;

      // Multiplayer score state
      let multiplayerScore = { local: 0, remote: 0 };
      // Multiplayer ready state
      let multiplayerReady = { local: false, remote: false };

      // Menu state tracking
      let isMenuVisible = false;
      
      // PERFORMANCE OPTIMIZATION: Track 3D model visibility for conditional BVH collision detection
      let any3DModelsVisible = false; // Will be updated by toggle functions
      
      // Helper function to check if any 3D models are currently visible
      function updateModelVisibilityState() {
        const level = document.querySelector('#model-level');
        const spaceship = document.querySelector('#model-spaceship');
        const asteroid = document.querySelector('#model-asteroid-42');
        
        const levelVisible = level && (level.getAttribute('visible') === true || level.getAttribute('visible') === 'true');
        const spaceshipVisible = spaceship && (spaceship.getAttribute('visible') === true || spaceship.getAttribute('visible') === 'true');
        const asteroidVisible = asteroid && (asteroid.getAttribute('visible') === true || asteroid.getAttribute('visible') === 'true');
        
        any3DModelsVisible = levelVisible || spaceshipVisible || asteroidVisible;
        
        console.log('🎯 3D Model Visibility State Updated:', {
          level: levelVisible,
          spaceship: spaceshipVisible,
          asteroid: asteroidVisible,
          any3DModelsVisible: any3DModelsVisible
        });
        
        return any3DModelsVisible;
      }

      // Space shooter mode - individual player vs bots (gameMode declared in initializeApp)

      // Helper: check if menu is currently visible
      function getMenuVisibility() {
        return isMenuVisible;
      }

      // Initialize players map
      for (let i = 0; i < 4; i++) {
        players.set(`player_${i}`, {
          id: `player_${i}`,
          name: playerSlots[i].name,
          color: '#888888', // CRITICAL FIX: Use neutral color, team colors will override
          position: playerSlots[i].position,
          rotation: playerSlots[i].rotation,
          isConnected: false,
          isBot: false,
          isReady: false
        });
      }

      // Helper: update HUD status display
      function updateMultiplayerStatus(text) {
        const hudStatus = document.getElementById('hud-status');
        if (hudStatus) {
          hudStatus.setAttribute('text', 'value', text);
        }

      }

      // Global toggles for effects - START AS OFF
      let smokeEnabled = false;
      let iceCubeEnabled = false;
      let sparksEnabled = false;

      // Keyboard controls for toggles
      document.addEventListener('keydown', (event) => {
        if (event.code === 'Digit4') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleSmoke();
          }
        } else if (event.code === 'Digit5') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleIceCube();
          }
        } else if (event.code === 'Digit6') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleSparks();
          }
        } else if (event.code === 'Digit7') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleBloom();
          }
        } else if (event.code === 'Digit8') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleModel('level');
          }
        } else if (event.code === 'Digit9') {
          const cursorListener = document.querySelector('[cursor-listener]');
          if (cursorListener && cursorListener.components['cursor-listener']) {
            cursorListener.components['cursor-listener'].toggleBots();
          }
        }
      });

      // Helper: update menu display
      function updateMenuDisplay() {
        const menuCurrentMode = document.getElementById('menu-current-mode');
        if (menuCurrentMode) {
          if (isMultiplayer) {
          const playerCount = activePlayers.size;
            const maxPlayers = 4; // Always 4 players in both modes
            menuCurrentMode.setAttribute('text', 'value', `Mode: Multiplayer (Lobby ${selectedLobby}) (${playerCount}/${maxPlayers})`);
          } else {
            menuCurrentMode.setAttribute('text', 'value', 'Mode: Singleplayer');
          }
        }
        
        // CRITICAL FIX: Disable game mode buttons for clients in multiplayer
        const dodgeButton = document.querySelector('#menu-mode-dodge');
        const captureButton = document.querySelector('#menu-mode-capture');
        
        if (dodgeButton && captureButton) {
          const canChangeMode = !isMultiplayer || isHost;
          const opacity = canChangeMode ? 1.0 : 0.3;
          const color = canChangeMode ? '#ffffff' : '#666666';
          
          dodgeButton.setAttribute('material', `opacity: ${opacity}; color: ${color}`);
          captureButton.setAttribute('material', `opacity: ${opacity}; color: ${color}`);
          
          // Add visual indicator for clients
          if (isMultiplayer && !isHost) {
            const statusText = document.getElementById('menu-mode-status');
            if (statusText) {
              statusText.setAttribute('text', 'value', '(Host controls game mode)');
              statusText.setAttribute('visible', true);
            }
          } else {
            const statusText = document.getElementById('menu-mode-status');
            if (statusText) {
              statusText.setAttribute('visible', false);
            }
          }
        }
      }

      // Space shooter has no teams - all players vs bots
      function areTeammates(playerId1, playerId2) {
        // SPACE SHOOTER: No teams, so never teammates
        return false;
      }

      // Helper: get ball assignment for space shooter
      function getBallForPlayer(playerId) {
        // SPACE SHOOTER mode: assign balls to players AND bots
        if (playerId === 'player_0') return 2;
        if (playerId === 'player_1') return 4;
        if (playerId === 'player_2') return 1;
        if (playerId === 'player_3') return 3;
        // Bot assignments for space shooter
        if (playerId === 'bot-red') return 1;
        if (playerId === 'bot-blue') return 3;
        if (playerId === 'bot-green') return 4;
        return 2; // default
      }

      // Space shooter uses fixed ball colors - no team system

      // Helper: check if ball should affect target based on team rules
      function shouldBallAffectTarget(ballPlayerIndex, targetId) {
        // SPACE SHOOTER: Player balls should hit all bots, bot balls should hit player
        const ballOwnerId = getBallOwnerId(ballPlayerIndex);
        
        // Player balls hit all bots
        if (ballOwnerId && ballOwnerId.startsWith('player_')) {
          return targetId.startsWith('bot-') || targetId.startsWith('player_');
        }
        
        // Bot balls hit player
        if (ballOwnerId && ballOwnerId.startsWith('bot-')) {
          return targetId.startsWith('player_');
        }
        
        return true; // Default allow all hits
      }
      
      // Helper: get the owner ID of a ball based on its player index
      function getBallOwnerId(ballPlayerIndex) {
        // CRITICAL FIX: Handle all 4 players + bots dynamically
        // Check if human players are using these balls first
        
        if (ballPlayerIndex === 1) {
          // Ball 1: player_2 takes priority, otherwise bot-red
          return activePlayers.has('player_2') ? 'player_2' : 'bot-red';
        }
        if (ballPlayerIndex === 2) return 'player_0';   // Host always owns ball 2
        if (ballPlayerIndex === 3) {
          // Ball 3: player_3 takes priority, otherwise bot-blue  
          return activePlayers.has('player_3') ? 'player_3' : 'bot-blue';
        }
        if (ballPlayerIndex === 4) {
          // Ball 4: player_1 takes priority, otherwise bot-green
          return activePlayers.has('player_1') ? 'player_1' : 'bot-green';
        }
        return null;
      }
      
      // Helper: get player ID from ball index
      function getPlayerIdFromBallIndex(ballPlayerIndex) {
        // CRITICAL FIX: Use the same dynamic logic as getBallOwnerId
        return getBallOwnerId(ballPlayerIndex) || 'player_0'; // fallback
      }
      
      // Update local player color and ensure proper visibility
      function updateLocalPlayerColor(color) {
        const playerTarget = document.querySelector('#player-target');
        const playerImpact = document.querySelector('#player-impact');
        
        if (playerTarget) {
          // CRITICAL: Ensure local player target is always visible
          playerTarget.setAttribute('visible', true);
          
          // Reset all color attributes to ensure clean state
          playerTarget.removeAttribute('color');
          playerTarget.removeAttribute('material');
          playerTarget.removeAttribute('impact-effect');
          
          // Hide only the client's own remote player to prevent self-interference
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            const remoteTarget = document.querySelector(`#remote-target-${playerIndex}`);
            if (remoteTarget) {
              remoteTarget.setAttribute('visible', false);
              remoteTarget.setAttribute('material', 'emissive: #000000; emissiveIntensity: 0; opacity: 0');
              remoteTarget.parentElement.setAttribute('visible', false);
            }
          }
          
          // Apply color changes after clearing previous attributes
          setTimeout(() => {
            // Set color using direct Three.js material access for reliability
            if (playerTarget.object3D && playerTarget.object3D.children[0] && playerTarget.object3D.children[0].material) {
              const material = playerTarget.object3D.children[0].material;
              const threeColor = new THREE.Color(color);
              material.color.copy(threeColor);
              material.emissive.set(0, 0, 0); // No emissive to prevent color mixing
              material.emissiveIntensity = 0;
              material.transparent = true;
              material.opacity = 0.7;
              material.needsUpdate = true;
            }
            
            // Set A-Frame attributes as backup
            playerTarget.setAttribute('color', color);
            playerTarget.setAttribute('material', `shader: standard; color: ${color}; emissive: #000000; emissiveIntensity: 0; transparent: true; opacity: 0.7`);
            playerTarget.setAttribute('impact-effect', `color: ${color}`);
          }, 10);
          
          // Update the light color
          const playerLight = playerTarget.querySelector('a-entity[light]');
          if (playerLight) {
            playerLight.setAttribute('light', `type: point; color: ${color}; intensity: 1; distance: 3`);
          }
          
          // Update impact sphere color
          if (playerImpact) {
            playerImpact.setAttribute('color', color);
          }
          
          // Store the current color to prevent overrides
          playerTarget.dataset.teamColor = color;
          
          // Update thruster VFX colors to match team color
          const leftThruster = document.querySelector('#leftHand .thruster-vfx');
          const rightThruster = document.querySelector('#rightHand .thruster-vfx');
          if (leftThruster) {
            leftThruster.setAttribute('color', color);
            leftThruster.setAttribute('material', `shader: standard; emissive: ${color}; emissiveIntensity: 1; transparent: true; opacity: 0.8`);
          }
          if (rightThruster) {
            rightThruster.setAttribute('color', color);
            rightThruster.setAttribute('material', `shader: standard; emissive: ${color}; emissiveIntensity: 1; transparent: true; opacity: 0.8`);
          }
          
          // Note: Remote players should remain visible so attackers can see hit effects on opponents
        }
      }
      
      // Helper: update player color based on team
      // Global cache to prevent infinite loops
      const colorUpdateCache = {};
      
      function updatePlayerTeamColor(playerId, team) {
        const teamColors = {
          red: '#ff0000',
          blue: '#0000ff',
          green: '#00ff00',
          yellow: '#ffff00',
          white: '#ffffff'
        };
        
        const color = teamColors[team];
        if (!color) return;
        
        // CRITICAL FIX: Prevent infinite loops but allow initial color updates
        const currentTime = Date.now();
        const cacheKey = `${playerId}-${team}`;
        
        // Allow first update or updates after 500ms (reduced from 2 seconds for faster retries)
        if (colorUpdateCache[cacheKey] && (currentTime - colorUpdateCache[cacheKey]) < 500) {
          return; // Skip if updated within last 500ms
        }
        
        colorUpdateCache[cacheKey] = currentTime;
        
        console.log(`🎨 Applying color ${color} (${team}) to player ${playerId}`);
        
        // CRITICAL FIX: Update LOCAL player target if this is for the current player
        // In singleplayer, myPlayerId might be null but we still want to update player_0
        const isLocalPlayer = (playerId === myPlayerId) || (playerId === 'player_0' && !isMultiplayer);
        if (isLocalPlayer) {
          console.log(`🎨 Updating LOCAL player body color: ${color} for ${playerId}`);
          updateLocalPlayerColor(color);
        }
        
        // Also update remote player colors if this is for a remote player
        if (playerId !== myPlayerId) {
          const playerIndex = parseInt(playerId.split('_')[1]);
          const remoteTarget = document.querySelector(`#remote-target-${playerIndex}`);
          const remoteImpact = document.querySelector(`#remote-impact-${playerIndex}`);
          
          console.log(`🎨 Updating REMOTE player body color: ${color} for ${playerId} (target: #remote-target-${playerIndex}, found: ${!!remoteTarget})`);
          
          if (remoteTarget) {
            remoteTarget.setAttribute('color', color);
            remoteTarget.setAttribute('material', `shader: standard; emissive: ${color}; emissiveIntensity: 0.5; transparent: true; opacity: 0.7`);
            remoteTarget.setAttribute('impact-effect', `color: ${color}`);
            
            // Update remote light color
            const remoteLight = remoteTarget.querySelector('a-entity[light]');
            if (remoteLight) {
              remoteLight.setAttribute('light', `type: point; color: ${color}; intensity: 1; distance: 3`);
            }
            
            // Update remote impact sphere color
            if (remoteImpact) {
              remoteImpact.setAttribute('color', color);
            }
            
            console.log(`✅ Updated remote target #remote-target-${playerIndex} with color ${color}`);
          } else {
            console.warn(`❌ Remote target #remote-target-${playerIndex} not found!`);
          }
        }
        
        // CRITICAL FIX: Update player ball color based on ACTUAL ball assignments
        const playerIndex = parseInt(playerId.split('_')[1]);
        
        // Map player slots to their ACTUAL ball assignments (from getBallForPlayer function)
        // getBallForPlayer: player_0->Ball2, player_1->Ball4, player_2->Ball1, player_3->Ball3
        // But balls are named player1, player2, player3, player4 in HTML
        const actualBallMapping = {
          0: 2, // player_0 shoots Ball 2 -> update player2 ball 
          1: 4, // player_1 shoots Ball 4 -> update player4 ball
          2: 1, // player_2 shoots Ball 1 -> update player1 ball  
          3: 3  // player_3 shoots Ball 3 -> update player3 ball
        };
        
        const actualBallNumber = actualBallMapping[playerIndex];
        if (!actualBallNumber) {
          console.warn(`⚽ No actual ball mapping for ${playerId} (index: ${playerIndex})`);
          return;
        }
        
        const playerBall = document.querySelector(`[zerog-ball*="player: player${actualBallNumber}"]`);
        
        if (playerBall) {
          // Update ball color
          playerBall.setAttribute('color', color);
          playerBall.setAttribute('material', `color: ${color}; shader: standard`);
          
          // Update ball glow
          playerBall.setAttribute('glow', `color: ${color}; intensity: 1.5`);
          
          // Update ball light
          const ballLight = playerBall.querySelector('a-entity[light]');
          if (ballLight) {
            ballLight.setAttribute('light', `type: point; color: ${color}; intensity: 1.5; distance: 5; decay: 2`);
          }
          
          // CRITICAL FIX: Update wireframe sphere color
          const wireframeSphere = playerBall.querySelector('a-sphere[material*="wireframe"]');
          if (wireframeSphere) {
            wireframeSphere.setAttribute('color', color);
            wireframeSphere.setAttribute('material', `wireframe: true; color: ${color}; opacity: 0.5`);
          }
          
          // CRITICAL FIX: Update ball shield color
          const ballShield = playerBall.querySelector('.ball-shield');
          if (ballShield) {
            ballShield.setAttribute('material', `transparent: true; opacity: 0.3; color: ${color}`);
          }
          
          console.log(`⚽ Updated ball color for ${playerId} (player${actualBallNumber}): ${color}`);
        } else {
          console.warn(`⚽ Ball not found for ${playerId} (player${actualBallNumber})`);
        }
      }

      // Multiplayer connection functions
      async function initMultiplayer() {
        updateMenuDisplay();
      }

      async function setupHost(lobbyNumber) {
        return new Promise((resolve, reject) => {
          isMultiplayer = true;
          isHost = true;
          selectedLobby = lobbyNumber;
          sessionID = `dodgevr-host-${multiplayerStartType}-${lobbyNumber}`;
          
          // Reset match state when becoming host
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            gameManager.components['game-manager'].resetMatch();
          }
          
          let iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
          
          const config = iceServersConfig;
          
          peer = new Peer(sessionID, {
            host: "0.peerjs.com",
            port: 443,
            secure: true,
            config: { 'iceServers': config }
          });
          
          peer.on("open", function() {
            updateMultiplayerStatus(`Host - Lobby ${lobbyNumber} (1/4)`);
            updateMenuDisplay();
            
            // Mark self as connected
            myPlayerId = 'player_0';
            activePlayers.add('player_0');
            const player = players.get('player_0');
            if (player) {
              player.isConnected = true;
              player.isBot = false;
            }
            
            // CRITICAL FIX: Assign host color (red for player_0)
            updatePlayerTeamColor('player_0', 'red');
            console.log(`🎨 HOST assigned color: red (player_0)`);
            
            // Update bot management for new player count
            manageActivePlayersAndBots();
            
            // CRITICAL FIX: Assign host to default team (red) for all modes
            // Space shooter: no teams, just start the game
            manageActivePlayersAndBots();
            
            // Position host at corner
            const rig = document.querySelector('#rig');
            if (rig) {
              rig.setAttribute('position', playerSlots[0].position);
              rig.setAttribute('rotation', playerSlots[0].rotation);
            }
            
            // Team colors are already applied by updatePlayerTeamColor above
            
                      // Make all remote players visible for host, but hide own remote player
            setTimeout(() => {
              makeAllRemotePlayersVisible();
            
            // Immediately hide own remote player to prevent color interference
            if (myPlayerId) {
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
              if (remotePlayer) {
                remotePlayer.setAttribute('visible', false);
              }
            }
            }, 100);
            
            resolve();
          });
          
          peer.on("connection", function(conn) {
            
            // Store the connection with a unique key based on peer ID
            const clientKey = `client_${conn.peer}`;
            connections.set(clientKey, conn);
            
            setupConnectionHandlers(conn, clientKey);
            
            conn.on("open", function() {
              
                          // Mark client as connected and send player count update
            // Don't add 'client' to activePlayers - we'll add the actual player ID when assigned
            // Only count actual players, not connection IDs
            const actualPlayerCount = activePlayers.size;
            const maxPlayers = 4; // Always 4 players in both modes
            updateMultiplayerStatus(`Host - Lobby ${lobbyNumber} (${actualPlayerCount}/${maxPlayers})`);
            updateMenuDisplay();
              
              // Send player count update to all clients
              sendPlayerCountUpdate();
              
              // Make all remote players visible but hide own remote player
              setTimeout(() => {
                makeAllRemotePlayersVisible();
                
                // Immediately hide own remote player to prevent color interference
                if (myPlayerId) {
                  const playerIndex = parseInt(myPlayerId.split('_')[1]);
                  const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
                  if (remotePlayer) {
                    remotePlayer.setAttribute('visible', false);
                  }
                }
              }, 200);
              
                        // Automatically assign player slot to the new client (only if not already assigned)
          setTimeout(() => {
            // Check if this connection already has a player assigned
            const existingPlayer = Array.from(activePlayers).find(id => id !== 'player_0' && id !== 'client');
            if (!existingPlayer) {
              handlePlayerAssignmentRequest(conn);
            } else {
            }
          }, 100);
            });
          });
          
          peer.on("error", function(err) {
            updateMultiplayerStatus(`Host error: ${err.type}`);
            if (err.type === 'unavailable-id') {
              reject(new Error('unavailable-id'));
            }
          });
        });
      }

      async function setupPeer(lobbyNumber) {
        return new Promise((resolve, reject) => {
          isMultiplayer = true;
          isHost = false;
          selectedLobby = lobbyNumber;
          
          // Reset match state when joining as client
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            gameManager.components['game-manager'].resetMatch();
          }
          const timestamp = Date.now();
          const randomId = Math.random().toString(36).substr(2, 9);
          sessionID = `dodgevr-peer-${multiplayerStartType}-${lobbyNumber}-${timestamp}-${randomId}`;
          
          let iceServersConfig = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' }
          ];
          
          const config = iceServersConfig;
          
          peer = new Peer(sessionID, {
            host: "0.peerjs.com",
            port: 443,
            secure: true,
            config: { 'iceServers': config }
          });
          
          peer.on("open", function() {
            updateMultiplayerStatus('Connecting to host...');
            const hostID = `dodgevr-host-${multiplayerStartType}-${lobbyNumber}`;
            const conn = peer.connect(hostID);
            connections.set('host', conn);
            
            conn.on("open", function() {
              setupConnectionHandlers(conn, 'client');
              updateMultiplayerStatus(`Connected - Lobby ${lobbyNumber} (connecting...)`);
              updateMenuDisplay();
              resolve();
            });
            
            conn.on("error", function(err) {
              reject(new Error('connection-failed'));
            });
          });
          
          peer.on("error", function(err) {
            updateMultiplayerStatus(`Peer error: ${err.type}`);
            reject(new Error(err.type));
          });
        });
      }

      function setupConnectionHandlers(conn, playerId) {
        conn.on('data', (data) => {
          // Throttle data reception logging to prevent spam
          if (!this.lastDataReceiveTime || Date.now() - this.lastDataReceiveTime > 30000) {
            this.lastDataReceiveTime = Date.now();
          }
          
          try {
            if (!data || !data.type) {
              console.warn('Received invalid data:', data);
              return;
            }
            
          switch(data.type) {
            case 'player-count-update':
              handlePlayerCountUpdate(data);
              break;
            case 'player-assignment':
              handlePlayerAssignment(data);
              break;
            case 'ready-update':
              handleReadyUpdate(data);
              break;
            case 'game-state':
              handleGameState(data);
              break;
            case 'match-start-sync':
              handleMatchStartSync(data);
              break;
            case 'player-update':
              handlePlayerUpdate(data);
              break;
            case 'request-player-assignment':
              handlePlayerAssignmentRequest(conn);
              break;
            case 'player-info-update':
              handlePlayerInfoUpdate(data);
              break;
            case 'score-update':
              handleScoreUpdate(data);
              break;
            case 'player-state':
              handlePlayerState(data);
              break;
            case 'ball-state':
              handleBallState(data);
              break;
            case 'bot-state':
              handleBotState(data);
              break;
            case 'door-animation':
              handleDoorAnimation(data);
              break;
            case 'bullet-create':
              handleBulletCreate(data);
              break;
            case 'bullet-destroy':
              handleBulletDestroy(data);
              break;
            case 'damage-effect':
              handleDamageEffect(data);
              break;
            case 'explosion-effect':
              handleExplosionEffect(data);
              break;
            case 'hit-sound':
              handleHitSound(data);
              break;
            case 'bot-damage-state':
              handleBotDamageState(data);
              break;
            case 'player-damage-state':
              handlePlayerDamageState(data);
              break;
            case 'game-mode-update':
              handleGameModeUpdate(data);
              break;
            case 'request-game-mode':
              handleGameModeRequest(conn);
              break;
            case 'request-team-assignments':
              handleTeamAssignmentsRequest(conn);
              break;
            case 'team-assignments':
              handleTeamAssignments(data);
              break;
            // Capture ball functionality removed - not used in space shooter
            case 'ball-shield-state':
              handleBallShieldState(data);
              // If host receives shield state from client, broadcast to all other clients
              if (isHost) {
                connections.forEach(otherConn => {
                  if (otherConn !== conn && otherConn.open) {
                    otherConn.send(data);
                  }
                });
              }
              break;
            case 'ball-grab-state':
              handleBallGrabState(data);
              // If host receives ball grab state from client, broadcast to all other clients
              if (isHost) {
                connections.forEach(otherConn => {
                  if (otherConn !== conn && otherConn.open) {
                    otherConn.send(data);
                  }
                });
              }
              break;
            case 'player-grab':
              handlePlayerGrab(data);
              // If host receives player grab from client, broadcast to all other clients
              if (isHost) {
                connections.forEach(otherConn => {
                  if (otherConn !== conn && otherConn.open) {
                    otherConn.send(data);
                  }
                });
              }
              break;
            case 'player-grab-force-release':
              handlePlayerGrabForceRelease(data);
              // If host receives force release from client, broadcast to all other clients
              if (isHost) {
                connections.forEach(otherConn => {
                  if (otherConn !== conn && otherConn.open) {
                    otherConn.send(data);
                  }
                });
              }
              break;
            case 'match-start':
              handleMatchStart(data);
              break;
                          case 'client-team-selection':
                handleClientTeamSelection(data);
                break;
              case 'hit-effect':
                handleHitEffect(data);
                // If host receives hit-effect from client, broadcast to all other clients
                if (isHost) {
                  connections.forEach(otherConn => {
                    if (otherConn !== conn && otherConn.open) {
                      otherConn.send(data);
                    }
                  });
                }
                break;
              // Goal functionality removed - not used in space shooter
          }
          } catch (error) {
            console.error('Error handling multiplayer data:', error, 'Data:', data);
          }
        });
        
        conn.on('close', () => {
          console.log('🔌 Connection closed for player:', playerId);
          handlePlayerDisconnection(conn, playerId);
        });
        
        conn.on('error', (err) => {
          console.log('❌ Connection error for player:', playerId, 'Error:', err);
          handlePlayerDisconnection(conn, playerId);
        });
      }

      function handlePlayerCountUpdate(data) {
        updateMenuDisplay();
        
        // Update status for clients to show player count from host
        if (!isHost) {
          const maxPlayers = 4; // Always 4 players in both modes
          updateMultiplayerStatus(`Connected - Lobby ${selectedLobby} (${data.playerCount}/${maxPlayers})`);
        }
        
        // Update local activePlayers set with the host's data
        if (data.activePlayers) {
          // Preserve client's own player ID if it exists
          const myId = myPlayerId;
          activePlayers.clear();
          data.activePlayers.forEach(playerId => {
            activePlayers.add(playerId);
          });
          
          // CRITICAL FIX: Ensure client's own ID is always included
          if (myId && !activePlayers.has(myId)) {
            activePlayers.add(myId);
            console.log(`🔧 CLIENT re-added own playerId to activePlayers: ${myId}`);
          }
          
          console.log(`📊 CLIENT updated activePlayers: ${Array.from(activePlayers)}`);
        }
        
        // If client doesn't have a player ID yet, request assignment
        if (!isHost && !myPlayerId) {
          console.log('🔍 CLIENT requesting player assignment...');
          const hostConn = connections.get('host');
          if (hostConn && hostConn.open) {
            hostConn.send({
              type: 'request-player-assignment'
            });
            console.log('📤 CLIENT sent player assignment request to host');
          } else {
            console.warn('❌ CLIENT cannot request assignment - no host connection');
          }
        }
        
        // Make remote players visible when player count updates
        setTimeout(() => {
          makeAllRemotePlayersVisible();
        }, 100);
      }

      function handlePlayerAssignment(data) {
        console.log('📥 CLIENT received player assignment:', data);
        
        // Only accept assignment if we don't already have a player ID
        if (myPlayerId) {
          console.log(`⚠️ CLIENT already has playerId: ${myPlayerId}, ignoring assignment`);
          return;
        }
        
        myPlayerId = data.playerId;
        console.log(`✅ CLIENT assigned playerId: ${myPlayerId}`);
        
        // Team assignment removed - space shooter doesn't use teams
        if (data.team) {
          // CRITICAL FIX: Update client's own body color immediately
          console.log(`🎨 CLIENT applying color ${data.team} to self (${myPlayerId})`);
          updatePlayerTeamColor(myPlayerId, data.team);
        }
        
        // Add self to active players
        activePlayers.add(myPlayerId);
        console.log(`✅ CLIENT added self to activePlayers: ${Array.from(activePlayers)}`);
        
        // Update bot management for new player count
        manageActivePlayersAndBots();
        
        // Team functionality removed - space shooter doesn't use teams
        
        // Update start message for new multiplayer state
        const gameManager = document.querySelector('[game-manager]');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].updateStartMessage();
          
          // CRITICAL FIX: Refresh HUD after player assignment to ensure proper state
          setTimeout(() => {
            const menuToggle = document.querySelector('[menu-toggle]');
            if (menuToggle && menuToggle.components['menu-toggle']) {
              menuToggle.components['menu-toggle'].refreshGameHUD();
              
              // CRITICAL FIX: Auto-close menu for clients when they successfully join a lobby
              if (!isHost && menuToggle.components['menu-toggle'].menuVisible) {
                console.log('🎮 Auto-closing menu for client after successful lobby join');
                console.log('🔍 Client state before auto-close:', {
                  isMultiplayer: isMultiplayer,
                  isHost: isHost,
                  myPlayerId: myPlayerId,
                  activePlayers: activePlayers.size,
                  connections: connections.size
                });
                
                // Add extra delay to ensure connection is fully stable
                setTimeout(() => {
                  // Double-check that we're still in multiplayer mode before closing
                  if (isMultiplayer && !isHost && myPlayerId) {
                    menuToggle.components['menu-toggle'].toggleMenu();
                    console.log('✅ Menu auto-closed successfully for client');
                  } else {
                    console.log('❌ Skipping auto-close - client state changed:', {
                      isMultiplayer: isMultiplayer,
                      isHost: isHost,
                      myPlayerId: myPlayerId
                    });
                  }
                }, 500); // Extra delay to ensure stability
              }
            }
          }, 200);
        }
        
        // Track this connection for the client side
        const hostConn = connections.get('host');
        if (hostConn) {
          connectionToPlayer.set(hostConn, myPlayerId);
        }
        
        // Position player at their assigned corner
        const playerIndex = parseInt(myPlayerId.split('_')[1]);
        const rig = document.querySelector('#rig');
        if (rig && playerSlots[playerIndex]) {
          rig.setAttribute('position', playerSlots[playerIndex].position);
          rig.setAttribute('rotation', playerSlots[playerIndex].rotation);
        } else {
        }
        
        // CRITICAL FIX: Update local player target's data-player-id for clients
        const playerTarget = document.querySelector('#player-target');
        if (playerTarget) {
          // Update the local player target's ID to match the client's assigned ID
          playerTarget.setAttribute('data-player-id', myPlayerId);
          
          // Ensure local player target is always visible
          playerTarget.setAttribute('visible', true);
          
          // CRITICAL FIX: Only set neutral color if no team color is already set
          if (!playerTarget.dataset.teamColor) {
            playerTarget.setAttribute('color', '#888888');
            playerTarget.setAttribute('material', 'emissive: #888888; emissiveIntensity: 0.5; transparent: true; opacity: 0.7');
          }
        }
        
        // CRITICAL: Hide the corresponding remote player representation (reuse playerIndex)
        const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
        if (remotePlayer) {
          remotePlayer.setAttribute('visible', false);
        }
        
        // Update status to show player count - use the count from the host
        updateMultiplayerStatus(`Connected - Lobby ${selectedLobby} (connecting...)`);
        
        // Make all other remote players visible
        makeAllRemotePlayersVisible();
        
        // Update bot management for new player
        manageActivePlayersAndBots();
        
        // CRITICAL FIX: Request current game mode from host
        const hostConnection = connections.get('host');
        if (hostConnection && hostConnection.open) {
          hostConnection.send({
            type: 'request-game-mode'
          });
        }
        
        // Request team assignments from host (with deduplication)
        if (hostConnection && hostConnection.open && !this.teamAssignmentsRequested) {
          this.teamAssignmentsRequested = true;
          hostConnection.send({
            type: 'request-team-assignments'
          });
          
          // Fallback request after delay if no response
          setTimeout(() => {
            if (!this.teamAssignmentsReceived) {
              const hostConnection = connections.get('host');
              if (hostConnection && hostConnection.open) {
                hostConnection.send({
                  type: 'request-team-assignments'
                });
              }
            }
          }, 1000);
        }
        
        updateMenuDisplay();
      }

      function makeAllRemotePlayersVisible() {
        
        // Get current player's position and rotation
        const rig = document.querySelector('#rig');
        const playerPos = rig ? rig.getAttribute('position') : { x: 0, y: 0, z: 0 };
        const playerRot = rig ? rig.getAttribute('rotation') : { x: 0, y: 0, z: 0 };
        
        
        for (let i = 0; i < 4; i++) {
          const remotePlayer = document.querySelector(`#remote-player-${i}`);
          if (remotePlayer) {
            // Skip if this is the current player's slot
            if (myPlayerId === `player_${i}`) {
              remotePlayer.setAttribute('visible', false);
              continue;
            }
            
            // Show remote players if they exist in remotePlayerStates (meaning we received data from them)
            // or if they're in activePlayers (for host-side visibility)
            const playerId = `player_${i}`;
            const hasReceivedData = remotePlayerStates.has(playerId);
            const isInActivePlayers = activePlayers.has(playerId);
            
            if (hasReceivedData || isInActivePlayers) {
              // Position remote player at their absolute world position
              const slot = playerSlots[i];
              if (slot) {
                // Set position and make visible
                remotePlayer.setAttribute('position', slot.position);
                remotePlayer.setAttribute('rotation', slot.rotation);
                remotePlayer.setAttribute('visible', true);
                
                // Keep the sphere at the same size but HIDDEN by default to prevent color interference
                const sphere = remotePlayer.querySelector(`#remote-target-${i}`);
                if (sphere) {
                  sphere.setAttribute('radius', '0.2');
                  
                  // Hide only if this is the client's own remote target, otherwise show it
                  if (myPlayerId === playerId) {
                    sphere.setAttribute('visible', false);
                  } else {
                    sphere.setAttribute('visible', true);
                  }
                  
                  // CRITICAL FIX: Don't override colors - let updatePlayerTeamColor handle this
                  // The colors will be set by the multiplayer color assignment system
                  
                  // Only set basic properties, not colors
                  if (!sphere.hasAttribute('material')) {
                    sphere.setAttribute('material', `shader: standard; transparent: true; opacity: 0.7`);
                  }
                }
                
              } else {
              }
            } else {
              // Hide if not connected
              remotePlayer.setAttribute('visible', false);
            }
          } else {
          }
        }
      }

      function handlePlayerAssignmentRequest(conn) {
        if (!isHost) return;
        
        console.log('🏠 HOST received player assignment request');
        
        let assignedSlot = null;
        for (let slotNumber = 1; slotNumber < 4; slotNumber++) {
          const playerId = `player_${slotNumber}`;
          const player = players.get(playerId);
          if (!player || !player.isConnected || player.isBot) {
            assignedSlot = slotNumber;
            break;
          }
        }
        
        if (assignedSlot !== null) {
          const playerId = `player_${assignedSlot}`;
          console.log(`🏠 HOST assigning slot ${assignedSlot} (${playerId}) to client`);
          
          // Mark player as connected
          const player = players.get(playerId) || { name: `Player ${assignedSlot}`, color: '#ffffff', isConnected: false, isBot: false };
            player.isConnected = true;
            player.isBot = false;
          players.set(playerId, player);
          
          // Add to active players
            activePlayers.add(playerId);
          
          // Assign colors based on player slot (not teams)
          const playerColors = {
            0: 'red',    // player_0 (host)
            1: 'blue',   // player_1 (first client)
            2: 'green',  // player_2 (second client) 
            3: 'yellow'  // player_3 (third client)
          };
          const assignedColor = playerColors[assignedSlot] || 'white';
          
          // Send assignment to client
          if (conn && conn.open) {
          conn.send({
            type: 'player-assignment',
              playerId: playerId,
              team: assignedColor // Send color as team for compatibility
            });
            console.log(`📤 HOST sent player assignment: ${playerId} with color: ${assignedColor}`);
          }
          
          // CRITICAL FIX: Host also needs to apply the same color to the client's remote target
          console.log(`🎨 HOST applying color ${assignedColor} to remote client ${playerId}`);
          updatePlayerTeamColor(playerId, assignedColor);
          
          // CRITICAL FIX: Refresh remote player visibility after color assignment
          setTimeout(() => {
            makeAllRemotePlayersVisible();
          }, 50);
          
          // CRITICAL FIX: Force ball color update with delay to ensure it takes effect
          setTimeout(() => {
            console.log(`🎨 HOST forcing ball color update for ${playerId} with ${assignedColor}`);
            updatePlayerTeamColor(playerId, assignedColor);
          }, 100);
          
          // Update player count for all clients
          updateAllClientsPlayerCount();
        } else {
          console.warn('❌ HOST cannot assign player - all slots taken');
        }
      }
      
      function updateAllClientsPlayerCount() {
        // Send updated player count to all connected clients
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
              conn.send({
              type: 'player-count-update',
              activePlayers: Array.from(activePlayers),
              playerCount: activePlayers.size,
              maxPlayers: 4
            });
          }
        });
      }

      function handlePlayerUpdate(data) {
        // Handle remote player position/state updates
        const remotePlayer = document.querySelector(`#remote-player-${data.playerId}`);
        if (remotePlayer) {
          remotePlayer.setAttribute('position', data.position);
          // Add more state updates as needed
        }
      }

        function handleMatchStartSync(data) {
        // Handle match start synchronization from host
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          const gameManagerComponent = gameManager.components['game-manager'];
          // Start match with host's exact match start time
          gameManagerComponent.startMatch(data.matchStartTime);
        }
      }

      function handleGameState(data) {
        console.log('📨 CLIENT received game-state:', data);
        // Handle game state updates from host
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          const gameManagerComponent = gameManager.components['game-manager'];
          
          // Update match state
          if (data.state) {
            gameManagerComponent.matchState = data.state;
          }
          
          // Update game properties
          if (data.gameStarted !== undefined) {
            gameManagerComponent.gameStarted = data.gameStarted;
          }
          
          if (data.matchStartTime) {
            gameManagerComponent.matchStartTime = data.matchStartTime;
          }
          
          if (data.matchDuration) {
            gameManagerComponent.matchDuration = data.matchDuration;
          }
          
          // Handle countdown timing
          if (data.countdownStartTime) {
            gameManagerComponent.countdownStartTime = data.countdownStartTime;
          }
          
          if (data.countdownDuration) {
            gameManagerComponent.countdownDuration = data.countdownDuration;
          }
          
          // Update scores
          if (data.playerScores) {
            gameManagerComponent.playerScores = data.playerScores;
          }
          
          // Team scores removed - space shooter uses individual player scores
          
          // Update game mode if provided
          if (data.gameMode && data.gameMode !== gameMode) {
            gameMode = data.gameMode;
            // Game mode UI removed - space shooter is always dodgeball
          }
          
          // Update UI based on current state - but respect menu visibility
          if (data.state === 'PLAYING' || data.state === 'OVERTIME') {
            // Only update HUD if menu is not visible
            if (!isMenuVisible) {
              setGameplayHUD(true);
              if (gameManagerComponent.startMessage) {
                gameManagerComponent.startMessage.setAttribute('visible', false);
              }
            }
            
            // Always update score and timer data (even if not visible due to menu)
            gameManagerComponent.updateMultiplayerScore();
            gameManagerComponent.updateTimer();
          } else if (data.state === 'COUNTDOWN') {
            // Only update HUD if menu is not visible
            if (!isMenuVisible) {
              setGameplayHUD(true);
              if (gameManagerComponent.startMessage) {
                gameManagerComponent.startMessage.setAttribute('visible', false);
              }
              
              // Start countdown display if not already running
              if (gameManagerComponent.countdownDisplay) {
                gameManagerComponent.countdownDisplay.setAttribute('visible', true);
              }
            }
            
            // Always update score data (even if not visible due to menu)
            gameManagerComponent.updateMultiplayerScore();
          } else if (data.state === 'ENDED') {
            // Only update HUD if menu is not visible
            if (!isMenuVisible) {
              setGameplayHUD(true);
              if (gameManagerComponent.startMessage) {
                gameManagerComponent.startMessage.setAttribute('visible', false);
              }
            }
            
            // Always update final score data
            gameManagerComponent.updateMultiplayerScore();
          } else if (data.state === 'WAITING') {
            // Only update HUD if menu is not visible
            if (!isMenuVisible) {
              setGameplayHUD(false);
              if (gameManagerComponent.startMessage) {
                gameManagerComponent.startMessage.setAttribute('visible', true);
              }
            }
          }
          
          // CRITICAL FIX: Update menu display to hide Start Match button for clients
          updateMenuDisplay();
          
          // CRITICAL FIX: Refresh HUD after game state sync to ensure proper display
          setTimeout(() => {
            const menuToggle = document.querySelector('[menu-toggle]');
            if (menuToggle && menuToggle.components['menu-toggle']) {
              menuToggle.components['menu-toggle'].refreshGameHUD();
            }
          }, 150);
          
          // DO NOT call updateStartMessage during matches - it interferes with HUD
        }
      }

      function handleReadyUpdate(data) {
        readyStates[data.playerIndex] = data.ready;
        
        // Update the game manager's ready states
        const gameManager = document.querySelector('#game-manager');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].playerReadyStates[data.playerIndex] = data.ready;
          gameManager.components['game-manager'].updateReadyState();
        }
        
        updateMenuDisplay();
      }

      function handlePlayerInfoUpdate(data) {
        // Update local player info from host
      }

      function handleScoreUpdate(data) {
        // Handle score updates from host
        if (data.scores) {
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            gameManager.components['game-manager'].playerScores = data.scores;
            gameManager.components['game-manager'].updateMultiplayerScore();
            
            // Check for overtime win condition on clients
            if (gameManager.components['game-manager'].matchState === 'OVERTIME') {
              gameManager.components['game-manager'].checkOvertimeWin();
            }
          }
        }
        
        // Team scores removed - space shooter uses individual player scores
      }
      
      function handlePlayerState(data) {
        // Debug logging for received player state
        if (!this.lastReceiveLog || Date.now() - this.lastReceiveLog > 5000) {
          this.lastReceiveLog = Date.now();
          console.log(`📥 Received player state from ${data.playerId}:`, {
            position: `${data.state.x?.toFixed(1)}, ${data.state.y?.toFixed(1)}, ${data.state.z?.toFixed(1)}`,
            hasRig: !!data.state.rig,
            hasLeftHand: !!data.state.leftHand,
            hasRightHand: !!data.state.rightHand
          });
        }
        
        // CRITICAL FIX: Check if playerId is valid
        if (!data.playerId || typeof data.playerId !== 'string') {
          console.warn('❌ Invalid playerId in player state:', data.playerId);
          return;
        }
        
        // Handle remote player position/rotation updates (throttled logging)
        if (!this.lastPlayerStateReceiveTime || Date.now() - this.lastPlayerStateReceiveTime > 30000) {
          this.lastPlayerStateReceiveTime = Date.now();
        }
        remotePlayerStates.set(data.playerId, data.state);
        
        // CRITICAL: Host forwards player states to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          // Forward this player state to all other clients
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open) {
              // Forward to all connections (the sender will ignore their own data)
              conn.send({
                type: 'player-state',
                state: data.state,
                playerId: data.playerId
              });
            }
          });
        }
        
        // Update the corresponding remote player entity
        const playerIndex = parseInt(data.playerId.split('_')[1]);
        const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
        if (remotePlayer) {
          // Update head position and rotation
          remotePlayer.setAttribute('position', `${data.state.x} ${data.state.y} ${data.state.z}`);
          remotePlayer.setAttribute('rotation', `${data.state.rx} ${data.state.ry} ${data.state.rz}`);
          remotePlayer.setAttribute('visible', true);
          
          // REMOVED: Redundant color application system
          // Colors are now applied directly from player assignments
          
          // Store rig rotation data for arm IK calculations
          if (data.state.rig) {
            remotePlayer.setAttribute('data-rig-rotation', `${data.state.rig.rx} ${data.state.rig.ry} ${data.state.rig.rz}`);
          }
          
          // Update controller positions for arm IK if available
          if (data.state.leftHand) {
            const leftHandEl = remotePlayer.querySelector('.remote-left-hand');
            if (leftHandEl) {
              // Convert world coordinates to local coordinates relative to remote player
              const remotePlayerPos = new THREE.Vector3(data.state.x, data.state.y, data.state.z);
              const leftHandWorldPos = new THREE.Vector3(data.state.leftHand.x, data.state.leftHand.y, data.state.leftHand.z);
              const leftHandLocalPos = leftHandWorldPos.sub(remotePlayerPos);
              
              leftHandEl.setAttribute('position', `${leftHandLocalPos.x} ${leftHandLocalPos.y} ${leftHandLocalPos.z}`);
              leftHandEl.setAttribute('rotation', `${data.state.leftHand.rx} ${data.state.leftHand.ry} ${data.state.leftHand.rz}`);
            }
          }
          
          if (data.state.rightHand) {
            const rightHandEl = remotePlayer.querySelector('.remote-right-hand');
            if (rightHandEl) {
              // Convert world coordinates to local coordinates relative to remote player
              const remotePlayerPos = new THREE.Vector3(data.state.x, data.state.y, data.state.z);
              const rightHandWorldPos = new THREE.Vector3(data.state.rightHand.x, data.state.rightHand.y, data.state.rightHand.z);
              const rightHandLocalPos = rightHandWorldPos.sub(remotePlayerPos);
              
              rightHandEl.setAttribute('position', `${rightHandLocalPos.x} ${rightHandLocalPos.y} ${rightHandLocalPos.z}`);
              rightHandEl.setAttribute('rotation', `${data.state.rightHand.rx} ${data.state.rightHand.ry} ${data.state.rightHand.rz}`);
            }
          }
          
          if (!this.lastRemotePlayerUpdateTime || Date.now() - this.lastRemotePlayerUpdateTime > 30000) {
            this.lastRemotePlayerUpdateTime = Date.now();
          }
        } else {
          if (!this.lastRemotePlayerErrorTime || Date.now() - this.lastRemotePlayerErrorTime > 30000) {
            this.lastRemotePlayerErrorTime = Date.now();
          }
        }
      }
      
      function handleGameModeUpdate(data) {
        // CRITICAL FIX: Only clients should receive game mode updates from host
        if (isHost) {
          return; // Host doesn't receive game mode updates, only sends them
        }
        
        const newMode = data.gameMode;
        
        // Only apply if different from current mode
        if (newMode !== gameMode) {
          // Apply the game mode change locally (clients receive only)
          gameMode = newMode;
          
          // Update local UI and game state
          // Game mode UI removed - space shooter is always dodgeball
        }
      }
      
      // Capture ball functions removed - not used in space shooter
      
      function handleBallShieldState(data) {
        // CRITICAL FIX: Only update shield state for remote player's ball, don't send back
        if (data.playerId !== myPlayerId) {
          console.log(`🛡️ Received shield state: ${data.ballId} -> ${data.shieldActive ? 'ON' : 'OFF'} from ${data.playerId}`);
          
          const ball = document.querySelector(`[zerog-ball*="player: ${data.ballId}"]`);
          if (ball && ball.components['zerog-ball']) {
            const shieldElement = ball.querySelector('.ball-shield');
            if (shieldElement && shieldElement.components['ball-shield']) {
              const shieldComponent = shieldElement.components['ball-shield'];
              
              // CRITICAL FIX: Sync visual state and update collision masks properly
              if (data.shieldActive) {
                shieldComponent.isActive = true;
                shieldElement.setAttribute('visible', true);
                console.log(`🛡️ Remote shield VISIBLE for ${data.ballId}`);
              } else {
                shieldComponent.isActive = false;
                shieldElement.setAttribute('visible', false);
                console.log(`🛡️ Remote shield HIDDEN for ${data.ballId}`);
              }
              
              // Update collision mask based on grab and shield state
              const ballComponent = ball.components['zerog-ball'];
              if (ballComponent && ballComponent.updateCollisionMask) {
                ballComponent.updateCollisionMask();
              }
              
              // Sync cooldown state if provided
              if (data.cooldownEndTime) {
                shieldComponent.isOnCooldown = data.cooldownEndTime > Date.now();
                shieldComponent.cooldownEndTime = data.cooldownEndTime;
              }
            } else {
              console.log(`🛡️ Shield element/component not found for ${data.ballId}`);
            }
          } else {
            console.log(`🛡️ Ball not found for shield update: ${data.ballId}`);
          }
        }
      }
      
      function handleBallGrabState(data) {
          // Only update grab state for remote player's ball, don't send back
          if (data.playerId !== myPlayerId) {
          
          const ball = document.querySelector(`[zerog-ball*="player: ${data.ballId}"]`);
          if (ball && ball.components['zerog-ball']) {
            const ballComponent = ball.components['zerog-ball'];
            
            // Update the grab state
            ballComponent.isGrabbed = data.isGrabbed;
            
            // Update release time if provided
            if (data.lastReleaseTime) {
              ballComponent.lastReleaseTime = data.lastReleaseTime;
            }
            
            // Update collision mask based on new grab state
            if (ballComponent.updateCollisionMask) {
              ballComponent.updateCollisionMask();
            }
            // Remote ball updated
          }
        }
      }
      
      function handlePlayerGrab(data) {
        const player = document.querySelector('[zerog-player]');
        if (!player || !player.components['zerog-player']) return;
        
        const playerComponent = player.components['zerog-player'];
        
        // If this player is being grabbed
        if (data.targetPlayerId === myPlayerId) {
          if (data.isGrabbing) {
            // Check for mutual grab (counter-grab)
            const isGrabbingBack = playerComponent.grabbingPlayer.left === data.grabberId || 
                                   playerComponent.grabbingPlayer.right === data.grabberId;
            
            if (isGrabbingBack) {
              // Mutual grab detected - force release and set timeout
              console.log(`Mutual grab detected! ${myPlayerId} and ${data.grabberId} grabbing each other`);
              
              // Force release the grabber's grab on this player
              playerComponent.forceReleaseGrabberTimeout(data.grabberId);
              
              // Send force release message back
              const forceReleaseData = {
                type: 'player-grab-force-release',
                grabberId: myPlayerId,
                targetPlayerId: data.grabberId,
                timestamp: Date.now()
              };
              
              if (isHost) {
                connections.forEach(conn => {
                  if (conn && conn.open) {
                    conn.send(forceReleaseData);
                  }
                });
              } else {
                const hostConn = connections.get('host');
                if (hostConn && hostConn.open) {
                  hostConn.send(forceReleaseData);
                }
              }
            } else {
              // Normal grab - set grabbed state
              playerComponent.grabbedByPlayer = data.grabberId;
              console.log(`Player ${myPlayerId} is being grabbed by ${data.grabberId}`);
            }
          } else {
            // Release grab
            playerComponent.grabbedByPlayer = null;
            console.log(`Player ${myPlayerId} released by ${data.grabberId}`);
          }
        }
      }
      
      function handlePlayerGrabForceRelease(data) {
        const player = document.querySelector('[zerog-player]');
        if (!player || !player.components['zerog-player']) return;
        
        const playerComponent = player.components['zerog-player'];
        
        // If this player is the target of the force release
        if (data.targetPlayerId === myPlayerId) {
          // Force release any grabs on the grabber and set timeout
          playerComponent.forceReleaseGrabberTimeout(data.grabberId);
          console.log(`Force released grab on ${data.grabberId} and set 3-second timeout`);
        }
      }
      
      function handleMatchStart(data) {
        // Client receives match start command from host
        const gameManager = document.querySelector('[game-manager]');
        if (gameManager && gameManager.components['game-manager']) {
          gameManager.components['game-manager'].startMatchWithBots();
        }
      }
      
      function handleGameModeRequest(conn) {
        // CRITICAL FIX: Host responds to game mode requests from clients
        if (!isHost) {
          return; // Only host can respond to game mode requests
        }
        
        // Send current game mode to requesting client
        if (conn && conn.open) {
          conn.send({
            type: 'game-mode-update',
            gameMode: gameMode
          });
        }
      }
      
      function handleTeamAssignmentsRequest(conn) {
        // CRITICAL FIX: Host responds to team assignment requests from clients
        if (!isHost) {
          return; // Only host can respond to team assignment requests
        }
        
        // Space shooter doesn't use teams, but send empty response to prevent errors
        if (conn && conn.open) {
          conn.send({
            type: 'team-assignments',
            assignments: {}
          });
        }
      }
      
      function handleTeamAssignments(data) {
        // Space shooter doesn't use teams, but handle to prevent errors
        console.log('Team assignments received (space shooter doesn\'t use teams):', data);
      }
      
      // Team assignment functions removed - space shooter doesn't use teams
      
      // Game mode UI function removed - space shooter is always in dodgeball mode
      
      function handleBotState(data) {
        // Handle remote bot position/velocity updates from host
        const botId = data.botState.botId;
        const botElement = document.querySelector(`#zerog-${botId}`);
        
        if (botElement && botElement.components['zerog-bot']) {
          const botComponent = botElement.components['zerog-bot'];
          
          // Only update bot position on clients (not on host)
          if (!isHost && botComponent.body) {
            // Update bot physics body position, velocity, and rotation
            botComponent.body.position.set(data.botState.x, data.botState.y, data.botState.z);
            botComponent.body.velocity.set(data.botState.vx, data.botState.vy, data.botState.vz);
            
            // Update rotation if provided
            if (data.botState.qx !== undefined && data.botState.qy !== undefined && 
                data.botState.qz !== undefined && data.botState.qw !== undefined) {
              botComponent.body.quaternion.set(data.botState.qx, data.botState.qy, data.botState.qz, data.botState.qw);
            }
            
            // Update visual position and rotation
            botElement.object3D.position.set(data.botState.x, data.botState.y, data.botState.z);
            if (data.botState.qx !== undefined && data.botState.qy !== undefined && 
                data.botState.qz !== undefined && data.botState.qw !== undefined) {
              botElement.object3D.quaternion.set(data.botState.qx, data.botState.qy, data.botState.qz, data.botState.qw);
            }
          }
        }
        
        // Host forwards bot states to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open) {
              conn.send({
                type: 'bot-state',
                botState: data.botState,
                playerId: data.playerId
              });
            }
          });
        }
      }
      
      function handleDoorAnimation(data) {
        // Handle door animation synchronization from other players
        const doorEntity = document.querySelector(`#${data.doorEntityId}`);
        
        if (doorEntity) {
          // Find the door system component on the entity
          const doorComponent = doorEntity.components['door-proximity-trigger'] || 
                               doorEntity.components['door-proximity-trigger-2'] || 
                               doorEntity.components['door-proximity-trigger-3'];
          
          if (doorComponent) {
            // Trigger the appropriate door animation (from multiplayer, so don't send another message)
            if (data.animationType === 'open') {
              doorComponent.openDoors(true);
            } else if (data.animationType === 'close') {
              doorComponent.closeDoors(true);
            }
          }
        }
        
        // Host forwards door animation to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.playerId) {
              conn.send(data);
            }
          });
        }
      }
      
      // Bullet multiplayer handlers
      function handleBulletCreate(data) {
        // Create a remote bullet from another player's shot
        if (data.shooterPlayerId === myPlayerId) {
          return; // Don't create our own bullets remotely
        }
        
        const bullet = document.createElement('a-entity');
        bullet.object3D.position.set(data.position.x, data.position.y, data.position.z);
        
        // Set visual properties for remote bullets
        if (data.isHoming) {
          // This is a missile - set missile appearance
          bullet.setAttribute('geometry', 'primitive: sphere; radius: 0.1');
          bullet.setAttribute('material', 'color: #ff0000');
          
          // Add hum sound to homing missile
          bullet.setAttribute('sound', {
            src: 'url(audio/electric-hum.wav)',
            autoplay: true,
            loop: true,
            volume: 0.3,
            positional: true,
            distanceModel: 'linear',
            refDistance: 1,
            maxDistance: 25
          });
        } else {
          // This is a regular bullet - set bullet appearance
          bullet.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
          bullet.setAttribute('material', 'color: #ffff00');
        }
        
        // Add bullet component with remote flag
        bullet.setAttribute('bullet', {
          speed: data.speed,
          shooter: data.shooterPlayerId,
          hand: data.hand,
          directionX: data.direction.x,
          directionY: data.direction.y,
          directionZ: data.direction.z,
          bulletId: data.bulletId,
          isRemote: true,
          isHoming: data.isHoming || false,
          targetId: data.targetId || '',
          homingForce: data.homingForce || 20,
          explosionRadius: data.explosionRadius || 1.0,
          explosionDamage: data.explosionDamage || 50,
          bulletHits: data.bulletHits || 0,
          maxBulletHits: data.maxBulletHits || 5
        });
        
        // Add to scene
        document.querySelector('a-scene').appendChild(bullet);
        
        // Host forwards bullet creation to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'bullet-create',
                bulletId: data.bulletId,
                shooterPlayerId: data.shooterPlayerId,
                position: data.position,
                direction: data.direction,
                speed: data.speed,
                hand: data.hand,
                isHoming: data.isHoming,
                targetId: data.targetId,
                homingForce: data.homingForce,
                explosionRadius: data.explosionRadius,
                explosionDamage: data.explosionDamage,
                bulletHits: data.bulletHits,
                maxBulletHits: data.maxBulletHits
              });
            }
          });
        }
      }
      
      function handleBulletDestroy(data) {
        // Remove bullet by ID
        const bullet = document.querySelector(`[bullet][bulletId="${data.bulletId}"]`);
        if (bullet && bullet.parentNode) {
          bullet.parentNode.removeChild(bullet);
        }
        
        // Host forwards bullet destroy to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'bullet-destroy',
                bulletId: data.bulletId,
                shooterPlayerId: data.shooterPlayerId
              });
            }
          });
        }
      }
      
      function handleDamageEffect(data) {
        console.log('💥 Received damage effect:', data);
        console.log('💥 Current myPlayerId:', myPlayerId);
        console.log('💥 Target player ID:', data.targetPlayerId);
        
        // Create damage effect (spark/smoke) on the correct player entity
        let targetEntity = null;
        
        // Find the target player entity
        if (data.targetPlayerId === myPlayerId) {
          // This is the local player - use local player entity
          targetEntity = document.querySelector('#player');
          console.log('💥 Using local player entity:', targetEntity);
        } else if (data.targetPlayerId.startsWith('player_')) {
          // This is a remote player - use remote player entity
          const playerIndex = parseInt(data.targetPlayerId.split('_')[1]);
          targetEntity = document.querySelector(`#remote-player-${playerIndex}`);
          console.log('💥 Using remote player entity:', targetEntity, 'for index:', playerIndex);
        } else if (data.targetPlayerId.startsWith('zerog-bot-')) {
          // This is a bot - use bot entity
          targetEntity = document.querySelector('#' + data.targetPlayerId);
          console.log('💥 Using bot entity:', targetEntity);
        }
        
        if (targetEntity) {
          console.log('💥 Target entity found:', targetEntity);
          // Create damage effect as child of the target entity
          const radius = data.targetPlayerId.startsWith('zerog-bot-') ? 0.3 : 0.2; // Bot or player radius
          
          // Random position on sphere surface (relative to target)
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const effectPos = new THREE.Vector3(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
          
          // Create looping spark+smoke animation for each missile hit (player damage state)
          const damageEffect = document.createElement('a-entity');
          damageEffect.setAttribute('position', `${effectPos.x} ${effectPos.y} ${effectPos.z}`);
          damageEffect.setAttribute('world-spark-system', '');
          damageEffect.setAttribute('spark-smoke-controller', '');
          damageEffect.setAttribute('threejs-smoke-puffs', '');
          
          // Add as child of target entity so it moves with the target
          targetEntity.appendChild(damageEffect);
          console.log('💥 Damage effect created and attached to:', targetEntity);
        } else {
          console.log('💥 Target entity not found for:', data.targetPlayerId);
        }
        
        // Host forwards damage effect to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          console.log('💥 Host forwarding damage effect to other clients');
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'damage-effect',
                position: data.position,
                targetPlayerId: data.targetPlayerId,
                shooterPlayerId: data.shooterPlayerId,
                timestamp: data.timestamp
              });
            }
          });
        }
      }
      
      function handleExplosionEffect(data) {
        console.log('💥 Received explosion effect:', data);
        
        // Play explosion animation and sound for target entity
        const targetEntity = document.querySelector(data.targetSelector);
        console.log('💥 Target entity found:', targetEntity);
        
        if (targetEntity) {
          // Play explosion sound at target position
          const soundEntity = document.querySelector('#impact-sound');
          if (soundEntity && soundEntity.components.sound) {
            const worldPos = new THREE.Vector3();
            targetEntity.object3D.getWorldPosition(worldPos);
            soundEntity.object3D.position.copy(worldPos);
            soundEntity.components.sound.playSound();
            console.log('💥 Playing explosion sound');
          }
          
          // Play explosion animation (growing/fading sphere)
          const impactTarget = targetEntity.querySelector('[impact-effect]');
          console.log('💥 Impact target found:', impactTarget);
          if (impactTarget && impactTarget.components['impact-effect']) {
            impactTarget.components['impact-effect'].playEffect();
            console.log('💥 Playing explosion animation');
          }
        }
        
        // Host forwards explosion effect to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'explosion-effect',
                targetSelector: data.targetSelector,
                targetPlayerId: data.targetPlayerId,
                shooterPlayerId: data.shooterPlayerId,
                timestamp: data.timestamp
              });
            }
          });
        }
      }
      
      function handleHitSound(data) {
        // Play hit sound at specified position
        const soundPos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
        const soundEntity = document.querySelector(data.soundSelector);
        if (soundEntity && soundEntity.components.sound) {
          soundEntity.object3D.position.copy(soundPos);
          soundEntity.components.sound.playSound();
        }
        
        // Host forwards hit sound to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'hit-sound',
                position: data.position,
                soundSelector: data.soundSelector,
                targetPlayerId: data.targetPlayerId,
                shooterPlayerId: data.shooterPlayerId,
                timestamp: data.timestamp
              });
            }
          });
        }
      }
      
      function handleBotDamageState(data) {
        console.log('🤖 Received bot damage state:', data);
        // Update bot damage state (hit counts, death, respawn) for all clients
        const botEntity = document.querySelector(data.botSelector);
        console.log('🤖 Bot entity found:', botEntity);
        if (botEntity && botEntity.components['zerog-bot']) {
          const botComponent = botEntity.components['zerog-bot'];
          
          // Update hit count
          if (data.hitCount !== undefined) {
            botComponent.hitCount = data.hitCount;
          }
          
          // Handle death
          if (data.isDead) {
            botComponent.isDead = true;
            botEntity.setAttribute('visible', false);
          }
          
          // Handle respawn
          if (data.respawn) {
            console.log('🤖 Handling bot respawn');
            botComponent.isDead = false;
            botComponent.hitCount = 0;
            botEntity.setAttribute('visible', true);
            botEntity.object3D.position.copy(new THREE.Vector3(data.position.x, data.position.y, data.position.z));
            
            // Clean up all damage effects for this bot
            const damageEffects = botEntity.querySelectorAll('[world-spark-system]');
            damageEffects.forEach(effect => {
              if (effect.parentNode) {
                effect.parentNode.removeChild(effect);
              }
            });
          }
        }
        
        // Host forwards bot damage state to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'bot-damage-state',
                botSelector: data.botSelector,
                hitCount: data.hitCount,
                isDead: data.isDead,
                respawn: data.respawn,
                position: data.position,
                shooterPlayerId: data.shooterPlayerId,
                timestamp: data.timestamp
              });
            }
          });
        }
      }
      
      function handlePlayerDamageState(data) {
        // Update player damage state (hit counts, death) for all clients
        if (data.playerId === myPlayerId) {
          return; // Don't update our own player state
        }
        
        // Find the remote player entity
        const playerIndex = parseInt(data.playerId.split('_')[1]);
        const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
        if (remotePlayer) {
          // Handle respawn - clean up damage effects
          if (data.respawn) {
            // Clean up all damage effects for this remote player
            const damageEffects = remotePlayer.querySelectorAll('[world-spark-system]');
            damageEffects.forEach(effect => {
              if (effect.parentNode) {
                effect.parentNode.removeChild(effect);
              }
            });
          }
          
          // Update remote player damage state
          remotePlayer.setAttribute('player-damage', {
            missileHits: data.missileHits,
            isDead: data.isDead
          });
          
          // Update damage bar for remote player if it exists
          const remoteDamageBar = document.querySelector(`#remote-damage-bar-${playerIndex}`);
          if (remoteDamageBar) {
            const healthPercent = ((5 - data.missileHits) / 5) * 100; // Assuming max 5 hits
            const barWidth = (healthPercent / 100) * 0.38;
            remoteDamageBar.setAttribute('geometry', 'primitive: plane; width: ' + barWidth + '; height: 0.02');
          }
        }
        
        // Host forwards player damage state to other clients
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.shooterPlayerId) {
              conn.send({
                type: 'player-damage-state',
                playerId: data.playerId,
                missileHits: data.missileHits,
                isDead: data.isDead,
                respawn: data.respawn || false,
                shooterPlayerId: data.shooterPlayerId,
                timestamp: data.timestamp
              });
            }
          });
        }
      }
      
      function handleBallState(data) {
        // Handle remote ball position/velocity updates (throttled logging)
        if (!this.lastBallStateReceiveTime || Date.now() - this.lastBallStateReceiveTime > 30000) {
          this.lastBallStateReceiveTime = Date.now();
        }
        remoteBallStates.set(data.playerId, data.ballState);
        
        // CRITICAL: Host forwards ball states to other clients (but NOT back to sender)
        if (isHost && isMultiplayer && activePlayers.size > 1) {
          // Forward this ball state to all other clients EXCEPT the sender
          connections.forEach((conn, connectionKey) => {
            if (conn && conn.open && connectionKey !== data.playerId) {
              // Only forward to connections that are NOT the original sender
              conn.send({
                type: 'ball-state',
                ballState: data.ballState,
                playerId: data.playerId
              });
            }
          });
        }
        
        // CRITICAL FIX: Apply ball updates from other players
        const ballNumber = data.ballState.playerId;
        
        // CRITICAL FIX: Handle capture ball with dynamic ownership
        if (ballNumber === 'capture') {
          const captureBall = document.querySelector('#capture-ball');
          if (captureBall && captureBall.components['zerog-ball']) {
            const ballComponent = captureBall.components['zerog-ball'];
            
            // Don't update capture ball if it's currently being controlled locally
            if (ballComponent.isGrabbed) {
              return;
            }
            
            // Apply network update to capture ball from any player
            captureBall.object3D.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
            if (ballComponent.body) {
              ballComponent.body.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
              ballComponent.body.velocity.set(data.ballState.vx, data.ballState.vy, data.ballState.vz);
            }
          }
          return;
        }
        
        // CRITICAL FIX: Use dynamic ball assignment instead of hardcoded logic
        const currentPlayerBallNumber = getBallForPlayer(myPlayerId || 'player_0');
        
        // CRITICAL FIX: NEVER apply network updates to our own ball
        if (ballNumber === currentPlayerBallNumber) {
          // This is our own ball - we have full authority over it
          // Don't apply any network updates regardless of control state
          return;
        }
        
        // Also check if this ball is currently being controlled by the local player
        const ball = document.querySelector(`[zerog-ball*="player: player${ballNumber}"]`);
        if (ball && ball.components['zerog-ball']) {
          const ballComponent = ball.components['zerog-ball'];
          
          // Skip network updates if ball is being grabbed OR if tractor beam is active for this ball OR if auto-return is active
          const isGrabbed = ballComponent.isGrabbed;
          // Tractor beam removed for space shooter
          const isLocallyControlled = isGrabbed;
          
          if (isLocallyControlled) {
            // Ball is being controlled locally - don't apply network updates
            if (!this.lastGrabbedBallSkipTime || Date.now() - this.lastGrabbedBallSkipTime > 30000) {
              this.lastGrabbedBallSkipTime = Date.now();
            }
            return;
          }
        }
        
        // Apply network updates to OTHER players' balls
        if (ball && ball.components['zerog-ball']) {
          const ballComponent = ball.components['zerog-ball'];
          
          // CRITICAL: Check if ball is locally controlled BEFORE applying any network updates
          const isLocallyControlled = ballComponent.isGrabbed;
          
          // Skip network updates if ball is locally controlled
          if (isLocallyControlled) {
            return; // Exit early - don't apply any network updates
          }
          
          // Force immediate visual update
          ball.object3D.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
          
          if (ballComponent.body) {
            ballComponent.body.position.set(data.ballState.x, data.ballState.y, data.ballState.z);
            ballComponent.body.velocity.set(data.ballState.vx, data.ballState.vy, data.ballState.vz);
            
            // Also sync the quaternion to ensure visual representation is fully updated
            ball.object3D.quaternion.copy(ballComponent.body.quaternion);
            
            // Force a visual update by marking the ball as needing update
            ball.object3D.updateMatrix();
            ball.object3D.updateMatrixWorld(true);
            
            // Mark this ball as remotely updated to prevent physics tick from overriding
            ball.setAttribute('data-remote-update', 'true');
            
            // Clear the remote update flag after a short delay
            setTimeout(() => {
              ball.removeAttribute('data-remote-update');
            }, 100); // 100ms delay
          }
          
          if (!this.lastBallUpdateTime || Date.now() - this.lastBallUpdateTime > 30000) {
            this.lastBallUpdateTime = Date.now();
          }
          
          // Debug: Log significant ball movement
          const ballSpeed = Math.sqrt(data.ballState.vx * data.ballState.vx + data.ballState.vy * data.ballState.vy + data.ballState.vz * data.ballState.vz);
          if (ballSpeed > 0.1) {
            
          }
          
          // Debug: Log ball update confirmation (throttled)
          if (!this.lastBallUpdateDebugTime || Date.now() - this.lastBallUpdateDebugTime > 30000) {
            this.lastBallUpdateDebugTime = Date.now();
          }
        } else {
          if (!this.lastBallErrorTime || Date.now() - this.lastBallErrorTime > 30000) {
            // Debug: list all balls to see what's available
            const allBalls = document.querySelectorAll('[zerog-ball]');
            allBalls.forEach((ball, index) => {
              const player = ball.getAttribute('zerog-ball')?.player;
            });
            this.lastBallErrorTime = Date.now();
          }
        }
      }

      function handlePlayerDisconnection(conn, playerId) {
        console.log('🚨 handlePlayerDisconnection called:', {
          playerId: playerId,
          actualPlayerId: connectionToPlayer.get(conn),
          isHost: isHost,
          isMultiplayer: isMultiplayer,
          myPlayerId: myPlayerId,
          connectionsSize: connections.size
        });
        
        // Find the actual player ID assigned to this connection
        const actualPlayerId = connectionToPlayer.get(conn);
        
        // Remove the connection from the connections map
        let connectionKeyToRemove = null;
        connections.forEach((connection, key) => {
          if (connection === conn) {
            connectionKeyToRemove = key;
          }
        });
        
        if (connectionKeyToRemove) {
          connections.delete(connectionKeyToRemove);
        }
        
        // Remove the connection-to-player mapping
        connectionToPlayer.delete(conn);
        
        // Remove player from active players (use actual player ID if available)
        const playerToRemove = actualPlayerId || playerId;
        if (playerToRemove) {
          activePlayers.delete(playerToRemove);
          
          // Update bot management for new player count
          manageActivePlayersAndBots();
          
          // If this was a client disconnecting, also remove them from the players map
          if (playerToRemove && playerToRemove.startsWith('player_')) {
            const player = players.get(playerToRemove);
            if (player) {
              player.isConnected = false;
              player.isBot = false;
            }
          }
        }
        
        // Handle client-side disconnection
        if (!isHost) {
          updateMultiplayerStatus('Connection lost - attempting to reconnect...');
          
          // Clear current state but keep multiplayer flag
          myPlayerId = null;
          activePlayers.clear();
          
          // Set a flag to prevent manual mode switches during reconnection
          window.isReconnecting = true;
          
          // Attempt to reconnect after a short delay
          setTimeout(() => {
            if (isMultiplayer && !isHost && window.isReconnecting) {
              
              // Add a timeout to the reconnection attempt
              const reconnectionTimeout = setTimeout(() => {
                if (window.isReconnecting) {
                  console.log('⏰ Reconnection timeout - switching to singleplayer mode');
                  window.isReconnecting = false;
                  
                  // Switch to singleplayer mode
                  isMultiplayer = false;
                  isHost = false;
                  myPlayerId = null;
                  activePlayers.clear();
                  connections.clear();
                  connectionToPlayer.clear();
                  
                  // Reset to singleplayer state
                  const rig = document.querySelector('#rig');
                  if (rig) {
                    rig.setAttribute('position', '0 5.300 0');
                    rig.setAttribute('rotation', '0 0 0');
                  }
                  
                  // CRITICAL FIX: Reset player target color to neutral, let team colors take over
                  const playerTarget = document.querySelector('#player-target');
                  if (playerTarget) {
                    const currentPlayerId = myPlayerId || 'player_0';
                    // Team colors removed - space shooter uses default colors
                    updatePlayerTeamColor(currentPlayerId, 'red');
                  }
                  
                  updateMultiplayerStatus('Singleplayer Mode');
                  updateMenuDisplay();
                }
              }, 10000); // 10 second timeout
              
              connectToLobby(selectedLobby).then(() => {
                clearTimeout(reconnectionTimeout);
                updateMultiplayerStatus(`Reconnected - Lobby ${selectedLobby}`);
                window.isReconnecting = false;
              }).catch((error) => {
                updateMultiplayerStatus('Reconnection failed - switching to singleplayer');
                
                // Switch to singleplayer mode if reconnection fails
                setTimeout(() => {
                  if (isMultiplayer && window.isReconnecting) {
                    isMultiplayer = false;
                    isHost = false;
                    myPlayerId = null;
                    activePlayers.clear();
                    connections.clear();
                    connectionToPlayer.clear();
                    window.isReconnecting = false;
                    
                    // Reset to singleplayer state
                    const rig = document.querySelector('#rig');
                    if (rig) {
                      rig.setAttribute('position', '0 5.300 0');
                      rig.setAttribute('rotation', '0 0 0');
                    }
                    
                    // CRITICAL FIX: Reset player target color to neutral, let team colors take over
                    const playerTarget = document.querySelector('#player-target');
                    if (playerTarget) {
                      const currentPlayerId = myPlayerId || 'player_0';
                      // Team colors removed - space shooter uses default colors
                      updatePlayerTeamColor(currentPlayerId, 'red');
                    }
                    
                    updateMultiplayerStatus('Singleplayer Mode');
                    updateMenuDisplay();
                  } else {
                    window.isReconnecting = false;
                  }
                }, 2000); // Wait 2 seconds before switching to singleplayer
              });
            } else {
              window.isReconnecting = false;
            }
          }, 1000); // Wait 1 second before attempting reconnection
        }
        
        // Update displays
        updateMenuDisplay();
        
        // Send updated player count to remaining clients
        if (isHost) {
          sendPlayerCountUpdate();
        }
        
        // Make remote players visible again (in case some were hidden)
        setTimeout(() => {
          makeAllRemotePlayersVisible();
        }, 100);
        
      }

      function sendPlayerCountUpdate() {
        // Calculate actual player count (excluding connection IDs)
        const actualPlayerCount = Array.from(activePlayers).filter(id => id.startsWith('player_')).length;
        
        
        // Update host's own status display
        if (isHost) {
          const maxPlayers = 4; // Always 4 players in both modes
          updateMultiplayerStatus(`Host - Lobby ${selectedLobby} (${actualPlayerCount}/${maxPlayers})`);
        }
        
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            conn.send({
              type: 'player-count-update',
              activePlayers: Array.from(activePlayers),
              playerCount: actualPlayerCount
            });
          }
        });
      }

      function connectToLobby(lobbyNumber) {
        return new Promise((resolve, reject) => {
          if (isMultiplayer) {
            // Disconnect from current session
            if (peer) {
              peer.destroy();
            }
            connections.clear();
            connectionToPlayer.clear();
            activePlayers.clear();
            myPlayerId = null;
            
            // Reset match state when switching lobbies
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].resetMatch();
            }
          }
          
          // Try to connect as host first, then as peer
          setupHost(lobbyNumber).then(() => {
            resolve();
          }).catch((error) => {
            setupPeer(lobbyNumber).then(() => {
              resolve();
            }).catch((peerError) => {
              updateMultiplayerStatus(`Lobby ${lobbyNumber} unavailable. Try another lobby.`);
              reject(peerError);
            });
          });
        });
      }

      function autoConnect() {
        // Try to find an available lobby
        for (let lobby = 1; lobby <= MAX_LOBBIES; lobby++) {
          connectToLobby(lobby);
          break; // For now, just try lobby 1
        }
      }

      // Update HUD score display
      function updateHUDScore(playerScore, opponentScore, isMultiplayer = false) {
        const hudScore = document.querySelector('#hud-score');
        
        if (hudScore) {
          const playerScoreEl = hudScore.children[0];
          const opponentScoreEl = hudScore.children[1];
          
          if (playerScoreEl && opponentScoreEl) {
            // Always use clean number-only format (colors indicate teams)
            playerScoreEl.setAttribute('text', 'value', `${playerScore}`);
            opponentScoreEl.setAttribute('text', 'value', `${opponentScore}`);
            
            if (isMultiplayer && myPlayerId) {
              // Team colors removed - space shooter uses default colors
              const myPlayerColor = '#ffffff'; // Default white
              let opponentColor = '#ff4444'; // Default red
              
              playerScoreEl.setAttribute('text', 'color', myPlayerColor);
              opponentScoreEl.setAttribute('text', 'color', opponentColor);
            }
          }
        } else {
        }
      }

      // Show/hide HUD elements during gameplay
function setGameplayHUD(isPlaying) {
  // Don't change HUD visibility if menu is open
  if (isMenuVisible) {
    return;
  }
  
  const hudStatus = document.querySelector('#hud-status');
  const hudScore = document.querySelector('#hud-score');
  const hudTimer = document.querySelector('#hud-timer');
  const hudMessage = document.querySelector('#hud-message');
  const versionDisplay = document.querySelector('#version-display');
  
  // ALWAYS keep version display visible (game version + FPS)
  if (versionDisplay) {
    versionDisplay.setAttribute('visible', true);
  }
  
  if (hudStatus) {
    hudStatus.setAttribute('visible', !isPlaying);
  }
  if (hudScore) {
    // Show score when playing (isPlaying = true means match is active)
    hudScore.setAttribute('visible', isPlaying);
  }
  if (hudTimer) {
    // Show timer only during active matches (PLAYING and OVERTIME states)
    // CRITICAL FIX: Find the correct game manager instance
    const allGameManagers = document.querySelectorAll('[game-manager]');
    let gameManagerComponent = null;
    
    for (let i = 0; i < allGameManagers.length; i++) {
      const gm = allGameManagers[i];
      if (gm.components && gm.components['game-manager']) {
        const comp = gm.components['game-manager'];
        if (!gameManagerComponent || comp.gameStarted || comp.matchState !== 'WAITING') {
          gameManagerComponent = comp;
        }
      }
    }
    
    const shouldShowTimer = gameManagerComponent && 
                           (gameManagerComponent.matchState === 'PLAYING' || 
                            gameManagerComponent.matchState === 'OVERTIME');
    hudTimer.setAttribute('visible', shouldShowTimer);
  }
  if (hudMessage) {
    // Handle message display based on multiplayer state and match status
    if (isPlaying) {
      hudMessage.setAttribute('visible', false); // Hide during active gameplay
    } else {
      // Check if we're in multiplayer and what state we're in
      // CRITICAL FIX: Find the correct game manager instance
      const allGameManagers = document.querySelectorAll('[game-manager]');
      let gameManagerComponent = null;
      
      for (let i = 0; i < allGameManagers.length; i++) {
        const gm = allGameManagers[i];
        if (gm.components && gm.components['game-manager']) {
          const comp = gm.components['game-manager'];
          if (!gameManagerComponent || comp.gameStarted || comp.matchState !== 'WAITING') {
            gameManagerComponent = comp;
          }
        }
      }
      
      if (isMultiplayer && gameManagerComponent) {
        // In multiplayer, show appropriate message based on role and state
        if (gameManagerComponent.matchState === 'WAITING') {
          hudMessage.setAttribute('visible', true);
          if (isHost) {
            hudMessage.setAttribute('text', 'value', 'Press X to open menu and start match');
          } else {
            hudMessage.setAttribute('text', 'value', 'Waiting for host to start match...');
          }
        } else if (gameManagerComponent.matchState === 'COUNTDOWN') {
          // During countdown, keep message visible for countdown numbers
          hudMessage.setAttribute('visible', true);
          // Don't change the text - let the game manager tick function handle it
        } else {
          hudMessage.setAttribute('visible', false);
        }
      } else {
        // Singleplayer - show default message
        hudMessage.setAttribute('visible', true);
        hudMessage.setAttribute('text', 'value', 'Press X to open menu');
      }
    }
  }
  
  // HUD updated silently
}

      // Start the app initialization immediately after dependencies load
      initializeApp();

      // Wait for components to be registered in head before proceeding
      function waitForComponents() {
        if (window.componentsReady) {
          console.log('Components ready, proceeding with component registration...');
          // Now register all the main components
          registerAllComponents();
        } else {
          setTimeout(waitForComponents, 50);
        }
      }
      
      // Start waiting for components
      waitForComponents();

      function registerAllComponents() {
        if (typeof AFRAME === 'undefined') {
          console.error('AFRAME still not available');
          return;
        }
        
        console.log('Registering main components...');
        
      // WORLD-SPACE Three.js spark system - completely independent of A-Frame hierarchy
      AFRAME.registerComponent('world-spark-system', {
        init: function() {
          this.sparks = [];
          this.worldPosition = new THREE.Vector3();
          this.el.object3D.getWorldPosition(this.worldPosition);
          this.setupSparks();
        },
        
        setupSparks: function() {
          const scene = this.el.sceneEl.object3D;
          
          const sparkConfigs = [
            {velocity: new THREE.Vector3(0.8, 0.3, 0.6), color: 0xFFFF00, size: 0.008, life: 1.2},
            {velocity: new THREE.Vector3(-0.7, 0.9, -0.4), color: 0xFFFF00, size: 0.006, life: 1.1},
            {velocity: new THREE.Vector3(0.4, -0.6, 0.8), color: 0xFF8800, size: 0.007, life: 1.0},
            {velocity: new THREE.Vector3(-0.5, -0.3, -0.7), color: 0xFFFF00, size: 0.005, life: 1.3},
            {velocity: new THREE.Vector3(0.2, 0.8, -0.9), color: 0xFF4400, size: 0.004, life: 0.9}
          ];
          
          sparkConfigs.forEach((config, i) => {
            const geometry = new THREE.SphereGeometry(config.size, 8, 6);
            const material = new THREE.MeshBasicMaterial({
              color: new THREE.Color(config.color),
              transparent: true,
              opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            // Set WORLD position directly
            mesh.position.copy(this.worldPosition);
            
            const spark = {
              mesh: mesh,
              velocity: config.velocity.clone(),
              startPosition: this.worldPosition.clone(),
              age: 0,
              maxAge: config.life,
              startColor: new THREE.Color(config.color),
              endColor: new THREE.Color(0x220000),
              originalOpacity: 0.9
            };
            
            this.sparks.push(spark);
            // Add directly to scene, NOT to A-Frame entity
            scene.add(mesh);
          });
        },
        
        tick: function(time, timeDelta) {
          if (!this.el.getAttribute('visible')) {
            this.sparks.forEach(spark => spark.mesh.visible = false);
            return;
          }
          
          this.sparks.forEach(spark => spark.mesh.visible = true);
          
          const deltaSeconds = timeDelta / 1000;
          
          this.sparks.forEach(spark => {
            spark.age += deltaSeconds;
            
            if (spark.age > spark.maxAge) {
              // Reset to world start position
              spark.age = 0;
              spark.mesh.position.copy(spark.startPosition);
              spark.mesh.material.opacity = spark.originalOpacity;
              spark.mesh.material.color.copy(spark.startColor);
              return;
            }
            
            // PURE WORLD-SPACE LINEAR MOVEMENT
            spark.mesh.position.x += spark.velocity.x * deltaSeconds;
            spark.mesh.position.y += spark.velocity.y * deltaSeconds;
            spark.mesh.position.z += spark.velocity.z * deltaSeconds;
            
            // Color transition
            const progress = spark.age / spark.maxAge;
            const currentColor = spark.startColor.clone().lerp(spark.endColor, progress);
            spark.mesh.material.color.copy(currentColor);
            spark.mesh.material.opacity = spark.originalOpacity * (1 - progress);
          });
        },
        
        remove: function() {
          const scene = this.el.sceneEl.object3D;
          this.sparks.forEach(spark => {
            scene.remove(spark.mesh);
            spark.mesh.geometry.dispose();
            spark.mesh.material.dispose();
          });
          this.sparks = [];
        }
      });

      // Spark burst controller - realistic welding/electrical spark patterns
      AFRAME.registerComponent('spark-burst-controller', {
        init: function() {
          this.timer = 0;
          this.state = 'pause'; // 'pause', 'burst', 'continuous'
          this.nextStateTime = 2; // Start with 2 second pause
          this.particleSystem = null;
          this.smokeSystem = null;
        },
        
        tick: function(time, timeDelta) {
          if (!this.el.getAttribute('visible')) return;
          
          // Get particle system components
          if (!this.particleSystem) {
            this.particleSystem = this.el.components['particle-system'];
            if (!this.particleSystem) return;
          }
          
          if (!this.smokeSystem) {
            const smokeEntity = this.el.querySelector('#spark-smoke');
            if (smokeEntity) {
              this.smokeSystem = smokeEntity.components['particle-system'];
            }
          }
          
          const deltaSeconds = timeDelta / 1000;
          this.timer += deltaSeconds;
          
          // Check if we should change state
          if (this.timer >= this.nextStateTime) {
            this.timer = 0;
            this.changeState();
          }
          
          // Control particle emission based on state
          if (this.state === 'pause') {
            // Stop particles during pause
            this.particleSystem.stopParticles();
            if (this.smokeSystem) {
              this.smokeSystem.stopParticles();
            }
          } else {
            // Start particles for burst or continuous
            this.particleSystem.startParticles();
            if (this.smokeSystem) {
              this.smokeSystem.startParticles();
            }
          }
        },
        
        changeState: function() {
          const rand = Math.random();
          
          if (this.state === 'pause') {
            // Coming out of pause - choose burst or continuous
            if (rand < 0.7) {
              // 70% chance of burst
              this.state = 'burst';
              this.nextStateTime = 0.1 + Math.random() * 0.4; // 0.1-0.5 second bursts
              // console.log('Spark burst for', this.nextStateTime.toFixed(2), 'seconds');
            } else {
              // 30% chance of continuous
              this.state = 'continuous';
              this.nextStateTime = 0.8 + Math.random() * 1.5; // 0.8-2.3 second continuous
              // console.log('Spark continuous for', this.nextStateTime.toFixed(2), 'seconds');
            }
          } else {
            // Coming out of burst or continuous - go to pause
            this.state = 'pause';
            this.nextStateTime = 1.5 + Math.random() * 3.5; // 1.5-5 second pauses
            // console.log('Spark pause for', this.nextStateTime.toFixed(2), 'seconds');
          }
        },
        
        remove: function() {
          if (this.particleSystem) {
            this.particleSystem.stopParticles();
          }
          if (this.smokeSystem) {
            this.smokeSystem.stopParticles();
          }
        }
      });

      // Impact Effects System - Creates temporary spark and smoke effects at any 3D position
      AFRAME.registerComponent('impact-effects-manager', {
        init: function() {
          this.activeEffects = [];
          this.maxEffects = 20; // Limit concurrent effects for performance
        },
        
        createImpactEffect: function(position) {
          // Remove oldest effect if at limit
          if (this.activeEffects.length >= this.maxEffects) {
            this.removeEffect(this.activeEffects[0]);
          }
          
          const effectId = 'impact-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          
          // Create temporary spark effect
          const sparkEntity = document.createElement('a-entity');
          sparkEntity.id = effectId + '-sparks';
          sparkEntity.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
          sparkEntity.setAttribute('impact-spark-burst', '');
          
          // Create a temporary copy of the working spark smoke system
          const smokeEntity = document.createElement('a-entity');
          smokeEntity.id = effectId + '-smoke';
          smokeEntity.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
          smokeEntity.setAttribute('visible', 'true');
          
          // Use specialized impact smoke controller instead of the continuous one
          smokeEntity.setAttribute('impact-smoke-controller', '');
          smokeEntity.setAttribute('threejs-smoke-puffs', '');
          
          // Add to scene
          this.el.sceneEl.appendChild(sparkEntity);
          this.el.sceneEl.appendChild(smokeEntity);
          
          // The impact-smoke-controller will handle immediate puff creation
          
          const effect = {
            id: effectId,
            sparkEntity: sparkEntity,
            smokeEntity: smokeEntity,
            startTime: Date.now(),
            duration: 5000 // 5 seconds to let smoke fully fade out
          };
          
          this.activeEffects.push(effect);
        },
        
        tick: function() {
          const now = Date.now();
          
          // Clean up expired effects
          this.activeEffects = this.activeEffects.filter(effect => {
            if (now - effect.startTime > effect.duration) {
              this.removeEffect(effect);
              return false;
            }
            return true;
          });
        },
        
        removeEffect: function(effect) {
          if (effect.sparkEntity && effect.sparkEntity.parentNode) {
            effect.sparkEntity.parentNode.removeChild(effect.sparkEntity);
          }
          if (effect.smokeEntity && effect.smokeEntity.parentNode) {
            effect.smokeEntity.parentNode.removeChild(effect.smokeEntity);
          }
        }
      });

      // One-time spark burst for bullet impacts
      AFRAME.registerComponent('impact-spark-burst', {
        init: function() {
          this.sparks = [];
          this.burstDuration = 0.8; // Sparks last 0.8 seconds
          this.startTime = Date.now();
          this.setupSparks();
        },
        
        setupSparks: function() {
          const scene = this.el.sceneEl.object3D;
          const worldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(worldPos);
          
          // Create 8-12 sparks for impact
          const sparkCount = 8 + Math.floor(Math.random() * 5);
          
          for (let i = 0; i < sparkCount; i++) {
            // Random directions in hemisphere above impact point
            const theta = Math.random() * Math.PI * 2; // 0 to 2π
            const phi = Math.random() * Math.PI * 0.5; // 0 to π/2 (hemisphere)
            const speed = 1.5 + Math.random() * 2; // 1.5-3.5 speed
            
            const velocity = new THREE.Vector3(
              Math.sin(phi) * Math.cos(theta) * speed,
              Math.cos(phi) * speed * 0.5, // Bias upward
              Math.sin(phi) * Math.sin(theta) * speed
            );
            
            const colors = [0xFFFF00, 0xFF8800, 0xFF4400, 0xFF6600];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const size = 0.006 + Math.random() * 0.004; // 0.006-0.010
            
            const geometry = new THREE.SphereGeometry(size, 6, 4);
            const material = new THREE.MeshBasicMaterial({
              color: new THREE.Color(color),
              transparent: true,
              opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(worldPos);
            
            const spark = {
              mesh: mesh,
              velocity: velocity,
              startPosition: worldPos.clone(),
              age: 0,
              maxAge: this.burstDuration,
              startColor: new THREE.Color(color),
              endColor: new THREE.Color(0x220000),
              originalOpacity: 0.9
            };
            
            this.sparks.push(spark);
            scene.add(mesh);
          }
        },
        
        tick: function(time, timeDelta) {
          const deltaSeconds = timeDelta / 1000;
          const elapsed = (Date.now() - this.startTime) / 1000;
          
          if (elapsed > this.burstDuration) {
            // Effect finished, mark for cleanup
            this.sparks.forEach(spark => spark.mesh.visible = false);
            return;
          }
          
          this.sparks.forEach(spark => {
            spark.age += deltaSeconds;
            
            if (spark.age > spark.maxAge) {
              spark.mesh.visible = false;
              return;
            }
            
            // Move spark
            spark.mesh.position.x += spark.velocity.x * deltaSeconds;
            spark.mesh.position.y += spark.velocity.y * deltaSeconds;
            spark.mesh.position.z += spark.velocity.z * deltaSeconds;
            
            // Apply gravity
            spark.velocity.y -= 2.0 * deltaSeconds;
            
            // Color and opacity fade
            const progress = spark.age / spark.maxAge;
            const currentColor = spark.startColor.clone().lerp(spark.endColor, progress);
            spark.mesh.material.color.copy(currentColor);
            spark.mesh.material.opacity = spark.originalOpacity * (1 - progress);
          });
        },
        
        remove: function() {
          const scene = this.el.sceneEl.object3D;
          this.sparks.forEach(spark => {
            scene.remove(spark.mesh);
            spark.mesh.geometry.dispose();
            spark.mesh.material.dispose();
          });
          this.sparks = [];
        }
      });

      // Specialized smoke controller for bullet impacts - creates immediate burst, no continuous emission
      AFRAME.registerComponent('impact-smoke-controller', {
        init: function() {
          this.smokeComponent = null;
          this.activePuffs = [];
          this.initialized = false;
          this.impactMeshes = []; // Separate mesh pool for impact effects
          
          // Initialize after a short delay to ensure threejs-smoke-puffs is ready
          setTimeout(() => {
            this.initializeImpactSmoke();
          }, 100);
        },
        
        initializeImpactSmoke: function() {
          // Create our own dedicated mesh pool for impact effects (don't share with static system)
          this.createImpactMeshes();
          
          // Create 2-4 puffs immediately at impact location
          const puffCount = 2 + Math.floor(Math.random() * 3); // 2-4 puffs
          
          for (let i = 0; i < puffCount; i++) {
            // Small delay between puffs for natural look
            setTimeout(() => {
              this.createImpactPuff();
            }, i * 50); // 50ms between each puff
          }
          
          this.initialized = true;
        },
        
        createImpactMeshes: function() {
          // Create 20 dedicated meshes for impact effects (separate from static system)
          this.impactMeshes = [];
          
          for (let i = 0; i < 20; i++) {
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                puffOpacity: { value: 0.0 },
                puffScale: { value: 0.001 },
                smokeTexture: { value: new THREE.TextureLoader().load('assets/particles/smoke1.png') },
                lightPosition: { value: new THREE.Vector3(0, 5.3, 12) },
                lightColor: { value: new THREE.Color(1, 0, 0) }
              },
              vertexShader: `
                uniform float time;
                uniform float puffScale;
                
                varying vec2 vUv;
                varying vec3 vWorldPosition;
                
                void main() {
                  vUv = uv;
                  vec3 pos = position;
                  
                  // Apply scaling directly to the geometry
                  pos *= puffScale;
                  
                  // Gentle movement
                  pos.x += sin(time * 0.3) * 0.01;
                  pos.y += cos(time * 0.2) * 0.01;
                  
                  vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  
                  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                  gl_Position = projectionMatrix * mvPosition;
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float puffOpacity;
                uniform sampler2D smokeTexture;
                uniform vec3 lightPosition;
                uniform vec3 lightColor;
                
                varying vec2 vUv;
                varying vec3 vWorldPosition;
                
                void main() {
                  // Use the realistic smoke texture (same as static system)
                  vec4 smokeColor = texture2D(smokeTexture, vUv);
                  
                  // Simple neutral coloring (no red lighting influence)
                  vec3 baseColor = vec3(0.5, 0.5, 0.5); // Neutral gray like static system
                  smokeColor.rgb *= baseColor;
                  
                  // Apply dynamic opacity
                  smokeColor.a *= puffOpacity;
                  
                  gl_FragColor = smokeColor;
                }
              `,
              transparent: true,
              blending: THREE.NormalBlending,
              depthWrite: false,
              side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Set up for camera billboarding like the static system
            mesh.userData.isBillboard = true;
            
            // Start invisible
            mesh.visible = false;
            
            // Add to scene
            this.el.sceneEl.object3D.add(mesh);
            
            this.impactMeshes.push(mesh);
          }
        },
        
        createImpactPuff: function() {
          if (!this.impactMeshes || this.impactMeshes.length === 0) {
            console.warn('💨 Impact smoke: No impact meshes available');
            return;
          }
          
          // Find an available mesh from our dedicated pool
          const totalMeshes = this.impactMeshes.length;
          const availableMeshes = this.impactMeshes.filter(mesh => !mesh.visible);
          
          const availableMesh = availableMeshes[0];
          
          if (!availableMesh) {
            return;
          }
          
          // Position at impact point with small random offset
          const worldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(worldPos);
          
          const puff = {
            age: 0,
            maxAge: 1.5 + Math.random() * 0.5, // 1.5-2.0 second lifetime (faster fade)
            startSize: 0.0125, // 4x smaller: was 0.05, now 0.0125
            endSize: 0.1 + Math.random() * 0.075, // 4x smaller: was 0.4-0.7, now 0.1-0.175
            opacity: 0.05625, // 4x more transparent: was 0.225, now 0.05625
            mesh: availableMesh,
            startTime: performance.now(),
            // Small random offset from impact point
            position: {
              x: (Math.random() - 0.5) * 0.05, // 5cm spawn area
              y: (Math.random() - 0.5) * 0.05,
              z: (Math.random() - 0.5) * 0.05
            }
          };
          
          // Position the mesh at world position + offset
          availableMesh.position.set(
            worldPos.x + puff.position.x,
            worldPos.y + puff.position.y,
            worldPos.z + puff.position.z
          );
          
          // No random rotation - billboarding will handle orientation
          availableMesh.visible = true;
          
          // Initialize with visible size and opacity
          if (availableMesh.material && availableMesh.material.uniforms) {
            availableMesh.material.uniforms.puffOpacity.value = 0.05625; // 4x more transparent
            availableMesh.material.uniforms.puffScale.value = puff.startSize;
          }
          
          this.activePuffs.push(puff);
        },
        
        tick: function(time, timeDelta) {
          if (!this.initialized || this.impactMeshes.length === 0) return;
          
          const deltaSeconds = timeDelta / 1000;
          const elapsedTime = time / 1000; // Convert to seconds for shader
          
          // Update time uniform and handle billboarding for all impact meshes
          this.impactMeshes.forEach(mesh => {
            mesh.material.uniforms.time.value = elapsedTime;
            
            // Billboard behavior - make mesh face the camera (same as static system)
            if (mesh.userData.isBillboard && mesh.visible) {
              const camera = document.querySelector('a-scene').camera;
              if (camera) {
                mesh.lookAt(camera.getWorldPosition(new THREE.Vector3()));
              }
            }
          });
          
          // Update and clean up puffs using our dedicated meshes
          this.activePuffs = this.activePuffs.filter(puff => {
            puff.age += deltaSeconds;
            
            if (puff.age >= puff.maxAge) {
              // Hide the mesh when puff expires
              puff.mesh.visible = false;
              return false; // Remove from active puffs
            }
            
            // Update puff appearance
            const progress = puff.age / puff.maxAge;
            
            // Scale grows throughout lifetime
            const currentScale = puff.startSize + (puff.endSize - puff.startSize) * progress;
            
            // Opacity: quick fade in, hold, then fade out
            let currentOpacity;
            if (progress < 0.2) {
              // Quick fade in (20% of lifetime)
              currentOpacity = puff.opacity * (progress / 0.2);
            } else if (progress > 0.6) {
              // Gradual fade out (40% of lifetime)
              currentOpacity = puff.opacity * (1 - (progress - 0.6) / 0.4);
            } else {
              // Hold at full opacity (40% of lifetime)
              currentOpacity = puff.opacity;
            }
            
            // Update mesh
            if (puff.mesh.material && puff.mesh.material.uniforms) {
              puff.mesh.material.uniforms.puffOpacity.value = currentOpacity;
              puff.mesh.material.uniforms.puffScale.value = currentScale;
            }
            
            return true; // Keep active
          });
        },
        
        remove: function() {
          // Clean up any remaining puffs and remove meshes from scene
          this.activePuffs.forEach(puff => {
            if (puff.mesh) {
              puff.mesh.visible = false;
            }
          });
          this.activePuffs = [];
          
          // Remove all dedicated meshes from scene
          this.impactMeshes.forEach(mesh => {
            this.el.sceneEl.object3D.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
          });
          this.impactMeshes = [];
        }
      });

      // Small smoke puffs for spark emitter - uses same logic as main smoke
      AFRAME.registerComponent('threejs-smoke-puffs', {
      init: function() {
        this.setupSmokePuffs();
      },
        
        setupSmokePuffs: function() {
          // Create up to 100 smoke puff planes with random orientations
          this.puffMeshes = [];
          
          for (let i = 0; i < 100; i++) {
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                puffOpacity: { value: 0.0 },
                puffScale: { value: 0.001 }, // Start at 1mm
                smokeTexture: { value: new THREE.TextureLoader().load('assets/particles/smoke1.png') },
                lightPosition: { value: new THREE.Vector3(0, 5.3, 12) }, // Player position for lighting
                lightColor: { value: new THREE.Color(1, 0, 0) } // Default red light
              },
              vertexShader: `
                uniform float time;
                uniform float puffScale;
                
                varying vec2 vUv;
                varying vec3 vWorldPosition;
                
                void main() {
                  vUv = uv;
                  vec3 pos = position;
                  
                  // Apply scaling directly to the geometry
                  pos *= puffScale;
                  
                  // Gentle movement
                  pos.x += sin(time * 0.3) * 0.01;
                  pos.y += cos(time * 0.2) * 0.01;
                  
                  vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  
                  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                  gl_Position = projectionMatrix * mvPosition;
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float puffOpacity;
                uniform sampler2D smokeTexture;
                uniform vec3 lightPosition;
                uniform vec3 lightColor;
                
                varying vec2 vUv;
                varying vec3 vWorldPosition;
                
                void main() {
                  // Use the realistic smoke texture
                  vec4 smokeColor = texture2D(smokeTexture, vUv);
                  
                  // Calculate lighting from player
                  vec3 lightDir = normalize(lightPosition - vWorldPosition);
                  float lightDistance = length(lightPosition - vWorldPosition);
                  float attenuation = 1.0 / (1.0 + 0.1 * lightDistance + 0.01 * lightDistance * lightDistance);
                  
                  // Base dark smoke color
                  vec3 baseColor = vec3(0.3, 0.3, 0.3);
                  
                  // Add colored lighting influence
                  vec3 lightInfluence = lightColor * attenuation * 0.8;
                  vec3 finalColor = baseColor + lightInfluence;
                  
                  // Apply to smoke texture
                  smokeColor.rgb *= finalColor;
                  
                  // Apply dynamic opacity
                  smokeColor.a *= puffOpacity;
                  
                  gl_FragColor = smokeColor;
                }
              `,
              transparent: true,
              blending: THREE.NormalBlending,
              depthWrite: false,
              side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Random orientation for each puff
            mesh.rotation.x = Math.random() * Math.PI * 2;
            mesh.rotation.y = Math.random() * Math.PI * 2;
            mesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Random position offset within small area
            mesh.position.set(
              (Math.random() - 0.5) * 0.02, // Within 2cm
              (Math.random() - 0.5) * 0.01,
              (Math.random() - 0.5) * 0.02
            );
            
            mesh.visible = false; // Start invisible
            this.puffMeshes.push(mesh);
            this.el.object3D.add(mesh);
          }
          
          this.clock = new THREE.Clock();
        },
        
        tick: function() {
          if (!this.puffMeshes || !this.el.getAttribute('visible')) return;
          const time = this.clock.getElapsedTime();
          
          // Get player position and light color for dynamic lighting
          const player = document.querySelector('#player');
          const playerLight = player ? player.querySelector('[light]') : null;
          
          // Update time uniform for all puff meshes and handle billboarding + lighting
          this.puffMeshes.forEach(mesh => {
            mesh.material.uniforms.time.value = time;
            
            // Update lighting from player
            if (player && playerLight) {
              const playerPos = player.object3D.position;
              mesh.material.uniforms.lightPosition.value.copy(playerPos);
              
              // Get light color from player's light component
              const lightComponent = playerLight.components.light;
              if (lightComponent && lightComponent.data.color) {
                const color = new THREE.Color(lightComponent.data.color);
                mesh.material.uniforms.lightColor.value.copy(color);
              }
            }
            
            // Billboard behavior - make mesh face the camera
            if (mesh.userData.isBillboard && mesh.visible) {
              const camera = document.querySelector('a-scene').camera;
              if (camera) {
                mesh.lookAt(camera.getWorldPosition(new THREE.Vector3()));
              }
            }
          });
        },
        
        remove: function() {
          if (this.puffMeshes) {
            this.puffMeshes.forEach(mesh => {
              this.el.object3D.remove(mesh);
              if (mesh.geometry) mesh.geometry.dispose();
              if (mesh.material) mesh.material.dispose();
            });
            this.puffMeshes = null;
          }
        }
      });

      // Smoke puff controller - creates growing, fading puffs with randomness
      AFRAME.registerComponent('spark-smoke-controller', {
        init: function() {
          this.timer = 0;
          this.nextPuffTime = 0.5 + Math.random() * 1; // Start creating puffs quickly
          this.smokeComponent = null;
          this.activePuffs = []; // Track individual puffs
          this.maxConcurrentPuffs = 80; // Allow 80 puffs at once for very dense smoke with 100 available meshes
        },
        
        tick: function(time, timeDelta) {
          if (!this.el.getAttribute('visible')) return;
          
        if (!this.smokeComponent) {
          this.smokeComponent = this.el.components['threejs-smoke-puffs'];
          if (!this.smokeComponent) {
            return;
          }
        }
          
          const deltaSeconds = timeDelta / 1000;
          this.timer += deltaSeconds;
          
          // Create new puffs more frequently and allow multiple concurrent ones
          if (this.timer >= this.nextPuffTime && this.activePuffs.length < this.maxConcurrentPuffs) {
            this.timer = 0;
            this.nextPuffTime = 0.1 + Math.random() * 0.2; // 0.1-0.3 second intervals for very rapid smoke creation
            
            // Create new smoke puff
            this.createPuff();
          }
          
          // Update existing puffs
          this.updatePuffs(deltaSeconds);
        },
        
        createPuff: function() {
          // Find an available mesh (not currently visible)
          const availableMesh = this.smokeComponent.puffMeshes.find(mesh => !mesh.visible);
          
          if (!availableMesh) {
            console.log('No available puff meshes - all 100 are in use');
            return;
          }
          
          const puff = {
            age: 0,
            maxAge: 1.5 + Math.random() * 1, // 1.5-2.5 second lifetime - 4x faster growth (was 6-10 seconds)
            startSize: 0.001, // Start at 1mm (0.001m)
            endSize: 0.15 + Math.random() * 0.15, // End at 15-30cm - much larger puffs for bigger smoke ball
            opacity: 0.2 + Math.random() * 0.2, // Peak at 0.2-0.4 opacity - more subtle for layering
            mesh: availableMesh, // Assign this specific mesh to this puff
            startTime: performance.now(), // Track when this puff started
            // Start from center of emitter with very small random offset
            position: {
              x: (Math.random() - 0.5) * 0.2, // 4x larger spawn area (20cm) for bigger smoke ball
              y: (Math.random() - 0.5) * 0.2, // 4x larger spawn area
              z: (Math.random() - 0.5) * 0.2  // 4x larger spawn area
            },
            velocity: {
              // More movement for larger smoke ball spread
              x: (Math.random() - 0.5) * 0.24, // 4x more spread (-0.12 to +0.12 m/s)
              y: 0.08 + Math.random() * 0.16,  // 4x more upward (0.08 to 0.24 m/s)
              z: (Math.random() - 0.5) * 0.24  // 4x more spread (-0.12 to +0.12 m/s)
            },
            // Very gentle rotation - barely noticeable (but billboard will override this)
            rotationVelocity: {
              x: (Math.random() - 0.5) * 0.1, // Reduced since billboard handles main rotation
              y: (Math.random() - 0.5) * 0.1,
              z: (Math.random() - 0.5) * 0.1
            }
          };
          
            // Give this mesh a random initial orientation but keep it subtle
            puff.mesh.rotation.x = Math.random() * Math.PI * 2;
            puff.mesh.rotation.y = Math.random() * Math.PI * 2;
            puff.mesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Add billboard component to make it face the camera
            puff.mesh.userData.isBillboard = true;
          
          // Start very close to center - smoke accumulates here
          puff.mesh.position.set(
            puff.position.x,
            puff.position.y,
            puff.position.z
          );
          
          this.activePuffs.push(puff);
          // console.log('Smoke puff created: size', (puff.endSize * 100).toFixed(1), 'cm, lifetime', puff.maxAge.toFixed(1), 's'); // Disabled for production
        },
        
        updatePuffs: function(deltaSeconds) {
          if (!this.smokeComponent || !this.smokeComponent.puffMeshes) return;
          
          // Remove expired puffs and hide their meshes
          this.activePuffs = this.activePuffs.filter(puff => {
            puff.age += deltaSeconds;
            
            if (puff.age >= puff.maxAge) {
              // Hide the mesh when puff expires
              puff.mesh.visible = false;
              return false; // Remove from active puffs
            }
            return true; // Keep active
          });
          
          // Update each active puff - they stay close together and overlap
          this.activePuffs.forEach(puff => {
            const progress = puff.age / puff.maxAge;
            
            // Scale grows continuously throughout the entire lifetime
            const currentScale = puff.startSize + (puff.endSize - puff.startSize) * progress;
            
            // Opacity has 3 phases for realistic fade
            let currentOpacity;
            if (progress < 0.3) {
              // Fade in phase - opacity grows
              currentOpacity = puff.opacity * (progress / 0.3);
            } else if (progress > 0.7) {
              // Fade out phase - opacity decreases
              currentOpacity = puff.opacity * (1 - (progress - 0.7) / 0.3);
            } else {
              // Stable phase - full opacity
              currentOpacity = puff.opacity;
            }
            
            // Apply scale and opacity to this puff's mesh
            puff.mesh.material.uniforms.puffScale.value = currentScale;
            puff.mesh.material.uniforms.puffOpacity.value = currentOpacity;
            puff.mesh.visible = currentOpacity > 0.01; // Only show if reasonably visible
            
            // Very gentle movement - smoke barely drifts, stays clustered
            puff.position.x += puff.velocity.x * deltaSeconds;
            puff.position.y += puff.velocity.y * deltaSeconds;
            puff.position.z += puff.velocity.z * deltaSeconds;
            
            // Strong air resistance - smoke slows down quickly and settles
            const damping = 0.85; // Stronger damping than before
            puff.velocity.x *= Math.pow(damping, deltaSeconds);
            puff.velocity.y *= Math.pow(damping, deltaSeconds);
            puff.velocity.z *= Math.pow(damping, deltaSeconds);
            
            // Very gentle rotation - barely noticeable since billboard overrides main rotation
            puff.mesh.rotation.x += puff.rotationVelocity.x * deltaSeconds;
            puff.mesh.rotation.y += puff.rotationVelocity.y * deltaSeconds;
            puff.mesh.rotation.z += puff.rotationVelocity.z * deltaSeconds;
            
            // Apply position - puffs stay close to origin
            puff.mesh.position.set(
              puff.position.x,
              puff.position.y,
              puff.position.z
            );
          });
          
          // Only log occasionally to avoid spam
          // if (Math.random() < 0.01) { // Disabled for production
          //   console.log('Smoke accumulation:', this.activePuffs.length, 'overlapping puffs');
          // }
        },
        
        remove: function() {
          this.activePuffs = [];
          if (this.smokeComponent && this.smokeComponent.puffMeshes) {
            this.smokeComponent.puffMeshes.forEach(mesh => {
              mesh.visible = false;
            });
          }
        }
      });
      AFRAME.registerComponent('webgpu-style-sparks', {
        init: function() {
          this.setupWebGPUStyleSparks();
        },
        
        setupWebGPUStyleSparks: function() {
          const scene = this.el.sceneEl.object3D;
          const particleCount = 5;
          
          // Get world position
          const worldPos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(worldPos);
          
          // Create positions and velocities exactly like WebGPU example
          const positions = new Float32Array(particleCount * 3);
          const velocities = new Float32Array(particleCount * 3);
          
          // Spark data - exactly like WebGPU particles
          const sparkVelocities = [
            [0.8, 0.3, 0.6],
            [-0.7, 0.9, -0.4], 
            [0.4, -0.6, 0.8],
            [-0.5, -0.3, -0.7],
            [0.2, 0.8, -0.9]
          ];
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Initial positions
            positions[i3] = worldPos.x;
            positions[i3 + 1] = worldPos.y;
            positions[i3 + 2] = worldPos.z;
            
            // Velocities
            velocities[i3] = sparkVelocities[i][0];
            velocities[i3 + 1] = sparkVelocities[i][1];
            velocities[i3 + 2] = sparkVelocities[i][2];
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
          
          const material = new THREE.PointsMaterial({
            color: 0xFFFF00,
            size: 0.02,
            transparent: true
          });
          
          this.points = new THREE.Points(geometry, material);
          this.startTime = Date.now();
          this.initialPositions = new Float32Array(positions);
          
          scene.add(this.points);
        },
        
        tick: function(time, timeDelta) {
          if (!this.points || !this.el.getAttribute('visible')) {
            if (this.points) this.points.visible = false;
            return;
          }
          
          this.points.visible = true;
          
          // Exact WebGPU approach - calculate position from initial + velocity * time
          const elapsedTime = (Date.now() - this.startTime) / 1000;
          const positions = this.points.geometry.attributes.position.array;
          const velocities = this.points.geometry.attributes.velocity.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            const cycleTime = elapsedTime % 2.0; // 2 second cycle
            
            // position = initial + velocity * time (EXACTLY like WebGPU)
            positions[i] = this.initialPositions[i] + velocities[i] * cycleTime;
            positions[i + 1] = this.initialPositions[i + 1] + velocities[i + 1] * cycleTime;
            positions[i + 2] = this.initialPositions[i + 2] + velocities[i + 2] * cycleTime;
          }
          
          this.points.geometry.attributes.position.needsUpdate = true;
        },
        
        remove: function() {
          if (this.points) {
            const scene = this.el.sceneEl.object3D;
            scene.remove(this.points);
            this.points.geometry.dispose();
            this.points.material.dispose();
            this.points = null;
          }
        }
      });

      // ACTUAL Three.js WebGPU Particles Implementation - STABLE FLUFFY BLACK SMOKE
      AFRAME.registerComponent('threejs-webgpu-particles', {
        init: function() {
          this.setupWebGPUParticles();
        },
        
        setupWebGPUParticles: function() {
          // Create the exact particle system from the WebGPU example - ULTRA OPTIMIZED FOR PERFORMANCE
          const particleCount = 2000; // Reduced from 5,000 to 2,000 for maximum performance
          
          // Create geometry
          const geometry = new THREE.BufferGeometry();
          
          // Position buffer
          const positions = new Float32Array(particleCount * 3);
          const randoms = new Float32Array(particleCount);
          const sizes = new Float32Array(particleCount);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Spherical distribution that stays in place - 4x SMALLER AREA
            const radius = Math.random() * 1.5; // Reduced from 6 to 1.5 (4x smaller)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = radius * Math.cos(phi);
            
            randoms[i] = Math.random();
            sizes[i] = Math.random() * 8 + 6; // Even larger sizes to compensate for fewer particles
          }
          
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));
          geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
          
          // Create shader material for STABLE FLUFFY BLACK SMOKE - PERFORMANCE OPTIMIZED
          const material = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0 }
            },
            vertexShader: `
              attribute float random;
              attribute float size;
              uniform float time;
              
              varying float vRandom;
              
              void main() {
                vRandom = random;
                
                // Use original position as base, add contained turbulence
                vec3 pos = position;
                
                // Gentle, contained turbulence that doesn't drift the cloud - SMALLER MOVEMENT
                pos.x += sin(time * 0.3 + random * 6.0) * 0.25; // Reduced from 1.0 to 0.25
                pos.y += cos(time * 0.2 + random * 4.0) * 0.2;  // Reduced from 0.8 to 0.2
                pos.z += sin(time * 0.25 + random * 5.0) * 0.25; // Reduced from 1.0 to 0.25
                
                // Additional small-scale turbulence for realism - SMALLER
                pos += sin(pos * 2.0 + time * 0.5) * 0.075; // Reduced from 0.3 to 0.075
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // Larger particle sizes for fluffy smoke appearance with fewer particles
                gl_PointSize = size * (500.0 / -mvPosition.z); // Increased size multiplier
              }
            `,
            fragmentShader: `
              varying float vRandom;
              uniform float time;
              
              void main() {
                // Soft circular particle shape
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;
                
                // BLACK/DARK GRAY smoke colors with variation
                float density = vRandom * 0.4 + 0.3;
                vec3 smokeColor = vec3(0.12, 0.12, 0.12) * density;
                
                // Add subtle variation for gritty smoke look (simplified for performance)
                smokeColor += vec3(0.03) * sin(time * 1.0 + vRandom * 10.0);
                
                // Very soft, fluffy edges
                float alpha = pow(1.0 - dist * 2.0, 2.0);
                alpha *= 0.6; // Slightly more opaque to compensate for fewer particles
                
                gl_FragColor = vec4(smokeColor, alpha);
              }
            `,
            transparent: true,
            blending: THREE.NormalBlending,
            depthWrite: false
          });
          
          // Create particle system
          this.particles = new THREE.Points(geometry, material);
          this.el.object3D.add(this.particles);
          
          this.clock = new THREE.Clock();
        },
        
        tick: function() {
          // Skip all processing if not visible or disabled
          if (!this.particles || !this.el.getAttribute('visible')) return;
          
          const time = this.clock.getElapsedTime();
          this.particles.material.uniforms.time.value = time;
          
          // Very slow rotation to keep the cloud stable
          this.particles.rotation.y = time * 0.008;
        },
        
        remove: function() {
          // Clean up resources when component is removed
          if (this.particles) {
            this.el.object3D.remove(this.particles);
            if (this.particles.geometry) this.particles.geometry.dispose();
            if (this.particles.material) this.particles.material.dispose();
            this.particles = null;
          }
        }
      });

      // Three.js WebGPU Parallax UV Component (exact from reference)
      AFRAME.registerComponent('webgpu-parallax-uv', {
        schema: {
          colorMap: { type: 'string' },
          normalMap: { type: 'string' },
          roughnessMap: { type: 'string' },
          displacementMap: { type: 'string' }
        },
        
        init: function() {
          this.setupParallaxUV();
        },
        
        setupParallaxUV: function() {
          const data = this.data;
          const textureLoader = new THREE.TextureLoader();
          
          // Load textures
          const colorMap = textureLoader.load(data.colorMap);
          const normalMap = textureLoader.load(data.normalMap);
          const roughnessMap = textureLoader.load(data.roughnessMap);
          const displacementMap = textureLoader.load(data.displacementMap);
          
          // Exact shader from Three.js WebGPU parallax UV example
          const material = new THREE.ShaderMaterial({
            uniforms: {
              map: { value: colorMap },
              normalMap: { value: normalMap },
              roughnessMap: { value: roughnessMap },
              displacementMap: { value: displacementMap },
              displacementScale: { value: 0.1 },
              time: { value: 0 }
            },
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vViewPosition;
              varying vec3 vNormal;
              varying vec3 vTangent;
              varying vec3 vBitangent;
              
              attribute vec4 tangent;
              
              void main() {
                vUv = uv;
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                
                vNormal = normalize(normalMatrix * normal);
                vTangent = normalize(normalMatrix * tangent.xyz);
                vBitangent = normalize(cross(vNormal, vTangent) * tangent.w);
                
                gl_Position = projectionMatrix * mvPosition;
              }
            `,
            fragmentShader: `
              uniform sampler2D map;
              uniform sampler2D normalMap;
              uniform sampler2D roughnessMap;
              uniform sampler2D displacementMap;
              uniform float displacementScale;
              
              varying vec2 vUv;
              varying vec3 vViewPosition;
              varying vec3 vNormal;
              varying vec3 vTangent;
              varying vec3 vBitangent;
              
              vec2 parallaxUv(vec2 uv, vec3 viewDir) {
                float height = texture2D(displacementMap, uv).r;
                vec2 p = viewDir.xy / viewDir.z * (height * displacementScale);
                return uv - p;
              }
              
              void main() {
                mat3 tbn = mat3(vTangent, vBitangent, vNormal);
                vec3 viewDir = normalize(tbn * vViewPosition);
                
                vec2 uv = parallaxUv(vUv, viewDir);
                
                vec4 diffuseColor = texture2D(map, uv);
                vec3 normal = normalize(texture2D(normalMap, uv).rgb * 2.0 - 1.0);
                float roughness = texture2D(roughnessMap, uv).r;
                
                // Simple lighting
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                normal = normalize(tbn * normal);
                float NdotL = max(dot(normal, lightDir), 0.0);
                
                vec3 color = diffuseColor.rgb * (0.1 + 0.9 * NdotL);
                
                gl_FragColor = vec4(color, diffuseColor.a);
              }
            `,
            transparent: true
          });
          
          // Apply to mesh
          const mesh = this.el.getObject3D('mesh');
          if (mesh) {
            mesh.material = material;
            
            // Ensure geometry has tangents for parallax mapping
            if (!mesh.geometry.attributes.tangent) {
              mesh.geometry.computeTangents();
            }
          }
        },
        
        tick: function() {
          // Skip processing if not visible or disabled
          if (!this.el.getAttribute('visible')) return;
          
          // No animation needed for ice cube - it's static
        },
        
        remove: function() {
          // Clean up resources when component is removed
          const mesh = this.el.getObject3D('mesh');
          if (mesh && mesh.material) {
            if (mesh.material.uniforms) {
              // Dispose textures
              Object.values(mesh.material.uniforms).forEach(uniform => {
                if (uniform.value && uniform.value.dispose) {
                  uniform.value.dispose();
                }
              });
            }
            mesh.material.dispose();
          }
        }
      });

      // Zero-G Player Controller - Physics-based movement
      AFRAME.registerComponent('zerog-player', {
        schema: {
          mass: { type: 'number', default: 70 }, // kg
          linearDamping: { type: 'number', default: 0.05 },
          angularDamping: { type: 'number', default: 0.1 },
          thrusterForce: { type: 'number', default: 0.8 },
          maxSpeed: { type: 'number', default: 8 },
          rotationSpeed: { type: 'number', default: 2 }
        },
        
        init: function() {
          
          // Create collision visualization (this IS our collision system now)
          this.createCollisionVisualization();
          
          // Custom physics simulation state
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.angularVelocity = new THREE.Vector3(0, 0, 0);
          this.lastPosition = new THREE.Vector3(0, 0, 0);
          this.collisionMargin = 0.02; // 2cm safety margin
          this.damping = 0.996; // 0.4% velocity loss per frame (much gentler)
          this.minVelocity = 0.01; // Stop very slow movement
          
          // Movement state
          this.isGrabbing = { left: false, right: false };
          this.grabbedSurface = { left: null, right: null };
          this.grabInfo = { left: null, right: null };
          this.thrusterActive = { left: false, right: false };
          
          // Desktop keyboard controls
          this.keys = {};
          this.keydownListener = (evt) => {
            this.keys[evt.code] = true;
            
            // Toggle collision visualization with 'V' key (moved from C)
            if (evt.key === 'v' || evt.key === 'V') {
              this.toggleCollisionVisualization();
            }
            
            // Toggle mesh distance culling visualization with 'M' key
            if (evt.key === 'm' || evt.key === 'M') {
              this.showMeshDebug = !this.showMeshDebug;
              console.log('🎨 Mesh debug visualization:', this.showMeshDebug ? 'ON (Green=nearby, Red=far)' : 'OFF');
              
              // Reset all mesh colors when turning off - only for visible meshes
              if (!this.showMeshDebug && this.bvhMeshes) {
                const visibleMeshes = this.getVisibleMeshes(this.bvhMeshes);
                visibleMeshes.forEach(mesh => {
                  if (mesh.material && mesh.userData.originalColor !== undefined) {
                    mesh.material.color.setHex(mesh.userData.originalColor);
                  }
                });
              }
            }
            
            // Toggle collision/grab debug logging with 'B' key
            if (evt.key === 'b' || evt.key === 'B') {
              this.debugCollisionGrab = !this.debugCollisionGrab;
              console.log(`🔧 Collision/Grab Debug Logging: ${this.debugCollisionGrab ? 'ON' : 'OFF'}`);
            }
            
            // Model toggles with number keys
            if (evt.key === '1') {
              // Find any element with cursor-listener component and call toggleModel
              const cursorListener = document.querySelector('[cursor-listener]');
              if (cursorListener && cursorListener.components && cursorListener.components['cursor-listener']) {
                console.log('🚀 Keyboard shortcut: Toggling Spaceship (Key 1)');
                if (cursorListener.components['cursor-listener'].toggleModel) {
                cursorListener.components['cursor-listener'].toggleModel('spaceship');
                } else {
                  console.warn('⚠️ toggleModel method not found on cursor-listener');
                }
              } else {
                console.warn('⚠️ Cursor listener component not found for spaceship toggle');
              }
            } else if (evt.key === '2') {
              // Find any element with cursor-listener component and call toggleModel
              const cursorListener = document.querySelector('[cursor-listener]');
              if (cursorListener && cursorListener.components && cursorListener.components['cursor-listener']) {
                console.log('🪨 Keyboard shortcut: Toggling Individual Asteroid (Key 2)');
                if (cursorListener.components['cursor-listener'].toggleModel) {
                cursorListener.components['cursor-listener'].toggleModel('asteroid-42');
                } else {
                  console.warn('⚠️ toggleModel method not found on cursor-listener');
                }
              } else {
                console.warn('⚠️ Cursor listener component not found for individual asteroid toggle');
              }
            } else if (evt.key === '3') {
              // Find any element with cursor-listener component and call toggleMeshDebug
              const cursorListener = document.querySelector('[cursor-listener]');
              if (cursorListener && cursorListener.components && cursorListener.components['cursor-listener']) {
                console.log('🎨 Keyboard shortcut: Toggling Mesh Debug (Key 3)');
                if (cursorListener.components['cursor-listener'].toggleMeshDebug) {
                cursorListener.components['cursor-listener'].toggleMeshDebug();
                } else {
                  console.warn('⚠️ toggleMeshDebug method not found on cursor-listener');
                }
              } else {
                console.warn('⚠️ Cursor listener component not found for mesh debug toggle');
              }
            }
            
            // Speed boost with Shift key
            if (evt.key === 'Shift') {
              console.log('🚀 Keyboard shortcut: Speed Boost (Shift)');
              this.activateSpeedBoost();
            }
            
            
            // Air brake with 'C' key
            if (evt.key === 'c' || evt.key === 'C') {
              this.startKeyboardBraking();
            }
            
            // Start match with Enter or Space key (desktop testing)
            if (evt.key === 'Enter' || evt.key === ' ') {
              const gameManager = document.querySelector('[game-manager]') || document.querySelector('#game-manager');
              if (gameManager && gameManager.components['game-manager']) {
                const gm = gameManager.components['game-manager'];
                if (gm.matchState === 'WAITING') {
                  console.log('🎮 Starting match via keyboard (Enter/Space)');
                  gm.startMatchWithBots();
                } else if (gm.matchState === 'ENDED') {
                  console.log('🎮 Restarting match via keyboard (Enter/Space)');
                  gm.resetMatch();
                  setTimeout(() => gm.startMatchWithBots(), 100);
                }
              }
            }
          };
          this.keyupListener = (evt) => {
            this.keys[evt.code] = false;
            
            // Stop air brake when 'C' key is released
            if (evt.key === 'c' || evt.key === 'C') {
              this.stopKeyboardBraking();
            }
          };
          
          document.addEventListener('keydown', this.keydownListener);
          document.addEventListener('keyup', this.keyupListener);
          
          // NEW: Anti-stuttering system
          this.velocityHistory = [];
          this.maxVelocityHistorySize = 10; // Track last 10 frames
          this.lastCollisionTime = 0;
          this.lastGrabTime = 0; // Track when grabs happen
          
          // Stunning state
          this.isStunned = false;
          this.stunEndTime = 0;
          this.stunImmunityEndTime = 0; // 10-second immunity after being stunned
          
          // Ball steal timeout (prevents immediate re-grab after ball is stolen)
          this.ballStealTimeout = null;
          
          // Global steal cooldown to prevent rapid back-and-forth stealing
          this.lastStealTime = 0;
          this.stealCooldown = 1000; // 1 second between steal attempts
          
          // NEW: Track grip state for continuous ball grabbing
          this.gripHeld = { left: false, right: false };
          
          // Speed boost system
          this.speedBoostAvailable = true;
          this.speedBoostCooldown = 5000; // 5 seconds
          this.speedBoostForce = 5; // Boost strength
          this.lastSpeedBoostTime = 0;
          this.captureBallReleaseTimeout = 0; // 2 second timeout after releasing capture ball
          
          // Player-to-player grabbing system
          this.playerGrabTimeouts = new Map(); // playerId -> timeout timestamp
          this.grabbedByPlayer = null; // which player is grabbing this player
          this.grabbingPlayer = { left: null, right: null }; // which players this player is grabbing
          this.playerGrabConstraints = { left: null, right: null }; // physics constraints for player grabs
          
          // Rotation state
          this.rotationY = 0;
          this.thumbstickRotation = { left: 0, right: 0 };
          
          // Braking state
          this.isBraking = { left: false, right: false };
          this.brakingForce = 0.9; // Stronger braking for immediate effect
          
          // Get hand references
          this.leftHand = null;
          this.rightHand = null;
          this.rig = null;
          
          // Debug mode (for optional console output)
          this.debugMode = this.data.debug || false;
          
          // Wait for scene to load to get hand references
        if (this.el.sceneEl.hasLoaded) {
          // Scene already loaded, get references immediately
            this.leftHand = document.querySelector('#leftHand');
            this.rightHand = document.querySelector('#rightHand');
          this.rig = this.el.querySelector('#rig'); // Look for rig as child of player entity
          
          console.log('🎮 Player references found immediately:', {
            leftHand: !!this.leftHand,
            rightHand: !!this.rightHand,
            rig: !!this.rig,
            rigId: this.rig ? this.rig.id : 'not found'
          });
            
            this.setupHandEvents();
        } else {
          // Scene not loaded yet, wait for it
          this.el.sceneEl.addEventListener('loaded', () => {
            this.leftHand = document.querySelector('#leftHand');
            this.rightHand = document.querySelector('#rightHand');
            this.rig = this.el.querySelector('#rig'); // Look for rig as child of player entity
            
            console.log('🎮 Player references found after scene load:', {
              leftHand: !!this.leftHand,
              rightHand: !!this.rightHand,
              rig: !!this.rig,
              rigId: this.rig ? this.rig.id : 'not found'
            });
            
            this.setupHandEvents();
          });
        }
        },


        setupHandEvents: function() {
          // Set up trigger detection for menu interactions
          console.log('🔧 Setting up trigger listeners in setupHandEvents');
          console.log('Left hand element:', this.leftHand);
          console.log('Right hand element:', this.rightHand);
          
          if (this.leftHand) {
            // Try multiple event names
            ['triggerdown', 'triggertouchstart', 'selectstart'].forEach(eventName => {
              this.leftHand.addEventListener(eventName, function(evt) {
                console.log('🎮 Left', eventName, 'event fired');
                lastTriggerController = 'leftHand';
                triggerPressTime = Date.now();
              });
            });
            console.log('✅ Left hand trigger listeners attached');
          }
          
          if (this.rightHand) {
            // Try multiple event names
            ['triggerdown', 'triggertouchstart', 'selectstart'].forEach(eventName => {
              this.rightHand.addEventListener(eventName, function(evt) {
                console.log('🎮 Right', eventName, 'event fired');
                lastTriggerController = 'rightHand';
                triggerPressTime = Date.now();
              });
            });
            console.log('✅ Right hand trigger listeners attached');
          }
          
          // Grip controls for grabbing surfaces AND balls (EchoVR style)
          this.el.sceneEl.addEventListener('gripdown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            
            // Track grip state for continuous ball grabbing
            this.gripHeld[handKey] = true;
            
            // Try to grab balls first (priority)
            const ballGrabbed = this.tryGrabBall(hand);
            
            // If no ball was grabbed, try players, then static surfaces
            if (!ballGrabbed) {
              const nearestPlayer = this.findNearestPlayer(hand);
              if (nearestPlayer) {
                const playerId = nearestPlayer.getAttribute('data-player-id');
                this.grabPlayer(hand, nearestPlayer, playerId);
              } else if (!this.isGrabbing[handKey]) {
              this.handleGrab(hand, true);
              }
            }
          });
          
          this.el.sceneEl.addEventListener('gripup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeft = hand.id === 'leftHand';
            const handKey = isLeft ? 'left' : 'right';
            
            
            // Track grip state
            this.gripHeld[handKey] = false;
            
            // Release whatever is being grabbed (ball, player, or surface)
            this.releaseGrabbedBall(hand);
            
            // Release player grab if active
            if (this.grabbingPlayer[handKey]) {
              this.releasePlayerGrab(hand);
            }
            
            this.handleGrab(hand, false);
          });
          
          
          // B button controls for thrusters (same as triggers) ONLY when menu is not visible
          this.el.sceneEl.addEventListener('bbuttondown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't activate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, true);
          });
          
          this.el.sceneEl.addEventListener('bbuttonup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't deactivate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, false);
          });
          
          // Y button controls for thrusters (same as left trigger) ONLY when menu is not visible
          this.el.sceneEl.addEventListener('ybuttondown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't activate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, true);
          });
          
          // X button is for menu toggle - don't use for weapons
          
          this.el.sceneEl.addEventListener('ybuttonup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            if (getMenuVisibility()) {
              return; // Don't deactivate thrusters when menu is visible
            }
            const hand = evt.target;
            this.handleThruster(hand, false);
          });
          
          // Thumbstick controls for rotation
          this.el.sceneEl.addEventListener('thumbstickmoved', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return; // Skip silently for thumbstick to avoid spam
            }
            
            const hand = evt.target;
            this.handleThumbstick(hand, evt.detail);
          });
          
          // B button assigned to menu toggle (see menu-toggle component)
          
          // Thumbstick click controls
          this.el.sceneEl.addEventListener('thumbstickdown', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeftHand = hand.id === 'leftHand';
            
            if (isLeftHand) {
              // Left thumbstick click: Speed boost
              this.activateSpeedBoost();
            } else {
              // Right thumbstick click: Air brake
            this.startBraking(hand);
            }
          });
          
          this.el.sceneEl.addEventListener('thumbstickup', (evt) => {
            // Safety check for controller state
            if (!evt.target || !evt.target.object3D) {
              return;
            }
            
            const hand = evt.target;
            const isLeftHand = hand.id === 'leftHand';
            
            if (!isLeftHand) {
              // Right thumbstick click: Stop air brake
            this.stopBraking(hand);
            }
            // Left thumbstick: Speed boost is instant, no need to handle up event
          });
        },
        
        // Debug arrows removed - not useful for this system
        
        handleThumbstick: function(hand, detail) {
          const isLeft = hand.id === 'leftHand';
          
          // Use right thumbstick for rotation (common VR convention)
          // Flip the direction to match expected behavior
          if (!isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.right = -detail.x;
            if (this.debugMode) {
            }
          } else if (!isLeft) {
            this.thumbstickRotation.right = 0;
          }
          
          // Left thumbstick could be used for other things in the future
          if (isLeft && Math.abs(detail.x) > 0.1) {
            this.thumbstickRotation.left = -detail.x;
            if (this.debugMode) {
            }
          } else if (isLeft) {
            this.thumbstickRotation.left = 0;
          }
        },
        
        handleGrab: function(hand, isDown) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          

          
          if (isDown) {
            // First check for nearby players to grab
            const nearestPlayer = this.findNearestPlayer(hand);

            if (nearestPlayer) {
              const playerId = nearestPlayer.getAttribute('data-player-id');
              this.grabPlayer(hand, nearestPlayer, playerId);
              return;
            }

            // If no player found, check for nearby surfaces to grab
            const surface = this.findNearestGrabbableSurface(hand);
            
            if (surface) {
              this.grabbedSurface[handKey] = surface;
              this.attachToSurface(hand, surface);
              
              // Haptic feedback
              this.playHapticFeedback(hand, 0.5, 100);
            }
          } else {
            // Release player grab if active
            if (this.grabbingPlayer[handKey]) {
              this.releasePlayerGrab(hand);
            }
            
            // Release surface grab if active
            if (this.isGrabbing[handKey]) {
              this.releaseFromSurface(hand);
              this.grabbedSurface[handKey] = null;
            }
          }
        },
        
        handleThruster: function(hand, isActive) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Disable thrusters while grabbing players/bots
          if (this.grabbingPlayer.left || this.grabbingPlayer.right) {
            this.thrusterActive[handKey] = false;
            this.hideThrusterEffect(hand);
            return; // Don't allow thruster use while grabbing players
          }
          
          this.thrusterActive[handKey] = isActive;
          
          if (isActive) {
            // Visual thruster effect
            this.showThrusterEffect(hand);
          } else {
            this.hideThrusterEffect(hand);
          }
        },
        
        findNearestGrabbableSurface: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
                  // Look for elements with grab-surface component OR zerog-ball attribute
        const allElements = document.querySelectorAll('[grab-surface], [zerog-ball]');
          let nearestSurface = null;
          let minDistance = Infinity;
          
          allElements.forEach(element => {
            const distance = this.getDistanceToSurface(handPos, handRadius, element);
            
            // If hand is touching or very close to surface (within 5cm)
            if (distance <= 0.05) {
              if (distance < minDistance) {
                minDistance = distance;
                nearestSurface = element;
              }
            }
          });
          
          // Also check level.glb model for grabbing
          const levelGrabResult = this.checkLevelModelGrab(handPos, handRadius);
          if (levelGrabResult && levelGrabResult.distance < minDistance) {
            nearestSurface = levelGrabResult.surface;
            minDistance = levelGrabResult.distance;
          }
          
          // Only log when something is found
          if (nearestSurface) {
            const distanceCm = minDistance > 0 ? (minDistance * 100).toFixed(1) : "touching";

          }
          
          return nearestSurface;
        },
        
        // Helper function to filter meshes from visible models only
        getVisibleMeshes: function(meshes) {
          const visibleMeshes = meshes.filter(mesh => {
            // Check if mesh belongs to a visible model entity
            let isFromVisibleModel = true;
            let currentParent = mesh.parent;
            
            // Traverse up the hierarchy to find the model entity
            while (currentParent) {
              if (currentParent.el && currentParent.el.getAttribute) {
                const visible = currentParent.el.getAttribute('visible');
                if (visible === false || visible === 'false') {
                  isFromVisibleModel = false;
                  break;
                }
              }
              currentParent = currentParent.parent;
            }
            
            return isFromVisibleModel;
          });
          
          // Performance logging with throttling (only log when count changes or every 5 seconds)
          if (meshes.length > 0 && visibleMeshes.length !== meshes.length) {
            const hiddenCount = meshes.length - visibleMeshes.length;
            
            // Initialize throttling if not exists
            if (!this._meshOptimizationLog) {
              this._meshOptimizationLog = {
                lastCount: -1,
                lastLogTime: 0,
                logInterval: 5000 // 5 seconds
              };
            }
            
            const now = Date.now();
            const shouldLog = hiddenCount !== this._meshOptimizationLog.lastCount || 
                            (now - this._meshOptimizationLog.lastLogTime) > this._meshOptimizationLog.logInterval;
            
            if (shouldLog) {
              // Performance optimization logging disabled to reduce console spam
              this._meshOptimizationLog.lastCount = hiddenCount;
              this._meshOptimizationLog.lastLogTime = now;
            }
          }
          
          return visibleMeshes;
        },
        
        // Check if hand can grab onto level.glb model surfaces
        checkLevelModelGrab: function(handPos, handRadius) {
          // Get cached BVH meshes
          if (!this.bvhMeshes || this.bvhMeshes.length === 0) {
            this.initializeBVH();
            if (!this.bvhMeshes || this.bvhMeshes.length === 0) return null;
          }
          
          // Use BVH-accelerated raycasting to find nearby surfaces for grabbing
          const raycaster = new THREE.Raycaster();
          raycaster.firstHitOnly = true; // MAJOR performance boost - stop at first hit!
          const grabDistance = 0.15; // 15cm grab range
          raycaster.far = grabDistance;
          
          const directions = [
            new THREE.Vector3(1, 0, 0),   // Right
            new THREE.Vector3(-1, 0, 0),  // Left
            new THREE.Vector3(0, 1, 0),   // Up
            new THREE.Vector3(0, -1, 0),  // Down
            new THREE.Vector3(0, 0, 1),   // Forward
            new THREE.Vector3(0, 0, -1)   // Backward
          ];
          
          let closestGrab = null;
          let closestDistance = Infinity;
          
          // Performance optimization: Use sphere-based grab detection
          const maxGrabDistance = 5; // 5 meter radius for grab detection
          
          // Create detection sphere at hand position
          const grabSphere = new THREE.Sphere(handPos, maxGrabDistance);
          
          // Filter meshes using sphere intersection for grabbing - only from visible models
          const visibleMeshes = this.getVisibleMeshes(this.bvhMeshes);
          const nearbyMeshes = visibleMeshes.filter(mesh => {
            
            // Update mesh world matrix
            mesh.updateMatrixWorld(true);
            
            // Get mesh bounding sphere in world space
            if (!mesh.geometry.boundingSphere) {
              mesh.geometry.computeBoundingSphere();
            }
            
            const meshSphere = mesh.geometry.boundingSphere.clone();
            meshSphere.applyMatrix4(mesh.matrixWorld);
            
            // Check if grab sphere intersects with mesh sphere
            const isNearby = grabSphere.intersectsSphere(meshSphere);
            
            // Visual debugging for grab detection (blue tint)
            if (isNearby && this.debugMode && mesh.material && !Array.isArray(mesh.material)) {
              if (!mesh.userData.originalColor) {
                mesh.userData.originalColor = mesh.material.color ? mesh.material.color.getHex() : 0x888888;
              }
              mesh.material.color.setHex(0x0088ff);
            }
            
            return isNearby;
          });
          
          // Check each direction for grabbable surfaces using nearby BVH-accelerated meshes
          directions.forEach(direction => {
            raycaster.set(handPos, direction);
            
            // Use THREE.js raycasting with BVH acceleration on nearby meshes only
            const intersects = raycaster.intersectObjects(nearbyMeshes, false);
            
            if (intersects.length > 0) {
              const intersection = intersects[0];
              const distance = intersection.distance;
              
              if (distance < closestDistance) {
                closestDistance = distance;
                closestGrab = {
                  surface: intersection.object, // The mesh itself
                  distance: distance,
                  point: intersection.point,
                  normal: intersection.face.normal,
                  isLevelMesh: true
                };
              }
            }
          });
          
          return closestGrab;
        },
        
        getDistanceToSurface: function(handPos, handRadius, element) {
          const elementPos = new THREE.Vector3();
          element.object3D.getWorldPosition(elementPos);
          const geometry = element.getAttribute('geometry');
          
          if (!geometry) {
            // Fallback to simple distance for elements without geometry
            return handPos.distanceTo(elementPos) - handRadius;
          }
          
          // Check collision based on geometry type
          if (geometry.primitive === 'box') {
            return this.distanceToBox(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'sphere') {
            return this.distanceToSphere(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'cylinder') {
            return this.distanceToCylinder(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'octahedron') {
            return this.distanceToOctahedron(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'dodecahedron') {
            return this.distanceToDodecahedron(handPos, handRadius, elementPos, geometry);
          } else if (geometry.primitive === 'icosahedron') {
            return this.distanceToIcosahedron(handPos, handRadius, elementPos, geometry);
          } else {
            // Check if this is a GLTF model entity
            const gltfModel = element.querySelector('a-gltf-model');
            if (gltfModel) {
              return this.distanceToGltfModel(handPos, handRadius, elementPos, element);
            }
            // Fallback
            return handPos.distanceTo(elementPos) - handRadius;
          }
        },
        
        distanceToBox: function(handPos, handRadius, boxPos, geometry) {
          // Calculate distance from hand sphere to box surface
          const halfWidth = geometry.width / 2;
          const halfHeight = geometry.height / 2;
          const halfDepth = geometry.depth / 2;
          
          // Get relative position of hand to box center
          const relativePos = new THREE.Vector3().subVectors(handPos, boxPos);
          
          // Calculate closest point on box to hand
          const closestPoint = new THREE.Vector3(
            Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
            Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
            Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
          );
          
          // Distance from hand to closest point on box surface
          const distance = relativePos.distanceTo(closestPoint);
          
          // Subtract hand radius to get surface distance
          return Math.max(0, distance - handRadius);
        },
        
        distanceToSphere: function(handPos, handRadius, spherePos, geometry) {
          const sphereRadius = geometry.radius;
          const centerDistance = handPos.distanceTo(spherePos);
          
          // Distance to sphere surface minus hand radius
          return Math.max(0, centerDistance - sphereRadius - handRadius);
        },
        
        distanceToCylinder: function(handPos, handRadius, cylinderPos, geometry) {
          const cylinderRadius = geometry.radius;
          const cylinderHeight = geometry.height;
          
          // Get relative position
          const relativePos = new THREE.Vector3().subVectors(handPos, cylinderPos);
          
          // Distance to cylinder axis (ignoring Y)
          const radialDistance = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
          
          // Clamp Y to cylinder height
          const clampedY = Math.max(-cylinderHeight/2, Math.min(cylinderHeight/2, relativePos.y));
          
          // Calculate distance to cylinder surface
          let distance;
          if (Math.abs(relativePos.y) <= cylinderHeight/2) {
            // Hand is within cylinder height, check radial distance
            distance = Math.max(0, radialDistance - cylinderRadius);
          } else {
            // Hand is above/below cylinder, check distance to circular ends
            const endDistance = Math.abs(relativePos.y) - cylinderHeight/2;
            if (radialDistance <= cylinderRadius) {
              distance = endDistance;
            } else {
              distance = Math.sqrt(endDistance * endDistance + Math.pow(radialDistance - cylinderRadius, 2));
            }
          }
          
          // Subtract hand radius
          return Math.max(0, distance - handRadius);
        },

        distanceToOctahedron: function(handPos, handRadius, octahedronPos, geometry) {
          const octahedronRadius = geometry.radius;
          
          // Get point relative to octahedron center
          const relativePos = handPos.clone().sub(octahedronPos);
          
          // Calculate distance to octahedron surface using Manhattan distance
          // An octahedron surface is defined by |x| + |y| + |z| = radius
          const absX = Math.abs(relativePos.x);
          const absY = Math.abs(relativePos.y);
          const absZ = Math.abs(relativePos.z);
          const manhattanDistance = absX + absY + absZ;
          
          // Distance to octahedron surface
          const distanceToSurface = manhattanDistance - octahedronRadius;
          
          // Return distance to surface minus hand radius (minimum 0)
          return Math.max(0, distanceToSurface - handRadius);
        },
        
        distanceToDodecahedron: function(handPos, handRadius, dodecahedronPos, geometry) {
          const radius = geometry.radius || 1.0;
          
          // Get point relative to dodecahedron center
          const relativePos = handPos.clone().sub(dodecahedronPos);
          
          // For dodecahedron, use the same radius as the physics body
          // The physics body uses full radius for vertices, so collision should match
          const distance = relativePos.length();
          
          // Use full radius to match physics body (not inscribed sphere)
          const distanceToSurface = distance - radius;
          
          // Return distance to surface minus hand radius (minimum 0)
          return Math.max(0, distanceToSurface - handRadius);
        },
        
        distanceToIcosahedron: function(handPos, handRadius, icosahedronPos, geometry) {
          const radius = geometry.radius || 1.0;
          
          // Get point relative to icosahedron center
          const relativePos = handPos.clone().sub(icosahedronPos);
          
          // For icosahedron, use the same radius as the physics body
          // The physics body uses full radius for vertices, so collision should match
          const distance = relativePos.length();
          
          // Use full radius to match physics body (not inscribed sphere)
          const distanceToSurface = distance - radius;
          
          // Return distance to surface minus hand radius (minimum 0)
          return Math.max(0, distanceToSurface - handRadius);
        },
        
        distanceToGltfModel: function(handPos, handRadius, modelPos, element) {
          // For GLTF models, use sphere approximation based on scale
          const scale = element.getAttribute('scale') || {x: 1, y: 1, z: 1};
          const avgScale = (scale.x + scale.y + scale.z) / 3;
          const radius = avgScale * 1.0; // Assume 1 unit radius, scaled
          
          // Get point relative to model center
          const relativePos = handPos.clone().sub(modelPos);
          const distance = relativePos.length();
          
          // Distance to surface
          const distanceToSurface = distance - radius;
          
          // Return distance to surface minus hand radius (minimum 0)
          return Math.max(0, distanceToSurface - handRadius);
        },
        
        
        attachToSurface: function(hand, surface) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Check if this is a level mesh (THREE.Mesh object)
          if (surface.isMesh) {
            // Handle level mesh grabbing - need to get the actual grab point
            const rigPos = new THREE.Vector3();
            this.rig.object3D.getWorldPosition(rigPos);
            
            // Find the actual grab point by re-running the grab detection
            const levelGrabResult = this.checkLevelModelGrab(handPos, 0.08);
            const actualGrabPoint = levelGrabResult && levelGrabResult.point ? 
                                   levelGrabResult.point.clone() : 
                                   handPos.clone(); // Fallback to hand position
            
            this.grabInfo[handKey] = {
              surface: surface,
              isBall: false,
              isLevelMesh: true,
              initialHandPos: handPos.clone(),
              lastHandPos: handPos.clone(),
              initialSurfacePos: actualGrabPoint.clone(), // Use actual intersection point
              initialPlayerPos: rigPos.clone(),
              grabPoint: actualGrabPoint.clone() // Use actual intersection point
            };
            
            
          } else {
            // Handle A-Frame entities (original logic)
            const surfacePos = new THREE.Vector3();
            surface.object3D.getWorldPosition(surfacePos);
            
            // Check if this is a ball and handle differently
            if (surface.hasAttribute && surface.hasAttribute('zerog-ball') && surface.components['zerog-ball']) {
              // For balls, call the ball's onGrab method
              surface.components['zerog-ball'].onGrab(hand);
              
              this.grabInfo[handKey] = {
                surface: surface,
                isBall: true,
                initialHandPos: handPos.clone(),
                lastHandPos: handPos.clone()
              };
              
            } else {
              // For static surfaces, use normal grab behavior
              // Option B: Use VR rig position instead of physics body
              const rigPos = new THREE.Vector3();
              this.rig.object3D.getWorldPosition(rigPos);
              
              this.grabInfo[handKey] = {
                surface: surface,
                isBall: false,
                initialHandPos: handPos.clone(),
                lastHandPos: handPos.clone(),
                initialSurfacePos: surfacePos.clone(),
                initialPlayerPos: rigPos.clone(),
                grabPoint: surfacePos.clone()
              };
            }
          }
          
          // Set grabbing flag
          this.isGrabbing[handKey] = true;
          
          // Record grab time for settling period
          this.lastGrabTime = Date.now();
          

        },
        
        releaseFromSurface: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabInfo = this.grabInfo[handKey];
          if (grabInfo) {
            // Check if releasing the capture ball - set 2 second boost timeout
            if (grabInfo.isBall && grabInfo.surface.id === 'capture-ball') {
              this.captureBallReleaseTimeout = Date.now() + 2000; // 2 second timeout
            }
            
            // If releasing a ball, call the ball's onRelease method
            if (grabInfo.isBall && grabInfo.surface.components['zerog-ball']) {
              grabInfo.surface.components['zerog-ball'].onRelease();
            } else if (!grabInfo.isBall) {
              // For static surfaces, apply velocity clamping to prevent explosive release
              const maxReleaseVelocity = 2.5; // Reduced from 3.0 for safer release
              if (this.velocity.length() > maxReleaseVelocity) {
                // Smooth the velocity reduction instead of hard clamping
                const reductionFactor = maxReleaseVelocity / this.velocity.length();
                this.velocity.multiplyScalar(reductionFactor);
              }
            }
          }
          
          // Clear grab info
          this.grabInfo[handKey] = null;
          this.isGrabbing[handKey] = false;
          

        },
        
        showThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', true);
            thrusterVFX.setAttribute('material', 'opacity', 0.8);
          }
        },
        
        hideThrusterEffect: function(hand) {
          const thrusterVFX = hand.querySelector('.thruster-vfx');
          if (thrusterVFX) {
            thrusterVFX.setAttribute('visible', false);
          }
        },
        
        // Debug arrow functions removed - not useful for this system
        
        playHapticFeedback: function(hand, intensity, duration) {
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(intensity, duration).catch(() => {});
          }
                },

        createCollisionVisualization: function() {
          // Create wireframe visualization of the collision capsule
          const radius = 0.25;
          const height = 1.6;
          
          // Option A: Add wireframes as camera children so they follow VR headset automatically
          const camera = document.querySelector('[camera]');
          if (!camera) {
            console.warn('Camera not found - cannot create collision visualization');
            return;
          }
          
          // Main cylinder (body center) - positioned relative to camera
          const cylinderWireframe = document.createElement('a-cylinder');
          cylinderWireframe.setAttribute('radius', radius);
          cylinderWireframe.setAttribute('height', height);
          cylinderWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          cylinderWireframe.setAttribute('position', '0 -0.4 0'); // 0.4m below camera (body center)
          camera.appendChild(cylinderWireframe);
          
          // Top sphere (head level) - positioned at camera position
          const topSphereWireframe = document.createElement('a-sphere');
          topSphereWireframe.setAttribute('radius', radius);
          topSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          topSphereWireframe.setAttribute('position', '0 0 0'); // At camera position (head level)
          camera.appendChild(topSphereWireframe);
          
          // Bottom sphere (feet level) - positioned 1.6m below camera
          const bottomSphereWireframe = document.createElement('a-sphere');
          bottomSphereWireframe.setAttribute('radius', radius);
          bottomSphereWireframe.setAttribute('material', {
            color: '#00ff00',
            wireframe: true,
            opacity: 0.3,
            transparent: true
          });
          bottomSphereWireframe.setAttribute('position', '0 -0.8 0'); // 0.8m below camera (feet level)
          camera.appendChild(bottomSphereWireframe);
          
          // Store references and hide by default
          this.collisionVisualization = {
            cylinder: cylinderWireframe,
            topSphere: topSphereWireframe,
            bottomSphere: bottomSphereWireframe,
            visible: false
          };
          
          // Hide by default
          this.setCollisionVisualizationVisible(false);
          
        },

        toggleCollisionVisualization: function() {
          if (this.collisionVisualization) {
            this.collisionVisualization.visible = !this.collisionVisualization.visible;
            this.setCollisionVisualizationVisible(this.collisionVisualization.visible);
          }
        },

        setCollisionVisualizationVisible: function(visible) {
          if (this.collisionVisualization) {
            this.collisionVisualization.cylinder.setAttribute('visible', visible);
            this.collisionVisualization.topSphere.setAttribute('visible', visible);
            this.collisionVisualization.bottomSphere.setAttribute('visible', visible);
          }
        },

        tick: function(time, deltaTime) {
          
          // Custom physics simulation with visual collision detection
          if (!this.rig) return;
          
          const dt = Math.min(deltaTime / 1000, 0.033); // Cap at 30fps for stability
          
          // Check if stunned and disable controls
          if (this.isStunned) {
              // While stunned, disable movement but allow rotation
              this.velocity.set(0, 0, 0);
              this.thrusterActive.left = false;
              this.thrusterActive.right = false;
              this.isBraking.left = false;
              this.isBraking.right = false;
              
              // Release any grabbed objects
              ['left', 'right'].forEach(handKey => {
                if (this.isGrabbing[handKey]) {
                  const hand = handKey === 'left' ? this.leftHand : this.rightHand;
                  this.releaseFromSurface(hand);
                }
              });
              
              // Continue processing for rotation (don't return early)
              // Only skip movement-related processing below
          }
          
          // Apply thumbstick rotation (allowed when stunned)
          this.applyRotation(dt);
          
          // Skip movement processing if stunned
          if (!this.isStunned) {
          // Apply thruster forces to velocity
          this.applyThrusterForces(dt);
          
          // Apply keyboard movement forces (desktop controls)
          this.applyKeyboardMovement(dt);
          
          // Apply movement from grabbed surfaces
          this.applyGrabMovement(dt);
          
          // Apply gradual braking if active
          this.applyGradualBraking(dt);
          
          // Apply damping to velocity
          this.applyDamping(dt);
          
            // Check for collisions and apply responses
            this.checkAndResolveCollisions(dt);
            
            // Apply velocity to move VR rig
            this.applyVelocityToRig(dt);
            
            // Update grab visual feedback
            this.updateGrabFeedback();
          
          // NEW: Continuous ball grabbing while grip is held
          this.updateGripBallGrabbing();
          
          // NEW: Update physics constraints for player grabs
          this.updatePlayerGrabConstraints();
          
          // NEW: Validate grab distances to prevent visual disconnection
          this.validateGrabDistances();
          
          // Update speed display in HUD
          this.updateSpeedDisplay();
          
          // Check speed boost cooldown
          if (!this.speedBoostAvailable && Date.now() - this.lastSpeedBoostTime >= this.speedBoostCooldown) {
            this.speedBoostAvailable = true;
          }
          
          }
        },
        
        updateSpeedDisplay: function() {
          // Calculate current speed from velocity vector
          const speed = this.velocity.length();
          
          // Update HUD speed display (limit to 1 decimal place)
          const speedDisplay = document.querySelector('#hud-speed');
          if (speedDisplay) {
            speedDisplay.setAttribute('text', 'value', `${speed.toFixed(1)} m/s`);
          }
        },
        
        isHoldingCaptureBall: function() {
          // Check if either hand is holding the capture ball
          const captureBall = document.querySelector('#capture-ball');
          if (!captureBall) return false;
          
          return (this.grabbedSurface.left === captureBall) || (this.grabbedSurface.right === captureBall);
        },
        
        findNearestPlayer: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
          let nearestPlayer = null;
          let nearestDistance = Infinity;
          
          // Look for grabbable players (remote targets and bots)
          const grabbablePlayers = document.querySelectorAll('.grabbable-player');
          
          for (const playerTarget of grabbablePlayers) {
            const playerId = playerTarget.getAttribute('data-player-id');
            
            // Skip if this is the player's own body (check this first)
            const currentPlayerId = myPlayerId || 'player_0';
            if (playerId === currentPlayerId) {
              continue; // Can't grab yourself
            }
            
            // Skip if player is not visible (not active)
            // For remote players, check parent visibility; for local player target, it's always visible
            if (playerId !== 'player_0') {
              // For remote players, check if their parent entity is visible
              const isVisible = playerTarget.parentElement.getAttribute('visible');
              if (!isVisible || isVisible === 'false') {
                continue;
              }
            }
            // Local player target (player_0) is always considered visible
            
            // Skip if this player is in timeout
            const currentTime = Date.now();
            if (this.playerGrabTimeouts.has(playerId) && currentTime < this.playerGrabTimeouts.get(playerId)) {
              continue;
            }
            
            // Calculate distance to player target
            const targetPos = new THREE.Vector3();
            playerTarget.object3D.getWorldPosition(targetPos);
            const distance = handPos.distanceTo(targetPos);
            const targetRadius = parseFloat(playerTarget.getAttribute('radius')) || 0.2;
            
            // Check if within grab range
            if (distance <= handRadius + targetRadius && distance < nearestDistance) {
              nearestPlayer = playerTarget;
              nearestDistance = distance;
            }
          }
          
          return nearestPlayer;
        },
        
        grabPlayer: function(hand, playerTarget, playerId) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Set up player grab state
          this.grabbingPlayer[handKey] = playerId;
          
          // Get positions for constraint setup
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          
          const targetPos = new THREE.Vector3();
          playerTarget.object3D.getWorldPosition(targetPos);
          
          // Get the physics body of the grabbed entity
          let grabbedBody = null;
          
          if (playerId.startsWith('bot_')) {
            // For bots, get their physics body
            let botId;
            if (playerId === 'bot_red') {
              botId = '#zerog-bot-red';
            } else if (playerId === 'bot_blue') {
              botId = '#zerog-bot-blue';
            } else if (playerId === 'bot_green') {
              botId = '#zerog-bot-green';
            }
            
            if (botId) {
              const botEntity = document.querySelector(botId);
              if (botEntity && botEntity.components['zerog-bot']) {
                grabbedBody = botEntity.components['zerog-bot'].body;
              }
            }
          } else {
          // For remote human players, create a temporary physics body for tether system
          // This allows the same "hitch a ride" behavior as with bots
            
            // Create a temporary physics body at the player's position for the tether system
            const playerShape = new CANNON.Sphere(0.3); // Larger sphere for player body
            grabbedBody = new CANNON.Body({
              mass: 70, // Human mass
              shape: playerShape,
              position: new CANNON.Vec3(targetPos.x, targetPos.y, targetPos.z),
              type: CANNON.Body.KINEMATIC // Kinematic so it follows the remote player
            });
            
            // Add to physics world
            world.addBody(grabbedBody);
          }
          
          // Create physics constraint if we have a physics body to grab
          if (grabbedBody) {
            // Create a temporary physics body for the grabbing player's hand
            const handShape = new CANNON.Sphere(0.05);
            const handBody = new CANNON.Body({
              mass: 1, // Light mass for the hand
              shape: handShape,
              position: new CANNON.Vec3(handPos.x, handPos.y, handPos.z),
              type: CANNON.Body.KINEMATIC // Kinematic so it follows hand movement
            });
            
            // Add hand body to physics world
            world.addBody(handBody);
            
            // Instead of physics constraint, use custom tether system
            // This allows bot to move freely while dragging player along
            const constraint = {
              type: 'custom-tether',
              handBody: handBody,
              grabbedBody: grabbedBody,
              maxDistance: 1.0,
              springStrength: 15.0  // Much stronger for immediate attachment feel
            };
            
            // Don't add to physics world - we'll handle this manually
            
            // Store constraint and hand body for cleanup
            this.playerGrabConstraints[handKey] = {
              constraint: constraint,
              handBody: handBody,
              grabbedBody: grabbedBody,
              playerId: playerId,
              handKey: handKey // Store hand key for tether break functionality
            };
          }
          
          // Set up grab info for visual feedback and tracking
          this.grabInfo[handKey] = {
            surface: playerTarget,
            isBall: false,
            isPlayer: true,
            playerId: playerId,
            initialHandPos: handPos.clone(),
            lastHandPos: handPos.clone(),
            initialSurfacePos: targetPos.clone(),
            lastSurfacePos: targetPos.clone(),
            grabPoint: targetPos.clone()
          };
          
          // Mark as grabbing
          this.isGrabbing[handKey] = true;
          this.grabbedSurface[handKey] = playerTarget;
          
          // Visual feedback - make target glow green
          playerTarget.setAttribute('material', 'emissive: #00ff00; emissiveIntensity: 0.3');
          
          // Haptic feedback
          this.playHapticFeedback(hand, 0.7, 150);
          
          // Send multiplayer message about player grab
          if (isMultiplayer) {
            this.sendPlayerGrabMessage(playerId, true);
          }
        },
        
        releasePlayerGrab: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabbedPlayerId = this.grabbingPlayer[handKey];
          if (!grabbedPlayerId) return;
          
          // Clean up constraint (physics or custom tether)
          const constraintInfo = this.playerGrabConstraints[handKey];
          if (constraintInfo) {
            // Only remove from physics world if it's a real physics constraint
            if (constraintInfo.constraint.type !== 'custom-tether') {
              world.removeConstraint(constraintInfo.constraint);
            }
            
            // Remove temporary hand physics body
            world.removeBody(constraintInfo.handBody);
            
            // For human players, also remove the temporary grabbed body
            if (!grabbedPlayerId.startsWith('bot_') && constraintInfo.grabbedBody) {
              world.removeBody(constraintInfo.grabbedBody);
            }
            
            // Clear constraint info
            this.playerGrabConstraints[handKey] = null;
          }
          
          // Find the player target to reset visual feedback
          const playerTarget = document.querySelector(`[data-player-id="${grabbedPlayerId}"]`);
          if (playerTarget) {
            // Reset visual feedback
            playerTarget.setAttribute('material', 'emissive: #000000; emissiveIntensity: 0');
          }
          
          // Clear grab state
          this.isGrabbing[handKey] = false;
          this.grabbedSurface[handKey] = null;
          this.grabInfo[handKey] = null;
          this.grabbingPlayer[handKey] = null;
          
          // Send multiplayer message about player release
          if (isMultiplayer) {
            this.sendPlayerGrabMessage(grabbedPlayerId, false);
          }
        },
        
        updatePlayerGrabConstraints: function() {
          // Update physics constraints to follow hand movement
          ['left', 'right'].forEach(handKey => {
            const constraintInfo = this.playerGrabConstraints[handKey];
            if (constraintInfo && constraintInfo.handBody) {
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              if (hand) {
                // Update hand physics body position to match actual hand position
                const handPos = new THREE.Vector3();
                hand.object3D.getWorldPosition(handPos);
                constraintInfo.handBody.position.set(handPos.x, handPos.y, handPos.z);
                
                // Handle custom tether system for bot grabs
                if (constraintInfo.constraint.type === 'custom-tether') {
                  this.updateCustomTether(constraintInfo, handPos);
                }
              }
            }
          });
        },
        
        updateCustomTether: function(constraintInfo, handPos) {
          const grabbedBody = constraintInfo.grabbedBody;
          const playerId = constraintInfo.playerId;
          
          // Store previous position for velocity calculation
          if (!constraintInfo.prevGrabbedPos) {
            constraintInfo.prevGrabbedPos = new THREE.Vector3();
          }
          const prevGrabbedPos = constraintInfo.prevGrabbedPos.clone();
          
          // Update physics body position to match the actual player/bot position
          let grabbedVelocity = new THREE.Vector3();
          if (playerId.startsWith('bot_')) {
            // For bots, get velocity from physics body
            if (grabbedBody.velocity) {
              grabbedVelocity.set(grabbedBody.velocity.x, grabbedBody.velocity.y, grabbedBody.velocity.z);
            }
          } else {
            // For human players, update the temporary physics body to match remote player position
            const playerTarget = document.querySelector(`[data-player-id="${playerId}"]`);
            if (playerTarget) {
              const currentPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(currentPos);
              grabbedBody.position.set(currentPos.x, currentPos.y, currentPos.z);
              
              // Calculate grabbed player's velocity from position change
              if (constraintInfo.prevGrabbedPos.length() > 0) {
                const deltaTime = 1/60; // Assume 60fps for velocity calculation
                grabbedVelocity.subVectors(currentPos, prevGrabbedPos).divideScalar(deltaTime);
              }
              constraintInfo.prevGrabbedPos.copy(currentPos);
            }
          }
          
          const grabbedPos = new THREE.Vector3(grabbedBody.position.x, grabbedBody.position.y, grabbedBody.position.z);
          const distance = handPos.distanceTo(grabbedPos);
          
          // Improved tether system with damping and velocity matching
          const targetDistance = 0.15; // Desired distance to maintain (15cm)
          const maxTetherDistance = 1.5; // Maximum allowed distance before breaking
          
          if (distance > targetDistance) {
            const direction = new THREE.Vector3().subVectors(grabbedPos, handPos).normalize();
            const distanceError = distance - targetDistance;
            
            // Break tether if too far (prevents infinite stretching)
            if (distance > maxTetherDistance) {
              // Force release the grab
              const handKey = constraintInfo.handKey || 'left'; // Fallback
              this.releasePlayerGrab(handKey);
              return;
            }
            
            // Calculate desired velocity to reach target position
            const springForce = Math.min(distanceError * 8.0, 15.0); // Capped spring force
            const targetVelocity = direction.clone().multiplyScalar(springForce);
            
            // Add the grabbed player's velocity for smooth following
            targetVelocity.add(grabbedVelocity.clone().multiplyScalar(0.8));
            
            // Apply damping to current velocity to reduce oscillation
            const dampingFactor = 0.85; // Reduce existing velocity by 15%
            this.velocity.multiplyScalar(dampingFactor);
            
            // Smoothly blend toward target velocity instead of adding force
            const blendFactor = 0.3; // How quickly to adjust velocity
            const velocityCorrection = targetVelocity.clone().sub(this.velocity).multiplyScalar(blendFactor);
            
            // Apply the smooth velocity correction
            this.velocity.add(velocityCorrection);
            
            // Limit maximum tether velocity to prevent extreme movements
            const maxTetherVelocity = 20.0; // m/s
            if (this.velocity.length() > maxTetherVelocity) {
              this.velocity.normalize().multiplyScalar(maxTetherVelocity);
            }
          }
        },
        
        sendPlayerGrabMessage: function(targetPlayerId, isGrabbing) {
          const data = {
            type: 'player-grab',
            grabberId: myPlayerId,
            targetPlayerId: targetPlayerId,
            isGrabbing: isGrabbing,
            timestamp: Date.now()
          };
          
          // Send to all other players
          if (isHost) {
            connections.forEach(conn => {
              if (conn && conn.open) {
                conn.send(data);
              }
            });
          } else {
            // Send to host
            const hostConn = connections.get('host');
            if (hostConn && hostConn.open) {
              hostConn.send(data);
            }
          }
        },
        
        forceReleaseGrabberTimeout: function(grabberId) {
          // Force release any grabs on the specified player
          ['left', 'right'].forEach(handKey => {
            if (this.grabbingPlayer[handKey] === grabberId) {
              // Clean up physics constraint
              const constraintInfo = this.playerGrabConstraints[handKey];
              if (constraintInfo) {
                world.removeConstraint(constraintInfo.constraint);
                world.removeBody(constraintInfo.handBody);
                this.playerGrabConstraints[handKey] = null;
              }
              
              // Find the player target to reset visual feedback
              const playerTarget = document.querySelector(`[data-player-id="${grabberId}"]`);
              if (playerTarget) {
                playerTarget.setAttribute('material', 'emissive: #000000; emissiveIntensity: 0');
              }
              
              // Clear grab state
              this.isGrabbing[handKey] = false;
              this.grabbedSurface[handKey] = null;
              this.grabInfo[handKey] = null;
              this.grabbingPlayer[handKey] = null;
            }
          });
          
          // Set 3-second timeout for grabbing this player again
          const timeoutEnd = Date.now() + 3000; // 3 seconds
          this.playerGrabTimeouts.set(grabberId, timeoutEnd);
        },
        
        activateSpeedBoost: function() {
          // Check if speed boost is available
          if (!this.speedBoostAvailable) {
            return; // Still on cooldown
          }
          
          // Check if player is holding capture ball (no boost allowed)
          if (this.isHoldingCaptureBall()) {
            return; // Cannot boost while holding capture ball
          }
          
          // Check if grabbing players/bots (no boost allowed)
          if (this.grabbingPlayer.left || this.grabbingPlayer.right) {
            return; // Cannot boost while grabbing players/bots
          }
          
          // Check if still in capture ball release timeout
          const currentTime = Date.now();
          if (currentTime < this.captureBallReleaseTimeout) {
            return; // Still in 2-second timeout after releasing capture ball
          }
          
          // Always boost in the direction the player is looking (head rotation)
          const camera = document.querySelector('[camera]');
          let boostDirection = new THREE.Vector3(0, 0, -1); // Forward direction
          
          if (camera) {
            // Use the same method as thrusters - get world quaternion and apply it
            const worldQuat = new THREE.Quaternion();
            camera.object3D.getWorldQuaternion(worldQuat);
            boostDirection.applyQuaternion(worldQuat);
          }
          
          // Apply the boost force as an additive force (mixes with existing velocity)
          const boostForce = boostDirection.multiplyScalar(this.speedBoostForce);
          this.velocity.add(boostForce);
          
          // Start cooldown
          this.speedBoostAvailable = false;
          this.lastSpeedBoostTime = Date.now();
        },
        
        applyCollisionForce: function(force, sourceHand) {
          // Apply force to player velocity (Newton's third law - equal and opposite reaction)
          const forceScale = 0.5; // Scale down the force for comfortable gameplay
          this.velocity.add(force.clone().multiplyScalar(forceScale));
          
          // Check if force is strong enough to break grabs
          const forceStrength = force.length();
          const forceThreshold = 0.3; // Lower threshold - release before deep penetration
          
          if (forceStrength > forceThreshold) {
            // Force release the other hand if it's grabbing a static surface
            const otherHandKey = sourceHand.id === 'leftHand' ? 'right' : 'left';
            
            if (this.isGrabbing[otherHandKey] && this.grabInfo[otherHandKey] && !this.grabInfo[otherHandKey].isBall) {
              // Release the other hand's grab on static surface
              this.grabInfo[otherHandKey] = null;
              this.isGrabbing[otherHandKey] = false;
              
              // Apply extra force since we broke the grab
              this.velocity.add(force.clone().multiplyScalar(0.3));
            }
          }
        },

        // Option B: Apply damping to velocity
        applyDamping: function(dt) {
          const dampingFactor = Math.pow(this.damping, dt * 60); // Frame-rate independent
          this.velocity.multiplyScalar(dampingFactor);
          
          // Stop very slow movement to prevent infinite drift
          if (this.velocity.length() < this.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
        },
        
        // Option B: Apply velocity to move VR rig
        applyVelocityToRig: function(dt) {
          if (this.velocity.length() > 0) {
            const movement = this.velocity.clone().multiplyScalar(dt);
            this.rig.object3D.position.add(movement);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
            }
          }
        },
        
        // Option B: Check for collisions using visual wireframes and resolve them
        checkAndResolveCollisions: function(dt) {
          if (!this.collisionVisualization) {
            return; // No collision checking if wireframes not created yet
          }
          
          // Get current camera position (this is our collision center)
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          const cameraWorldPos = new THREE.Vector3();
          camera.object3D.getWorldPosition(cameraWorldPos);
          
          // Check collision points (head, body center, feet)
          const collisionPoints = [
            { pos: cameraWorldPos.clone(), radius: 0.25, name: 'head' }, // Head level
            //{ pos: cameraWorldPos.clone().add(new THREE.Vector3(0, -0.4, 0)), radius: 0.25, name: 'body' }, // Body center
            //{ pos: cameraWorldPos.clone().add(new THREE.Vector3(0, -0.8, 0)), radius: 0.25, name: 'feet' } // Feet level
          ];
          
          let totalCollisionResponse = new THREE.Vector3(0, 0, 0);
          
          // Check each collision point against all collidable surfaces
          collisionPoints.forEach(point => {
            const response = this.checkPointCollision(point.pos, point.radius, point.name);
            if (response.length() > 0) {
              totalCollisionResponse.add(response);
            }
          });
          
          // Check for ball hits on player target (separate from wall collisions)
          this.checkBallHits(cameraWorldPos);
          
          // Check for melee hits (player holding ball and hitting opponent)
          this.checkMeleeHits(cameraWorldPos);
          
          // Apply collision response by moving rig and dampening velocity
          if (totalCollisionResponse.length() > 0) {
            // NEW: Smart collision response based on grab context
            const leftGrabbing = this.isGrabbing.left && this.grabInfo.left && !this.grabInfo.left.isBall;
            const rightGrabbing = this.isGrabbing.right && this.grabInfo.right && !this.grabInfo.right.isBall;
            const totalStaticGrabs = (leftGrabbing ? 1 : 0) + (rightGrabbing ? 1 : 0);
            
            let collisionStrength = 1.0;
            
            if (totalStaticGrabs > 0) {
              // More aggressive reduction for dual grabs to prevent three-way conflicts
              if (totalStaticGrabs === 2) {
                collisionStrength = 0.4; // Very reduced for dual grabs
              } else {
                collisionStrength = 0.7; // Moderately reduced for single grab
              }
              
              // Also check if we're colliding with a grabbed surface - if so, reduce even more
              const grabbedSurfaces = [];
              if (this.isGrabbing.left && this.grabInfo.left && !this.grabInfo.left.isBall) {
                grabbedSurfaces.push(this.grabInfo.left.surface);
              }
              if (this.isGrabbing.right && this.grabInfo.right && !this.grabInfo.right.isBall) {
                grabbedSurfaces.push(this.grabInfo.right.surface);
              }
              
              // Check if collision is with a grabbed surface
              const surfaces = document.querySelectorAll('[grab-surface]');
              let collidingWithGrabbedSurface = false;
              surfaces.forEach(surface => {
                if (grabbedSurfaces.includes(surface)) {
                  const surfacePos = new THREE.Vector3();
                  surface.object3D.getWorldPosition(surfacePos);
                  const distanceToSurface = cameraWorldPos.distanceTo(surfacePos);
                  
                  // If we're very close to a grabbed surface, it's likely the collision source
                  if (distanceToSurface < 1.5) { // Within 1.5m of grabbed surface
                    collidingWithGrabbedSurface = true;
                  }
                }
              });
              
              if (collidingWithGrabbedSurface) {
                // Use distance-based collision strength for grabbed surfaces
                const surfaces = document.querySelectorAll('[grab-surface]');
                let minDistanceToGrabbedSurface = Infinity;
                
                surfaces.forEach(surface => {
                  if (grabbedSurfaces.includes(surface)) {
                    const surfacePos = new THREE.Vector3();
                    surface.object3D.getWorldPosition(surfacePos);
                    const distance = cameraWorldPos.distanceTo(surfacePos);
                    minDistanceToGrabbedSurface = Math.min(minDistanceToGrabbedSurface, distance);
                  }
                });
                
                // Gradually reduce collision strength as player gets closer to grabbed surface
                // Scale based on number of grabs and distance
                const baseStrength = totalStaticGrabs === 2 ? 0.15 : 0.25; // Lower base for dual grabs
                const maxStrength = totalStaticGrabs === 2 ? 0.4 : 0.7;   // Lower max for dual grabs
                const distanceRatio = Math.max(0, Math.min(1, (minDistanceToGrabbedSurface - 0.5) / 1.0));
                collisionStrength = baseStrength + ((maxStrength - baseStrength) * distanceRatio);
              }
            }
            
            // Apply scaled collision response
            const scaledResponse = totalCollisionResponse.clone().multiplyScalar(collisionStrength);
            this.rig.object3D.position.add(scaledResponse);
            
            // Dampen velocity in collision direction (also scaled)
            const collisionNormal = totalCollisionResponse.clone().normalize();
            const velocityInCollisionDirection = this.velocity.clone().projectOnVector(collisionNormal);
            const dampingStrength = 1.2 * collisionStrength; // Scale damping too
            this.velocity.sub(velocityInCollisionDirection.multiplyScalar(dampingStrength));
            
            // NEW: Smart anti-stuttering - only limit velocity if oscillating
            if (totalStaticGrabs > 0) {
              this.lastCollisionTime = Date.now();
              
              // Track velocity history for oscillation detection
              this.velocityHistory.push(this.velocity.clone());
              if (this.velocityHistory.length > this.maxVelocityHistorySize) {
                this.velocityHistory.shift();
              }
              
              // Allow settling period after grabbing before checking for oscillation
              const timeSinceGrab = Date.now() - this.lastGrabTime;
              const isInSettlingPeriod = timeSinceGrab < 500; // 500ms settling period
              
              if (!isInSettlingPeriod) {
                // Check if we're oscillating (rapid direction changes)
                const isOscillating = this.detectVelocityOscillation();
                
                if (isOscillating) {
                  // Only limit velocity if we detect unwanted oscillation
                  const maxVelocityWhenOscillating = 2.0; // Further reduced for better stability
                  if (this.velocity.length() > maxVelocityWhenOscillating) {
                    this.velocity.normalize().multiplyScalar(maxVelocityWhenOscillating);
                  }
                }
              }
              // Otherwise, allow full velocity for intentional rapid movements
            }
            
            if (this.debugMode) {
            }
          }
        },
        
        // Option B: Check a single point for collision with surfaces
        checkPointCollision: function(point, radius, pointName) {
          const response = new THREE.Vector3(0, 0, 0);
          
          // PERFORMANCE OPTIMIZATION: Skip BVH collision detection if no 3D models are visible
          if (!any3DModelsVisible) {
            // No 3D models visible, skip expensive BVH collision checks
            return response;
          }
          
          // Check collision with level.glb model using raycasting
          const levelCollision = this.checkLevelModelCollision(point, radius);
          if (levelCollision.length() > 0) {
            response.add(levelCollision);
          }
          
          // Check against all grab-surface objects
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            const surfacePos = new THREE.Vector3();
            surface.object3D.getWorldPosition(surfacePos);
            const geometry = surface.getAttribute('geometry');
            
            if (!geometry) return;
            
            const collision = this.getCollisionResponse(point, radius, surfacePos, geometry, surface);
            if (collision.length() > 0) {
              response.add(collision);
              if (this.debugMode) {
              }
            }
          });
          
          return response;
        },
        
        // Check collision with level.glb model using raycasting
        checkLevelModelCollision: function(point, radius) {
          const response = new THREE.Vector3(0, 0, 0);
          
          // Get cached BVH meshes
          if (!this.bvhMeshes || this.bvhMeshes.length === 0) {
            this.initializeBVH();
            if (!this.bvhMeshes || this.bvhMeshes.length === 0) return response;
          }
          
          // Use BVH-accelerated raycasting
          const raycaster = new THREE.Raycaster();
          raycaster.firstHitOnly = true; // MAJOR performance boost - stop at first hit!
          raycaster.far = radius * 3;    // Increase range to match grab detection coverage
          const directions = [
            new THREE.Vector3(1, 0, 0),   // Right
            new THREE.Vector3(-1, 0, 0),  // Left
            new THREE.Vector3(0, 1, 0),   // Up
            new THREE.Vector3(0, -1, 0),  // Down
            new THREE.Vector3(0, 0, 1),   // Forward
            new THREE.Vector3(0, 0, -1)   // Backward
          ];
          
          // Performance optimization: Use sphere-based collision detection
          const maxDistance = 5; // 5 meter radius around player
          
          // Create detection sphere at player position
          const detectionSphere = new THREE.Sphere(point, maxDistance);
          
          // Reset all mesh colors first (if debug mode is on) - only for visible meshes
          if (this.showMeshDebug) {
            const visibleMeshes = this.getVisibleMeshes(this.bvhMeshes);
            visibleMeshes.forEach(mesh => {
              if (mesh.material && !Array.isArray(mesh.material)) {
                // Clone material if it's shared to avoid affecting other meshes
                if (!mesh.userData.hasOwnMaterial) {
                  mesh.material = mesh.material.clone();
                  mesh.userData.hasOwnMaterial = true;
                  mesh.userData.originalColor = mesh.material.color ? mesh.material.color.getHex() : 0x888888;
                }
                // Set all to red first
                mesh.material.color.setHex(0xff0000);
              }
            });
          }
          
          // Filter meshes using improved proximity detection - only from visible models
          const visibleMeshes = this.getVisibleMeshes(this.bvhMeshes);
          const nearbyMeshes = [];
          
          visibleMeshes.forEach(mesh => {
            // Update mesh world matrix
            mesh.updateMatrixWorld(true);
            
            const geometry = mesh.geometry;
            let hasNearbyParts = false;
            
            // Get mesh bounding sphere
            if (!geometry.boundingSphere) {
              geometry.computeBoundingSphere();
            }
            
            const meshSphere = geometry.boundingSphere.clone();
            meshSphere.applyMatrix4(mesh.matrixWorld);
            
            // IMPROVED: Check distance from player to mesh surface, not just bounding sphere intersection
            const distanceToMeshSurface = detectionSphere.center.distanceTo(meshSphere.center) - meshSphere.radius;
            
            // Include mesh if any part of it is within detection range
            if (distanceToMeshSurface <= maxDistance) {
              // For very large meshes, still do vertex sampling for optimization
              const meshSize = meshSphere.radius;
              
              if (meshSize > maxDistance * 4) {
                // Very large mesh - sample vertices to see if any are actually nearby
                const positions = geometry.attributes.position.array;
                const sampleRate = Math.max(1, Math.floor(positions.length / 150)); // Even more samples for better accuracy
                
                // Large mesh detected - using vertex sampling for better culling
                
                for (let i = 0; i < positions.length; i += sampleRate * 3) {
                  const vertex = new THREE.Vector3(
                    positions[i],
                    positions[i + 1],
                    positions[i + 2]
                  );
                  vertex.applyMatrix4(mesh.matrixWorld);
                  
                  if (detectionSphere.containsPoint(vertex)) {
                    hasNearbyParts = true;
                    break;
                  }
                }
                
                // FALLBACK: If no vertices found nearby but mesh is reasonably close, include it anyway
                if (!hasNearbyParts && distanceToMeshSurface <= maxDistance * 0.5) {
                  hasNearbyParts = true;
                  // console.log(`🔧 Fallback inclusion for large mesh (distance: ${distanceToMeshSurface.toFixed(2)}m, size: ${meshSize.toFixed(2)}m)`);
                }
              } else {
                // Medium/small mesh - if surface is close enough, include it
                hasNearbyParts = true;
              }
            }
            
            // Visual debugging and inclusion logic
            if (this.showMeshDebug && mesh.material && !Array.isArray(mesh.material)) {
              if (hasNearbyParts) {
                mesh.material.color.setHex(0x00ff00);
              }
            }
            
            if (hasNearbyParts) {
              // Check if mesh belongs to a visible model entity
              let isFromVisibleModel = true;
              let currentParent = mesh.parent;
              
              // Traverse up the hierarchy to find the model entity
              while (currentParent) {
                if (currentParent.el && currentParent.el.getAttribute && currentParent.el.getAttribute('visible') === false) {
                  isFromVisibleModel = false;
                  break;
                }
                currentParent = currentParent.parent;
              }
              
              // Only include mesh if it's from a visible model
              if (isFromVisibleModel) {
                nearbyMeshes.push(mesh);
              }
            }
          });
          
          // Debug logging every 60 frames
          if (!this.debugFrameCounter) this.debugFrameCounter = 0;
          this.debugFrameCounter++;
          if (this.debugFrameCounter % 180 === 0 && this.showMeshDebug) {
            // Debug info available if needed
          }
          
          // Check collision in all directions using nearby BVH-accelerated meshes
          let collisionHits = 0;
          directions.forEach(direction => {
            raycaster.set(point, direction);
            
            // Use THREE.js raycasting with BVH acceleration on nearby meshes only
            const intersects = raycaster.intersectObjects(nearbyMeshes, false);
            
            if (intersects.length > 0) {
              const intersection = intersects[0];
              const distance = intersection.distance;
              
              // If intersection is within collision radius, push player away
              if (distance < radius) {
                collisionHits++;
                const pushDistance = radius - distance + 0.01; // Small buffer
                const pushDirection = direction.clone().negate(); // Push opposite to ray direction
                response.add(pushDirection.multiplyScalar(pushDistance));
              }
            }
          });
          
          // Debug logging for collision detection issues
          if (this.debugCollisionGrab && (collisionHits > 0 || this.debugFrameCounter % 60 === 0)) {
            // Debug info available if needed
          }
          
          
          return response;
        },
        
        // Initialize BVH for all level meshes (called once for massive performance boost)
        initializeBVH: function() {
          if (this.bvhMeshes) return; // Already initialized
          if (this.bvhInitializing) return; // Currently initializing, prevent spam
          
          // Check what's available and patch THREE.js if needed
          
          // Patch THREE.js to use BVH if available
          if (window.MeshBVHLib && window.MeshBVHLib.acceleratedRaycast) {
            // Apply the BVH patch to THREE.js
            window.THREE.BufferGeometry.prototype.computeBoundsTree = window.MeshBVHLib.computeBoundsTree;
            window.THREE.BufferGeometry.prototype.disposeBoundsTree = window.MeshBVHLib.disposeBoundsTree;
            window.THREE.Mesh.prototype.raycast = window.MeshBVHLib.acceleratedRaycast;
          }
          
          // Initialize BVH for multiple models
          this.initializeBVHForModels([
            { selector: '#model-level', name: 'Level' },
            { selector: '#model-spaceship', name: 'Spaceship' },
            { selector: '#model-asteroid-42', name: 'Asteroid-42' }
          ]);
        },
        
        // Initialize BVH for multiple model entities
        initializeBVHForModels: function(modelConfigs) {
          this.bvhMeshes = [];
          let totalBvhCount = 0;
          let totalTraversed = 0;
          let modelsProcessed = 0;
          let modelsFound = 0;
          
          modelConfigs.forEach(config => {
            const entity = document.querySelector(config.selector);
            if (!entity) {
              return;
            }

            
            modelsFound++;
            const gltfModel = entity.querySelector('a-gltf-model');
            if (!gltfModel) {
              return;
            }
            
            // Check if model is loaded
            const modelComponent = gltfModel.components['gltf-model'];
            if (!modelComponent || !modelComponent.model) {
              if (!this.bvhInitializing) {
                this.bvhInitializing = true;
                
                // Listen for model-loaded event
                const onModelLoaded = () => {
                  this.bvhMeshes = null;
                  this.bvhInitializing = false;
                  setTimeout(() => this.initializeBVH(), 100);
                };
                
                gltfModel.removeEventListener('model-loaded', onModelLoaded);
                gltfModel.addEventListener('model-loaded', onModelLoaded);
              }
              return;
            }
            
            // Process this model
            const loadedModel = modelComponent.model;
            const targetObject = loadedModel?.scene || gltfModel.object3D;
            
            let modelBvhCount = 0;
            let modelTraversed = 0;
            
            targetObject.traverse((child) => {
              totalTraversed++;
              modelTraversed++;
              
              if (child.isMesh && child.geometry) {
                // Build BVH for this mesh geometry
                if (!child.geometry.boundsTree) {
                  let MeshBVH;
                  if (window.MeshBVHLib && window.MeshBVHLib.MeshBVH) {
                    MeshBVH = window.MeshBVHLib.MeshBVH;
                  } else if (window.MeshBVH) {
                    MeshBVH = window.MeshBVH;
                  } else if (window.THREE && window.THREE.MeshBVH) {
                    MeshBVH = window.THREE.MeshBVH;
                  } else {
                    console.warn('⚠️ MeshBVH library not found - falling back to standard raycasting');
                    this.useFallbackRaycasting = true;
                    return;
                  }
                  
                  // Build BVH using optimized options for static geometry
                  if (child.geometry.computeBoundsTree) {
                    child.geometry.computeBoundsTree({
                      maxLeafTris: 8,
                      maxDepth: 30,
                      verbose: false,
                      strategy: 0,
                      packData: false
                    });
                  } else {
                    child.geometry.boundsTree = new MeshBVH(child.geometry, {
                      maxLeafTris: 8,
                      maxDepth: 30,
                      verbose: false,
                      strategy: 0,
                      packData: false
                    });
                  }
                  
                  totalBvhCount++;
                  modelBvhCount++;
                }
                this.bvhMeshes.push(child);
              }
            });
            
            modelsProcessed++;
          });
          
          // Clean up initialization flag
          this.bvhInitializing = false;
          
          // Optional: Performance analysis (enable for debugging)
          if (this.debugMode && window.MeshBVHLib && window.MeshBVHLib.estimateMemoryInBytes) {
            const totalMemory = this.bvhMeshes.reduce((total, mesh) => {
              if (mesh.geometry.boundsTree) {
                return total + window.MeshBVHLib.estimateMemoryInBytes(mesh.geometry.boundsTree);
              }
              return total;
            }, 0);
            console.log(`📊 BVH Memory Usage: ${(totalMemory / 1024 / 1024).toFixed(2)} MB`);
          }
        },
        
        // Option B: Calculate collision response for point vs geometry
        getCollisionResponse: function(point, radius, surfacePos, geometry, element) {
          const response = new THREE.Vector3(0, 0, 0);
          
          if (geometry.primitive === 'box') {
            // Box collision
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            const penetration = radius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              // Calculate push-out direction
              const direction = relativePos.clone().sub(closestPoint).normalize();
              if (direction.length() === 0) {
                // Point is exactly on surface, push up
                direction.set(0, 1, 0);
              }
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision
            const sphereRadius = geometry.radius;
            const distance = point.distanceTo(surfacePos);
            const penetration = radius + sphereRadius + this.collisionMargin - distance;
            
            if (penetration > 0) {
              const direction = point.clone().sub(surfacePos).normalize();
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'octahedron') {
            // Octahedron collision - FIXED implementation
            const octahedronRadius = geometry.radius || 1.0; // A-Frame default is 1.0
            
            // Get point relative to octahedron center
            const relativePos = point.clone().sub(surfacePos);
            
            // Calculate distance to octahedron surface
            // An octahedron surface is defined by |x| + |y| + |z| = radius
            const absX = Math.abs(relativePos.x);
            const absY = Math.abs(relativePos.y);
            const absZ = Math.abs(relativePos.z);
            const manhattanDistance = absX + absY + absZ;
            
            // FIXED: Proper distance calculation
            // If inside octahedron: distance is negative (how far inside)
            // If outside octahedron: distance is positive (how far from surface)
            const distanceToSurface = manhattanDistance - octahedronRadius;
            
            // FIXED: Only collide if the player's collision sphere intersects the octahedron
            // This means: distanceToSurface < (radius + margin)
            const penetration = (radius + this.collisionMargin) - distanceToSurface;
          
            if (penetration > 0) {
              // Calculate proper push-out direction
              let direction = new THREE.Vector3();
              
              if (manhattanDistance > 0.001) { // Avoid division by zero
                // Push away from octahedron surface
                // The gradient of |x| + |y| + |z| gives us the surface normal direction
                direction.x = relativePos.x >= 0 ? 1 : -1;
                direction.y = relativePos.y >= 0 ? 1 : -1;
                direction.z = relativePos.z >= 0 ? 1 : -1;
                direction.normalize();
              } else {
                // Point is at center, push up
                direction.set(0, 1, 0);
              }
              
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'dodecahedron') {
            // Dodecahedron collision
            const dodecahedronRadius = geometry.radius || 1.0;
            
            // Get point relative to dodecahedron center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + this.collisionMargin + dodecahedronRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'icosahedron') {
            // Icosahedron collision
            const icosahedronRadius = geometry.radius || 1.0;
            
            // Get point relative to icosahedron center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + this.collisionMargin + icosahedronRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (!geometry && element.querySelector('a-gltf-model')) {
            // GLTF Model collision
            const scale = element.getAttribute('scale') || {x: 1, y: 1, z: 1};
            const avgScale = (scale.x + scale.y + scale.z) / 3;
            const modelRadius = avgScale * 1.0;
            
            // Get point relative to model center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + this.collisionMargin + modelRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          }
          
          return response;
        },
        
        // Check for ball hits on player target sphere
        checkBallHits: function(playerPos) {
          // Get all balls
          const balls = document.querySelectorAll('[zerog-ball]');
          
          balls.forEach(ball => {
            if (!ball.body) return; // Skip if no physics body
            
            const ballPos = new THREE.Vector3();
            ballPos.copy(ball.body.position);
            const ballVelocity = ball.body.velocity.length();
            
            // Check distance to player target (camera position)
            const distance = ballPos.distanceTo(playerPos);
            const hitDistance = 0.3; // 0.2m target radius + 0.1m ball radius
            
            // Only trigger if ball is moving and close to player target
            if (distance <= hitDistance && ballVelocity > 0.5) {
              // Check which player owns this ball
              const ballPlayer = ball.getAttribute('zerog-ball').player;
              
              // Only opponent balls (player1) can hit the player target
              if (ballPlayer === 'player1') {
                // Play impact effect
                const playerTarget = document.querySelector('#player-target');
                if (playerTarget && playerTarget.components['impact-effect']) {
                  playerTarget.components['impact-effect'].playEffect();
                  
                  // Reset ball after hit
                  if (ball.components['zerog-ball']) {
                    ball.components['zerog-ball'].resetPosition();
                  }
                  
                  if (this.debugMode) {
                  }
                }
              }
            }
          });
        },
        
        // Check for melee hits (player holding ball and hitting opponent)
        checkMeleeHits: function(playerPos) {
          if (gameMode !== 'capture') return; // Only in capture mode
          if (this.isStunned) return; // Can't melee while stunned
          
          // Check if player is holding any ball
          let heldBall = null;
          const balls = document.querySelectorAll('[zerog-ball]');
          
          balls.forEach(ball => {
            if (ball.components['zerog-ball'] && ball.components['zerog-ball'].isGrabbed) {
              heldBall = ball;
            }
          });
          
          if (!heldBall) return; // No ball held
          
          // Check if player is moving fast enough for melee hit
          const playerVelocity = this.velocity.length();
          if (playerVelocity < 2.0) return; // Need to be moving at least 2 m/s
          
          // Add cooldown to prevent spam
          const now = Date.now();
          this.lastMeleeTime = this.lastMeleeTime || 0;
          if (now - this.lastMeleeTime < 1000) return; // 1 second cooldown
          
          // Check collision with bot target (singleplayer)
          if (!isMultiplayer || activePlayers.size <= 1) {
            const botTarget = document.querySelector('#bot-target');
            if (botTarget) {
              const targetPos = new THREE.Vector3();
              botTarget.object3D.getWorldPosition(targetPos);
              const distance = playerPos.distanceTo(targetPos);
              
              if (distance < 0.5) { // Close enough for melee hit
                const playerId = myPlayerId || 'player_0';
                if (areTeammates(playerId, 'bot-red') || areTeammates(playerId, 'bot-blue') || areTeammates(playerId, 'bot-green')) {
                  return;
                }
                
                // Stun the bot
                const impactEffect = botTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                
                // Find the ball component and call stunBot
                if (heldBall.components['zerog-ball']) {
                  heldBall.components['zerog-ball'].stunBot();
                }
                
                // Add cooldown to prevent spam
                this.lastMeleeTime = Date.now();
                return;
              }
            }
          }
          
          // Check collision with other players (multiplayer)
          for (let i = 0; i < 4; i++) {
            const targetId = `player_${i}`;
            if (!activePlayers.has(targetId)) continue;
            
            let targetEntity = null;
            const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
            
            if (i === myPlayerIndex) continue; // Can't hit yourself
            
            if (myPlayerId && i === myPlayerIndex) {
              continue; // Skip self
            } else {
              targetEntity = document.querySelector(`#remote-target-${i}`);
            }
            
            if (!targetEntity) continue;
            
            const targetPos = new THREE.Vector3();
            targetEntity.object3D.getWorldPosition(targetPos);
            const distance = playerPos.distanceTo(targetPos);
            
            if (distance < 0.5) { // Close enough for melee hit
              const playerId = myPlayerId || 'player_0';
              if (areTeammates(playerId, targetId)) {
                continue;
              }
              
              // Stun the target player
              const impactEffect = targetEntity.components['impact-effect'];
              if (impactEffect) impactEffect.playEffect();
              
              // Find the ball component and call stunPlayer
              if (heldBall.components['zerog-ball']) {
                heldBall.components['zerog-ball'].stunPlayer();
              }
              
              // Add cooldown to prevent spam
              this.lastMeleeTime = Date.now();
              return;
            }
          }
        },
        
        updateGrabFeedback: function() {
          // Show visual feedback for grabbable objects in range
          if (!this.leftHand || !this.rightHand) return;
          
          const leftNearby = this.findNearestGrabbableSurface(this.leftHand);
          const rightNearby = this.findNearestGrabbableSurface(this.rightHand);
          
          // Reset all grabbable objects to normal color first
          document.querySelectorAll('.grabbable-surface, [zerog-ball]').forEach(el => {
            if (el.hasAttribute('material')) {
              const currentColor = el.getAttribute('material').color;
              if (currentColor === '#00ff00') { // Reset if it was highlighted
                el.setAttribute('material', 'color', '#888888');
              }
            }
          });
          
          
          // Highlight objects in grab range (A-Frame entities only)
          if (leftNearby && !this.isGrabbing.left && leftNearby.setAttribute) {
            leftNearby.setAttribute('material', 'color', '#00ff00');
          }
          if (rightNearby && !this.isGrabbing.right && rightNearby !== leftNearby && rightNearby.setAttribute) {
            rightNearby.setAttribute('material', 'color', '#00ff00');
          }
        },
        
        // Option B: Apply rotation to VR rig only (no physics body)
        applyRotation: function(deltaTime) {
          if (!this.rig) {
            return;
          }
          
          // Apply rotation from right thumbstick
          const rotationInput = this.thumbstickRotation.right;
          if (Math.abs(rotationInput) > 0.1) {
            const rotationSpeed = this.data.rotationSpeed * deltaTime; // deltaTime is already in seconds
            this.rotationY += rotationInput * rotationSpeed;
            
            // Apply rotation to the rig only (Option B: no physics body)
            this.rig.object3D.rotation.y = this.rotationY;
            
            // Debug output
            if (this.debugMode) {
            }
          }
        },
        
        // Option B: Apply thruster forces to velocity
        applyThrusterForces: function(dt) {
          if (!this.leftHand || !this.rightHand) return;
          
          let totalThrust = new THREE.Vector3(0, 0, 0);
          
          // Left hand thruster
          if (this.thrusterActive.left) {
            // Get thrust direction from controller orientation
            const leftDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.leftHand.object3D.getWorldQuaternion(worldQuat);
            leftDir.applyQuaternion(worldQuat);
            leftDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(leftDir);
            
            if (this.debugMode) {
            }
          }
          
          // Right hand thruster
          if (this.thrusterActive.right) {
            // Get thrust direction from controller orientation
            const rightDir = new THREE.Vector3(0, -1, 0); // pointing down from controller
            const worldQuat = new THREE.Quaternion();
            this.rightHand.object3D.getWorldQuaternion(worldQuat);
            rightDir.applyQuaternion(worldQuat);
            rightDir.multiplyScalar(this.data.thrusterForce * dt); // Frame-rate independent force
            
            totalThrust.add(rightDir);
            
            if (this.debugMode) {
            }
          }
          
          // Apply thrust to velocity (Option B approach)
          if (totalThrust.length() > 0) {
            this.velocity.add(totalThrust);
            
            // Cap maximum velocity
            if (this.velocity.length() > this.data.maxSpeed) {
              this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
            }
            
            if (this.debugMode) {
            }
          }
        },
        
        // CannonJS physics-based thruster forces
        
        // CannonJS physics-based keyboard movement
        applyKeyboardMovementToPhysics: function(dt) {
          if (!this.rig || !this.playerBody) return;
          
          // Get camera orientation for relative movement
          const camera = this.rig.querySelector('[camera]');
          if (!camera) return;
          
          const cameraQuat = new THREE.Quaternion();
          camera.object3D.getWorldQuaternion(cameraQuat);
          
          let forceX = 0, forceY = 0, forceZ = 0;
          
          // WASD movement relative to camera direction
          if (this.keys['KeyW']) { // Forward
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(cameraQuat);
            forceX += forward.x;
            forceY += forward.y;
            forceZ += forward.z;
          }
          if (this.keys['KeyS']) { // Backward
            const backward = new THREE.Vector3(0, 0, 1);
            backward.applyQuaternion(cameraQuat);
            forceX += backward.x;
            forceY += backward.y;
            forceZ += backward.z;
          }
          if (this.keys['KeyA']) { // Left
            const left = new THREE.Vector3(-1, 0, 0);
            left.applyQuaternion(cameraQuat);
            forceX += left.x;
            forceY += left.y;
            forceZ += left.z;
          }
          if (this.keys['KeyD']) { // Right
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(cameraQuat);
            forceX += right.x;
            forceY += right.y;
            forceZ += right.z;
          }
          if (this.keys['KeyQ']) { // Up
            forceY += 1;
          }
          if (this.keys['KeyZ']) { // Down
            forceY -= 1;
          }
          
          // Apply keyboard force if any keys are pressed
          if (forceX !== 0 || forceY !== 0 || forceZ !== 0) {
            // Normalize the force vector
            const length = Math.sqrt(forceX * forceX + forceY * forceY + forceZ * forceZ);
            if (length > 0) {
              forceX = (forceX / length) * this.data.thrusterForce * 100;
              forceY = (forceY / length) * this.data.thrusterForce * 100;
              forceZ = (forceZ / length) * this.data.thrusterForce * 100;
              
              // Apply force using proper CannonJS Vec3
              const force = new CANNON.Vec3(forceX, forceY, forceZ);
              this.playerBody.applyForce(force);
            }
          }
        },
        
        // CannonJS physics-based braking
        applyGradualBrakingToPhysics: function(dt) {
          if (!this.playerBody) return;
          
          const isBrakingActive = this.isBraking.left || this.isBraking.right;
          
          if (isBrakingActive) {
            // Apply damping to velocity
            const velocity = this.playerBody.velocity;
            const dampingForce = new CANNON.Vec3(
              -velocity.x * 5,
              -velocity.y * 5,
              -velocity.z * 5
            );
            this.playerBody.applyForce(dampingForce);
          }
        },
        
        // Sync VR rig position with physics body
        syncRigWithPhysics: function() {
          if (!this.rig || !this.playerBody) return;
          
          // Update rig position to match physics body
          const physicsPos = this.playerBody.position;
          this.rig.object3D.position.set(physicsPos.x, physicsPos.y - 0.8, physicsPos.z); // Offset for VR height
        },
        
        // Desktop keyboard movement controls (OLD - keeping for reference)
        applyKeyboardMovement: function(dt) {
          if (!this.rig) return;
          
          let keyboardThrust = new THREE.Vector3(0, 0, 0);
          
          // Get camera orientation for relative movement
          const camera = this.rig.querySelector('[camera]');
          if (!camera) return;
          
          const cameraQuat = new THREE.Quaternion();
          camera.object3D.getWorldQuaternion(cameraQuat);
          
          // WASD movement relative to camera direction
          if (this.keys['KeyW']) { // Forward
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(cameraQuat);
            keyboardThrust.add(forward);
          }
          if (this.keys['KeyS']) { // Backward
            const backward = new THREE.Vector3(0, 0, 1);
            backward.applyQuaternion(cameraQuat);
            keyboardThrust.add(backward);
          }
          if (this.keys['KeyA']) { // Left
            const left = new THREE.Vector3(-1, 0, 0);
            left.applyQuaternion(cameraQuat);
            keyboardThrust.add(left);
          }
          if (this.keys['KeyD']) { // Right
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(cameraQuat);
            keyboardThrust.add(right);
          }
          if (this.keys['KeyQ']) { // Up
            const up = new THREE.Vector3(0, 1, 0);
            up.applyQuaternion(cameraQuat);
            keyboardThrust.add(up);
          }
          if (this.keys['KeyZ']) { // Down
            const down = new THREE.Vector3(0, -1, 0);
            down.applyQuaternion(cameraQuat);
            keyboardThrust.add(down);
          }
          
          // Apply keyboard thrust if any keys are pressed
          if (keyboardThrust.length() > 0) {
            keyboardThrust.normalize();
            keyboardThrust.multiplyScalar(this.data.thrusterForce * dt);
            this.velocity.add(keyboardThrust);
            
            // Cap maximum velocity
            if (this.velocity.length() > this.data.maxSpeed) {
              this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
            }
          }
        },
        
        // Option B: Apply grab movement to velocity - UNIFIED SYSTEM
        applyGrabMovement: function(dt) {
          // Count active static grabs
          const activeGrabs = [];
          ['left', 'right'].forEach(handKey => {
            if (this.isGrabbing[handKey] && this.grabInfo[handKey] && !this.grabInfo[handKey].isBall) {
              const grabInfo = this.grabInfo[handKey];
              // Check if surface exists and is not a ball (handle both A-Frame entities and level meshes)
              if (!grabInfo.surface || 
                  (grabInfo.surface.hasAttribute && !grabInfo.surface.hasAttribute('zerog-ball')) ||
                  (grabInfo.surface.isMesh)) {
                activeGrabs.push({ handKey, grabInfo });
              }
            }
          });
          
          if (activeGrabs.length === 0) return;
          
          // Calculate combined movement from all active grabs
          let totalVelocityChange = new THREE.Vector3(0, 0, 0);
          let totalMovement = 0;
          
          activeGrabs.forEach(({ handKey, grabInfo }) => {
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              if (!hand) return;
              
              const currentHandPos = new THREE.Vector3();
              hand.object3D.getWorldPosition(currentHandPos);
              
              // Calculate how much the hand has moved since last frame
              const handMovement = new THREE.Vector3()
                .subVectors(currentHandPos, grabInfo.lastHandPos);
              
              const movementMagnitude = handMovement.length();
              
              // Only apply movement if hand has moved significantly
            if (movementMagnitude > 0.001) {
              // For multiple grabs, average the movements to prevent conflicts
              const weight = activeGrabs.length > 1 ? 0.6 : 1.0; // Reduce individual influence when multiple grabs
              const velocityChange = handMovement.clone().negate().multiplyScalar(weight);
              
              totalVelocityChange.add(velocityChange);
              totalMovement += movementMagnitude;
            }
            
            // Update last hand position for next frame
            grabInfo.lastHandPos.copy(currentHandPos);
          });
          
          // Apply the combined movement if there was significant motion
          if (totalMovement > 0.001) {
            // NEW: Realistic grab strength that can't exceed natural human movement speeds
            const baseMovementStrength = activeGrabs.length > 1 ? 45.0 : 55.0; // Much more realistic
            
            // Scale down strength based on current velocity to prevent runaway acceleration
            const currentSpeed = this.velocity.length();
            const speedRatio = Math.max(0.1, Math.min(1.0, (4.0 - currentSpeed) / 4.0)); // Reduce strength as speed increases
            const adjustedStrength = baseMovementStrength * speedRatio;
            
            const finalVelocityChange = totalVelocityChange.multiplyScalar(adjustedStrength / dt);
            
            // Add to velocity
            this.velocity.add(finalVelocityChange.multiplyScalar(dt));
            
            // Smart velocity limiting based on context
            const timeSinceCollision = Date.now() - this.lastCollisionTime;
            const isNearCollision = timeSinceCollision < 100;
            
            // NEW: Realistic grab velocity limits based on human movement capabilities
            let maxVelocity;
            if (activeGrabs.length > 1 && isNearCollision) {
              maxVelocity = 2.5; // Very conservative for dual grabs near collision
            } else if (isNearCollision) {
              maxVelocity = 3.0; // Conservative for single grab near collision  
            } else if (activeGrabs.length > 1) {
              maxVelocity = 3.5; // Realistic for dual grabs (human arm speed)
            } else {
              maxVelocity = 4.5; // Realistic for single grab (fast human arm movement)
            }
            
            // Allow higher speeds only for thruster-based movement, not grab-based
            const thrusterMaxSpeed = this.data.maxSpeed; // 8.0 m/s for thrusters/throwing
            
            if (this.velocity.length() > maxVelocity) {
              this.velocity.normalize().multiplyScalar(maxVelocity);
            }
          }
        },
        
        startBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Start braking for this hand
          this.isBraking[handKey] = true;
          
          // Haptic feedback when starting braking
          this.playHapticFeedback(hand, 0.2, 100);
        },
        
        stopBraking: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Stop braking for this hand
          this.isBraking[handKey] = false;
          
          // Haptic feedback when stopping braking
          this.playHapticFeedback(hand, 0.1, 50);
        },
        
        // Keyboard braking functions
        startKeyboardBraking: function() {
          // Activate braking for both hands when using keyboard
          this.isBraking.left = true;
          this.isBraking.right = true;
        },
        
        stopKeyboardBraking: function() {
          // Stop braking for both hands when using keyboard
          this.isBraking.left = false;
          this.isBraking.right = false;
        },
        
        // Option B: Apply braking to velocity
        applyGradualBraking: function(dt) {
          // Check if either hand is braking
          const isBrakingActive = this.isBraking.left || this.isBraking.right;
          
          if (isBrakingActive) {
            // Apply stronger braking to velocity
            const brakingFactor = Math.pow(this.brakingForce, dt * 60); // Frame-rate independent
            this.velocity.multiplyScalar(brakingFactor);
            
            if (this.debugMode && this.velocity.length() > 0.1) {
            }
          }
        },

        // NEW: Try to grab a ball with the specified hand
        tryGrabBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          // Don't grab if already grabbing something
          if (this.isGrabbing[handKey]) return false;
          
          // Look for nearby balls only (not static surfaces)
          const ball = this.findNearestBall(hand);
          
          if (ball) {
            // Only grab player's own ball or capture ball
            const ballPlayer = ball.getAttribute('zerog-ball')?.player;
            
            // CRITICAL FIX: Check for ball steal timeout before allowing capture ball grab
            if (ballPlayer === 'capture' && this.ballStealTimeout && Date.now() < this.ballStealTimeout) {
              console.log('⏰ Ball grab blocked - steal timeout active for', Math.ceil((this.ballStealTimeout - Date.now()) / 1000), 'more seconds');
              return false;
            }
            
            // CRITICAL FIX: Check for global steal cooldown to prevent rapid back-and-forth stealing
            if (ballPlayer === 'capture') {
              const timeSinceLastSteal = Date.now() - this.lastStealTime;
              if (timeSinceLastSteal < this.stealCooldown) {
                console.log('🔄 Ball grab blocked - steal cooldown active for', Math.ceil((this.stealCooldown - timeSinceLastSteal) / 1000), 'more seconds');
                return false;
              }
              
              // Check ball ownership and stealing rules
              const ballComponent = ball.components['zerog-ball'];
              if (ballComponent) {
                // Check if someone else currently owns the ball
                if (ballComponent.currentOwner && ballComponent.currentOwner !== myPlayerId) {
                  const timeSinceOwnerChange = Date.now() - (ballComponent.lastOwnerChangeTime || 0);
                  
                  // Prevent stealing for 2 seconds after ownership change to allow stable control
                  if (timeSinceOwnerChange < 2000) {
                    console.log('🛡️ Ball grab blocked - owner protection active for', Math.ceil((2000 - timeSinceOwnerChange) / 1000), 'more seconds (owner:', ballComponent.currentOwner, ')');
                    return false;
                  }
                  
                  console.log('🔍 Attempting to steal ball from owner:', ballComponent.currentOwner);
                }
                
                // Check if ball is currently held by another player and require close proximity
                if (ballComponent.isGrabbed) {
                  const ballPos = new THREE.Vector3();
                  ball.object3D.getWorldPosition(ballPos);
                  const handPos = new THREE.Vector3();
                  hand.object3D.getWorldPosition(handPos);
                  const distance = handPos.distanceTo(ballPos);
                  
                  // Require closer proximity to steal (0.3m instead of normal grab range)
                  if (distance > 0.3) {
                    console.log('🤏 Ball grab blocked - too far to steal (distance:', distance.toFixed(2), 'm)');
                    return false;
                  }
                  
                  console.log('💪 Attempting to steal capture ball from', ballComponent.currentOwner || 'unknown player');
                  this.lastStealTime = Date.now(); // Set cooldown for this player
                }
              }
            }
            
            // Determine which ball this player should grab
            let shouldGrabThisBall = false;
            
            // Always allow grabbing the capture ball (if not in timeout)
            if (ballPlayer === 'capture') {
              shouldGrabThisBall = true;
            } else {
              // Use dynamic ball assignment based on current team and game mode
              const currentPlayerId = myPlayerId || 'player_0';
              const myBallIndex = getBallForPlayer(currentPlayerId);
              const expectedBallPlayer = `player${myBallIndex}`;
              shouldGrabThisBall = (ballPlayer === expectedBallPlayer);
              
              console.log(`Ball grab attempt: currentPlayerId=${currentPlayerId}, myBallIndex=${myBallIndex}, expectedBallPlayer=${expectedBallPlayer}, ballPlayer=${ballPlayer}, shouldGrab=${shouldGrabThisBall}`);
            }
            
            if (shouldGrabThisBall) {
              // Clear the timeout when successfully grabbing (for future steals)
              if (ballPlayer === 'capture' && this.ballStealTimeout) {
                console.log('✅ Ball steal timeout cleared - successful grab');
                this.ballStealTimeout = null;
              }
              
              this.grabbedSurface[handKey] = ball;
              this.attachToSurface(hand, ball);
              
              // Haptic feedback
              this.playHapticFeedback(hand, 0.5, 100);
              
              return true; // Ball was successfully grabbed
            }
          }
          
          return false; // No ball was grabbed
        },
        
        // NEW: Release grabbed ball  
        releaseGrabbedBall: function(hand) {
          const isLeft = hand.id === 'leftHand';
          const handKey = isLeft ? 'left' : 'right';
          
          const grabInfo = this.grabInfo[handKey];
          if (grabInfo && grabInfo.isBall) {
            this.releaseFromSurface(hand);
            this.grabbedSurface[handKey] = null;
            
          }
        },
        
        // NEW: Find nearest ball (not static surfaces)
        findNearestBall: function(hand) {
          const handPos = new THREE.Vector3();
          hand.object3D.getWorldPosition(handPos);
          const handRadius = 0.08; // Hand collision radius
          
          // Look for balls only
          const balls = document.querySelectorAll('[zerog-ball]');
          let nearestBall = null;
          let minDistance = Infinity;
          
          balls.forEach(ball => {
            const distance = this.getDistanceToSurface(handPos, handRadius, ball);
            
            // If hand is touching or very close to ball (within 10cm for easier grabbing)
            if (distance <= 0.10) {
              if (distance < minDistance) {
                minDistance = distance;
                nearestBall = ball;
              }
            }
          });
          
          return nearestBall;
        },
        
        // NEW: Continuous grabbing while grip is held (balls and static objects)
        updateGripBallGrabbing: function() {
          // Check each hand
          ['left', 'right'].forEach(handKey => {
            const hand = handKey === 'left' ? this.leftHand : this.rightHand;
            if (!hand) return;
            
            // If grip is held but not currently grabbing anything
            if (this.gripHeld[handKey] && !this.isGrabbing[handKey] && !this.grabbingPlayer[handKey]) {
              // CRITICAL FIX: Check if we're in steal timeout before trying to grab balls
              if (this.ballStealTimeout && Date.now() < this.ballStealTimeout) {
                console.log('⏰ Skipping ball grab attempt - in steal timeout for', Math.ceil((this.ballStealTimeout - Date.now()) / 1000), 'more seconds');
                return; // Skip ball grabbing while in timeout
              }
              
              // Try to grab balls first (priority)
              const ballGrabbed = this.tryGrabBall(hand);

              if (!ballGrabbed) {
                // Try to grab players second (priority over static surfaces)
                const nearestPlayer = this.findNearestPlayer(hand);
                if (nearestPlayer) {
                  const playerId = nearestPlayer.getAttribute('data-player-id');
                  this.grabPlayer(hand, nearestPlayer, playerId);
                  return;
                }

                // If no ball or player found, try static surfaces
                this.handleGrab(hand, true);
              }
            }
          });
        },
        
        // NEW: Detect if velocity is oscillating (stuttering)
        detectVelocityOscillation: function() {
          if (this.velocityHistory.length < 6) return false; // Need more history for accuracy
          
          // Check for rapid direction changes in recent history
          let directionChanges = 0;
          let significantVelocityChanges = 0;
          const recentHistory = this.velocityHistory.slice(-6); // Last 6 frames
          
          for (let i = 1; i < recentHistory.length; i++) {
            const prev = recentHistory[i - 1];
            const curr = recentHistory[i];
            
            // Skip if either velocity is very small (avoid false positives)
            if (prev.length() < 0.3 || curr.length() < 0.3) continue;
            
            // Check if direction changed significantly (more restrictive)
            const dotProduct = prev.clone().normalize().dot(curr.clone().normalize());
            if (dotProduct < 0.2) { // Much more restrictive - nearly opposite directions
              directionChanges++;
            }
            
            // Check for significant velocity magnitude changes (higher threshold)
            const velocityChange = Math.abs(curr.length() - prev.length());
            if (velocityChange > 2.0 && prev.length() > 1.0 && curr.length() > 1.0) {
              significantVelocityChanges++;
            }
          }
          
          // Much more restrictive criteria - need multiple clear oscillations
          return directionChanges >= 3 && significantVelocityChanges >= 2;
        },
        
        // NEW: Validate that grabbed surfaces are still within reach
        validateGrabDistances: function() {
          // RE-ENABLED with improved logic
          
          ['left', 'right'].forEach(handKey => {
            if (this.isGrabbing[handKey] && this.grabInfo[handKey]) {
              const grabInfo = this.grabInfo[handKey];
              const hand = handKey === 'left' ? this.leftHand : this.rightHand;
              
              if (!hand || !grabInfo.surface) return;
              
              // Skip validation for balls - they follow the hand
              if (grabInfo.isBall) return;
              
              // Skip validation for player grabs - custom tether system handles distance
              if (grabInfo.isPlayer) return;
              
              // Get current hand position
              const handPos = new THREE.Vector3();
              hand.object3D.getWorldPosition(handPos);
              
              // Get surface position - handle both A-Frame entities and THREE.Mesh objects
              const surfacePos = new THREE.Vector3();
              if (grabInfo.surface.object3D) {
                // A-Frame entity
                grabInfo.surface.object3D.getWorldPosition(surfacePos);
              } else if (grabInfo.surface.isMesh) {
                // THREE.Mesh object (level mesh)
                grabInfo.surface.getWorldPosition(surfacePos);
              } else {
                // Fallback - skip validation for unknown surface types
                return;
              }
              
              // Calculate distance - different methods for different surface types
              let distance;
              if (grabInfo.surface.object3D) {
                // A-Frame entity - use existing distance calculation
                distance = this.getDistanceToSurface(handPos, 0.08, grabInfo.surface);
              } else if (grabInfo.surface.isMesh) {
                // THREE.Mesh object (level mesh) - use distance to actual grab point
                const grabPoint = grabInfo.grabPoint || grabInfo.initialSurfacePos;
                distance = handPos.distanceTo(grabPoint) - 0.08; // 0.08 = hand radius
              } else {
                // Unknown surface type - skip validation
                return;
              }
              
              // More generous distance for validation than initial grab
              // Initial grab: 5cm, Validation: 18cm (allows for collision displacement)
              const maxGrabDistance = 0.18;
              
              // If hand is too far from surface, release the grab
              if (distance > maxGrabDistance) {
                
                // Gentle velocity reduction to prevent jarring release
                this.velocity.multiplyScalar(0.8); // Reduce velocity by 20% (less aggressive)
                
                // Release the grab
                this.releaseFromSurface(hand);
                
                // Haptic feedback to indicate auto-release
                this.playHapticFeedback(hand, 0.15, 80);
              }
            }
          });
        },

        remove: function() {
          // Option B: No physics body to remove
          
          // Clean up event listeners
          if (this.keydownListener) {
            document.removeEventListener('keydown', this.keydownListener);
          }
          if (this.keyupListener) {
            document.removeEventListener('keyup', this.keyupListener);
          }
          
          // Clean up collision visualization elements from camera
          if (this.collisionVisualization) {
            if (this.collisionVisualization.cylinder && this.collisionVisualization.cylinder.parentNode) {
              this.collisionVisualization.cylinder.parentNode.removeChild(this.collisionVisualization.cylinder);
            }
            if (this.collisionVisualization.topSphere && this.collisionVisualization.topSphere.parentNode) {
              this.collisionVisualization.topSphere.parentNode.removeChild(this.collisionVisualization.topSphere);
            }
            if (this.collisionVisualization.bottomSphere && this.collisionVisualization.bottomSphere.parentNode) {
              this.collisionVisualization.bottomSphere.parentNode.removeChild(this.collisionVisualization.bottomSphere);
            }
          }
        },
        
      });


      // Surface Grab Points - Interactive surfaces for grabbing
      AFRAME.registerComponent('grab-surface', {
        schema: {
          type: { type: 'string', default: 'static' }, // static, dynamic
          strength: { type: 'number', default: 1.0 }
        },
        
        init: function() {
          // Add grabbable class
          this.el.classList.add('grabbable-surface');
          
          // Wait for parent transforms to be applied
          setTimeout(() => {
            this.createPhysicsBody();
          }, 100);
        },
        
        createPhysicsBody: function() {
          // Create physics body for surface
          const geometry = this.el.getAttribute('geometry');
          const gltfModel = this.el.querySelector('a-gltf-model');
          let shape;
          
          if (geometry && geometry.primitive === 'box') {
            shape = new CANNON.Box(new CANNON.Vec3(
              geometry.width / 2,
              geometry.height / 2,
              geometry.depth / 2
            ));
          } else if (geometry && geometry.primitive === 'sphere') {
            shape = new CANNON.Sphere(geometry.radius);
          } else if (geometry && geometry.primitive === 'octahedron') {
            // Octahedron: create accurate ConvexPolyhedron collision shape
            const radius = geometry.radius || 1.0; // A-Frame default is 1.0
            
            // Define octahedron vertices (6 vertices at ±radius on each axis)
            const vertices = [
              new CANNON.Vec3(radius, 0, 0),   // +X
              new CANNON.Vec3(-radius, 0, 0),  // -X
              new CANNON.Vec3(0, radius, 0),   // +Y
              new CANNON.Vec3(0, -radius, 0),  // -Y
              new CANNON.Vec3(0, 0, radius),   // +Z
              new CANNON.Vec3(0, 0, -radius)   // -Z
            ];
            
            // Define octahedron faces (8 triangular faces)
            const faces = [
              [0, 2, 4],  // +X, +Y, +Z
              [2, 1, 4],  // +Y, -X, +Z
              [1, 3, 4],  // -X, -Y, +Z
              [3, 0, 4],  // -Y, +X, +Z
              [0, 5, 2],  // +X, -Z, +Y
              [2, 5, 1],  // +Y, -Z, -X
              [1, 5, 3],  // -X, -Z, -Y
              [3, 5, 0]   // -Y, -Z, +X
            ];
            
            shape = new CANNON.ConvexPolyhedron(vertices, faces);
          } else if (geometry && geometry.primitive === 'dodecahedron') {
            // Dodecahedron: use sphere approximation for better performance and no winding errors
            const radius = geometry.radius || 1.0;
            shape = new CANNON.Sphere(radius);
          } else if (geometry && geometry.primitive === 'icosahedron') {
            // Icosahedron: use sphere approximation for better performance and no winding errors
            const radius = geometry.radius || 1.0;
            shape = new CANNON.Sphere(radius);
          } else if (gltfModel) {
            // GLTF Model: use sphere approximation based on scale
            const scale = this.el.getAttribute('scale') || {x: 1, y: 1, z: 1};
            const avgScale = (scale.x + scale.y + scale.z) / 3;
            const radius = avgScale * 1.0; // Assume 1 unit radius, scaled
            shape = new CANNON.Sphere(radius);
          } else {
            // Fallback for unknown geometry
            shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
          }
          
          this.body = new CANNON.Body({
            mass: this.data.type === 'static' ? 0 : 1,
            shape: shape,
            material: surfaceMaterial,
            type: this.data.type === 'static' ? CANNON.Body.STATIC : CANNON.Body.DYNAMIC,
            collisionFilterGroup: 4, // Surfaces are in group 4
            collisionFilterMask: 3   // Surfaces collide with groups 1 (player) + 2 (balls) = 3
          });
          
          // Get position including parent transforms
          const position = this.el.getAttribute('position') || {x: 0, y: 0, z: 0};
          const parentPosition = this.el.parentEl ? this.el.parentEl.getAttribute('position') : {x: 0, y: 0, z: 0};
          
          const finalPosition = {
            x: position.x + (parentPosition.x || 0),
            y: position.y + (parentPosition.y || 0), 
            z: position.z + (parentPosition.z || 0)
          };
          
          const rotation = this.el.getAttribute('rotation');
          this.body.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
          
          // Apply rotation if present
          if (rotation) {
            const rad = Math.PI / 180;
            this.body.quaternion.setFromEuler(
              rotation.x * rad,
              rotation.y * rad,
              rotation.z * rad
            );
          }
          
          world.addBody(this.body);
          
          // Store body reference for grabbing
          this.el.body = this.body;
          
          // CRITICAL: Store element reference in physics body for collision detection
          this.body.el = this.el;
          

          
          // Visual feedback for grabbable surfaces
          this.el.addEventListener('mouseenter', () => {
            this.el.setAttribute('material', 'color', '#00ff00');
          });
          
          this.el.addEventListener('mouseleave', () => {
            this.el.setAttribute('material', 'color', '#ffffff');
          });
        },
        
        // NEW: Add wireframe visualization for collision shape
        addCollisionWireframe: function(geometry, shape) {
          // Only show wireframes in debug mode or when explicitly enabled
          const showWireframes = true; // Set to false to disable
          
          if (!showWireframes) return;
          
          let wireframe;
          
          if (geometry && geometry.primitive === 'box') {
            // Box wireframe
            wireframe = document.createElement('a-box');
            wireframe.setAttribute('width', geometry.width);
            wireframe.setAttribute('height', geometry.height);
            wireframe.setAttribute('depth', geometry.depth);
            wireframe.setAttribute('material', 'wireframe: true; color: #00ffff; opacity: 0.3; transparent: true');
          } else if (geometry && geometry.primitive === 'sphere') {
            // Sphere wireframe
            wireframe = document.createElement('a-sphere');
            wireframe.setAttribute('radius', geometry.radius);
            wireframe.setAttribute('material', 'wireframe: true; color: #00ffff; opacity: 0.3; transparent: true');
          } else if (geometry && geometry.primitive === 'octahedron') {
            // Octahedron wireframe (use actual octahedron)
            wireframe = document.createElement('a-octahedron');
            wireframe.setAttribute('radius', geometry.radius || 1.0);
            wireframe.setAttribute('material', 'wireframe: true; color: #ff00ff; opacity: 0.3; transparent: true');
          } else if (geometry && geometry.primitive === 'dodecahedron') {
            // Dodecahedron wireframe
            wireframe = document.createElement('a-dodecahedron');
            wireframe.setAttribute('radius', geometry.radius || 1.0);
            wireframe.setAttribute('material', 'wireframe: true; color: #ffff00; opacity: 0.3; transparent: true');
          } else if (geometry && geometry.primitive === 'icosahedron') {
            // Icosahedron wireframe
            wireframe = document.createElement('a-icosahedron');
            wireframe.setAttribute('radius', geometry.radius || 1.0);
            wireframe.setAttribute('material', 'wireframe: true; color: #00ffff; opacity: 0.3; transparent: true');
          } else {
            // Fallback box wireframe
            wireframe = document.createElement('a-box');
            wireframe.setAttribute('width', '1');
            wireframe.setAttribute('height', '1');
            wireframe.setAttribute('depth', '1');
            wireframe.setAttribute('material', 'wireframe: true; color: #ff0000; opacity: 0.3; transparent: true');
          }
          
          if (wireframe) {
            wireframe.setAttribute('position', '0 0 0'); // Relative to parent
            this.el.appendChild(wireframe);
          }
        },
        
        // Apply velocity to position and handle damping
        updatePosition: function(dt) {
          if (!this.velocity || !this.rig) return;
          
          // Apply damping
          this.velocity.multiplyScalar(this.damping);
          
          // Stop very slow movement
          if (this.velocity.length() < this.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
          
          // Apply velocity to position
          if (this.velocity.length() > 0) {
            const deltaPosition = this.velocity.clone().multiplyScalar(dt);
            this.rig.object3D.position.add(deltaPosition);
            
            if (this.debugMode) {
              console.log('Position updated by velocity:', deltaPosition.toArray().map(x => x.toFixed(3)));
            }
          }
        },
      });



      // Zero-G Bot Component - AI opponent for singleplayer
      AFRAME.registerComponent('zerog-bot', {
        schema: {
          enabled: { type: 'boolean', default: false },
          difficulty: { type: 'string', default: 'medium' },
          throwInterval: { type: 'number', default: 4000 }, // 4 seconds between throws
          minThrowForce: { type: 'number', default: 3 },
          maxThrowForce: { type: 'number', default: 8 },
          movementSpeed: { type: 'number', default: 1.5 },
          accuracy: { type: 'number', default: 0.7 },
          team: { type: 'string', default: 'red' }, // 'red' or 'blue'
          // Damage system
          bulletHits: { type: 'number', default: 0 },
          maxBulletHits: { type: 'number', default: 30 },
          isDead: { type: 'boolean', default: false },
          respawnTime: { type: 'number', default: 5000 }, // 5 seconds
          // Player-like locomotion parameters
          thrusterForce: { type: 'number', default: 0.8 },
          maxSpeed: { type: 'number', default: 8 },
          rotationSpeed: { type: 'number', default: 2 }
        },
        
        init: function() {
          this.ball = null;
          this.lastThrowTime = 0;
          this.lastMoveTime = 0;
          this.moveInterval = 6000; // Move every 6 seconds
          this.targetPosition = new THREE.Vector3();
          this.isMoving = false;
          this.moveStartTime = 0;
          this.moveStartPos = new THREE.Vector3();
          this.moveDuration = 2000; // 2 second movement duration
          
          // Player tracking for predictive aiming
          this.playerPos = new THREE.Vector3();
          this.playerLastPos = new THREE.Vector3();
          this.playerVelocity = new THREE.Vector3();
          this.lastPlayerUpdate = 0;
          
          // Stunning state
          this.isStunned = false;
          this.stunEndTime = 0;
          this.stunImmunityEndTime = 0; // 10-second immunity after being stunned
          
          // Damage system
          this.bulletHits = 0;
          this.maxBulletHits = 30;
          this.isDead = false;
          this.respawnTime = 5000;
          this.deathTime = 0;
          this.initialPosition = new THREE.Vector3().copy(this.el.object3D.position);
          
          this.damageEffects = []; // Track active damage effects
          
          // Set up event listener for bot damage system
          const self = this;
          this.el.addEventListener('bot-hit-by-bullet', function(event) {
            if (self.isDead) return;
            
            self.bulletHits++;
            
            // Send bot hit state to other players in multiplayer (for every hit)
            if (isMultiplayer && activePlayers.size > 1) {
              const botSelector = '#' + self.el.id;
              sendBotDamageState(botSelector, self.bulletHits, false, false, null);
            }
            
            // Play metal hit sound for bullet hit
            const metalHitSounds = [
              document.querySelector('#metal-hit-sound-1'),
              document.querySelector('#metal-hit-sound-2'),
              document.querySelector('#metal-hit-sound-3')
            ];
            const randomSound = metalHitSounds[Math.floor(Math.random() * metalHitSounds.length)];
            if (randomSound) {
              const botWorldPos = new THREE.Vector3();
              self.el.object3D.getWorldPosition(botWorldPos);
              randomSound.object3D.position.copy(botWorldPos);
              randomSound.components.sound.playSound();
              
              // Send hit sound to other players in multiplayer
              if (isMultiplayer && activePlayers.size > 1) {
                sendHitSound(botWorldPos, randomSound.id, 'bot-red');
              }
            }
            
            // Create simple hit effect for individual hits (one-time spark burst)
            const radius = 0.3; // Bot radius
            
            // Random position on sphere surface (relative to bot)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const effectPos = new THREE.Vector3(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
            
            // Create simple hit effect for individual hits (one-time spark burst, no loop)
            const hitEffect = document.createElement('a-entity');
            hitEffect.setAttribute('position', `${effectPos.x} ${effectPos.y} ${effectPos.z}`);
            hitEffect.setAttribute('impact-spark-burst', '');
            // NO world-spark-system, spark-smoke-controller, or threejs-smoke-puffs for individual hits
            
            // Add as child of bot entity so it moves with the bot
            self.el.appendChild(hitEffect);
            
            // Track the effect
            if (!self.damageEffects) self.damageEffects = [];
            self.damageEffects.push(hitEffect);
            
            // Individual hits are only visible to the local player
            // Damage milestone effects are sent to other players below
            
            // Check for damage milestones (every 5 hits) - create larger effect
            if (self.bulletHits % 5 === 0) {
              // Create larger damage effect for milestones
              const milestoneEffect = document.createElement('a-entity');
              milestoneEffect.setAttribute('position', `${effectPos.x} ${effectPos.y} ${effectPos.z}`);
              milestoneEffect.setAttribute('world-spark-system', '');
              milestoneEffect.setAttribute('spark-smoke-controller', '');
              milestoneEffect.setAttribute('threejs-smoke-puffs', '');
              
              // Add as child of bot entity
              self.el.appendChild(milestoneEffect);
              self.damageEffects.push(milestoneEffect);
              
              // Send damage milestone effect to other players in multiplayer
              if (isMultiplayer && activePlayers.size > 1) {
                const worldPos = new THREE.Vector3();
                self.el.object3D.getWorldPosition(worldPos);
                const botId = self.el.id;
                sendDamageEffect(worldPos, botId);
              }
            }
            
            // Check if bot is dead
            if (self.bulletHits >= self.maxBulletHits) {
              console.log('🤖 Bot killed!');
              // Kill bot directly here
              self.isDead = true;
              self.deathTime = Date.now();
              
              // Send bot death state to other players in multiplayer
              if (isMultiplayer && activePlayers.size > 1) {
                console.log('🤖 Sending bot death state to other players');
                const botSelector = '#' + self.el.id;
                sendBotDamageState(botSelector, self.bulletHits, true, false, null);
              }
              
              // Play explosion effect using the existing impact-effect component
              // The impact-effect is on the inner sphere, not the main bot entity
              const botTarget = self.el.querySelector('[impact-effect]');
              console.log('🤖 Bot target found:', botTarget);
              if (botTarget && botTarget.components['impact-effect']) {
                botTarget.components['impact-effect'].playEffect();
                console.log('🤖 Playing local bot explosion animation');
                
                // Send explosion effect to other players in multiplayer
                if (isMultiplayer && activePlayers.size > 1) {
                  console.log('🤖 Sending bot explosion effect to other players');
                  const botTargetSelector = '#' + self.el.id + '-target';
                  const botId = self.el.id;
                  sendExplosionEffect(botTargetSelector, botId);
                }
              }
              
              // Award point to player who destroyed the bot (host authority)
              if (isHost) {
                const gameManager = document.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  // Find the player who shot the bot (from the bullet that hit it)
                  // This will be handled by the bullet collision system
                  gameManager.components['game-manager'].awardBotKill();
                }
              }
              
              // Hide bot
              self.el.setAttribute('visible', false);
              
              // Start respawn timer
              setTimeout(() => {
                // Reset damage
                self.bulletHits = 0;
                self.isDead = false;
                
                // Clean up damage effects
                self.damageEffects.forEach(effect => {
                  if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                  }
                });
                self.damageEffects = [];
                
                // Reset position
                self.body.position.set(
                  self.initialPosition.x,
                  self.initialPosition.y,
                  self.initialPosition.z
                );
                self.body.velocity.set(0, 0, 0);
                self.body.angularVelocity.set(0, 0, 0);
                
                // Show bot
                self.el.setAttribute('visible', true);
                
                // Send bot respawn state to other players in multiplayer
                if (isMultiplayer && activePlayers.size > 1) {
                  const respawnPos = self.body.position;
                  const botSelector = '#' + self.el.id;
                  sendBotDamageState(botSelector, 0, false, true, respawnPos);
                }
              }, self.respawnTime);
            }
          });
          
          // Player-like locomotion system
          this.velocity = new THREE.Vector3(); // Persistent velocity accumulator like humans
          this.damping = 0.996; // Same damping as humans (0.4% loss per frame)
          this.minVelocity = 0.01; // Stop very slow movement
          this.thrusterActive = { left: false, right: false };
          this.rotationY = 0;
          this.currentTarget = null;
          this.targetDirection = new THREE.Vector3();
          this.desiredRotation = 0;
          this.rotationVelocity = 0;
          this.maxRotationVelocity = this.data.rotationSpeed;
          
          // Performance optimization: Intelligent update frequencies
          this.frameCount = 0;
          this.lastCollisionCheck = 0;
          this.lastNavigationUpdate = 0;
          this.lastPlayerTrackingUpdate = 0;
          
          // Calculate optimal update frequencies based on max speed (8 m/s)
          // At 90 FPS, bot can move max 8/90 = 0.089m per frame
          // Collision detection: Every 2-3 frames (sufficient for 8 m/s)
          // Navigation: Every 5-10 frames (pathfinding doesn't need 90Hz)
          // Player tracking: Every 3-5 frames (aiming prediction)
          this.collisionUpdateInterval = 3; // Every 3 frames (30Hz)
          this.navigationUpdateInterval = 8; // Every 8 frames (11.25Hz)
          this.playerTrackingInterval = 5; // Every 5 frames (18Hz)
          
          // Navigation state
          this.navigationState = 'idle'; // 'idle', 'rotating', 'thrusting', 'drifting', 'avoiding-obstacle', 'seeking-lost-target'
          this.lastNavigationUpdate = 0;
          this.rotationTolerance = 0.2; // radians (~11.5 degrees) - more forgiving
          this.lastCloseTime = 0; // Track when bot was last close to target
          this.closeDistance = 0.5; // Distance considered "close" to target
          
          // Collision state for navigation system
          this.isColliding = false;
          
          // Line of sight memory system
          this.lastKnownTargetPosition = new THREE.Vector3();
          this.lineOfSightLost = false;
          this.lastKnownTargetTime = 0;
          this.lastKnownTargetIndicator = null;
          this.targetMemoryDuration = 10000; // 10 seconds
          
          // Collision and obstacle avoidance
          this.isColliding = false;
          this.collisionResponse = new THREE.Vector3();
          this.obstacleAvoidanceDirection = new THREE.Vector3();
          
          // Create physics body for the bot
          const shape = new CANNON.Sphere(0.2);
          // Position based on bot ID around ice cube area (2, 5.8, 12)
          let startX = 2, startY = 5.8, startZ = 12;
          if (this.el.id === 'zerog-bot-red') {
            startX = 4; startZ = 10; // Right side of ice cube
          } else if (this.el.id === 'zerog-bot-blue') {
            startX = 0; startZ = 14; // Behind ice cube
          } else if (this.el.id === 'zerog-bot-green') {
            startX = -2; startZ = 10; // Left side of ice cube
          }
          
          this.body = new CANNON.Body({
            mass: 50, // 50kg bot
            shape: shape,
            material: defaultMaterial,
            position: new CANNON.Vec3(startX, startY, startZ), // Ice cube area positioning
            linearDamping: 0.8,
            angularDamping: 0.8,
            collisionFilterGroup: 1,
            collisionFilterMask: 7 // Collide with players (1) + balls (2) + surfaces (4) = 7
          });
          
          this.body.gravity = new CANNON.Vec3(0, 0, 0); // Zero gravity
          world.addBody(this.body);
          
          // Store reference
          this.body.el = this.el;
          
          // Create direction indicator for debugging (2m forward-facing line)
          this.createDirectionIndicator();
          
          // Initialize position
          this.generateNewTargetPosition();
          
          // Initialize ball assignment - will be updated when game mode changes
          this.updateBallAssignment();
          
          // Bot initialized with team
          
          // Add collision detection for bot being hit
          this.body.addEventListener('collide', (evt) => {
            this.checkPlayerBallHit(evt);
            this.handleEnvironmentCollision(evt);
          });
          
          // Reset collision state when no longer colliding
          this.body.addEventListener('endContact', (evt) => {
            const otherBody = evt.target === this.body ? evt.body : evt.target;
            
            // Reset collision state when no longer touching environment
            if ((otherBody.el && otherBody.el.hasAttribute('grab-surface')) || 
                (otherBody.collisionFilterGroup === 4)) {
              this.isColliding = false;
            }
          });
          
          // Update difficulty settings
          if (this.data.difficulty === 'easy') {
            this.data.throwInterval = 6000;  // 6 seconds between throws
            this.data.accuracy = 0.5;        // 50% accuracy
          } else if (this.data.difficulty === 'medium') {
            this.data.throwInterval = 4000;  // 4 seconds between throws  
            this.data.accuracy = 0.7;        // 70% accuracy
          } else if (this.data.difficulty === 'hard') {
            this.data.throwInterval = 3000;  // 3 seconds between throws
            this.data.accuracy = 0.9;        // 90% accuracy
          }
        },
        
        updateBallAssignment: function() {
          // Get ball assignment based on bot element ID
          let botId;
          if (this.el.id === 'zerog-bot-red') {
            botId = 'bot-red';
          } else if (this.el.id === 'zerog-bot-blue') {
            botId = 'bot-blue';
          } else if (this.el.id === 'zerog-bot-green') {
            botId = 'bot-green';
          } else {
            console.error(`Unknown bot ID: ${this.el.id}`);
            return;
          }
          
          const ballIndex = getBallForPlayer(botId);
          const ballPlayer = `player${ballIndex}`;
          this.ball = this.el.sceneEl.querySelector(`[zerog-ball*="player: ${ballPlayer}"]`);
          
        },
        
        createDirectionIndicator: function() {
          // Create a 2m line showing bot's forward direction for debugging
          const line = document.createElement('a-entity');
          line.setAttribute('geometry', {
            primitive: 'cylinder',
            radius: 0.02,
            height: 2
          });
          line.setAttribute('material', {
            color: this.data.team === 'red' ? '#ff0000' : (this.data.team === 'blue' ? '#0000ff' : '#00ff00'),
            opacity: 0.7,
            transparent: true
          });
          line.setAttribute('position', '0 0 1'); // 1m forward from bot center (positive Z is forward)
          line.setAttribute('rotation', '90 0 0'); // Rotate to point forward (Z-axis)
          line.setAttribute('class', 'bot-direction-indicator');
          
          this.el.appendChild(line);
          this.directionIndicator = line;
        },
        
        handleEnvironmentCollision: function(evt) {
          // Handle collision with environment objects (surfaces, meshes)
          const otherBody = evt.target === this.body ? evt.body : evt.target;
          
          // Handle collisions with grab-surface elements OR level physics bodies
          if ((otherBody.el && otherBody.el.hasAttribute('grab-surface')) || 
              (otherBody.collisionFilterGroup === 4)) {
            this.isColliding = true;
            
            // Stop thruster forces when colliding
            this.thrusterActive.left = false;
            this.thrusterActive.right = false;
            
            // Change navigation state to avoid obstacle
            if (this.navigationState === 'thrusting') {
              this.navigationState = 'avoiding-obstacle';
            }
          }
        },
        
        checkLevelModelCollision: function(botPos, radius = 0.3) {
          // Use the SAME collision detection system as human players
          const response = new THREE.Vector3(0, 0, 0);
          
          // Get human player component to access BVH meshes
          const player = document.querySelector('[zerog-player]');
          if (!player || !player.components['zerog-player']) {
            return response;
          }
          
          const playerComponent = player.components['zerog-player'];
          if (!playerComponent.bvhMeshes || playerComponent.bvhMeshes.length === 0) {
            return response;
          }
          
          // Use BVH-accelerated raycasting (same as human players)
          const raycaster = new THREE.Raycaster();
          raycaster.firstHitOnly = true;
          raycaster.far = radius * 3;
          const directions = [
            new THREE.Vector3(1, 0, 0),   // Right
            new THREE.Vector3(-1, 0, 0),  // Left
            new THREE.Vector3(0, 1, 0),   // Up
            new THREE.Vector3(0, -1, 0),  // Down
            new THREE.Vector3(0, 0, 1),   // Forward
            new THREE.Vector3(0, 0, -1)   // Backward
          ];
          
          // Performance optimization: Use sphere-based collision detection
          const maxDistance = 5; // 5 meter radius around bot
          const detectionSphere = new THREE.Sphere(botPos, maxDistance);
          
          // Filter to nearby meshes only (same as human players)
          const nearbyMeshes = playerComponent.bvhMeshes.filter(mesh => {
            if (!mesh.geometry || !mesh.geometry.boundingSphere) return false;
            
            const meshSphere = mesh.geometry.boundingSphere.clone();
            meshSphere.applyMatrix4(mesh.matrixWorld);
            
            return detectionSphere.intersectsSphere(meshSphere);
          });
          
          // Check each direction for collisions
          directions.forEach(direction => {
            raycaster.set(botPos, direction);
            
            const intersects = raycaster.intersectObjects(nearbyMeshes, false);
            
            if (intersects.length > 0) {
              const intersection = intersects[0];
              const distance = intersection.distance;
              
              // If intersection is within collision radius, push bot away
              if (distance < radius) {
                const pushDistance = radius - distance + 0.01; // Small buffer
                const pushDirection = direction.clone().negate(); // Push opposite to ray direction
                response.add(pushDirection.multiplyScalar(pushDistance));
              }
            }
          });
          
          return response;
        },
        
        checkForObstacles: function(fromPos, toPos) {
          // Check if there are obstacles between current position and target
          const direction = new THREE.Vector3().subVectors(toPos, fromPos).normalize();
          const distance = fromPos.distanceTo(toPos);
          
          // Use raycasting to detect obstacles
          const raycaster = new THREE.Raycaster();
          raycaster.set(fromPos, direction);
          raycaster.far = Math.min(distance, 5.0); // Check up to 5 meters ahead
          
          // Get obstacle meshes (same as line of sight detection)
          const meshes = [];
          const models = [
            document.querySelector('#model-level'),
            document.querySelector('#model-spaceship'),
            document.querySelector('#model-asteroid-42')
          ];
          
          models.forEach(model => {
            if (model && model.object3D) {
              model.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  meshes.push(child);
                }
              });
            }
          });
          
          // Add grab-surface objects
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            if (surface.object3D) {
              surface.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  meshes.push(child);
                }
              });
            }
          });
          
          const intersects = raycaster.intersectObjects(meshes, false);
          return intersects.length > 0 && intersects[0].distance < raycaster.far - 0.5; // 0.5m buffer
        },
        
        createLastKnownPositionIndicator: function(position) {
          // Remove existing indicator
          this.removeLastKnownPositionIndicator();
          
          // Create wireframe sphere at last known position
          const sphere = document.createElement('a-sphere');
          sphere.setAttribute('radius', '0.5');
          sphere.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
          sphere.setAttribute('material', {
            wireframe: true,
            color: this.data.team === 'red' ? '#ff0000' : (this.data.team === 'blue' ? '#0000ff' : '#00ff00'),
            opacity: 0.6,
            transparent: true
          });
          sphere.setAttribute('class', 'bot-last-known-position');
          
          // Add to scene
          document.querySelector('a-scene').appendChild(sphere);
          this.lastKnownTargetIndicator = sphere;
          
          // Auto-remove after 10 seconds
          setTimeout(() => {
            this.removeLastKnownPositionIndicator();
          }, this.targetMemoryDuration);
        },
        
        removeLastKnownPositionIndicator: function() {
          if (this.lastKnownTargetIndicator && this.lastKnownTargetIndicator.parentNode) {
            this.lastKnownTargetIndicator.parentNode.removeChild(this.lastKnownTargetIndicator);
            this.lastKnownTargetIndicator = null;
          }
        },
        
        updateLineOfSightMemory: function(hasLOS, targetPos) {
          const now = Date.now();
          
          if (hasLOS) {
            // We have line of sight - update last known position
            this.lastKnownTargetPosition.copy(targetPos);
            this.lastKnownTargetTime = now;
            this.lineOfSightLost = false;
            
            // Remove indicator if we regained sight
            this.removeLastKnownPositionIndicator();
          } else {
            // We lost line of sight
            if (!this.lineOfSightLost) {
              // Just lost sight - store position and create indicator
              this.lineOfSightLost = true;
              this.createLastKnownPositionIndicator(this.lastKnownTargetPosition);
            }
          }
          
          // Check if memory has expired
          if (this.lineOfSightLost && (now - this.lastKnownTargetTime > this.targetMemoryDuration)) {
            this.lineOfSightLost = false;
            this.removeLastKnownPositionIndicator();
          }
        },
        
        calculateObstacleAvoidance: function(botPos, targetPos) {
          // Calculate a direction to avoid obstacles while moving toward target
          const toTarget = new THREE.Vector3().subVectors(targetPos, botPos).normalize();
          
          // Try perpendicular directions to find clear path
          const rightDir = new THREE.Vector3().crossVectors(toTarget, new THREE.Vector3(0, 1, 0)).normalize();
          const leftDir = rightDir.clone().multiplyScalar(-1);
          
          // Test both directions
          const rightClear = !this.checkForObstacles(botPos, botPos.clone().add(rightDir.clone().multiplyScalar(3)));
          const leftClear = !this.checkForObstacles(botPos, botPos.clone().add(leftDir.clone().multiplyScalar(3)));
          
          if (rightClear && leftClear) {
            // Both directions clear - choose randomly
            this.obstacleAvoidanceDirection.copy(Math.random() > 0.5 ? rightDir : leftDir);
          } else if (rightClear) {
            this.obstacleAvoidanceDirection.copy(rightDir);
          } else if (leftClear) {
            this.obstacleAvoidanceDirection.copy(leftDir);
          } else {
            // Both blocked - try going up or back
            const upDir = new THREE.Vector3(0, 1, 0);
            const backDir = toTarget.clone().multiplyScalar(-1);
            this.obstacleAvoidanceDirection.copy(Math.random() > 0.5 ? upDir : backDir);
          }
        },
        
        checkAndResolveCollisions: function(dt) {
          // Bot collision detection using the SAME system as human players
          // but applied to CANNON.js physics body instead of VR rig
          
          const botPos = new THREE.Vector3().copy(this.body.position);
          const radius = 0.25; // Same collision radius as human players
          
          // Check collision points (same as human players but relative to bot position)
          const collisionPoints = [
            { pos: botPos.clone(), radius: radius, name: 'bot-center' }
          ];
          
          let totalCollisionResponse = new THREE.Vector3(0, 0, 0);
          
          // Check each collision point against all collidable surfaces (same as humans)
          collisionPoints.forEach(point => {
            const response = this.checkBotPointCollision(point.pos, point.radius, point.name);
            if (response.length() > 0) {
              totalCollisionResponse.add(response);
            }
          });
          
          // Apply collision response by moving physics body (not VR rig like humans)
          if (totalCollisionResponse.length() > 0) {
            // Move the CANNON.js physics body to resolve collision
            this.body.position.x += totalCollisionResponse.x;
            this.body.position.y += totalCollisionResponse.y;
            this.body.position.z += totalCollisionResponse.z;
            
            // Dampen velocity in collision direction (same as humans)
            const collisionNormal = totalCollisionResponse.clone().normalize();
            const currentVelocity = new THREE.Vector3(this.body.velocity.x, this.body.velocity.y, this.body.velocity.z);
            const velocityInCollisionDirection = currentVelocity.clone().projectOnVector(collisionNormal);
            const dampedVelocity = currentVelocity.sub(velocityInCollisionDirection.multiplyScalar(1.2));
            
            // Apply dampened velocity back to physics body
            this.body.velocity.set(dampedVelocity.x, dampedVelocity.y, dampedVelocity.z);
            
            // Also dampen the persistent velocity accumulator
            const persistentVelInCollisionDir = this.velocity.clone().projectOnVector(collisionNormal);
            this.velocity.sub(persistentVelInCollisionDir.multiplyScalar(1.2));
            
            // Set collision flag for navigation system
            this.isColliding = true;
          } else {
            this.isColliding = false;
          }
        },
        
        checkBotPointCollision: function(point, radius, pointName) {
          // Use the EXACT same collision detection as human players
          // This is a simplified version of the human player's checkPointCollision method
          
          let totalResponse = new THREE.Vector3(0, 0, 0);
          
          // Check against grab-surface elements (same as human players)
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            const response = this.getBotCollisionResponse(point, radius, surface);
            if (response.length() > 0) {
              totalResponse.add(response);
            }
          });
          
          // Check against level model using BVH (same as human players)
          const levelResponse = this.checkBotLevelModelCollision(point, radius);
          if (levelResponse.length() > 0) {
            totalResponse.add(levelResponse);
          }
          
          return totalResponse;
        },
        
        getBotCollisionResponse: function(point, radius, element) {
          // Get element world position and geometry (same as human players)
          const surfacePos = new THREE.Vector3();
          element.object3D.getWorldPosition(surfacePos);
          
          const geometry = element.getAttribute('geometry');
          if (!geometry) return new THREE.Vector3(0, 0, 0);
          
          // Use the SAME collision response math as human players
          const response = new THREE.Vector3(0, 0, 0);
          const collisionMargin = 0.02; // Same as player collision margin
          
          if (geometry.primitive === 'box') {
            // Box collision (same math as human players)
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            const penetration = radius + collisionMargin - distance;
            
            if (penetration > 0) {
              // Calculate push-out direction
              const direction = relativePos.clone().sub(closestPoint).normalize();
              if (direction.length() === 0) {
                // Point is exactly on surface, push up
                direction.set(0, 1, 0);
              }
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision (same math as human players)
            const sphereRadius = geometry.radius || 1.0;
            
            // Get point relative to sphere center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration
            const penetration = radius + collisionMargin + sphereRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'cylinder') {
            // Cylinder collision (same math as human players)
            const cylinderRadius = geometry.radius || 1.0;
            const cylinderHeight = geometry.height || 2.0;
            
            // Get point relative to cylinder center
            const relativePos = point.clone().sub(surfacePos);
            
            // Check if point is within cylinder height
            if (Math.abs(relativePos.y) <= cylinderHeight / 2 + radius + collisionMargin) {
              // Calculate horizontal distance from cylinder axis
              const horizontalDistance = Math.sqrt(relativePos.x * relativePos.x + relativePos.z * relativePos.z);
              const penetration = radius + collisionMargin + cylinderRadius - horizontalDistance;
              
              if (penetration > 0) {
                // Push away horizontally
                const direction = horizontalDistance > 0.001 ? 
                  new THREE.Vector3(relativePos.x, 0, relativePos.z).normalize() : 
                  new THREE.Vector3(1, 0, 0);
                response.copy(direction.multiplyScalar(penetration));
              }
            }
          }
          
          return response;
        },
        
        checkBotLevelModelCollision: function(point, radius) {
          // Use the SAME BVH collision detection as human players
          const response = new THREE.Vector3(0, 0, 0);
          
          // Get human player component to access BVH meshes
          const player = document.querySelector('[zerog-player]');
          if (!player || !player.components['zerog-player']) {
            return response;
          }
          
          const playerComponent = player.components['zerog-player'];
          if (!playerComponent.bvhMeshes || playerComponent.bvhMeshes.length === 0) {
            return response;
          }
          
          // Use BVH-accelerated raycasting (same as human players)
          const raycaster = new THREE.Raycaster();
          raycaster.firstHitOnly = true;
          raycaster.far = radius * 3;
          const directions = [
            new THREE.Vector3(1, 0, 0),   // Right
            new THREE.Vector3(-1, 0, 0),  // Left
            new THREE.Vector3(0, 1, 0),   // Up
            new THREE.Vector3(0, -1, 0),  // Down
            new THREE.Vector3(0, 0, 1),   // Forward
            new THREE.Vector3(0, 0, -1)   // Backward
          ];
          
          // Performance optimization: Use sphere-based collision detection
          const maxDistance = 5; // 5 meter radius around bot
          const detectionSphere = new THREE.Sphere(point, maxDistance);
          
          // Filter to nearby meshes only (same as human players) - only from visible models
          const visibleMeshes = playerComponent.getVisibleMeshes(playerComponent.bvhMeshes);
          const nearbyMeshes = visibleMeshes.filter(mesh => {
            if (!mesh.geometry || !mesh.geometry.boundingSphere) return false;
            
            const meshSphere = mesh.geometry.boundingSphere.clone();
            meshSphere.applyMatrix4(mesh.matrixWorld);
            
            return detectionSphere.intersectsSphere(meshSphere);
          });
          
          // Check each direction for collisions (same as human players)
          directions.forEach(direction => {
            raycaster.set(point, direction);
            
            const intersects = raycaster.intersectObjects(nearbyMeshes, false);
            
            if (intersects.length > 0) {
              const intersection = intersects[0];
              const distance = intersection.distance;
              
              // If intersection is within collision radius, push bot away
              if (distance < radius) {
                const pushDistance = radius - distance + 0.01; // Small buffer
                const pushDirection = direction.clone().negate(); // Push opposite to ray direction
                response.add(pushDirection.multiplyScalar(pushDistance));
              }
            }
          });
          
          return response;
        },
        
                 checkPlayerBallHit: function(evt) {
           if (!this.data.enabled) return;
           
           const otherBody = evt.target === this.body ? evt.body : evt.target;
           
           // Check if hit by player's ball
           if (otherBody.el && otherBody.el.hasAttribute('zerog-ball')) {
             const ballPlayer = otherBody.el.getAttribute('zerog-ball').player;
             const ballNumber = parseInt(ballPlayer.replace('player', ''));
             let currentPlayerBallNumber = 2; // Default for singleplayer
             if (isMultiplayer && myPlayerId) {
               currentPlayerBallNumber = getBallForPlayer(myPlayerId);
             }
             
             if (ballNumber === currentPlayerBallNumber) {
               // Bot was hit - only trigger impact effect (scoring handled by zerog-ball component)
               const impactEffect = this.el.components['impact-effect'];
               if (impactEffect) {
                 impactEffect.playEffect();
               }
               
             }
           }
         },
        
        generateNewTargetPosition: function() {
          // Generate a random position around the ice cube area (2, 5.8, 12)
          const iceCubePos = { x: 2, y: 5.8, z: 12 };

          // Position bots in a wider area around the ice cube based on their ID
          if (this.el.id === 'zerog-bot-red') {
            // Red bot: right side of ice cube
          this.targetPosition.set(
              iceCubePos.x + 2 + (Math.random() - 0.5) * 2,  // X: 3 to 5 (right side)
              iceCubePos.y + (Math.random() - 0.5) * 2,      // Y: 4.8 to 6.8 (around ice cube height)
              iceCubePos.z + (Math.random() - 0.5) * 4       // Z: 10 to 14 (front/back of ice cube)
            );
          } else if (this.el.id === 'zerog-bot-blue') {
            // Blue bot: behind ice cube
            this.targetPosition.set(
              iceCubePos.x + (Math.random() - 0.5) * 4,      // X: 0 to 4 (around ice cube)
              iceCubePos.y + (Math.random() - 0.5) * 2,      // Y: 4.8 to 6.8 (around ice cube height)
              iceCubePos.z + 2 + (Math.random() - 0.5) * 2   // Z: 13 to 15 (behind ice cube)
            );
          } else if (this.el.id === 'zerog-bot-green') {
            // Green bot: left side of ice cube
            this.targetPosition.set(
              iceCubePos.x - 2 + (Math.random() - 0.5) * 2,  // X: -1 to -3 (left side)
              iceCubePos.y + (Math.random() - 0.5) * 2,      // Y: 4.8 to 6.8 (around ice cube height)
              iceCubePos.z + (Math.random() - 0.5) * 4       // Z: 10 to 14 (front/back of ice cube)
            );
          } else {
            // Fallback for unknown bots - around ice cube
            this.targetPosition.set(
              iceCubePos.x + (Math.random() - 0.5) * 6,      // X: -1 to 5
              iceCubePos.y + (Math.random() - 0.5) * 2,      // Y: 4.8 to 6.8
              iceCubePos.z + (Math.random() - 0.5) * 6       // Z: 9 to 15
            );
          }
        },
        
        updatePlayerTracking: function(time) {
          // Get player TARGET position (the actual sphere that needs to be hit)
          const playerTarget = document.querySelector('#player-target');
          if (!playerTarget) return;
          
          // Store previous position
          this.playerLastPos.copy(this.playerPos);
          
          // Get current world position of the target sphere
          playerTarget.object3D.getWorldPosition(this.playerPos);
          
          // Calculate velocity if we have a previous frame
          if (this.lastPlayerUpdate > 0) {
            const deltaTime = (time - this.lastPlayerUpdate) / 1000; // Convert to seconds
            if (deltaTime > 0.001) { // Avoid division by zero
              this.playerVelocity.subVectors(this.playerPos, this.playerLastPos).divideScalar(deltaTime);
            }
          }
          
          this.lastPlayerUpdate = time;
        },
        
        startMovementToTarget: function(currentTime) {
          this.isMoving = true;
          this.moveStartTime = currentTime; // Use A-Frame time consistently
          this.moveStartPos.copy(this.body.position);
          
          // Calculate velocity needed to reach target
          const direction = new THREE.Vector3()
            .subVectors(this.targetPosition, this.moveStartPos)
            .normalize();
          
          const velocity = direction.multiplyScalar(this.data.movementSpeed);
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          
        },
        
        stopMovement: function() {
          this.isMoving = false;
          // Apply damping to slow down
          this.body.velocity.scale(0.1, this.body.velocity);
          this.generateNewTargetPosition();
        },
        
        findBestTarget: function() {
          const botPos = new THREE.Vector3().copy(this.body.position);
          const botId = this.data.team === 'red' ? 'bot-red' : 'bot-blue';
          let targets = [];
          
          // Add human player as potential target
          const playerTarget = document.querySelector('#player-target');
          if (playerTarget) {
            const playerId = myPlayerId || 'player_0';
            if (!areTeammates(botId, playerId)) {
              const targetPos = new THREE.Vector3();
              playerTarget.object3D.getWorldPosition(targetPos);
              const distance = botPos.distanceTo(targetPos);
              
              // CRITICAL FIX: Check line of sight before adding target
              if (this.hasLineOfSight(botPos, targetPos)) {
              // Get player velocity (simplified)
              const playerVelocity = new THREE.Vector3(); // Could be enhanced with actual tracking
              
              targets.push({
                type: 'human player',
                position: targetPos,
                velocity: playerVelocity,
                distance: distance
              });
              }
            }
          }
          
          // Bots only target players, not other bots
          
          // Return target with switching logic
          if (targets.length === 0) return null;
          
          // If only one target, use it
          if (targets.length === 1) return targets[0];
          
          // Multiple targets: switch between them periodically
          if (!this.lastTargetSwitchTime) this.lastTargetSwitchTime = 0;
          if (!this.currentTargetIndex) this.currentTargetIndex = 0;
          
          const now = Date.now();
          const switchInterval = 3000; // Switch target every 3 seconds
          
          if (now - this.lastTargetSwitchTime > switchInterval) {
            this.currentTargetIndex = (this.currentTargetIndex + 1) % targets.length;
            this.lastTargetSwitchTime = now;

          }
          
          // Sort by distance but use the selected target
          targets.sort((a, b) => a.distance - b.distance);
          
          // If current target index is valid, use it, otherwise use closest
          if (this.currentTargetIndex < targets.length) {
            return targets[this.currentTargetIndex];
          } else {
            this.currentTargetIndex = 0;
            return targets[0];
          }
        },
        
        hasLineOfSight: function(fromPos, toPos, showDebugLine = false) {
          // Simple, direct raycast from bot center to player center
          const direction = new THREE.Vector3();
          direction.subVectors(toPos, fromPos).normalize();
          const distance = fromPos.distanceTo(toPos);
          
          // Get all 3D meshes that can block line of sight
          const meshes = [];
          const models = [
            document.querySelector('#model-level'),
            document.querySelector('#model-spaceship'),
            document.querySelector('#model-asteroid-42')
          ];
          
          models.forEach(model => {
            if (model && model.object3D) {
              model.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  meshes.push(child);
                }
              });
            }
          });
          
          // Add grab-surface objects as blocking meshes
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            if (surface.object3D) {
              surface.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  meshes.push(child);
                }
              });
            }
          });
          
          // Single raycast from bot to player
          const raycaster = new THREE.Raycaster();
          raycaster.set(fromPos, direction);
          raycaster.far = distance; // Only check up to player distance
          
          const intersects = raycaster.intersectObjects(meshes, false);
          
          // If any intersection is closer than the player, line of sight is blocked
          let hasLOS = true;
          if (intersects.length > 0) {
            const closestIntersection = intersects[0];
            if (closestIntersection.distance < distance - 0.1) { // Small buffer
              hasLOS = false;
            }
          }
          
          // Show debug line if requested
          if (showDebugLine) {
            this.createLineOfSightDebug(fromPos, toPos, hasLOS);
          }
          
          return hasLOS;
        },
        
        createLineOfSightDebug: function(fromPos, toPos, hasLineOfSight) {
          // Remove old debug line
          if (this.debugLine) {
            this.debugLine.parent.remove(this.debugLine);
          }
          
          // Create new debug line
          const geometry = new THREE.BufferGeometry().setFromPoints([fromPos, toPos]);
          const material = new THREE.LineBasicMaterial({ 
            color: hasLineOfSight ? 0x00ff00 : 0xff0000,
            transparent: true,
            opacity: 0.7
          });
          
          this.debugLine = new THREE.Line(geometry, material);
          document.querySelector('a-scene').object3D.add(this.debugLine);
          
          // Auto-remove after 1 second
          setTimeout(() => {
            if (this.debugLine && this.debugLine.parent) {
              this.debugLine.parent.remove(this.debugLine);
              this.debugLine = null;
            }
          }, 1000);
        },
        
        // Player-like locomotion methods
        
        rotateTowards: function(targetDirection, dt) {
          // Get current forward direction (positive Z is forward in A-Frame)
          const currentForward = new THREE.Vector3(0, 0, 1);
          currentForward.applyQuaternion(this.el.object3D.quaternion);
          
          // Normalize target direction
          const targetDir = targetDirection.clone().normalize();
          
          // Calculate the angle between current forward and target direction
          const dot = currentForward.dot(targetDir);
          const angle = Math.acos(Math.max(-1, Math.min(1, dot))); // Clamp to avoid NaN
          
          // Check if rotation is needed
          if (angle > this.rotationTolerance) {
            // Calculate rotation axis (cross product)
            const rotationAxis = new THREE.Vector3();
            rotationAxis.crossVectors(currentForward, targetDir);
            
            // If vectors are nearly opposite, choose an arbitrary perpendicular axis
            if (rotationAxis.length() < 0.001) {
              rotationAxis.set(0, 1, 0); // Use Y-axis as fallback
            } else {
              rotationAxis.normalize();
            }
            
            // Calculate rotation amount for this frame
            const maxRotationThisFrame = this.data.rotationSpeed * dt;
            const rotationAmount = Math.min(angle, maxRotationThisFrame);
            
            // Create quaternion for this frame's rotation
            const rotationQuaternion = new THREE.Quaternion();
            rotationQuaternion.setFromAxisAngle(rotationAxis, rotationAmount);
            
            // Apply rotation to bot
            this.el.object3D.quaternion.multiplyQuaternions(rotationQuaternion, this.el.object3D.quaternion);
            this.el.object3D.quaternion.normalize();
            
            // Update physics body quaternion
            this.body.quaternion.set(
              this.el.object3D.quaternion.x,
              this.el.object3D.quaternion.y,
              this.el.object3D.quaternion.z,
              this.el.object3D.quaternion.w
            );
            
            return false; // Still rotating
          }
          
          return true; // Rotation complete
        },
        
        applyThrusterForces: function(dt) {
          // Use persistent velocity system EXACTLY like humans
          let totalThrust = new THREE.Vector3(0, 0, 0);
          
          // Simulate left and right thrusters based on navigation needs
          if (this.thrusterActive.left || this.thrusterActive.right) {
            // Get forward direction from bot orientation (positive Z is forward)
            const forwardDir = new THREE.Vector3(0, 0, 1);
            forwardDir.applyQuaternion(this.el.object3D.quaternion);
            
            // Use same incremental force system as humans
            const incrementalForce = this.data.thrusterForce * dt; // Same as humans: force * dt
            totalThrust.add(forwardDir.multiplyScalar(incrementalForce));
          }
          
          // Add to PERSISTENT velocity (same as humans)
          if (totalThrust.length() > 0) {
            this.velocity.add(totalThrust); // Add to persistent velocity accumulator
            
            // Cap maximum velocity
            if (this.velocity.length() > this.data.maxSpeed) {
              this.velocity.normalize().multiplyScalar(this.data.maxSpeed);
            }
          }
          
          // Apply damping to persistent velocity (same as humans)
          const dampingFactor = Math.pow(this.damping, dt * 60); // Frame-rate independent
          this.velocity.multiplyScalar(dampingFactor);
          
          // Stop very slow movement
          if (this.velocity.length() < this.minVelocity) {
            this.velocity.set(0, 0, 0);
          }
          
          // Apply persistent velocity to physics body
          this.body.velocity.set(this.velocity.x, this.velocity.y, this.velocity.z);
        },
        
        intelligentNavigation: function(dt) {
          const MIN_TARGET_DISTANCE = 5.0; // 5 meter minimum distance from target
          const MAX_APPROACH_DISTANCE = 3.0; // Stop approaching when this close
          
          // Find the closest visible HUMAN PLAYER (not other bots)
          let currentTarget = null;
          let targetPos = new THREE.Vector3();
          let hasLineOfSight = false;
          let closestDistance = Infinity;
          
          const botPos = new THREE.Vector3().copy(this.body.position);
          
          // Check for local player target first
          const playerTarget = document.querySelector('#player-target');
          if (playerTarget) {
            const testPos = new THREE.Vector3();
            playerTarget.object3D.getWorldPosition(testPos);
            const distance = botPos.distanceTo(testPos);
            const hasLOS = this.hasLineOfSight(botPos, testPos);
            
            if (hasLOS && distance < closestDistance) {
              currentTarget = {
                position: testPos.clone(),
                type: 'local-player',
                distance: distance
              };
              targetPos = testPos.clone();
              hasLineOfSight = true;
              closestDistance = distance;
            }
          }
          
          // Check for remote players (only if no local player or remote is closer)
          for (let i = 0; i < 4; i++) {
            const remoteTarget = document.querySelector(`#remote-target-${i}`);
            const remotePlayer = document.querySelector(`#remote-player-${i}`);
            
            if (remoteTarget && remotePlayer && remotePlayer.getAttribute('visible') !== 'false') {
              const testPos = new THREE.Vector3();
              remoteTarget.object3D.getWorldPosition(testPos);
              const distance = botPos.distanceTo(testPos);
              const hasLOS = this.hasLineOfSight(botPos, testPos);
              
              if (hasLOS && distance < closestDistance) {
                currentTarget = {
                  position: testPos.clone(),
                  type: 'remote-player',
                  distance: distance
                };
                targetPos = testPos.clone();
                hasLineOfSight = true;
                closestDistance = distance;
              }
            }
          }
          
          // Update line of sight memory
          if (currentTarget) {
            this.updateLineOfSightMemory(hasLineOfSight, currentTarget.position);
          } else {
            // No visible target - check if we should use last known position
            if (this.lineOfSightLost && this.lastKnownTargetPosition.length() > 0) {
              // Use last known position but don't update LOS memory
            } else {
              // No target at all - go idle
              this.navigationState = 'idle';
              this.thrusterActive.left = false;
              this.thrusterActive.right = false;
              return;
            }
          }
          
          // Determine navigation target
          let navigationTarget;
          if (hasLineOfSight && currentTarget) {
            // Use current visible target
            navigationTarget = currentTarget.position.clone();
          } else if (this.lineOfSightLost && this.lastKnownTargetPosition.length() > 0) {
            // Navigate to last known position
            navigationTarget = this.lastKnownTargetPosition.clone();
          } else {
            // No target - go idle
            this.navigationState = 'idle';
            this.thrusterActive.left = false;
            this.thrusterActive.right = false;
            return;
          }
          
          // Get current bot position and calculate distance/direction
          const distanceToTarget = botPos.distanceTo(navigationTarget);
          const directionToTarget = new THREE.Vector3().subVectors(navigationTarget, botPos).normalize();
          
          // Check for obstacles in path
          const hasObstacle = this.checkForObstacles(botPos, navigationTarget);
          
          // Apply collision response if colliding with environment (use raycasting like human players)
          const collisionResponse = this.checkLevelModelCollision(botPos, 0.3);
          if (collisionResponse.length() > 0) {
            // Apply collision response to bot position (same as human players)
            this.body.position.x += collisionResponse.x * dt;
            this.body.position.y += collisionResponse.y * dt;
            this.body.position.z += collisionResponse.z * dt;
            this.isColliding = true;
            
            // Stop thruster forces when colliding
            this.thrusterActive.left = false;
            this.thrusterActive.right = false;
            
            // Change navigation state to avoid obstacle
            if (this.navigationState === 'thrusting') {
              this.navigationState = 'avoiding-obstacle';
            }
          } else {
            this.isColliding = false;
          }
          
          // State machine for intelligent navigation with obstacle avoidance
          switch (this.navigationState) {
            case 'idle':
              // Start navigation if target is at appropriate distance
              if (distanceToTarget > MAX_APPROACH_DISTANCE) {
                if (hasObstacle) {
                  this.navigationState = 'avoiding-obstacle';
                  this.calculateObstacleAvoidance(botPos, navigationTarget);
                } else {
                  this.navigationState = 'rotating';
                  this.targetDirection.copy(directionToTarget);
                }
                this.thrusterActive.left = false;
                this.thrusterActive.right = false;
              }
              break;
              
            case 'rotating':
              // Rotate towards target direction (or avoidance direction)
              const rotationComplete = this.rotateTowards(this.targetDirection, dt);
              
              if (rotationComplete) {
                // Check distance before starting to thrust
                if (distanceToTarget > MIN_TARGET_DISTANCE) {
                  this.navigationState = 'thrusting';
                  this.thrusterActive.left = true;
                  this.thrusterActive.right = true;
                } else {
                  // Too close - maintain distance
                  this.navigationState = 'maintaining-distance';
                  this.thrusterActive.left = false;
                  this.thrusterActive.right = false;
                }
              }
              break;
              
            case 'thrusting':
              // Continue thrusting while monitoring for obstacles and distance
              if (distanceToTarget < MIN_TARGET_DISTANCE) {
                // Too close - stop and maintain distance
                this.navigationState = 'maintaining-distance';
                this.thrusterActive.left = false;
                this.thrusterActive.right = false;
              } else if (hasObstacle || this.isColliding) {
                // Obstacle detected - start avoidance
                this.navigationState = 'avoiding-obstacle';
                this.thrusterActive.left = false;
                this.thrusterActive.right = false;
                this.calculateObstacleAvoidance(botPos, navigationTarget);
              } else {
                // Keep rotating towards target while thrusting
                this.targetDirection.copy(directionToTarget);
                this.rotateTowards(this.targetDirection, dt);
              }
              break;
              
            case 'maintaining-distance':
              // Maintain minimum distance from target
              if (distanceToTarget < MIN_TARGET_DISTANCE - 1.0) {
                // Too close - back away
                const awayDirection = new THREE.Vector3().subVectors(botPos, navigationTarget).normalize();
                this.targetDirection.copy(awayDirection);
                this.rotateTowards(this.targetDirection, dt);
                this.thrusterActive.left = true;
                this.thrusterActive.right = true;
              } else if (distanceToTarget > MIN_TARGET_DISTANCE + 2.0) {
                // Far enough - can approach again
                this.navigationState = 'idle';
              } else {
                // Good distance - just maintain orientation
                this.thrusterActive.left = false;
                this.thrusterActive.right = false;
              }
              break;
              
            case 'avoiding-obstacle':
              // Navigate around obstacle
              const avoidanceComplete = this.rotateTowards(this.obstacleAvoidanceDirection, dt);
              
              if (avoidanceComplete) {
                // Start moving in avoidance direction
                this.thrusterActive.left = true;
                this.thrusterActive.right = true;
                
                // Check if we can see target again or if obstacle is cleared
                const clearPath = !this.checkForObstacles(botPos, navigationTarget);
                if (clearPath && distanceToTarget > MIN_TARGET_DISTANCE) {
                  this.navigationState = 'rotating';
                  this.targetDirection.copy(directionToTarget);
                }
              }
              break;
              
            case 'seeking-lost-target':
              // Navigate to last known position when LOS is lost
              if (hasLineOfSight) {
                // Regained sight - switch back to normal navigation
                this.navigationState = 'idle';
              } else if (distanceToTarget < 2.0) {
                // Reached last known position but no target - search around
                this.navigationState = 'idle';
                this.removeLastKnownPositionIndicator();
              } else {
                // Continue moving toward last known position
                this.targetDirection.copy(directionToTarget);
                const rotationComplete = this.rotateTowards(this.targetDirection, dt);
                if (rotationComplete) {
                  this.thrusterActive.left = true;
                  this.thrusterActive.right = true;
                }
              }
              break;
              
            case 'drifting':
              // Legacy state - drift for a while before starting new navigation
              const driftTime = Date.now() - this.lastCloseTime;
              if (driftTime > 3000 && distanceToTarget > MIN_TARGET_DISTANCE) {
                this.navigationState = 'idle';
              }
              break;
          }
        },
        
        // === BALL THROWING SYSTEM ===
        // This system handles physics-based ball throwing by bots
        // Separate from bullet shooting mechanics used by players
        
        throwBallAtPlayer: function() {
          // Find the best target (closest opponent with line of sight)
          const bestTarget = this.findBestTarget();
          if (!bestTarget) {
            // No target in sight - don't shoot
            return;
          }
          
          // Show debug line to the actual target we're shooting at
          const botPos = new THREE.Vector3().copy(this.body.position);
          this.hasLineOfSight(botPos, bestTarget.position, true); // Show debug line
          
          // Calculate direction to target
          const direction = new THREE.Vector3().subVectors(bestTarget.position, botPos).normalize();
          
          // Simple rotation: make bot face the target
          const targetAngle = Math.atan2(direction.x, direction.z);
          this.body.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
          
          // Get bot's forward direction after rotation
          const botForward = new THREE.Vector3(0, 0, 1);
          botForward.applyQuaternion(this.body.quaternion);
          
          // Position missile 50cm in front of bot body center
          const missilePos = botPos.clone();
          missilePos.add(botForward.clone().multiplyScalar(0.5)); // 50cm in front of bot
          
          // Create homing bullet instead of ball
          const bullet = document.createElement('a-sphere');
          bullet.setAttribute('radius', '0.1');
          bullet.setAttribute('color', '#ff0000');
          bullet.setAttribute('position', `${missilePos.x} ${missilePos.y} ${missilePos.z}`);
          bullet.setAttribute('bullet', {
            shooter: 'bot',
            speed: 4,
            lifetime: 10000,
            isHoming: true,
            targetId: bestTarget.type,
            homingForce: 5,
            explosionRadius: 1.0,
            explosionDamage: 50,
            bulletHits: 0,
            maxBulletHits: 5,
            directionX: botForward.x,
            directionY: botForward.y,
            directionZ: botForward.z
          });
          
          // Add hum sound to homing missile
          bullet.setAttribute('sound', {
            src: 'url(audio/electric-hum.wav)',
            autoplay: true,
            loop: true,
            volume: 0.3,
            positional: true,
            distanceModel: 'linear',
            refDistance: 1,
            maxDistance: 25
          });
          
          // Add to scene
          document.querySelector('a-scene').appendChild(bullet);
          
          // Debug logging - removed console spam
          
          // Missile lifecycle tracking - removed console spam
          
          // The missile's own sound component will handle the hum sound
        },
        
        tick: function(time) {
          if (!this.data.enabled) return;
          
          // Skip AI if bot is dead
          if (this.isDead) {
            // Still update visual position from physics for dead bots
            if (this.body) {
              this.el.object3D.position.copy(this.body.position);
              this.el.object3D.quaternion.copy(this.body.quaternion);
            }
            return;
          }
          
          // Performance monitoring
          const perfStart = performance.now();
          this.frameCount++;
          
          // CRITICAL: In multiplayer, only the host should run bot AI
          // Clients should only receive bot position updates
          if (isMultiplayer && activePlayers.size > 1 && !isHost) {
            // CRITICAL FIX: Clients still need to update bot visual position from physics
            // but don't run AI logic
            if (this.body) {
              this.el.object3D.position.copy(this.body.position);
              this.el.object3D.quaternion.copy(this.body.quaternion);
            }
            return; // Clients don't run bot AI
          }
          
          // Bot AI continues even when grabbed - this allows players to "hitch a ride"
          // The physics constraint will drag the player along with the bot's movement
          
          // Check if stunned and disable AI
          if (this.isStunned) {
            if (Date.now() > this.stunEndTime) {
              this.isStunned = false;

            } else {
              // While stunned, stop all movement and AI
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              this.isMoving = false;

              return; // Skip all AI processing while stunned
            }
          }
          
          // Update visual position from physics (ALWAYS - needed for smooth movement)
          this.el.object3D.position.copy(this.body.position);
          this.el.object3D.quaternion.copy(this.body.quaternion);
          
          // Keep zero gravity (ALWAYS - physics requirement)
          this.body.gravity.set(0, 0, 0);
          
          // Calculate delta time for frame-rate independent movement
          const dt = 1/60; // Assume 60 FPS for consistent behavior
          
          // PERFORMANCE OPTIMIZATION: Intelligent update frequencies
          // Adaptive frequencies based on bot speed and proximity to players
          const currentSpeed = this.body.velocity.length();
          const playerTarget = document.querySelector('#player-target');
          let distanceToPlayer = 100; // Default far distance
          
          if (playerTarget) {
            const botPos = this.body.position;
            const playerPos = new THREE.Vector3();
            playerTarget.object3D.getWorldPosition(playerPos);
            distanceToPlayer = botPos.distanceTo(playerPos);
          }
          
          // Adaptive collision detection: More frequent when moving fast or close to players
          let collisionInterval = this.collisionUpdateInterval;
          if (currentSpeed > 4.0 || distanceToPlayer < 10.0) {
            collisionInterval = 2; // Every 2 frames (45Hz) when fast/close
          } else if (currentSpeed < 1.0 && distanceToPlayer > 20.0) {
            collisionInterval = 5; // Every 5 frames (18Hz) when slow/far
          }
          
          // Adaptive navigation: More frequent when close to players or moving
          let navigationInterval = this.navigationUpdateInterval;
          if (distanceToPlayer < 15.0 || currentSpeed > 2.0) {
            navigationInterval = 5; // Every 5 frames (18Hz) when active
          } else if (currentSpeed < 0.5 && distanceToPlayer > 25.0) {
            navigationInterval = 15; // Every 15 frames (6Hz) when idle/far
          }
          
          // Adaptive player tracking: More frequent when close
          let trackingInterval = this.playerTrackingInterval;
          if (distanceToPlayer < 20.0) {
            trackingInterval = 3; // Every 3 frames (30Hz) when close
          } else if (distanceToPlayer > 30.0) {
            trackingInterval = 10; // Every 10 frames (9Hz) when far
          }
          
          // Navigation: Adaptive frequency based on activity
          if (this.frameCount % navigationInterval === 0) {
          this.intelligentNavigation(dt);
          }
          
          // Thruster forces: Every frame (needed for smooth physics)
          this.applyThrusterForces(dt);
          
          // Collision detection: Adaptive frequency based on speed and proximity
          if (this.frameCount % collisionInterval === 0) {
          this.checkAndResolveCollisions(dt);
          }
          
          // Player tracking: Adaptive frequency based on proximity
          if (this.frameCount % trackingInterval === 0) {
          this.updatePlayerTracking(time);
          }
          
          // Only shoot when match is active (like other parts of the code do)
          const gameManagerComponent = this.el.sceneEl.components['game-manager'];
          const isMatchActive = gameManagerComponent && 
                               (gameManagerComponent.gameStarted || 
                                gameManagerComponent.matchState === 'PLAYING' || 
                                gameManagerComponent.matchState === 'OVERTIME');
          
          const timeSinceLastThrow = time - this.lastThrowTime;
          const throwIntervalMet = timeSinceLastThrow > this.data.throwInterval;

          if (isMatchActive && throwIntervalMet) {
            
            // In capture mode, only throw at opponents
            if (gameMode === 'capture') {
              const playerId = myPlayerId || 'player_0';
              const botId = this.data.team === 'red' ? 'bot-red' : 'bot-blue';
              const isTeammate = areTeammates(botId, playerId);
              
              console.log(`Bot throw check: botId=${botId}, playerId=${playerId}, isTeammate=${isTeammate}, bot.data.team=${this.data.team}`);
              
              if (isTeammate) {
                this.lastThrowTime = time;
                return;
              }
            }
  
          this.throwBallAtPlayer();
          this.lastThrowTime = time;
        }
        
        // Performance monitoring
        const perfEnd = performance.now();
        const perfTime = perfEnd - perfStart;
        // Bot performance logging removed to reduce console spam
        
        // Bot optimization logging disabled to reduce console spam
      },
      
      remove: function() {
        if (this.body) {
          world.removeBody(this.body);
        }
        
        // Clean up line of sight memory indicators
        this.removeLastKnownPositionIndicator();
      }
    });

      // Goal component for team-based gameplay
      AFRAME.registerComponent('goal', {
        schema: {
          team: { type: 'string', default: 'red' }
        },
        
        init: function() {
          
          // Wait for the scene to be fully loaded before creating physics
          if (this.el.sceneEl.hasLoaded) {
            this.createPhysicsBody();
          } else {
            this.el.sceneEl.addEventListener('loaded', () => {
              this.createPhysicsBody();
            });
          }
        },
        
        createPhysicsBody: function() {
          
          // Create physics body for goal detection (vertical cylinder to match visual)
          const shape = new CANNON.Cylinder(1, 1, 0.1, 8); // radius, radius, height, segments
          this.body = new CANNON.Body({
            mass: 0, // Static body
            shape: shape,
            position: new CANNON.Vec3(
              this.el.getAttribute('position').x,
              this.el.getAttribute('position').y,
              this.el.getAttribute('position').z
            ),
            collisionFilterGroup: 8, // Goals are in group 8
            collisionFilterMask: 2   // Goals only detect balls (group 2)
          });
          
          
          // FIXED: No rotation - keep cylinder vertical to match the visual goal
          // (The visual goal is already vertical, so the collision should match)
          
          world.addBody(this.body);
          this.el.body = this.body;
          
          // NEW: Add wireframe visualization for goal collision shape (debug)
          this.addCollisionWireframe();
          
          // Listen for ball collisions
          this.body.addEventListener('collide', (evt) => {
            this.checkGoalScore(evt);
          });
          
        },
        
        // NEW: Add wireframe visualization for collision shape
        addCollisionWireframe: function() {
          // Only show wireframes in debug mode or when explicitly enabled
          const showWireframes = true; // Set to false to disable
          
          if (!showWireframes) return;
          
          // Create wireframe cylinder to match the collision shape (vertical)
          const wireframe = document.createElement('a-cylinder');
          wireframe.setAttribute('radius', '1');
          wireframe.setAttribute('height', '0.1');
          wireframe.setAttribute('rotation', '0 0 0'); // FIXED: No rotation - vertical like the visual
          wireframe.setAttribute('material', 'wireframe: true; color: #ffff00; opacity: 0.3; transparent: true');
          wireframe.setAttribute('position', '0 0 0'); // Relative to goal
          
          // Add to goal element
          this.el.appendChild(wireframe);
        },
        
        checkGoalScore: function(evt) {
          
          // Only score in capture mode
          if (gameMode !== 'capture') {
            return;
          }
          
          // Global goal scoring lock to prevent multiple goals from scoring simultaneously
          const now = Date.now();
          window.lastGlobalGoalTime = window.lastGlobalGoalTime || 0;
          const globalGoalCooldown = 1000; // 1 second global cooldown
          
          if (now - window.lastGlobalGoalTime < globalGoalCooldown) {
            return; // Another goal scored recently
          }
          
          const otherBody = evt.target === this.body ? evt.body : evt.target;
          
          // Check if the colliding object is the capture ball
          // Method 1: Check by element ID
          const isCaptureBallById = otherBody.el && otherBody.el.id === 'capture-ball';
          // Method 2: Check by physics properties (capture ball has radius 0.2, others have 0.1)
          const isCaptureBallBySize = otherBody.shape && otherBody.shape.radius === 0.2;
          
          
          if (isCaptureBallById || isCaptureBallBySize) {
            
            // Set global cooldown timestamp to prevent any other goal from scoring
            window.lastGlobalGoalTime = now;
            
            // HOST-AUTHORITATIVE SCORING: Only host updates team scores in multiplayer
            // In single player, always allow scoring
            if (isHost || !isMultiplayer) {
              // Score for the team that got the ball into the opponent's goal
              // If ball goes into red goal, blue team scores (and vice versa)
              const scoringTeam = this.data.team === 'red' ? 'blue' : 'red';
              // Team scoring removed - space shooter uses individual player scores
              
              // Update score display
              this.updateTeamScores();
              
              // Also update the multiplayer score display
              const gameManager = document.querySelector('#game-manager');
              if (gameManager && gameManager.components['game-manager']) {
                gameManager.components['game-manager'].updateMultiplayerScore();
                gameManager.components['game-manager'].sendScoreUpdate();
                gameManager.components['game-manager'].checkOvertimeWin();
              }
            } else {
              // CLIENT: Send goal hit to host for processing
              const hostConnection = connections.get('host');
              if (hostConnection && hostConnection.open) {
                hostConnection.send({
                  type: 'goal-hit',
                  goalTeam: this.data.team,
                  playerId: myPlayerId,
                  timestamp: Date.now()
                });
              }
            }
            
            // Reset capture ball to center (all players do this for immediate feedback)
            const captureBall = document.querySelector('#capture-ball');
            if (captureBall && captureBall.components['zerog-ball']) {
              captureBall.components['zerog-ball'].resetPosition();
            }
            
            // Play goal sound/effect (all players do this)
            this.playGoalEffect();
          } else {
          }
        },
        
        updateTeamScores: function() {
          // Use the dedicated blue/red score elements for consistent display
          const blueScore = document.querySelector('#blue-score');
          const redScore = document.querySelector('#red-score');
          
          // Team scores removed - space shooter uses individual player scores
          
          // Also make the score display visible
          const scoreDisplay = document.querySelector('#score-display');
          if (scoreDisplay) {
            scoreDisplay.setAttribute('visible', true);
          }
        },
        
        playGoalEffect: function() {
          // Flash the goal
          const originalColor = this.el.getAttribute('material').color;
          this.el.setAttribute('material', 'color', '#ffffff');
          setTimeout(() => {
            this.el.setAttribute('material', 'color', originalColor);
          }, 200);
          
          // Play impact sound (same as when ball hits opponent)
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            // Position sound at goal location
            const goalPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(goalPos);
            impactSound.object3D.position.copy(goalPos);
            impactSound.components.sound.playSound();
          }
          
          // Create impact animation similar to player hit
          this.createImpactAnimation();
        },
        
        createImpactAnimation: function() {
          // Create temporary impact sphere for animation
          const impactSphere = document.createElement('a-sphere');
          impactSphere.setAttribute('radius', 0.1);
          impactSphere.setAttribute('color', '#ffffff');
          impactSphere.setAttribute('material', 'opacity: 0.5; transparent: true; side: double');
          impactSphere.setAttribute('position', '0 0 0');
          
          // Add animations
          impactSphere.setAttribute('animation__grow', 
            'property: radius; from: 0.1; to: 2.0; dur: 1000; easing: easeOutQuad; autoplay: true');
          impactSphere.setAttribute('animation__fade', 
            'property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; autoplay: true');
          
          // Add to goal
          this.el.appendChild(impactSphere);
          
          // Remove after animation
          setTimeout(() => {
            if (impactSphere.parentNode) {
              impactSphere.parentNode.removeChild(impactSphere);
            }
          }, 1000);
        },
        
        remove: function() {
          if (this.body) {
            world.removeBody(this.body);
          }
        },
        
        // Damage system functions
        hitByBullet: function() {
          if (this.isDead) return;
          
          this.bulletHits++;
          
          // Check for damage milestones (every 5 hits)
          if (this.bulletHits % 5 === 0) {
            this.createDamageEffect();
          }
          
          // Check if bot is dead
          if (this.bulletHits >= this.maxBulletHits) {
            this.killBot();
          }
        },
        
        createDamageEffect: function() {
          // Create a damage effect at a random position on the bot's surface
          const botPos = this.body.position;
          const radius = 0.3; // Bot radius
          
          // Random position on sphere surface
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const effectPos = new THREE.Vector3(
            botPos.x + radius * Math.sin(phi) * Math.cos(theta),
            botPos.y + radius * Math.sin(phi) * Math.sin(theta),
            botPos.z + radius * Math.cos(phi)
          );
          
          // Create damage effect entity
          const damageEffect = document.createElement('a-entity');
          damageEffect.setAttribute('position', `${effectPos.x} ${effectPos.y} ${effectPos.z}`);
          damageEffect.setAttribute('world-spark-system', '');
          damageEffect.setAttribute('spark-smoke-controller', '');
          damageEffect.setAttribute('threejs-smoke-puffs', '');
          
          // Add to scene
          document.querySelector('a-scene').appendChild(damageEffect);
          
          // Track the effect
          this.damageEffects.push(damageEffect);
          
          // Send damage effect to other players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            const worldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(worldPos);
            sendDamageEffect(worldPos, myPlayerId);
          }
          
        },
        
        killBot: function() {
          this.isDead = true;
          this.deathTime = Date.now();
          
          
          // Create explosion effect
          this.createExplosionEffect();
          
          // Award point to team (players)
          this.awardTeamPoint();
          
          // Hide bot
          this.el.setAttribute('visible', false);
          
          // Start respawn timer
          setTimeout(() => {
            this.respawnBot();
          }, this.respawnTime);
        },
        
        createExplosionEffect: function() {
          const botPos = this.body.position;
          
          // Create explosion effect
          const explosionEffect = document.createElement('a-entity');
          explosionEffect.setAttribute('position', `${botPos.x} ${botPos.y} ${botPos.z}`);
          explosionEffect.setAttribute('impact-spark-burst', '');
          explosionEffect.setAttribute('impact-smoke-controller', '');
          explosionEffect.setAttribute('threejs-smoke-puffs', '');
          
          // Add to scene
          document.querySelector('a-scene').appendChild(explosionEffect);
          
          // Play explosion sound
          const explosionSound = document.querySelector('#impact-sound');
          if (explosionSound) {
            explosionSound.object3D.position.copy(botPos);
            explosionSound.components.sound.playSound();
          }
          
          // Remove explosion effect after 5 seconds
          setTimeout(() => {
            if (explosionEffect.parentNode) {
              explosionEffect.parentNode.removeChild(explosionEffect);
            }
          }, 5000);
        },
        
        awardTeamPoint: function() {
          // Award point to team (players)
          const scoreElements = document.querySelectorAll('#hud-score a-entity');
          if (scoreElements.length > 0) {
            const playerScoreEl = scoreElements[0];
            const currentText = playerScoreEl.getAttribute('text').value;
            const currentScore = parseInt(currentText) || 0;
            const newScore = currentScore + 1;
            playerScoreEl.setAttribute('text', 'value', newScore.toString());
          }
        },
        
        respawnBot: function() {
          
          // Reset damage
          this.bulletHits = 0;
          this.isDead = false;
          
          // Send bot respawn state to other players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            const respawnPos = this.body.position;
            const botSelector = '#' + this.el.id;
            console.log('🤖 Sending bot respawn state:', botSelector, respawnPos);
            sendBotDamageState(botSelector, 0, false, true, respawnPos);
          }
          
          // Clean up damage effects
          this.damageEffects.forEach(effect => {
            if (effect.parentNode) {
              effect.parentNode.removeChild(effect);
            }
          });
          this.damageEffects = [];
          
          // Reset position
          this.body.position.set(
            this.initialPosition.x,
            this.initialPosition.y,
            this.initialPosition.z
          );
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          
          // Show bot
          this.el.setAttribute('visible', true);
          
        }
      });

      // Player Damage System Component
      AFRAME.registerComponent('player-damage', {
        schema: {
          missileHits: { type: 'number', default: 0 },
          maxMissileHits: { type: 'number', default: 5 },
          isDead: { type: 'boolean', default: false },
          respawnTime: { type: 'number', default: 5000 }
        },
        
        init: function() {
          this.missileHits = 0;
          this.maxMissileHits = 5;
          this.isDead = false;
          this.respawnTime = 5000;
          this.deathTime = 0;
          // Set initial spawn position (center of the level)
          this.initialPosition = new THREE.Vector3(0, 0, 0);
          
          // Create damage bar in HUD
          this.createDamageBar();
        },
        
        createDamageBar: function() {
          // Check if damage bar already exists
          if (document.querySelector('#damage-bar-container')) {
            return; // Already created
          }
          
          // Find the camera (HUD parent)
          const camera = document.querySelector('[camera]');
          if (!camera) {
            console.warn('Camera not found - cannot create damage bar');
            return;
          }
          
          // Create damage bar container
          const damageBarContainer = document.createElement('a-entity');
          damageBarContainer.id = 'damage-bar-container';
          damageBarContainer.setAttribute('position', '0 -0.35 -0.5');
          damageBarContainer.setAttribute('geometry', 'primitive: plane; width: 0.4; height: 0.05');
          damageBarContainer.setAttribute('material', 'color: #333333; opacity: 0.8; transparent: true');
          
          // Create damage bar
          const damageBar = document.createElement('a-entity');
          damageBar.id = 'damage-bar';
          damageBar.setAttribute('position', '0 0 0.01');
          damageBar.setAttribute('geometry', 'primitive: plane; width: 0.38; height: 0.04');
          damageBar.setAttribute('material', 'color: #00ff00; opacity: 0.9; transparent: true');
          
          // Create damage text
          const damageText = document.createElement('a-text');
          damageText.id = 'damage-text';
          damageText.setAttribute('value', 'Health: 100%');
          damageText.setAttribute('position', '0 0 0.02');
          damageText.setAttribute('align', 'center');
          damageText.setAttribute('color', '#ffffff');
          damageText.setAttribute('width', '0.8');
          
          damageBarContainer.appendChild(damageBar);
          damageBarContainer.appendChild(damageText);
          camera.appendChild(damageBarContainer);
          
          console.log('✅ Damage bar created successfully');
        },
        
        hitByMissile: function() {
          if (this.isDead) return;
          
          this.missileHits++;
          
          // Send player hit state to other players in multiplayer (for every hit)
          if (isMultiplayer && activePlayers.size > 1) {
            // Send player damage state synchronization
            const playerDamageData = {
              type: 'player-damage-state',
              playerId: myPlayerId,
              missileHits: this.missileHits,
              isDead: this.isDead,
              timestamp: Date.now()
            };
            
            // Send to all connected players
            if (isHost) {
              connections.forEach(conn => {
                if (conn.open) {
                  conn.send(playerDamageData);
                }
              });
            } else {
              // Client sends to host, who will broadcast to all
              const hostConnection = connections.get('host');
              if (hostConnection && hostConnection.open) {
                hostConnection.send(playerDamageData);
              }
            }
          }
          
          // Update damage bar
          this.updateDamageBar();
          
          // Create hit effect for each missile hit
          const playerPos = this.el.object3D.position;
          const radius = 0.2; // Player radius
          
          // Random position on sphere surface (relative to player)
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const effectPos = new THREE.Vector3(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
          
          // Create looping spark+smoke animation for each missile hit (player damage state)
          const hitEffect = document.createElement('a-entity');
          hitEffect.setAttribute('position', `${effectPos.x} ${effectPos.y} ${effectPos.z}`);
          hitEffect.setAttribute('world-spark-system', '');
          hitEffect.setAttribute('spark-smoke-controller', '');
          hitEffect.setAttribute('threejs-smoke-puffs', '');
          
          // Add as child of player entity so it moves with the player
          this.el.appendChild(hitEffect);
          
          // Track the effect
          if (!this.damageEffects) this.damageEffects = [];
          this.damageEffects.push(hitEffect);
          
          // Send damage effect to other players in multiplayer (for each missile hit)
          if (isMultiplayer && activePlayers.size > 1) {
            const worldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(worldPos);
            sendDamageEffect(worldPos, myPlayerId);
          }
          
          // Each missile hit creates a looping spark+smoke animation (no milestones needed)
          
          // Play metal hit sound (not explosion sound)
          const metalHitSounds = [
            document.querySelector('#metal-hit-sound-1'),
            document.querySelector('#metal-hit-sound-2'),
            document.querySelector('#metal-hit-sound-3')
          ];
          const randomSound = metalHitSounds[Math.floor(Math.random() * metalHitSounds.length)];
          if (randomSound) {
            const playerWorldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(playerWorldPos);
            randomSound.object3D.position.copy(playerWorldPos);
            randomSound.components.sound.playSound();
            
            // Send hit sound to other players in multiplayer
            if (isMultiplayer && activePlayers.size > 1) {
              sendHitSound(playerWorldPos, randomSound.id, myPlayerId);
            }
          }
          
          // Check if player is dead
          if (this.missileHits >= this.maxMissileHits) {
            this.killPlayer();
          }
        },
        
        updateDamageBar: function() {
          const damageBar = document.querySelector('#damage-bar');
          const damageText = document.querySelector('#damage-text');
          
          if (!damageBar || !damageText) {
            console.warn('Damage bar elements not found');
            return;
          }
          
          const healthPercent = ((this.maxMissileHits - this.missileHits) / this.maxMissileHits) * 100;
          const barWidth = (healthPercent / 100) * 0.38; // Scale to 0.38 units width (max width)
          
          // Update bar width and color
          damageBar.setAttribute('geometry', 'primitive: plane; width: ' + barWidth + '; height: 0.04');
          
          // Change color based on health
          let color = '#00ff00'; // Green
          if (healthPercent < 60) color = '#ffff00'; // Yellow
          if (healthPercent < 30) color = '#ff0000'; // Red
          
          damageBar.setAttribute('material', 'color: ' + color + '; opacity: 0.9; transparent: true');
          
          // Update text
          damageText.setAttribute('value', `Health: ${Math.round(healthPercent)}%`);
        },
        
        killPlayer: function() {
          console.log('💀 Player killed!');
          this.isDead = true;
          this.isStunned = true;
          this.deathTime = Date.now();
          
          // Disable all player controls
          this.disablePlayerControls();
          
          // Play explosion effect using the existing impact-effect component
          // The impact-effect is on the player-target element, not the main player entity
          const playerTarget = document.querySelector('#player-target');
          console.log('💀 Player target found:', playerTarget);
          if (playerTarget && playerTarget.components['impact-effect']) {
            playerTarget.components['impact-effect'].playEffect();
            console.log('💀 Playing local explosion animation');
            
            // Send explosion effect to other players in multiplayer
            if (isMultiplayer && activePlayers.size > 1) {
              console.log('💀 Sending explosion effect to other players');
              sendExplosionEffect('#player-target', myPlayerId);
            }
          }
          
          // Award point to bots
          this.awardBotPoint();
          
          // Hide player
          this.el.setAttribute('visible', false);
          
          // Start respawn timer
          setTimeout(() => {
            this.respawnPlayer();
          }, this.respawnTime);
        },
        
        awardBotPoint: function() {
          // Award point to bots (host authority)
          if (isHost) {
            const gameManager = document.querySelector('#game-manager');
            if (gameManager && gameManager.components['game-manager']) {
              gameManager.components['game-manager'].awardBotKill();
            }
          }
        },
        
        respawnPlayer: function() {
          // Reset damage
          this.missileHits = 0;
          this.isDead = false;
          this.isStunned = false;
          
          // Re-enable all player controls
          this.enablePlayerControls();
          
          // Clean up damage effects
          if (this.damageEffects) {
            this.damageEffects.forEach(effect => {
              if (effect.parentNode) {
                effect.parentNode.removeChild(effect);
              }
            });
            this.damageEffects = [];
          }
          
          // Reset position
          this.el.object3D.position.copy(this.initialPosition);
          
          // Show player
          this.el.setAttribute('visible', true);
          
          // Update damage bar
          this.updateDamageBar();
          
          // Send player respawn state to other players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            const playerRespawnData = {
              type: 'player-damage-state',
              playerId: myPlayerId,
              missileHits: 0,
              isDead: false,
              respawn: true,
              timestamp: Date.now()
            };
            
            // Send to all connected players
            if (isHost) {
              connections.forEach(conn => {
                if (conn.open) {
                  conn.send(playerRespawnData);
                }
              });
          } else {
              // Client sends to host, who will broadcast to all
              const hostConnection = connections.get('host');
              if (hostConnection && hostConnection.open) {
                hostConnection.send(playerRespawnData);
              }
            }
          }
        },
        
        disablePlayerControls: function() {
          console.log('🚫 Disabling player controls - stunned state');
          
          // Disable movement controls
          const playerComponent = this.el.components['zerog-player'];
          if (playerComponent) {
            playerComponent.isStunned = true;
          }
          
          // Disable shooting controls
          const leftHand = document.querySelector('#left-hand');
          const rightHand = document.querySelector('#right-hand');
          
          if (leftHand) {
            leftHand.setAttribute('shoot', 'enabled', false);
          }
          if (rightHand) {
            rightHand.setAttribute('shoot', 'enabled', false);
          }
          
          // Add visual stunned effect
          this.el.setAttribute('material', 'opacity', 0.5);
        },
        
        enablePlayerControls: function() {
          console.log('✅ Re-enabling player controls - respawned');
          
          // Re-enable movement controls
          const playerComponent = this.el.components['zerog-player'];
          if (playerComponent) {
            playerComponent.isStunned = false;
          }
          
          // Re-enable shooting controls
          const leftHand = document.querySelector('#left-hand');
          const rightHand = document.querySelector('#right-hand');
          
          if (leftHand) {
            leftHand.setAttribute('shoot', 'enabled', true);
          }
          if (rightHand) {
            rightHand.setAttribute('shoot', 'enabled', true);
          }
          
          // Remove visual stunned effect
          this.el.setAttribute('material', 'opacity', 1.0);
        }
      });

      // Game manager component for zero-g multiplayer
      // Add glow component (copied from index.html)
      AFRAME.registerComponent('glow', {
        schema: {
          color: {default: '#ffffff', type: 'color'},
          intensity: {default: 1.0}
        },
        init: function () {
          this.el.addEventListener('object3dset', this.update.bind(this));
          this.el.addEventListener('material-loaded', this.update.bind(this));
        },
        update: function () {
          const data = this.data;
          if (!this.el.object3D) return;
          
          this.el.object3D.traverse(function (node) {
            if (node.isMesh && node.material) {
              if (!node.material.emissive) {
                node.material.emissive = new THREE.Color(data.color);
              } else {
                node.material.emissive.copy(new THREE.Color(data.color));
              }
              node.material.emissiveIntensity = data.intensity;
            }
          });
        }
      });


      // Add sound manager component
      AFRAME.registerComponent('sound-manager', {
        init: function() {
          this.ballSounds = [];
          this.soundsInitialized = false;
          
          // Get all ball sounds
          this.el.sceneEl.querySelectorAll('[zerog-ball]').forEach(ball => {
            const sound = ball.querySelector('[sound]');
            if (sound) {
              this.ballSounds.push(sound);
              // Initially pause all sounds
              sound.components.sound.pauseSound();
            }
          });
          
          // Get bounce sound
          this.bounceSound = this.el.sceneEl.querySelector('#bounce-sound');
          if (this.bounceSound) {
            this.bounceSound.components.sound.pauseSound();
          }
          
          // Listen for game start
          this.el.sceneEl.addEventListener('gameStarted', () => {
            this.initializeSounds();
          });
          
          // Try to start sounds on first user interaction (helps with autoplay restrictions)
          this.el.sceneEl.addEventListener('abuttondown', () => {
            this.tryStartSounds();
          });
        },
        
        initializeSounds: function() {
          if (this.soundsInitialized) return;
          
          
          // Resume AudioContext
          const audioContext = this.el.sceneEl.audioContext;
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          // Start all ball hum sounds
          this.ballSounds.forEach((sound, index) => {
            if (sound.id && (sound.id === 'red-ball-hum' || sound.id === 'blue-ball-hum')) {
              try {
                sound.components.sound.playSound();
              } catch (e) {
              }
            }
          });
          
          // Initialize bounce sound
          if (this.bounceSound) {
            try {
              this.bounceSound.components.sound.playSound();
              this.bounceSound.components.sound.pauseSound();
            } catch (e) {
            }
          }
          
          this.soundsInitialized = true;
        },
        
        // Add method to try starting sounds immediately on user interaction
        tryStartSounds: function() {
          this.initializeSounds();
        }
      });

      AFRAME.registerComponent('game-manager', {
        schema: {
          playerScore: { type: 'number', default: 0 },
          opponentScore: { type: 'number', default: 0 },
          gameStarted: { type: 'boolean', default: false }
        },
        init: function() {
          this.playerScore = 0;
          this.opponentScore = 0;
          this.gameStarted = false;
          
          // Match states: WAITING, COUNTDOWN, PLAYING, OVERTIME, ENDED
          this.matchState = 'WAITING';
          this.matchDuration = 180; // 3 minutes in seconds
          this.matchStartTime = 0;
          this.countdownTime = 3;
          this.countdownStartTime = 0;
          
          // K/D Stats for up to 4 players: [kills, deaths] for each player
          this.playerStats = [
            {kills: 0, deaths: 0}, // Player 0
            {kills: 0, deaths: 0}, // Player 1  
            {kills: 0, deaths: 0}, // Player 2
            {kills: 0, deaths: 0}  // Player 3
          ];
          this.playerScores = [0, 0, 0, 0]; // Keep for compatibility
          this.playerReadyStates = [false, false, false, false];
          
          // Get references to the HUD displays
          this.scoreDisplay = this.el.querySelector('#score-display');
          this.startMessage = document.querySelector('#hud-message');
          this.timerDisplay = document.querySelector('#hud-timer');
          
          // Show initial message in HUD
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.updateStartMessage();
          }
          
          // Hide score and timer displays initially
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
          // A button no longer controls match start - host controls via menu
          // Keep A button for other interactions if needed in the future
        },
        
        startMatchWithBots: function() {
          // Start match immediately with current players + bots to fill to correct total based on game mode
          const humanPlayerCount = isMultiplayer ? activePlayers.size : 1;
          
          // Ensure we have the correct number of total players (humans + bots) based on game mode
          manageActivePlayersAndBots();
          
          // Start countdown immediately
                this.startCountdown();
          
          // Send match start message to all connected players
          if (isMultiplayer && isHost) {
            const data = {
              type: 'match-start',
              timestamp: Date.now()
            };
            
            connections.forEach(conn => {
              if (conn && conn.open) {
                conn.send(data);
              }
            });
          }
        },
        
        updateStartMessage: function() {
          if (!this.startMessage) return;
          
          // CRITICAL: NEVER show HUD messages when menu is open
          const menuVisible = getMenuVisibility();
          if (menuVisible) {
            this.startMessage.setAttribute('visible', false);
            return;
          }
          
          // Only show messages when waiting and menu is closed
          if (this.matchState === 'WAITING') {
            if (isMultiplayer) {
              if (isHost) {
                this.startMessage.setAttribute('text', 'value', 'Press X to open menu and start match');
              } else {
                this.startMessage.setAttribute('text', 'value', 'Waiting for host to start match...');
              }
            } else {
              // Singleplayer
              this.startMessage.setAttribute('text', 'value', 'Press X to open menu and start match');
            }
            this.startMessage.setAttribute('visible', true);
          } else {
            // Hide message during ANY active match state
            this.startMessage.setAttribute('visible', false);
          }
        },

        tick: function() {
          const currentTime = Date.now();
          
          if (this.matchState === 'COUNTDOWN') {
            const elapsed = (currentTime - this.countdownStartTime) / 1000;
            const remaining = Math.ceil(this.countdownTime - elapsed);
            
            if (remaining > 0) {
              this.startMessage.setAttribute('text', 'value', remaining.toString());
            } else {
              this.startMessage.setAttribute('text', 'value', 'GO!');
              
              // CRITICAL FIX: Prevent multiple setTimeout calls by using a flag
              if (!this.matchStartScheduled) {
                this.matchStartScheduled = true;
                
                setTimeout(() => {
                  // CRITICAL FIX: Only host should call startMatch and sync to clients
                  if (!isMultiplayer || isHost) {
                    const matchStartTime = Date.now();
                    this.startMatch(matchStartTime);
                    
                    // Send match start sync to all clients
                    if (isMultiplayer && isHost) {
                      console.log('📡 HOST sending match-start-sync to', connections.size, 'clients');
                      connections.forEach((conn, playerId) => {
                        if (conn && conn.open) {
                          conn.send({ 
                            type: 'match-start-sync', 
                            matchStartTime: matchStartTime 
                          });
                        }
                      });
                    }
                  }
                  // Clients will receive match-start-sync message and start their match
                }, 500);
              }
            }
          } else if (this.matchState === 'PLAYING') {
            this.updateTimer();
          }
        },

        handleMultiplayerReady: function() {
          // Mark local player as ready
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            this.playerReadyStates[playerIndex] = true;
            readyStates[playerIndex] = true;
            
            // Send ready update to all connected players
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({
                  type: 'ready-update',
                  playerIndex: playerIndex,
                  ready: true
                });
              }
            });
          } else {
            // Fallback: if myPlayerId is not set but we're the host, assume player_0
            if (isHost) {
              this.playerReadyStates[0] = true;
              readyStates[0] = true;
            }
          }
          this.updateReadyState();
        },

        updateReadyState: function() {
          const minPlayers = 2; // Both modes need at least 2 players
          const maxPlayers = 4; // Both modes use 4 players total
          
          if (!isMultiplayer) {
            // Single player mode - shouldn't reach here
            return;
          }
          
          // In multiplayer lobbies, allow solo starts but show appropriate message
          if (activePlayers.size < minPlayers) {
            const needed = minPlayers - activePlayers.size;
            this.startMessage.setAttribute('text', 'value', `Press A to start solo or wait for ${needed} more player(s)...`);
            // Don't return - allow solo start to proceed
          } else {
            // Enough players for normal multiplayer
            this.startMessage.setAttribute('text', 'value', `Press A when ready...`);
          }
          
          // CRITICAL FIX: Only count ready states for active players
          let readyCount = 0;
          activePlayers.forEach(playerId => {
            const playerIndex = parseInt(playerId.split('_')[1]);
            if (this.playerReadyStates[playerIndex]) {
              readyCount++;
            }
          });
          
          const totalPlayers = activePlayers.size;
          
          if (readyCount < totalPlayers) {
            const waitingMessage = this.matchState === 'ENDED' 
              ? `Waiting for ${totalPlayers - readyCount} more player(s) to restart...`
              : `Waiting for ${totalPlayers - readyCount} more player(s)...`;
            this.startMessage.setAttribute('text', 'value', waitingMessage);
          } else if (readyCount === totalPlayers) {
            // All players ready - start countdown
            const startTime = Date.now();
            this.syncedStartCountdown(startTime);
            // Send countdown sync to all players
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'countdown-start', startTime: startTime });
              }
            });
          }
        },

        setMultiplayerWaiting: function() {
          this.matchState = 'WAITING';
          this.gameStarted = false;
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Show start message only if menu is not visible
          if (this.startMessage) {
            const menuVisible = getMenuVisibility();
            this.startMessage.setAttribute('visible', !menuVisible);
            this.updateStartMessage();
          }
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          
        },

        syncedStartCountdown: function(startTime) {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = startTime;
          this.matchStartScheduled = false; // Reset flag for new countdown
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset ready states
          multiplayerReady.local = false;
          multiplayerReady.remote = false;
          
          // Reset and respawn balls
          this.respawnBalls();
          
        },

        startCountdown: function() {
          this.matchState = 'COUNTDOWN';
          this.countdownStartTime = Date.now();
          this.matchStartScheduled = false; // Reset flag for new countdown
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', '3');
          }
          
          // Reset and respawn balls
          this.respawnBalls();
          
          // Match countdown started
        },

        startMatch: function(matchStartTime) {
          this.matchState = 'PLAYING';
          this.matchStartTime = matchStartTime || Date.now(); // Use provided time or current time as fallback
          this.gameStarted = true;
          
          // SPACE SHOOTER: Reset K/D stats at match start
          for (let i = 0; i < 4; i++) {
            this.playerStats[i].kills = 0;
            this.playerStats[i].deaths = 0;
            this.playerScores[i] = 0;
          }
          
          // Immediately update timer to show initial time
          this.updateTimer();
          
          // Hide start message, show game UI
          if (this.startMessage) this.startMessage.setAttribute('visible', false);
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', true);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', true);
          
          // Show HUD score display, hide controls
          setGameplayHUD(true);
          
          // Update K/D display immediately
          this.updateMultiplayerScore();
          
          // Reset scores
          this.playerScore = 0;
          this.opponentScore = 0;
          
          // Team scores removed - space shooter uses individual player scores
          
          // Update score display to show 0-0 at match start
          this.updateMultiplayerScore();
          
          // Ensure HUD elements are properly shown during match
          setTimeout(() => {
            setGameplayHUD(true);
            this.updateMultiplayerScore();
            // Explicitly ensure timer is visible during match
            if (this.timerDisplay) {
              this.timerDisplay.setAttribute('visible', true);
              // Update timer immediately to show current time
              this.updateTimer();
            }
          }, 100);
          
          // Reset multiplayer scores
          if (isMultiplayer) {
            this.playerScores = [0, 0, 0, 0];
          }
          
          this.updateScore();
          
          // NEW: Activate tractor beam for 2 seconds at start
          this.activateStartTractorBeam();
          
          // Dispatch game started event to trigger sound initialization
          this.el.sceneEl.emit('gameStarted');
          
          // Zero-G match started
        },
        
        // NEW: Activate tractor beam for player's ball at start
        activateStartTractorBeam: function() {
          // Get the current player's ball number
          let playerBallNumber = 2; // Default for singleplayer
          if (isMultiplayer && myPlayerId) {
            playerBallNumber = getBallForPlayer(myPlayerId);
          }
          
          const playerBall = document.querySelector(`[zerog-ball*="player: player${playerBallNumber}"]`);
          if (playerBall && playerBall.components['zerog-ball']) {
            // Auto-return removed for space shooter
            // Start tractor beam activated
          }
        },

        updateTimer: function() {
          if (!this.timerDisplay) return;
          
          const currentTime = Date.now();
          const elapsed = (currentTime - this.matchStartTime) / 1000;
          const remaining = Math.max(0, this.matchDuration - elapsed);
          
          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.timerDisplay.setAttribute('text', 'value', `Time: ${timeString}`);
          
          // Check if time is up
          if (remaining <= 0 && this.matchState === 'PLAYING') {
            // Use correct scores based on game mode
            let score1, score2;
            if (gameMode === 'capture') {
              // Team scores removed - space shooter always uses player scores
              score1 = this.playerScores[0] || 0;
              score2 = this.playerScores[1] || 0;
            } else {
              // In dodge mode, use player scores
            if (isMultiplayer && activePlayers.size > 1) {
              score1 = this.playerScores[0];
              score2 = this.playerScores[1];
            } else {
              score1 = this.playerScore;
              score2 = this.opponentScore;
              }
            }
            
            if (score1 === score2) {
              this.startOvertime();
            } else {
              this.endMatch();
            }
          }
        },

        startOvertime: function() {
          this.matchState = 'OVERTIME';
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'OVERTIME - Next hit wins!');
          }
          
          // Sync overtime state in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'game-state', state: 'OVERTIME' });
              }
            });
          }
        },

        endMatch: function() {
          this.matchState = 'ENDED';
          this.gameStarted = false;
          
          // Reset ready states for restart
          this.playerReadyStates = [false, false, false, false];
          readyStates = [false, false, false, false];
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Determine winner
          let winner;
          if (gameMode === 'capture') {
            // Team scores removed - space shooter always uses player scores
            if (this.playerScores[0] > this.playerScores[1]) {
              winner = 'Player 1 wins!';
            } else if (this.playerScores[1] > this.playerScores[0]) {
              winner = 'Player 2 wins!';
            } else {
              winner = 'Tie game!';
            }
          } else {
            // In dodge mode, use original logic
          if (isMultiplayer && activePlayers.size > 1) {
            if (myPlayerId) {
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              const myScore = this.playerScores[playerIndex];
              const otherScores = this.playerScores.filter((score, index) => index !== playerIndex);
              const maxOtherScore = Math.max(...otherScores);
              winner = myScore > maxOtherScore ? 'You win!' : 'Opponent wins!';
            } else {
              winner = 'Game ended';
            }
          } else {
            winner = this.playerScore > this.opponentScore ? 'Player wins!' : 'Opponent wins!';
            }
          }
          
          // Show end message
          if (this.startMessage) {
            this.startMessage.setAttribute('visible', true);
            this.startMessage.setAttribute('text', 'value', `${winner}\nPress A to play again`);
          }
          if (this.timerDisplay) {
            this.timerDisplay.setAttribute('text', 'value', 'Match ended');
          }
          
          // Sync end state in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send({ type: 'game-state', state: 'ENDED', winner: winner });
              }
            });
          }
          
        },

        resetMatch: function() {
          this.matchState = 'WAITING';
          this.playerScore = 0;
          this.opponentScore = 0;
          
          // Team scores removed - space shooter uses individual player scores
          
          // Update score display
          if (gameMode === 'capture') {
            // Find a goal component to call updateTeamScores
            const redGoal = document.querySelector('[goal="team: red"]');
            if (redGoal && redGoal.components.goal) {
              redGoal.components.goal.updateTeamScores();
            }
          }
          this.gameStarted = false;
          
          // Hide HUD score display, show controls
          setGameplayHUD(false);
          
          // Reset multiplayer scores and ready states
          if (isMultiplayer) {
            this.playerScores = [0, 0, 0, 0];
            this.playerReadyStates = [false, false, false, false];
            readyStates = [false, false, false, false];
          }
          
          // Hide game UI, show start message only if menu is not visible
          if (this.scoreDisplay) this.scoreDisplay.setAttribute('visible', false);
          if (this.timerDisplay) this.timerDisplay.setAttribute('visible', false);
          if (this.startMessage) {
            // Only show start message if menu is not currently open
            const menuVisible = getMenuVisibility();
            this.startMessage.setAttribute('visible', !menuVisible);
            this.updateStartMessage();
          }
          
        },

        respawnBalls: function() {
          // Reset all balls to their spawn positions
          for (let i = 1; i <= 4; i++) {
            const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
            if (ball && ball.components['zerog-ball']) {
              ball.components['zerog-ball'].resetPosition();
            }
          }
          
          // Zero-G balls respawned
        },

        updateMultiplayerScore: function() {
          // Update score display for multiplayer - use individual player scores
          if (this.scoreDisplay) {
            const scoreText = this.playerScores.join(' - ');
            this.scoreDisplay.setAttribute('text', 'value', scoreText);
          }
          
          // CRITICAL FIX: Update HUD score display for the current player
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            const myScore = this.playerScores[playerIndex] || 0;
            const otherScores = this.playerScores.filter((score, index) => index !== playerIndex);
            const maxOtherScore = Math.max(...otherScores, 0);
            updateHUDScore(myScore, maxOtherScore, true);
          }
          
          // SPACE SHOOTER: Also update K/D display for player 0 (legacy)
          const blueScore = document.querySelector('#blue-score');
          const redScore = document.querySelector('#red-score');
          
          if (blueScore && this.playerStats[0]) {
            const kills = this.playerStats[0].kills;
            blueScore.setAttribute('text', 'value', `${kills}`);
            blueScore.setAttribute('text', 'color', '#00ff00'); // Green for kills
          }
          if (redScore && this.playerStats[0]) {
            const deaths = this.playerStats[0].deaths;
            redScore.setAttribute('text', 'value', `${deaths}`);
            redScore.setAttribute('text', 'color', '#ff0000'); // Red for deaths
          }
          
          // Make the score display visible
          const scoreDisplay = document.querySelector('#score-display');
          if (scoreDisplay) {
            scoreDisplay.setAttribute('visible', true);
          }
          
          // Update HUD to show K/D stats
          const hudScore = document.querySelector('#hud-score');
          if (hudScore) {
            // Ensure HUD is visible during match and update content
            hudScore.setAttribute('visible', true);
            
            const leftScoreEl = hudScore.children[0];
            const rightScoreEl = hudScore.children[1];
            
            if (leftScoreEl && rightScoreEl) {
              // Show K/D in HUD
              leftScoreEl.setAttribute('text', 'value', `K:${this.playerStats[0].kills}`);
              leftScoreEl.setAttribute('text', 'color', '#00ff00');
              rightScoreEl.setAttribute('text', 'value', `D:${this.playerStats[0].deaths}`);
              rightScoreEl.setAttribute('text', 'color', '#ff0000');
            }
          }
          
          // Legacy dodge mode logic (simplified)
          if (gameMode !== 'capture') {
            // In dodge mode, use individual player scores
          if (this.scoreDisplay) {
            const scoreText = this.playerScores.join(' - ');
            this.scoreDisplay.setAttribute('text', 'value', scoreText);
          }
          
            // Update HUD score display for dodge mode
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            const myScore = this.playerScores[playerIndex];
            const otherScores = this.playerScores.filter((score, index) => index !== playerIndex);
            const maxOtherScore = Math.max(...otherScores);
            updateHUDScore(myScore, maxOtherScore, true);
            }
          }
        },

        sendScoreUpdate: function() {
          // Send score update to all connected players
          connections.forEach((conn, playerId) => {
            if (conn && conn.open) {
              const scoreData = {
                type: 'score-update',
                scores: this.playerScores
              };
              
              // Team scores removed - space shooter uses individual player scores
              
              conn.send(scoreData);
            }
          });
        },

        awardBotKill: function() {
          // Award point to player who destroyed the bot (host authority)
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            return;
          }
          
          // Find the player who shot the bot (this will be set by the bullet collision system)
          // For now, award to the local player (this should be improved to track the actual shooter)
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            this.playerScores[playerIndex] += 1;
            this.updateMultiplayerScore();
            this.sendScoreUpdate();
          }
        },

        onPlayerHit: function() {
          // SPACE SHOOTER: Player scores when hitting bot
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastPlayerHitTime = this.lastPlayerHitTime || 0;
          this.playerHitCooldown = this.playerHitCooldown || 500; // 0.5 second cooldown
          
          if (now - this.lastPlayerHitTime < this.playerHitCooldown) {
            return;
          }
          
          this.lastPlayerHitTime = now;
          
          if (isMultiplayer && activePlayers.size > 1) {
            // CRITICAL FIX: All multiplayer scoring is now handled via hit-effect system
            // This ensures host-authoritative scoring for all players
            // The hit-effect will be sent via sendHitEffect() and processed by handleHitEffect()
            } else {
            // SINGLEPLAYER: Use legacy scoring system
            this.playerStats[0].kills += 1;
            this.playerScores[0] = this.playerStats[0].kills;
            this.playerScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.checkOvertimeWin();
          }
        },

        onOpponentHit: function() {
          if (this.matchState !== 'PLAYING' && this.matchState !== 'OVERTIME') {
            return;
          }
          
          // Prevent rapid multiple hits with cooldown system
          const now = Date.now();
          this.lastOpponentHitTime = this.lastOpponentHitTime || 0;
          this.opponentHitCooldown = this.opponentHitCooldown || 1000; // 1 second cooldown
          
          if (now - this.lastOpponentHitTime < this.opponentHitCooldown) {
            return;
          }
          
          this.lastOpponentHitTime = now;
          
          if (isMultiplayer && activePlayers.size > 1) {
            // HOST-AUTHORITATIVE SCORING: Only host handles scoring logic
            if (isHost && myPlayerId) {
              const playerIndex = parseInt(myPlayerId.split('_')[1]);
              this.playerStats[playerIndex].deaths += 1;
              console.log(`🎯 HOST onOpponentHit: Player ${playerIndex} deaths updated to ${this.playerStats[playerIndex].deaths}`);
              // Note: Deaths don't affect score in space shooter, only kills do
              this.updateMultiplayerScore();
              this.sendScoreUpdate();
            } else {
              console.log(`🎯 CLIENT onOpponentHit: Ignoring - host handles scoring`);
            }
          } else {
            // SINGLEPLAYER: Use legacy scoring system
            this.playerStats[0].deaths += 1;
            this.opponentScore += 1;
            this.updateScore();
          }
          
          // Check for overtime win
          if (this.matchState === 'OVERTIME') {
            this.checkOvertimeWin();
          }
        },

        updateScore: function() {
          if (isMultiplayer && activePlayers.size > 1) {
            // Use the new player-based scoring system
            this.updateMultiplayerScore();
          } else {
            // In singleplayer, player is blue, opponent is red
            const blueScore = document.getElementById('blue-score');
            const redScore = document.getElementById('red-score');
            if (blueScore && redScore) {
              blueScore.setAttribute('text', 'value', this.playerScore.toString());
              redScore.setAttribute('text', 'value', this.opponentScore.toString());
            }
            // Update HUD score display
            updateHUDScore(this.playerScore, this.opponentScore, false);
          }
        },

        checkOvertimeWin: function() {
          // Only check in overtime
          if (this.matchState !== 'OVERTIME') return;

          if (gameMode === 'capture') {
            // Team scores removed - space shooter uses individual player scores
            if (this.playerScores[0] !== this.playerScores[1]) {
              this.endMatch();
            }
          } else {
            // In dodge mode, check player scores (multiplayer only)
          if (!isMultiplayer || activePlayers.size < 2) return;

          // Find the highest score and how many players have it
          const maxScore = Math.max(...this.playerScores);
          const winners = this.playerScores.filter(score => score === maxScore).length;

          // If only one player has the highest score, end the match
          if (winners === 1) {
            this.endMatch();
            }
          }
        },
        
      });

      // Level Physics Component - Creates CannonJS collision from 3D model
      AFRAME.registerComponent('level-physics', {
        init: function() {
          // Wait for the GLTF model to load
          const gltfModel = this.el.querySelector('a-gltf-model');
          if (gltfModel) {
            gltfModel.addEventListener('model-loaded', () => {
              // Add delay to ensure player physics body is created first
              setTimeout(() => {
                this.createPhysicsFromModel();
              }, 1000); // 1 second delay
            });
          }
        },
        
        createPhysicsFromModel: function() {
          const object3D = this.el.object3D;
          const meshes = [];
          
          // Traverse the model and collect all meshes
          object3D.traverse((child) => {
            if (child.isMesh && child.geometry) {
              meshes.push(child);
            }
          });
          
          console.log(`🏗️ Creating physics for level model with ${meshes.length} meshes`);
          
          // Create physics bodies for each mesh
          meshes.forEach((mesh, index) => {
            this.createPhysicsBodyFromMesh(mesh, index);
          });
          
          // Safety check: Move player to safe position if needed
          setTimeout(() => {
            this.ensurePlayerSafePosition();
          }, 500);
        },
        
        createPhysicsBodyFromMesh: function(mesh, index) {
          const geometry = mesh.geometry;
          
          // Get world position and scale
          const worldPos = new THREE.Vector3();
          const worldScale = new THREE.Vector3();
          const worldQuat = new THREE.Quaternion();
          mesh.getWorldPosition(worldPos);
          mesh.getWorldScale(worldScale);
          mesh.getWorldQuaternion(worldQuat);
          
          // Create a simplified collision shape (box for performance)
          geometry.computeBoundingBox();
          const bbox = geometry.boundingBox;
          const size = new THREE.Vector3();
          bbox.getSize(size);
          
          // Scale the size by world scale
          size.multiply(worldScale);
          
          // Create CannonJS box shape
          const shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
          
          // Create static physics body
          const body = new CANNON.Body({
            mass: 0, // Static body
            shape: shape,
            position: new CANNON.Vec3(worldPos.x, worldPos.y, worldPos.z),
            material: new CANNON.Material({
              friction: 0.3,
              restitution: 0.0 // No bouncing
            }),
            collisionFilterGroup: 2,
            collisionFilterMask: 1 // Only collide with player
          });
          
          // Set rotation
          body.quaternion.set(worldQuat.x, worldQuat.y, worldQuat.z, worldQuat.w);
          
          // Add to physics world
          world.addBody(body);
          
          console.log(`📦 Created physics body ${index} for level mesh at`, worldPos);
        },
        
        ensurePlayerSafePosition: function() {
          // Find the player physics body
          const playerComponent = document.querySelector('[zerog-player]');
          if (playerComponent && playerComponent.components['zerog-player'] && playerComponent.components['zerog-player'].playerBody) {
            const playerBody = playerComponent.components['zerog-player'].playerBody;
            
            // Check if player velocity is too high (indicating collision ejection)
            const velocity = playerBody.velocity;
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            
            if (speed > 10) { // If moving too fast, likely ejected
              console.log('⚠️ Player ejected by collision, moving to safe position');
              
              // Stop the player and move to safe position
              playerBody.velocity.set(0, 0, 0);
              playerBody.angularVelocity.set(0, 0, 0);
              playerBody.position.set(0, 15, 0); // Move higher up
              
              // Also update the VR rig
              const rig = document.querySelector('#rig');
              if (rig) {
                rig.object3D.position.set(0, 15, 0);
              }
            }
          }
        }
      });

      // Physics update loop - Anti-tunneling optimized for zero-gravity
      AFRAME.registerComponent('physics-world', {
        init: function() {
          this.lastTime = 0;
        },
        tick: function(time) {
          const deltaTime = (time - this.lastTime) / 1000;
          if (deltaTime > 0) {
            // Use smaller timesteps to prevent tunneling at high speeds in zero-g
            const maxStep = 1/240; // 240Hz timestep for better collision detection
            const steps = Math.ceil(deltaTime / maxStep);
            
            // Clamp to reasonable step count to prevent performance issues
            const clampedSteps = Math.min(steps, 8);
            const clampedStepSize = deltaTime / clampedSteps;
            
            for (let i = 0; i < clampedSteps; i++) {
              world.step(clampedStepSize);
            }
          }
          this.lastTime = time;
        }
      });

      // Impact effect component
      AFRAME.registerComponent('impact-effect', {
        schema: {
          color: { type: 'color', default: '#ffffff' }
        },
        init: function() {
          // Find the impact sphere within this entity
          this.impactSphere = this.el.querySelector('a-sphere[id*="-impact"]') || 
                              this.el.querySelector('a-sphere[id$="-impact"]') ||
                              this.el.querySelector('#player-impact') ||
                              this.el.querySelector('#remote-impact-0') ||
                              this.el.querySelector('#remote-impact-1') ||
                              this.el.querySelector('#remote-impact-2') ||
                              this.el.querySelector('#remote-impact-3');
          if (!this.impactSphere) {
            console.warn('Impact sphere not found for:', this.el.id);
            return;
          }
        },
        
        playEffect: function() {
          if (!this.impactSphere) {
            return;
          }
          
          // Play impact sound at the world position of the hit target
          const impactSound = document.querySelector('#impact-sound');
          if (impactSound) {
            const worldPosition = new THREE.Vector3();
            this.el.object3D.getWorldPosition(worldPosition);
            impactSound.object3D.position.copy(worldPosition);
            impactSound.components.sound.playSound();
          }
          
          // Reset impact sphere state
          this.impactSphere.setAttribute('radius', 0.1);
          this.impactSphere.setAttribute('material', 'opacity', 0.5);
          this.impactSphere.setAttribute('visible', true);
          
          // Trigger the animations
          this.impactSphere.emit('impact');
          
          // Note: Scoring is handled by the zerog-ball component collision detection
          
          // Reset after animation completes
          setTimeout(() => {
            this.impactSphere.setAttribute('visible', false);
            this.impactSphere.setAttribute('material', 'opacity', 0);
            this.impactSphere.setAttribute('radius', 0.1);
          }, 1000);
        }
      });

      // B button for menu system
      AFRAME.registerComponent('menu-toggle', {
        init: function() {
          this.menuVisible = false;
          this.lastXButtonPress = 0;
          this.lastMenuToggle = 0; // Track menu toggle time to prevent accidental clicks
          
          // X button to toggle menu with debouncing
          this.el.sceneEl.addEventListener('xbuttondown', () => {
            const now = Date.now();
            if (now - this.lastXButtonPress < 500) return; // 500ms debounce
            this.lastXButtonPress = now;
            this.toggleMenu();
          });
        },

        toggleMenu: function() {
          // Additional debouncing to prevent rapid toggling
          const now = Date.now();
          if (now - this.lastMenuToggle < 300) {
            console.log('🚫 Menu toggle blocked - too soon after last toggle');
            return;
          }
          this.lastMenuToggle = now;
          
          this.menuVisible = !this.menuVisible;
          isMenuVisible = this.menuVisible; // Update global state
          
          const menu = document.querySelector('#game-menu');
          const leftHand = document.querySelector('#leftHand');
          const rightHand = document.querySelector('#rightHand');
          
          // Toggle menu visibility
          if (menu) {
            menu.setAttribute('visible', this.menuVisible);
          }
          
          // Show/hide start/restart button for hosts and update button text
          if (this.menuVisible) {
            const restartButton = document.querySelector('#menu-restart-match');
            const restartText = document.querySelector('#menu-restart-text');
            if (restartButton && restartText) {
              const gameManager = document.querySelector('[game-manager]');
              const matchState = gameManager && gameManager.components['game-manager'] ? 
                                gameManager.components['game-manager'].matchState : 'WAITING';
              
              // Show button only for hosts in multiplayer, or in singleplayer
              const shouldShowButton = !isMultiplayer || isHost;
              restartButton.setAttribute('visible', shouldShowButton);
              
              // Update button text based on match state
              if (matchState === 'WAITING') {
                restartText.setAttribute('text', 'value', 'START MATCH');
              } else {
                restartText.setAttribute('text', 'value', 'RESTART MATCH');
              }
            }
          }
          
          // Toggle HUD layers - simple and clean
          this.toggleHUDLayers(this.menuVisible);
          
          // BULLETPROOF FIX: Direct component manipulation for laser pointers
            if (this.menuVisible) {
            // Menu is open - enable laser pointers and menu
            if (leftHand && leftHand.components.raycaster && leftHand.components.raycaster.data) {
              leftHand.components.raycaster.enabled = true;
              leftHand.components.raycaster.data.objects = '.clickable';
              leftHand.components.raycaster.data.lineColor = '#ffffff';
              leftHand.components.raycaster.data.lineOpacity = 1;
              leftHand.components.raycaster.data.far = 10;
              // Disable any active thrusters when menu opens
              const leftThruster = leftHand.querySelector('.thruster-vfx');
              if (leftThruster) leftThruster.setAttribute('visible', false);
            }
            if (rightHand && rightHand.components.raycaster && rightHand.components.raycaster.data) {
              rightHand.components.raycaster.enabled = true;
              rightHand.components.raycaster.data.objects = '.clickable';
              rightHand.components.raycaster.data.lineColor = '#ffffff';
              rightHand.components.raycaster.data.lineOpacity = 1;
              rightHand.components.raycaster.data.far = 10;
              // Disable any active thrusters when menu opens
              const rightThruster = rightHand.querySelector('.thruster-vfx');
              if (rightThruster) rightThruster.setAttribute('visible', false);
            }
            
            // Re-enable the menu and all buttons
            const menu = document.querySelector('#game-menu');
            if (menu) {
              menu.setAttribute('enabled', true);
            }
            
            // Re-enable all menu buttons
            const menuButtons = document.querySelectorAll('.clickable');
            menuButtons.forEach(button => {
              button.setAttribute('enabled', true);
              button.setAttribute('visible', true);
              // Also enable the cursor-listener component if it exists
              if (button.components['cursor-listener']) {
                button.components['cursor-listener'].el.setAttribute('enabled', true);
              }
            });
            
            // Fix bloom interference by quickly toggling debug twice to reinitialize raycaster
            setTimeout(() => {
              const scene = document.querySelector('a-scene');
              if (scene) {
                // Toggle debug off and on twice to reinitialize raycaster
                scene.setAttribute('debug', false);
                setTimeout(() => {
                  scene.setAttribute('debug', true);
                  setTimeout(() => {
                    scene.setAttribute('debug', false);
                    setTimeout(() => {
                      scene.setAttribute('debug', true);
                      console.log('🔧 Debug toggled twice to fix bloom interference with raycaster');
                    }, 50);
                  }, 50);
                }, 50);
              }
            }, 100); // Small delay to ensure menu is fully opened
            console.log('🟢 Laser pointers ENABLED - menu opened');
          } else {
            // Menu is closed - disable laser pointers completely
            if (leftHand && leftHand.components.raycaster && leftHand.components.raycaster.data) {
              leftHand.components.raycaster.enabled = false;
              leftHand.components.raycaster.data.objects = '';
              leftHand.components.raycaster.data.lineOpacity = 0;
            }
            if (rightHand && rightHand.components.raycaster && rightHand.components.raycaster.data) {
              rightHand.components.raycaster.enabled = false;
              rightHand.components.raycaster.data.objects = '';
              rightHand.components.raycaster.data.lineOpacity = 0;
            }
            
            // Also disable the menu to prevent interactions
            const menu = document.querySelector('#game-menu');
            if (menu) {
              menu.setAttribute('enabled', false);
            }
            
            // Disable all menu buttons to prevent interactions
            const menuButtons = document.querySelectorAll('.clickable');
            menuButtons.forEach(button => {
              button.setAttribute('enabled', false);
              // Also disable the cursor-listener component if it exists
              if (button.components['cursor-listener']) {
                button.components['cursor-listener'].el.setAttribute('enabled', false);
              }
            });
            
            console.log('🔴 Laser pointers DISABLED - menu closed and properly disabled');
          }
          
          // Reset thruster states when menu opens
          if (this.menuVisible) {
            const zerogPlayer = document.querySelector('[zerog-player]');
            if (zerogPlayer && zerogPlayer.components['zerog-player']) {
              const player = zerogPlayer.components['zerog-player'];
              player.thrusterActive.left = false;
              player.thrusterActive.right = false;
            }
          }
          
          // Update menu display when opening
          if (this.menuVisible) {
            this.updateMenuDisplay();
          }
          
          // When menu closes, refresh HUD to show proper state
          if (!this.menuVisible) {
            this.refreshGameHUD();
          }
          
          // Menu toggled
        },

        updateMenuDisplay: function() {
          // Update lobby section visibility
          const lobbySection = document.querySelector('#menu-lobby-section');
          const autoConnect = document.querySelector('#menu-auto-connect');
          
          if (lobbySection) {
            lobbySection.setAttribute('visible', isMultiplayer);
          }
          if (autoConnect) {
            autoConnect.setAttribute('visible', isMultiplayer);
          }
          
          // Update lobby number display
          const lobbyNumber = document.querySelector('#menu-lobby-number');
          if (lobbyNumber) {
            lobbyNumber.setAttribute('text', 'value', selectedLobby.toString());
          }
          
          // Update player slot indicators
          for (let i = 0; i < 4; i++) {
            const slot = document.querySelector(`#menu-slot-${i}`);
            if (slot) {
              const player = players.get(`player_${i}`);
              const isOccupied = player && player.isConnected;
              const sphere = slot.querySelector('a-sphere');
              if (sphere) {
                sphere.setAttribute('material', 'opacity', isOccupied ? 1 : 0.3);
                // CRITICAL FIX: Use team colors instead of hardcoded playerSlots colors
                let playerColor = '#666666'; // Default gray for unoccupied
                if (isOccupied) {
                  const playerId = `player_${i}`;
                  // Team colors removed - space shooter uses default colors
                  playerColor = '#ffffff'; // Default white
                }
                sphere.setAttribute('color', playerColor);
              }
            }
          }
          
          // Update current mode display
          updateMenuDisplay();
        },

        toggleHUDLayers: function(showMenu) {
          if (showMenu) {
            // Hide HUD elements when menu is shown, but KEEP version display visible
            const hiddenHudElements = [
            '#hud-status', 
            '#hud-score',
            '#hud-timer',
              '#hud-speed',
            '#hud-message',
            '#power-bars-container'  // Hide power bars when menu is open
          ];
          
            hiddenHudElements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                element.setAttribute('visible', false);
              }
            });
            
            // ALWAYS keep version display visible (game version + FPS)
            const versionElement = document.querySelector('#version-display');
            if (versionElement) {
              versionElement.setAttribute('visible', true);
            }
          } else {
            // Menu closed - restore HUD based on match state
            // CRITICAL FIX: Find the correct game manager instance (there are multiple due to component re-initialization)
            let gameManagerComponent = null;
            
            // Try to find the game manager with the correct state
            const allGameManagers = document.querySelectorAll('[game-manager]');
            
            for (let i = 0; i < allGameManagers.length; i++) {
              const gm = allGameManagers[i];
              if (gm.components && gm.components['game-manager']) {
                const comp = gm.components['game-manager'];
                
                // Prefer the one that has gameStarted=true or is not in WAITING state
                if (comp.gameStarted === true || comp.matchState !== 'WAITING') {
                  gameManagerComponent = comp;
                  break;
                }
              }
            }
            
            // Fallback to first one if none found with correct state
            if (!gameManagerComponent && allGameManagers.length > 0) {
              const gm = allGameManagers[0];
              if (gm.components && gm.components['game-manager']) {
                gameManagerComponent = gm.components['game-manager'];
              }
            }
            
            // Always show speed and version display
            const speedElement = document.querySelector('#hud-speed');
            if (speedElement) speedElement.setAttribute('visible', true);
            
            // Always show power bars when menu is closed
            const powerBarsElement = document.querySelector('#power-bars-container');
            if (powerBarsElement) powerBarsElement.setAttribute('visible', true);
            
            // ALWAYS show version display (game version + FPS)
            const versionElement = document.querySelector('#version-display');
            if (versionElement) versionElement.setAttribute('visible', true);
            
            if (gameManagerComponent) {
              const matchState = gameManagerComponent.matchState;
              
              // Show score and timer during active match states (but NOT during countdown)
              const showGameHUD = (matchState === 'PLAYING' || matchState === 'OVERTIME' || 
                                 matchState === 'ENDED') ||
                                 (gameManagerComponent.gameStarted === true && matchState !== 'COUNTDOWN');
              
              const scoreElement = document.querySelector('#hud-score');
              const timerElement = document.querySelector('#hud-timer');
              
              
              if (scoreElement) scoreElement.setAttribute('visible', showGameHUD);
              if (timerElement) timerElement.setAttribute('visible', showGameHUD);
              
              if (showGameHUD) {
                gameManagerComponent.updateMultiplayerScore();
                gameManagerComponent.updateTimer();
              }
            }
            
            // Handle message visibility based on match state
            const messageElement = document.querySelector('#hud-message');
            const statusElement = document.querySelector('#hud-status');
            
            if (gameManagerComponent) {
              const matchState = gameManagerComponent.matchState;
              
              // Handle message visibility carefully to avoid showing "GO!" during matches
              if (messageElement) {
                if (matchState === 'COUNTDOWN') {
                  // Show countdown numbers during COUNTDOWN state
                  messageElement.setAttribute('visible', true);
                } else if (matchState === 'WAITING') {
                  // Only show message in WAITING if it's not "GO!" (which means countdown just finished)
                  const currentText = messageElement.getAttribute('text').value;
                  if (currentText !== 'GO!') {
                    messageElement.setAttribute('visible', true);
                  } else {
                    messageElement.setAttribute('visible', false);
                  }
                } else {
                  // During PLAYING, OVERTIME, ENDED - always hide
                  messageElement.setAttribute('visible', false);
                }
              }
            }
            
            // Always keep status hidden during matches
            if (statusElement) statusElement.setAttribute('visible', false);
          }
        },

        refreshGameHUD: function() {
          // Refresh the game HUD based on current game state
          setTimeout(() => {
            // CRITICAL FIX: Find the correct game manager instance (same logic as host connection handler)
            const allGameManagers = document.querySelectorAll('[game-manager]');
            let gameManagerComponent = null;
            let gameManager = null;
            
            // Find the game manager with active state or the first valid one
            for (let i = 0; i < allGameManagers.length; i++) {
              const gm = allGameManagers[i];
              if (gm.components && gm.components['game-manager']) {
                const comp = gm.components['game-manager'];
                
                // Prefer the one with active match or use first valid one
                if (!gameManagerComponent || comp.gameStarted || comp.matchState !== 'WAITING') {
                  gameManagerComponent = comp;
                  gameManager = gm;
                }
              }
            }
            
            // ALWAYS ensure version display is visible
            const versionDisplay = document.querySelector('#version-display');
            if (versionDisplay) {
              versionDisplay.setAttribute('visible', true);
            }
            
            // Don't update HUD if menu is currently visible
            if (isMenuVisible) {
              return;
            }
            
            // Refreshing HUD
            
            if (gameManagerComponent) {
              const matchState = gameManagerComponent.matchState;
              const isMatchActive = gameManagerComponent.gameStarted || 
                                   matchState === 'PLAYING' || 
                                   matchState === 'OVERTIME' || 
                                   matchState === 'COUNTDOWN' ||
                                   matchState === 'ENDED';
              
              if (isMatchActive) {
                // Handle different match states appropriately
                if (matchState === 'COUNTDOWN') {
                  // During countdown, show HUD but keep message visible for countdown numbers
                  setGameplayHUD(true);
                  
                  // CRITICAL: Re-enable the HUD message for countdown display
                  const hudMessage = document.querySelector('#hud-message');
                  if (hudMessage) {
                    hudMessage.setAttribute('visible', true);
                  }
                } else {
                  // Match is active (PLAYING/OVERTIME/ENDED) - show gameplay HUD with score and timer
                  setGameplayHUD(true);
                }
                
                // For clients joining active matches, ensure score and timer are updated
                gameManagerComponent.updateMultiplayerScore();
                gameManagerComponent.updateTimer();
              } else if (isMultiplayer && activePlayers.size > 1) {
                // Multiplayer connected but no match - set waiting state
                setGameplayHUD(false);
                
                // Only set waiting state if not already in an active match
                if (matchState === 'WAITING' || !matchState) {
                  gameManagerComponent.setMultiplayerWaiting();
                }
              } else {
                // Singleplayer or no connection - show default state
                setGameplayHUD(false);
                
                // Ensure "Press X to open menu" message is visible in default state
                const hudMessage = document.querySelector('#hud-message');
                if (hudMessage) {
                  hudMessage.setAttribute('visible', true);
                  hudMessage.setAttribute('text', 'value', 'Press X to open menu');
                }
              }
            } else {
              // No game manager - show default state
              setGameplayHUD(false);
            }
            
            // Game HUD refreshed
          }, 100); // Small delay to ensure menu state is fully updated
        }
      });

      // Multiplayer connection logic (slot-based, PeerJS, TURN support)
      async function startMultiplayerConnection() {
        connectionState = 'connecting';
        multiplayerStatus = 'Searching...';
        updateMultiplayerStatus('Searching for match...');
        isMultiplayer = false;
        try {
          const slot = await findAvailableSlot(multiplayerStartType);
          if (!slot) {
            updateMultiplayerStatus('No available slots. Try again.');
            connectionState = 'disconnected';
            return;
          }
          multiplayerSlot = slot.slotNumber;
          isHost = slot.role === 'host';
          if (isHost) {
            await setupHost(multiplayerSlot);
          } else {
            await setupPeer(multiplayerSlot);
          }
        } catch (e) {
          updateMultiplayerStatus('Connection failed.');
          connectionState = 'disconnected';
        }
      }

      async function checkPeerAvailability(id) {
        return new Promise((resolve) => {
          const tempPeer = new Peer(id, { host: "0.peerjs.com", port: 443, secure: true });
          const timeout = setTimeout(() => {
            tempPeer.destroy();
            resolve(false);
          }, 2000);
          tempPeer.on("open", () => {
            clearTimeout(timeout);
            tempPeer.destroy();
            resolve(true);
          });
          tempPeer.on("error", (err) => {
            clearTimeout(timeout);
            tempPeer.destroy();
            if (err.type === 'unavailable-id') {
              resolve(false);
            } else {
              resolve(true);
            }
          });
        });
      }

      async function findAvailableSlot(desiredStartType) {
        for (let i = 1; i <= MAX_LOBBIES; i++) {
          const hostId = `zerog-host-${desiredStartType}-${i}`;
          const peerId = `zerog-peer-${desiredStartType}-${i}`;
          const hostAvailable = await checkPeerAvailability(hostId);
          if (hostAvailable) {
            return { slotNumber: i, role: 'host' };
          } else {
            const peerAvailable = await checkPeerAvailability(peerId);
            if (peerAvailable) {
              return { slotNumber: i, role: 'peer' };
            }
          }
        }
        return null;
      }








      
      // Removed complex patching system - scoring is now handled directly in the game-manager component

      // Attach menu-toggle to scene
      document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene && !scene.hasAttribute('menu-toggle')) {
          scene.setAttribute('menu-toggle', '');
        }
        
        // Initialize visibility - but don't call manageActivePlayersAndBots yet
        // It will be called when multiplayer is properly initialized
        
        // Hide all remote players initially
        for (let i = 1; i < 4; i++) {
          const remotePlayer = document.querySelector(`#remote-player-${i}`);
          if (remotePlayer) {
            remotePlayer.setAttribute('visible', false);
          }
        }
        
        // Initialize status display
        updateMultiplayerStatus('Singleplayer');
        
        // Wait for A-Frame scene to be fully loaded before setting team colors
        const aframeScene = document.querySelector('a-scene');
        if (aframeScene) {
          if (aframeScene.hasLoaded) {
            // Scene already loaded, initialize immediately
            initializeDefaultTeam();
          } else {
            // Wait for scene to load
            aframeScene.addEventListener('loaded', initializeDefaultTeam);
          }
        }
        
        // Scoring is now handled directly in the game-manager component - no patching needed
      });

      // Initialize default team assignment for singleplayer
      function initializeDefaultTeam() {
        // Set default team for singleplayer
        // Team system removed.set('player_0', 'red');
        
        // Update player body color
        updatePlayerTeamColor('player_0', 'red');
        
        // Update ball colors
        // Ball colors removed - space shooter uses fixed colors
        
        // Update team display in menu
        // Team display removed - space shooter doesn't use teams
        
        // Update game mode UI for capture mode
        // Game mode UI removed - space shooter is always dodgeball
        
        // Manage bot and ball visibility for capture mode
        manageActivePlayersAndBots();
      }

      // --- MULTIPLAYER SYNC COMPONENT ---
      AFRAME.registerComponent('multiplayer-sync', {
        tick: function() {
          // Debug logging for multiplayer sync (throttled)
          if (!this.lastDebugLog || Date.now() - this.lastDebugLog > 5000) {
            this.lastDebugLog = Date.now();
          }
          
          // In multiplayer, send the local camera's world position/rotation as player state
          if (isMultiplayer && activePlayers.size > 1) {
            const camera = document.querySelector('[camera]');
            if (camera) {
              const worldPos = new THREE.Vector3();
              camera.object3D.getWorldPosition(worldPos);
              const worldQuat = new THREE.Quaternion();
              camera.object3D.getWorldQuaternion(worldQuat);
              const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
              // Get controller data for arm IK
              const leftHand = document.querySelector('#leftHand');
              const rightHand = document.querySelector('#rightHand');
              const rig = document.querySelector('#rig');
              
              const playerState = {
                x: worldPos.x, y: worldPos.y, z: worldPos.z,
                rx: worldRot.x, ry: worldRot.y, rz: worldRot.z
              };
              
              // Add rig (body) rotation for shoulder positioning
              if (rig) {
                const rigPos = new THREE.Vector3();
                const rigQuat = new THREE.Quaternion();
                rig.object3D.getWorldPosition(rigPos);
                rig.object3D.getWorldQuaternion(rigQuat);
                const rigRot = new THREE.Euler().setFromQuaternion(rigQuat, 'YXZ');
                
                playerState.rig = {
                  x: rigPos.x, y: rigPos.y, z: rigPos.z,
                  rx: rigRot.x, ry: rigRot.y, rz: rigRot.z
                };
              }
              
              // Add controller positions and rotations for arm IK
              if (leftHand) {
                const leftPos = new THREE.Vector3();
                const leftQuat = new THREE.Quaternion();
                leftHand.object3D.getWorldPosition(leftPos);
                leftHand.object3D.getWorldQuaternion(leftQuat);
                const leftRot = new THREE.Euler().setFromQuaternion(leftQuat, 'YXZ');
                
                playerState.leftHand = {
                  x: leftPos.x, y: leftPos.y, z: leftPos.z,
                  rx: leftRot.x, ry: leftRot.y, rz: leftRot.z
                };
              }
              
              if (rightHand) {
                const rightPos = new THREE.Vector3();
                const rightQuat = new THREE.Quaternion();
                rightHand.object3D.getWorldPosition(rightPos);
                rightHand.object3D.getWorldQuaternion(rightQuat);
                const rightRot = new THREE.Euler().setFromQuaternion(rightQuat, 'YXZ');
                
                playerState.rightHand = {
                  x: rightPos.x, y: rightPos.y, z: rightPos.z,
                  rx: rightRot.x, ry: rightRot.y, rz: rightRot.z
                };
              }
              
              sendPlayerState(playerState);
              
              // Debug: Log when sending player state (throttled)
              if (!this.lastSendLog || Date.now() - this.lastSendLog > 5000) {
                this.lastSendLog = Date.now();
                console.log(`📤 Sending player state as ${myPlayerId}:`, {
                  position: `${playerState.x?.toFixed(1)}, ${playerState.y?.toFixed(1)}, ${playerState.z?.toFixed(1)}`,
                  hasRig: !!playerState.rig,
                  hasLeftHand: !!playerState.leftHand,
                  hasRightHand: !!playerState.rightHand
                });
              }
              
              // Debug: Log when client sends data (throttled to once per 30 seconds)
              if (!isHost) {
                if (!this.lastClientSendTime || Date.now() - this.lastClientSendTime > 30000) {
                  this.lastClientSendTime = Date.now();
                }
              }
            }
          }
          
          // Debug: Log sync component activity (only once per 30 seconds)
          if (isMultiplayer && activePlayers.size > 1) {
            if (!this.lastDebugTime || Date.now() - this.lastDebugTime > 30000) {
              this.lastDebugTime = Date.now();
            }
          }
          
          // Send ball states for all players
          if (isMultiplayer && activePlayers.size > 1 && myPlayerId) {
            // CRITICAL FIX: Use dynamic ball assignment instead of hardcoded logic
            const myBallNumber = getBallForPlayer(myPlayerId);
            
            const ball = document.querySelector(`[zerog-ball*="player: player${myBallNumber}"]`);
            if (ball) {
              const pos = ball.object3D.position;
              const ballComponent = ball.components['zerog-ball'];
              const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
              

              
              sendBallState({ 
                playerId: myBallNumber,
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            }
            
            // CRITICAL FIX: Dynamic capture ball ownership for multiplayer
            if (gameMode === 'capture') {
              const captureBall = document.querySelector('#capture-ball');
              if (captureBall && captureBall.components['zerog-ball']) {
                const ballComponent = captureBall.components['zerog-ball'];
                
                // Check if local player is controlling the capture ball
                const isLocallyControlled = ballComponent.isGrabbed;
                
                if (isLocallyControlled) {
                  // LOCAL PLAYER controls capture ball - send updates to everyone
                  const pos = captureBall.object3D.position;
                  const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
                  
                  sendBallState({ 
                    playerId: 'capture',
                    x: pos.x, y: pos.y, z: pos.z, 
                    vx: velocity.x, vy: velocity.y, vz: velocity.z 
                  });
                } else if (isHost) {
                  // HOST controls uncontrolled capture ball - send updates to clients
                  const pos = captureBall.object3D.position;
                  const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
                  
                  sendBallState({ 
                    playerId: 'capture',
                    x: pos.x, y: pos.y, z: pos.z, 
                    vx: velocity.x, vy: velocity.y, vz: velocity.z 
                  });
                }
              }
            }
            
            // CRITICAL: Host syncs bot positions to all clients
            if (isHost) {
              const redBot = document.querySelector('#zerog-bot-red');
              const blueBot = document.querySelector('#zerog-bot-blue');
              
              if (redBot && redBot.components['zerog-bot'] && redBot.components['zerog-bot'].body) {
                const botBody = redBot.components['zerog-bot'].body;
                sendBotState({
                  botId: 'bot-red',
                  x: botBody.position.x, y: botBody.position.y, z: botBody.position.z,
                  vx: botBody.velocity.x, vy: botBody.velocity.y, vz: botBody.velocity.z,
                  qx: botBody.quaternion.x, qy: botBody.quaternion.y, qz: botBody.quaternion.z, qw: botBody.quaternion.w
                });
              }
              
              if (blueBot && blueBot.components['zerog-bot'] && blueBot.components['zerog-bot'].body) {
                const botBody = blueBot.components['zerog-bot'].body;
                sendBotState({
                  botId: 'bot-blue',
                  x: botBody.position.x, y: botBody.position.y, z: botBody.position.z,
                  vx: botBody.velocity.x, vy: botBody.velocity.y, vz: botBody.velocity.z,
                  qx: botBody.quaternion.x, qy: botBody.quaternion.y, qz: botBody.quaternion.z, qw: botBody.quaternion.w
                });
              }
              
              // CRITICAL FIX: Host also sends bot ball states to clients
              // Bot balls: player1, player2, player3, player4
              for (let i = 1; i <= 4; i++) {
                const botBall = document.querySelector(`[zerog-ball*="player: player${i}"]`);
                if (botBall && botBall.components['zerog-ball']) {
                  const pos = botBall.object3D.position;
                  const ballComponent = botBall.components['zerog-ball'];
                  const velocity = ballComponent?.body?.velocity || {x:0, y:0, z:0};
                  
                  // Only send if ball is moving or not at spawn position
                  const ballSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
                  if (ballSpeed > 0.1) {
                    sendBallState({ 
                      playerId: i, // Bot ball number (1, 2, 3, 4)
                      x: pos.x, y: pos.y, z: pos.z, 
                      vx: velocity.x, vy: velocity.y, vz: velocity.z 
                    });
                  }
                }
              }
            }
          }
          
          // Debug: Check if client is sending data (throttled)
          if (!isHost && myPlayerId && connections.size > 0) {
            if (!this.lastClientDebugTime || Date.now() - this.lastClientDebugTime > 30000) {
              this.lastClientDebugTime = Date.now();
            }
          }
          
          // Apply remote player states
          if (isMultiplayer && activePlayers.size > 1) {
            // Show remote players and hide bot
            for (let i = 1; i < 4; i++) {
              const remotePlayer = document.querySelector(`#remote-player-${i}`);
              if (remotePlayer && activePlayers.has(`player_${i}`)) {
                remotePlayer.setAttribute('visible', true);
              } else if (remotePlayer) {
                remotePlayer.setAttribute('visible', false);
              }
            }
            
            // CRITICAL FIX: Use proper bot management instead of hiding all bots
            // Always maintain 4 total players (humans + bots)
            manageActivePlayersAndBots();
          } else if (!isMultiplayer) {
            // CRITICAL: Ensure bot is enabled and visible in singleplayer mode
            for (let i = 1; i < 4; i++) {
              const remotePlayer = document.querySelector(`#remote-player-${i}`);
              if (remotePlayer) {
                remotePlayer.setAttribute('visible', false);
              }
            }
            // Use the new player management system
            manageActivePlayersAndBots();
          }
          
          // Prevent local input from affecting other players' balls in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            for (let i = 0; i < 4; i++) {
              // Calculate which ball this player should control
              const ballPlayerIndex = i + 1; // player_0 controls player1, player_1 controls player2, etc.
              const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
              // Use dynamic ball assignment
              const myBallIndex = getBallForPlayer(myPlayerId || 'player_0');
              
              // Only reset isGrabbed for balls that don't belong to the current player
              if (ballPlayerIndex !== myBallIndex) {
                const ball = document.querySelector(`[zerog-ball*="player: player${ballPlayerIndex}"]`);
                if (ball && ball.components['zerog-ball']) {
                  ball.components['zerog-ball'].isGrabbed = false;
                }
              }
            }
          }
          
          // REMOVED: Test ball movement code that was interfering with physics
        }
      });

      // Dynamic ball physics for zero-g - can be grabbed and thrown

      AFRAME.registerComponent('zerog-ball', {
        schema: {
          player: { type: 'string', default: 'player1' },
          maxVelocity: { type: 'number', default: 8 },
          owner: { type: 'string', default: 'human' }, // 'bot' or 'human'
          isHomingMissile: { type: 'boolean', default: false },
          targetId: { type: 'string', default: '' },
          homingForce: { type: 'number', default: 15 },
          explosionRadius: { type: 'number', default: 1.0 },
          explosionDamage: { type: 'number', default: 50 },
          bulletHits: { type: 'number', default: 0 },
          maxBulletHits: { type: 'number', default: 5 }
        },
        
        init: function() {
          
          // Make balls grabbable (unless it's a homing missile)
          if (!this.data.isHomingMissile) {
          this.el.classList.add('grabbable-surface');
          }
          
          // Track if ball is being grabbed
          this.isGrabbed = false;
          this.grabbingHand = null;
          
          // Network authority tracking for capture ball
          this.currentOwner = null; // Player ID who currently owns the ball
          this.lastOwnerChangeTime = 0; // When ownership last changed
          
          // Check if this is the special capture ball
          this.isCaptureBall = (this.data.player === 'capture');
          
          // Homing missile initialization
          if (this.data.isHomingMissile) {
            this.isHomingMissile = true;
            this.target = null;
            this.lastDistanceToTarget = Infinity;
            this.distanceIncreasingFrames = 0;
            this.maxDistanceIncreasingFrames = 10; // Explode after 10 frames of increasing distance
            this.lifetime = 10000; // 10 seconds max lifetime
            this.startTime = Date.now();
            this.lastTargetUpdate = 0;
            this.targetUpdateInterval = 100; // Update target every 100ms
          } else {
            this.isHomingMissile = false;
          }
          
          // Capture ball has special collision properties
          
          // Set initial position based on player
          const ballPlayerIndex = this.isCaptureBall ? 0 : parseInt(this.data.player.replace('player', ''));
          let spawnPos;
          
          // Position balls based on their player assignment
          if (this.isCaptureBall) {
            // Capture ball always spawns at center
            spawnPos = { x: 0, y: 2, z: 0 };
          } else if (isMultiplayer) {
            // Multiplayer: Position balls at their assigned player positions
            const playerIndex = ballPlayerIndex - 1; // player1 -> index 0, player2 -> index 1, etc.
            if (playerIndex >= 0 && playerIndex < playerSlots.length) {
              const slot = playerSlots[playerIndex];
              const positionParts = slot.position.split(' ');
              spawnPos = {
                x: parseFloat(positionParts[0]),
                y: parseFloat(positionParts[1]) + 2, // Add 2m height for ball spawn
                z: parseFloat(positionParts[2])
              };
            } else {
              // Fallback to center position
              spawnPos = { x: 0, y: 2, z: 0 };
            }
          } else {
            // Singleplayer: Position balls at their traditional positions
            if (ballPlayerIndex === 1) {
              // Bot's ball (red) - position near bot
              spawnPos = { x: 0, y: 2, z: -8 };
            } else if (ballPlayerIndex === 2) {
              // Player's ball (green) - position near player
              spawnPos = { x: 0, y: 2, z: 8 };
            } else {
              // Fallback
              spawnPos = { x: 0, y: 2, z: 0 };
            }
          }
          
          // Update the ball's visual position
          this.el.setAttribute('position', `${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);
          
          this.initialPosition = new CANNON.Vec3(spawnPos.x, spawnPos.y, spawnPos.z);
          
          // Different properties for capture ball vs regular balls
          const radius = this.isCaptureBall ? 0.2 : 0.1;
          const mass = this.isCaptureBall ? 2 : 1; // Heavier capture ball
          
          const shape = new CANNON.Sphere(radius);
          
          // Different collision masks for capture ball vs regular balls
          const collisionMask = this.isCaptureBall 
            ? 4 | 8  // Capture ball collides with walls (4) AND goals (8)
            : 4; // CRITICAL FIX: Regular balls start with walls only (4) - no ball collisions by default
          
          this.body = new CANNON.Body({
            mass: mass,
            shape: shape,
            material: ballMaterial,
            linearDamping: 0.02, // Slight damping for realistic movement
            angularDamping: 0.02,
            position: this.initialPosition,
            collisionFilterGroup: 2, // All balls are in group 2
            collisionFilterMask: collisionMask
          });
          
          // Initialize lastPosition for collision detection
          this.lastPosition = new THREE.Vector3().copy(this.body.position);
          
          if (this.isCaptureBall) {
          }
          
          // Zero gravity
          this.body.gravity = new CANNON.Vec3(0, 0, 0);
          
          world.addBody(this.body);
          
          // Store body reference for grabbing
          this.el.body = this.body;
          
          // CRITICAL: Store element reference in physics body for collision detection
          this.body.el = this.el;
          
          // CRITICAL FIX: Add shield collision detection using beginContact (before collision resolution)
          this.body.addEventListener('beginContact', (evt) => {
            const otherBody = evt.target === this.body ? evt.body : evt.target;
            
            if (otherBody.el && otherBody.el.components && otherBody.el.components['zerog-ball']) {
              const otherBallComponent = otherBody.el.components['zerog-ball'];
              
              // Don't process shield collisions for capture ball
              if (!this.isCaptureBall && !otherBallComponent.isCaptureBall) {
                this.handleShieldBeginContact(otherBody, otherBallComponent, evt.contact);
              }
            }
          });
          
          if (this.isCaptureBall) {
          }
          
          // Add collision detection for bounce sounds and target hits
          this.body.addEventListener('collide', (evt) => {
            const contact = evt.contact;
            const otherBody = evt.target === this.body ? evt.body : evt.target;
            
            // Environment collision now handled by tick function
            // Only handle ball-to-ball and ball-to-target collisions here
            
            // CRITICAL FIX: Check for shield collisions between balls
            if (otherBody.el && otherBody.el.components && otherBody.el.components['zerog-ball']) {
              const otherBallComponent = otherBody.el.components['zerog-ball'];
              
              // Don't process shield collisions for capture ball
              if (!this.isCaptureBall && !otherBallComponent.isCaptureBall) {
                // Handle shield logic - this will deactivate shields and restore collision masks
                this.handleShieldCollision(otherBody, otherBallComponent, evt.contact);
              }
            }
            
            // Capture ball collision detection
            
            // Check for target hits first
            this.checkTargetHit();
            
            // Only play bounce sound if not grabbed and moving fast enough
            if (!this.isGrabbed && this.body.velocity.length() > 0.5) {
              const bounceSound = document.querySelector('#bounce-sound');
              if (bounceSound) {
                // Position sound at collision point
                const collisionPoint = new THREE.Vector3();
                collisionPoint.copy(this.body.position);
                bounceSound.object3D.position.copy(collisionPoint);
                
                // Stop any currently playing sound and play new one
                bounceSound.components.sound.stopSound();
                bounceSound.components.sound.playSound();
              }
            }
          });
          
          // Velocity tracking for smooth throwing
          this.velocityHistory = [];
          this.maxHistorySize = 5;
          this.lastPosition = new THREE.Vector3();
          this.lastPositionTime = 0;
          
          // Tractor beam with A button - only for player's own ball
          // Tractor beam removed for space shooter
          this.targetPosition = new THREE.Vector3();
          
          // NEW: Auto-return mode (for 2 seconds after hitting target)
          // Auto-return removed for space shooter
          this.autoReturnStartTime = 0;
          this.autoReturnDuration = 2000; // 2 seconds
          
          // NEW: Hit cooldown to prevent multiple hits during auto-return
          this.lastHitTime = 0;
          this.hitCooldown = 2000; // 2 seconds cooldown
          
          this.el.sceneEl.addEventListener('triggerdown', (evt) => {
            // Check if player is stunned
            const player = document.querySelector('[zerog-player]');
            if (player && player.components['zerog-player'] && player.components['zerog-player'].isStunned) {
              return;
            }
            
            // Check if menu is visible
            if (getMenuVisibility()) {
              return;
            }
            
            // SPACE SHOOTER: Use triggers to shoot balls as projectiles
            const currentPlayerId = myPlayerId || 'player_0';
            const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
            const ballOwnerId = getBallOwnerId(ballPlayerIndex);
            
            // OLD BALL SHOOTING DISABLED - Now using bullet system
            // Only shoot player's own ball, not capture ball
            // if (this.data.owner === 'human' && ballOwnerId === currentPlayerId && !this.isCaptureBall) {
            //   this.shootBall(evt.target);
            // }
          });
        },
        
        tick: function(time, timeDelta) {
          if (!this.body) return;
          
          // Sync A-Frame object with physics body
          this.el.object3D.position.copy(this.body.position);
          this.el.object3D.quaternion.copy(this.body.quaternion);
          
          // Homing missile logic
          if (this.isHomingMissile) {
            this.updateHomingMissile(time, timeDelta);
          }
          
          // Check for environment collisions using Three.js raycasting
          this.checkEnvironmentCollision();
        },
        
        checkEnvironmentCollision: function() {
          if (!this.body || this.isGrabbed) return;
          
          const currentPos = new THREE.Vector3().copy(this.body.position);
          const lastPos = this.lastPosition || currentPos.clone();
          
          // Only check collision if ball is moving
          if (currentPos.distanceTo(lastPos) < 0.01) return;
          
          // Use bullet collision logic - get all collidable meshes
          const allMeshes = [];
          const models = [
            document.querySelector('#model-level'),
            document.querySelector('#model-spaceship'),
            document.querySelector('#model-asteroid-42')
          ];
          
          // Collect all meshes first
          models.forEach(model => {
            if (model && model.object3D) {
              model.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  allMeshes.push(child);
                }
              });
            }
          });
          
          // Add grab-surface objects (only if visible)
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            if (surface.object3D && surface.getAttribute('visible') !== false && surface.getAttribute('visible') !== 'false') {
              surface.object3D.traverse(child => {
                if (child.isMesh && child.geometry) {
                  allMeshes.push(child);
                }
              });
            }
          });
          
          // Filter to only visible meshes using the same logic as bullet system
          const meshes = this.getVisibleMeshes(allMeshes);
          
          // CCD - Raycast from last position to current position (same as bullets)
          const raycaster = new THREE.Raycaster();
          const direction = new THREE.Vector3().subVectors(currentPos, lastPos);
          const distance = direction.length();
          
          if (distance > 0) {
            direction.normalize();
            raycaster.set(lastPos, direction);
            raycaster.far = distance + 0.02; // Add small buffer
          
          const intersects = raycaster.intersectObjects(meshes, false);
          
          if (intersects.length > 0) {
              const hit = intersects[0];
              if (hit.distance <= distance + 0.01) {
                // Ball hit environment - create impact effects and handle collision
                const impactManager = document.querySelector('[impact-effects-manager]');
                if (impactManager && impactManager.components['impact-effects-manager']) {
                  impactManager.components['impact-effects-manager'].createImpactEffect(hit.point);
                }
                
                if (this.isHomingMissile) {
                  // Homing missile hit environment - explode
                  this.explodeMissile();
                } else {
                  // Regular ball hit environment - remove it
              this.resetPosition();
            }
          }
            }
          }
          
          // Store current position for next frame
          this.lastPosition = currentPos.clone();
        },
        
        resetPosition: function() {
          // Capture ball always resets to center
          if (this.isCaptureBall) {
            const resetPos = { x: 0, y: 2, z: 0 };
            this.body.position.set(resetPos.x, resetPos.y, resetPos.z);
            this.el.object3D.position.set(resetPos.x, resetPos.y, resetPos.z);
            this.body.velocity.set(0, 0, 0);
            this.body.angularVelocity.set(0, 0, 0);
            this.body.gravity.set(0, 0, 0);
            this.isGrabbed = false;
            this.grabbingHand = null;
            this.velocityHistory = [];
            return;
          }
          
          // Recalculate the correct reset position based on current game mode
          const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
          let resetPos;
          
          if (isMultiplayer) {
            // Multiplayer: Reset to assigned player position
            const playerIndex = ballPlayerIndex - 1; // player1 -> index 0, player2 -> index 1, etc.
            if (playerIndex >= 0 && playerIndex < playerSlots.length) {
              const slot = playerSlots[playerIndex];
              const positionParts = slot.position.split(' ');
              resetPos = {
                x: parseFloat(positionParts[0]),
                y: parseFloat(positionParts[1]) + 2, // Add 2m height for ball spawn
                z: parseFloat(positionParts[2])
              };
            } else {
              resetPos = this.initialPosition;
            }
          } else {
            // Singleplayer: Use traditional positions
            if (ballPlayerIndex === 1) {
              // Bot's ball (red) - reset near bot
              resetPos = { x: 0, y: 2, z: -8 };
            } else if (ballPlayerIndex === 2) {
              // Player's ball (green) - reset near player
              resetPos = { x: 0, y: 2, z: 8 };
            } else {
              resetPos = this.initialPosition;
            }
          }
          
          // Update both physics body and visual position
          this.body.position.set(resetPos.x, resetPos.y, resetPos.z);
          this.el.object3D.position.set(resetPos.x, resetPos.y, resetPos.z);
          
          this.body.velocity.set(0, 0, 0);
          this.body.angularVelocity.set(0, 0, 0);
          this.body.gravity.set(0, 0, 0);
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
          
          // Clear hit cooldown and auto-return when manually resetting
          this.lastHitTime = 0;
          // Auto-return removed for space shooter
          
          // Reset homing missile properties if this was a homing missile
          if (this.isHomingMissile) {
            this.el.setAttribute('zerog-ball', {
              isHomingMissile: false,
              targetId: '',
              homingForce: 15,
              explosionRadius: 1.0,
              explosionDamage: 50,
              bulletHits: 0,
              maxBulletHits: 5
            });
            this.isHomingMissile = false;
            this.target = null;
            this.lastDistanceToTarget = Infinity;
            this.distanceIncreasingFrames = 0;
            console.log('🚀 Homing missile reset to regular ball');
          }
          
          // Ball reset to position
        },
        
        checkTargetHit: function() {
          if (this.isGrabbed || !this.body) return;

          // Per-ball cooldown to prevent double hits
          const now = Date.now();
          if (now - this.lastHitTime < this.hitCooldown) return;
          // Auto-return removed for space shooter

          const ballPos = new THREE.Vector3().copy(this.body.position);
          const ballVelocity = this.body.velocity.length();
          if (ballVelocity < 0.5) return;
          
          // Skip capture ball from hitting players
          if (this.isCaptureBall) return;

          const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
          const myPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
          // Dynamic ball assignment based on team in capture mode
          const myBallIndex = getBallForPlayer(myPlayerId || 'player_0');

          // --- SINGLEPLAYER LOGIC ---
          if (!isMultiplayer || activePlayers.size <= 1) {
            // Player2's ball hits bot target
            if (ballPlayerIndex === 2) {
              // CRITICAL FIX: Check both red and blue bot targets
              const redBotTarget = document.querySelector('#bot-target');
              const blueBotTarget = document.querySelector('#bot-blue-target');
              
              // Check red bot target
              if (redBotTarget) {
                const targetPos = new THREE.Vector3();
                redBotTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  if (gameMode === 'capture') {
                    // Check if ball should affect red bot based on team rules
                    if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-red')) {
                      return; // Same team - no effect (no explosion/sound)
                    }
                    // Play explosion/sound on red bot (only if different teams)
                    const impactEffect = redBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                    // In capture mode: stun the red bot
                    this.stunBot('bot-red');
                  } else {
                    // In dodge mode: always play effect and score
                    const impactEffect = redBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                  const gameManager = this.el.sceneEl.querySelector('#game-manager');
                  if (gameManager && gameManager.components['game-manager']) {
                    gameManager.components['game-manager'].onPlayerHit();
                  }
                  }
                  
                  this.lastHitTime = now;
                  // Auto-return removed for space shooter
                  return;
                }
              }
              
              // Check blue bot target
              if (blueBotTarget) {
                const targetPos = new THREE.Vector3();
                blueBotTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  if (gameMode === 'capture') {
                    // Check if ball should affect blue bot based on team rules
                    if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-blue')) {
                      return; // Same team - no effect (no explosion/sound)
                    }
                    // Play explosion/sound on blue bot (only if different teams)
                    const impactEffect = blueBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                    // In capture mode: stun the blue bot
                    this.stunBot('bot-blue');
                  } else {
                    // In dodge mode: always play effect and score
                    const impactEffect = blueBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                    const gameManager = this.el.sceneEl.querySelector('#game-manager');
                    if (gameManager && gameManager.components['game-manager']) {
                      gameManager.components['game-manager'].onPlayerHit();
                    }
                  }
                  
                  this.lastHitTime = now;
                  // Auto-return removed for space shooter
                  return;
                }
              }
              
              // Check green bot target
              const greenBotTarget = document.querySelector('#bot-green-target');
              if (greenBotTarget) {
                const targetPos = new THREE.Vector3();
                greenBotTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  if (gameMode === 'capture') {
                    // Check if ball should affect green bot based on team rules
                    if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-green')) {
                      return; // Same team - no effect (no explosion/sound)
                    }
                    // Play explosion/sound on green bot (only if different teams)
                    const impactEffect = greenBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                    // In capture mode: stun the green bot
                    this.stunBot('bot-green');
                  } else {
                    // In dodge mode: always play effect and score
                    const impactEffect = greenBotTarget.components['impact-effect'];
                    if (impactEffect) impactEffect.playEffect();
                    const gameManager = this.el.sceneEl.querySelector('#game-manager');
                    if (gameManager && gameManager.components['game-manager']) {
                      gameManager.components['game-manager'].onPlayerHit();
                    }
                  }
                  
                  this.lastHitTime = now;
                  // Auto-return removed for space shooter
                  return;
                }
              }
            }
            // Red bot's ball (ballPlayerIndex 1) hits player target
            if (ballPlayerIndex === 1) {
              const playerTarget = document.querySelector('#player-target');
              if (playerTarget) {
                const targetPos = new THREE.Vector3();
                playerTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  // Play explosion/sound on player
                  const impactEffect = playerTarget.components['impact-effect'];
                  if (impactEffect) impactEffect.playEffect();
                  
                  if (gameMode === 'capture') {
                    // Check if ball should affect player based on team rules
                    const playerId = myPlayerId || 'player_0';
                    if (!shouldBallAffectTarget(ballPlayerIndex, playerId)) {
                      return; // Same team - no effect
                    }
                    // In capture mode: stun the player
                    this.stunPlayer();
                  } else {
                    // In dodge mode: score for bot
                  const gameManager = this.el.sceneEl.querySelector('#game-manager');
                  if (gameManager && gameManager.components['game-manager']) {
                    gameManager.components['game-manager'].onOpponentHit();
                  }
                  }
                  
                  this.lastHitTime = now;
                  this.resetPosition();
                  return;
                }
              }
            }
            
            // Blue bot's ball (ballPlayerIndex 3) hits player target
            if (ballPlayerIndex === 3) {
              const playerTarget = document.querySelector('#player-target');
              if (playerTarget) {
                const targetPos = new THREE.Vector3();
                playerTarget.object3D.getWorldPosition(targetPos);
                if (ballPos.distanceTo(targetPos) < 0.3) {
                  // Play explosion/sound on player
                  const impactEffect = playerTarget.components['impact-effect'];
                  if (impactEffect) impactEffect.playEffect();
                  
                  if (gameMode === 'capture') {
                    // Check if ball should affect player based on team rules
                    const playerId = myPlayerId || 'player_0';
                    if (!shouldBallAffectTarget(ballPlayerIndex, playerId)) {
                      return; // Same team - no effect
                    }
                    // In capture mode: stun the player
                    this.stunPlayer();
                  } else {
                    // In dodge mode: score for bot
                  const gameManager = this.el.sceneEl.querySelector('#game-manager');
                  if (gameManager && gameManager.components['game-manager']) {
                    gameManager.components['game-manager'].onOpponentHit();
                  }
                  }
                  
                  this.lastHitTime = now;
                  this.resetPosition();
                  return;
                }
              }
            }
            return;
          }

          // --- MULTIPLAYER LOGIC ---
          // Only score if this ball hits another player's target (not own target)
          const currentPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
          
          for (let i = 0; i < 4; i++) {
            // CRITICAL FIX: Use proper ownership check instead of hardcoded ball numbers
            const targetPlayerId = `player_${i}`;
            const ballOwnerId = getBallOwnerId(ballPlayerIndex);
            
            // Skip if this ball belongs to the target player (prevent self-hits)
            if (ballOwnerId === targetPlayerId) {
              continue;
            }
            
            // Only check active players
            if (!activePlayers.has(targetPlayerId)) continue;
            // Find the correct target entity
            let targetEntity = null;
            if (myPlayerId && i === currentPlayerIndex) {
              targetEntity = document.querySelector('#player-target');
            } else {
              targetEntity = document.querySelector(`#remote-target-${i}`);
            }
            if (!targetEntity) {
              continue;
            }
            const targetPos = new THREE.Vector3();
            targetEntity.object3D.getWorldPosition(targetPos);
            if (ballPos.distanceTo(targetPos) < 0.3) {
              // Play explosion/sound on hit target
              const impactEffect = targetEntity.components['impact-effect'];
              if (impactEffect) {
                impactEffect.playEffect();
              }
              
              // Broadcast hit effect to all other players so they can see it too
              const hitTargetId = `player_${i}`;
              sendHitEffect(hitTargetId);
              
              if (gameMode === 'capture') {
                // Check if thrower and target are teammates
                const targetId = `player_${i}`;
                
                if (!shouldBallAffectTarget(ballPlayerIndex, targetId)) {
                  return; // Same team - no effect
                }
                
                // In capture mode: stun the hit player
                if (myPlayerId && i === currentPlayerIndex) {
                  // Local player was hit - stun them
                  this.stunPlayer();
                } else {
                  // Remote player was hit - they handle their own stunning
                }
              } else {
                // In dodge mode: score for the thrower
              const gameManager = this.el.sceneEl.querySelector('#game-manager');
              if (gameManager && gameManager.components['game-manager']) {
                if (isHost) {
                  // Score for the thrower (ballPlayerIndex-1)
                  gameManager.components['game-manager'].playerScores[ballPlayerIndex-1] += 1;
                  gameManager.components['game-manager'].updateMultiplayerScore();
                  gameManager.components['game-manager'].sendScoreUpdate();
                }
              }
              }
              
              this.lastHitTime = now;
              // SPACE SHOOTER: No auto-return after hitting opponent
              return;
            }
          }
          
          // --- MULTIPLAYER BOT COLLISION LOGIC ---
          // Check collisions with bots in multiplayer mode
          const redBotTarget = document.querySelector('#bot-target');
          const blueBotTarget = document.querySelector('#bot-blue-target');
          const greenBotTarget = document.querySelector('#bot-green-target');
          
          // Check red bot target
          if (redBotTarget) {
            const targetPos = new THREE.Vector3();
            redBotTarget.object3D.getWorldPosition(targetPos);
            if (ballPos.distanceTo(targetPos) < 0.3) {
              if (gameMode === 'capture') {
                // Check if ball should affect red bot based on team rules
                if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-red')) {
                  return; // Same team - no effect (no explosion/sound)
                }
                // Play explosion/sound on red bot (only if different teams)
                const impactEffect = redBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                // In capture mode: stun the red bot
                this.stunBot('bot-red');
              } else {
                // In dodge mode: always play effect and score
                const impactEffect = redBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                
                // CRITICAL FIX: Send hit effect for multiplayer scoring
                sendHitEffect('bot-red');
                
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  gameManager.components['game-manager'].onPlayerHit();
                }
              }
              
              this.lastHitTime = now;
              // SPACE SHOOTER: No auto-return after hitting bot
              return;
            }
          }
          
          // Check blue bot target
          if (blueBotTarget) {
            const targetPos = new THREE.Vector3();
            blueBotTarget.object3D.getWorldPosition(targetPos);
            if (ballPos.distanceTo(targetPos) < 0.3) {
              if (gameMode === 'capture') {
                // Check if ball should affect blue bot based on team rules
                if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-blue')) {
                  return; // Same team - no effect (no explosion/sound)
                }
                // Play explosion/sound on blue bot (only if different teams)
                const impactEffect = blueBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                // In capture mode: stun the blue bot
                this.stunBot('bot-blue');
              } else {
                // In dodge mode: always play effect and score
                const impactEffect = blueBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                
                // CRITICAL FIX: Send hit effect for multiplayer scoring
                sendHitEffect('bot-blue');
                
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  gameManager.components['game-manager'].onPlayerHit();
                }
              }
              
              this.lastHitTime = now;
              // SPACE SHOOTER: No auto-return after hitting bot
              return;
            }
          }
          
          // Check green bot target
          if (greenBotTarget) {
            const targetPos = new THREE.Vector3();
            greenBotTarget.object3D.getWorldPosition(targetPos);
            if (ballPos.distanceTo(targetPos) < 0.3) {
              if (gameMode === 'capture') {
                // Check if ball should affect green bot based on team rules
                if (!shouldBallAffectTarget(ballPlayerIndex, 'bot-green')) {
                  return; // Same team - no effect (no explosion/sound)
                }
                // Play explosion/sound on green bot (only if different teams)
                const impactEffect = greenBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                // In capture mode: stun the green bot
                this.stunBot('bot-green');
              } else {
                // In dodge mode: always play effect and score
                const impactEffect = greenBotTarget.components['impact-effect'];
                if (impactEffect) impactEffect.playEffect();
                
                // CRITICAL FIX: Send hit effect for multiplayer scoring
                sendHitEffect('bot-green');
                
                const gameManager = this.el.sceneEl.querySelector('#game-manager');
                if (gameManager && gameManager.components['game-manager']) {
                  gameManager.components['game-manager'].onPlayerHit();
              }
              }
              
              this.lastHitTime = now;
              // SPACE SHOOTER: No auto-return after hitting bot
              return;
            }
          }
        },
        
        onGrab: function(hand) {
          // CRITICAL FIX: For capture ball, send network message to force release on other players
          if (this.isCaptureBall && isMultiplayer && activePlayers.size > 1) {
            // Debounce network messages to prevent spam
            const now = Date.now();
            if (!this.lastGrabMessageTime || now - this.lastGrabMessageTime > 500) {
              this.lastGrabMessageTime = now;
              
              // Send capture ball grab message to all other players
              const data = {
                type: 'capture-ball-grabbed',
                grabberId: myPlayerId,
                timestamp: now
              };
              
              console.log('📡 Sending capture ball grab message to', connections.size, 'players');
              connections.forEach((conn, playerId) => {
                if (conn && conn.open) {
                  conn.send(data);
                }
              });
            } else {
              console.log('🚫 Skipping duplicate grab message (debounced)');
            }
          }
          
          this.isGrabbed = true;
          this.grabbingHand = hand;
          this.body.gravity.set(0, 0, 0);
          
          // CRITICAL FIX: Set ownership when ball is grabbed
          if (this.isCaptureBall) {
            this.currentOwner = myPlayerId;
            this.lastOwnerChangeTime = Date.now();
          }
          
          // Activate shield for player balls when grabbed (if available and not capture ball)
          if (!this.isCaptureBall) {
            const shieldElement = this.el.querySelector('.ball-shield');
            if (shieldElement && shieldElement.components['ball-shield']) {
              const activated = shieldElement.components['ball-shield'].activateShield();
              console.log(`🛡️ Shield activation for ${this.data.player}: ${activated ? 'SUCCESS' : 'FAILED (cooldown)'}`);
            } else {
              console.log(`🛡️ Shield element or component missing for ${this.data.player}`);
            }
            
            // CRITICAL: Update collision mask after shield activation
            this.updateCollisionMask();
          }
          
          // CRITICAL FIX: Send ball grab state to other players for collision mask sync
          if (isMultiplayer && activePlayers.size > 1 && !this.isCaptureBall) {
            const data = {
              type: 'ball-grab-state',
              ballId: this.data.player,
              playerId: myPlayerId,
              isGrabbed: true,
              timestamp: Date.now()
            };
            
            connections.forEach((conn, playerId) => {
              if (conn && conn.open) {
                conn.send(data);
              }
            });
          }
          
          // Cancel auto-return if player grabs the ball
          if (this.autoReturnActive) {
            // Auto-return removed for space shooter
          }
          
          // Start velocity and rotation tracking
          this.velocityHistory = [];
          const handPos = new THREE.Vector3();
          const handQuat = new THREE.Quaternion();
          hand.object3D.getWorldPosition(handPos);
          hand.object3D.getWorldQuaternion(handQuat);
          this.lastPosition.copy(handPos);
          this.lastRotation = handQuat.clone();
          this.lastPositionTime = performance.now();
          
          // Haptic feedback
          if (hand?.components?.['tracked-controls']?.controller?.gamepad?.hapticActuators?.[0]) {
            const haptics = hand.components['tracked-controls'].controller.gamepad.hapticActuators[0];
            haptics.pulse(0.7, 100).catch(() => {});
          }
        },
        
        onRelease: function() {
          if (!this.isGrabbed) return;
          
          
          // Calculate throw velocity from hand movement history
          let velocity = new THREE.Vector3(0, 0, 0);
          
          if (this.velocityHistory.length > 0) {
            // Use weighted average of recent velocities
            let totalWeight = 0;
            for (let i = 0; i < this.velocityHistory.length; i++) {
              const weight = (i + 1) / this.velocityHistory.length;
              velocity.add(this.velocityHistory[i].clone().multiplyScalar(weight));
              totalWeight += weight;
            }
            velocity.divideScalar(totalWeight);
            
            // Scale for satisfying throws
            velocity.multiplyScalar(1.5);
            
            // Cap maximum throw speed (different for capture ball)
            const maxThrowSpeed = this.isCaptureBall ? this.data.maxVelocity : 15; // m/s
            if (velocity.length() > maxThrowSpeed) {
              velocity.normalize().multiplyScalar(maxThrowSpeed);
            }
          }
          
          // Apply velocity to physics body
          this.body.velocity.set(velocity.x, velocity.y, velocity.z);
          
          // CRITICAL FIX: Immediately send ball state for multiplayer sync when throwing
          if (isMultiplayer && activePlayers.size > 1) {
            // Send immediate ball state with throw velocity for capture ball
            if (this.isCaptureBall) {
              const pos = this.el.object3D.position;
              sendBallState({ 
                playerId: 'capture',
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            } else {
              // Send immediate ball state for regular player balls
              const ballPlayerIndex = parseInt(this.data.player.replace('player', ''));
              const pos = this.el.object3D.position;
              sendBallState({ 
                playerId: ballPlayerIndex,
                x: pos.x, y: pos.y, z: pos.z, 
                vx: velocity.x, vy: velocity.y, vz: velocity.z 
              });
            }
          }
          
          // Calculate angular velocity based on hand rotation change
          let angularVelocity = new THREE.Vector3(0, 0, 0);
          if (this.lastRotation && this.grabbingHand) {
            const currentHandQuat = new THREE.Quaternion();
            this.grabbingHand.object3D.getWorldQuaternion(currentHandQuat);
            
            // Calculate rotation difference
            const deltaRot = new THREE.Quaternion().multiplyQuaternions(
              currentHandQuat,
              this.lastRotation.clone().invert()
            );
            
            // Convert quaternion to angular velocity
            const angle = 2 * Math.acos(Math.abs(deltaRot.w));
            if (angle > 0.0001) {
              const axis = new THREE.Vector3(deltaRot.x, deltaRot.y, deltaRot.z).normalize();
              // Scale angular velocity for good spin effect (matching index.html)
              axis.multiplyScalar(angle * 40); // Same as index.html for consistency
              angularVelocity = axis;
            }
          }
          
          // Apply calculated angular velocity for realistic spin
          this.body.angularVelocity.set(angularVelocity.x, angularVelocity.y, angularVelocity.z);
          
          
          this.body.gravity.set(0, 0, 0);
          

          
          this.isGrabbed = false;
          this.grabbingHand = null;
          this.velocityHistory = [];
          
          // CRITICAL: Track release time for collision logic
          this.lastReleaseTime = Date.now();
          
          // CRITICAL FIX: Ensure shield is deactivated when ball is released
          if (!this.isCaptureBall) {
            const shieldElement = this.el.querySelector('.ball-shield');
            if (shieldElement && shieldElement.components['ball-shield']) {
              const shieldComponent = shieldElement.components['ball-shield'];
              if (shieldComponent.isActive && !shieldComponent.isOnCooldown) {
                shieldComponent.deactivateShield();
              }
            }
            
            // CRITICAL: Update collision mask after release (should be walls only)
            this.updateCollisionMask();
            
            // CRITICAL FIX: Send ball release state to other players for collision mask sync
            if (isMultiplayer && activePlayers.size > 1) {
              const data = {
                type: 'ball-grab-state',
                ballId: this.data.player,
                playerId: myPlayerId,
                isGrabbed: false,
                lastReleaseTime: this.lastReleaseTime,
                timestamp: Date.now()
              };
              
              connections.forEach((conn, playerId) => {
                if (conn && conn.open) {
                  conn.send(data);
                }
              });
            }
          }
          
          // CRITICAL FIX: Clear ownership when ball is voluntarily released (not stolen)
          if (this.isCaptureBall && this.currentOwner === myPlayerId) {
            this.currentOwner = null;
            this.lastOwnerChangeTime = Date.now();
          }
          
          // NOTE: Ball state with velocity is already sent immediately above in onRelease
          // No need to send additional release state here since throw velocity sync handles it
        },
        
        handleShieldCollision: function(otherBody, otherBallComponent, contact) {
          // Check if either ball has an active shield
          const myShieldElement = this.el.querySelector('.ball-shield');
          const otherShieldElement = otherBody.el.querySelector('.ball-shield');
          
          let myShield = null;
          let otherShield = null;
          
          if (myShieldElement && myShieldElement.components['ball-shield']) {
            myShield = myShieldElement.components['ball-shield'];
          }
          
          if (otherShieldElement && otherShieldElement.components['ball-shield']) {
            otherShield = otherShieldElement.components['ball-shield'];
          }
          
          // Check team logic - only process if balls are from opposing teams
          const myBallIndex = parseInt(this.data.player.replace('player', ''));
          const otherBallIndex = parseInt(otherBallComponent.data.player.replace('player', ''));
          const myPlayerId_safe = myPlayerId || 'player_0';
          
          if (!shouldBallAffectTarget(otherBallIndex, myPlayerId_safe)) {
            return; // Same team - no shield interaction
          }
          
          // Check if my ball has an active shield and is being hit
          if (myShield && myShield.isActive) {
            console.log(`🛡️ SHIELD HIT! ${this.data.player} blocked ${otherBallComponent.data.player}`);
            
            // CRITICAL FIX: Deactivate shield first, then let collision happen normally
            if (this.isLocalPlayerBall && this.isLocalPlayerBall()) {
              console.log(`🛡️ Deactivating MY shield for ${this.data.player}`);
              myShield.deactivateShield(); // This restores collision mask to 4|2
              myShield.startCooldown();
            }
            
            // Now let the collision happen with normal physics (bouncy)
            if (contact) {
              contact.restitution = 1.2; // Slightly bouncy for shield collision
            }
            
            return; // Let physics handle the collision
          }
          
          // Check if the other ball has an active shield and I'm hitting it
          if (otherShield && otherShield.isActive) {
            console.log(`🛡️ SHIELD BLOCKED! ${this.data.player} hit ${otherBallComponent.data.player}'s shield`);
            
            // CRITICAL FIX: Deactivate the other shield first, then let collision happen
            if (otherBallComponent.isLocalPlayerBall && otherBallComponent.isLocalPlayerBall()) {
              console.log(`🛡️ Deactivating OTHER shield for ${otherBallComponent.data.player}`);
              otherShield.deactivateShield(); // This restores collision mask to 4|2
              otherShield.startCooldown();
            }
            
            // Now let the collision happen with normal physics (bouncy)
            if (contact) {
              contact.restitution = 1.2; // Slightly bouncy for shield collision
            }
            
            return; // Let physics handle the collision
          }
        },
        
        handleShieldBeginContact: function(otherBody, otherBallComponent, contact) {
          // Check if either ball has an active shield
          const myShieldElement = this.el.querySelector('.ball-shield');
          const otherShieldElement = otherBody.el.querySelector('.ball-shield');
          
          let myShield = null;
          let otherShield = null;
          
          if (myShieldElement && myShieldElement.components['ball-shield']) {
            myShield = myShieldElement.components['ball-shield'];
          }
          
          if (otherShieldElement && otherShieldElement.components['ball-shield']) {
            otherShield = otherShieldElement.components['ball-shield'];
          }
          
          // Check team logic - only process if balls are from opposing teams
          const myBallIndex = parseInt(this.data.player.replace('player', ''));
          const otherBallIndex = parseInt(otherBallComponent.data.player.replace('player', ''));
          const myPlayerId_safe = myPlayerId || 'player_0';
          
          if (!shouldBallAffectTarget(otherBallIndex, myPlayerId_safe)) {
            return; // Same team - no shield interaction
          }
          
          
          // Check if my ball has an active shield and is being hit
          if (myShield && myShield.isActive) {
            console.log(`🛡️ SHIELD HIT! ${this.data.player} blocked ${otherBallComponent.data.player}`);
            
            // CRITICAL FIX: Deactivate shield and update collision mask immediately
            if (this.isLocalPlayerBall && this.isLocalPlayerBall()) {
              console.log(`🛡️ Deactivating MY shield for ${this.data.player}`);
              myShield.deactivateShield();
              myShield.startCooldown();
              
              // TRIPLE IMMEDIATE collision mask updates to ensure it takes effect
              this.updateCollisionMask();
              // Shield deactivated (debug spam removed)
              
              setTimeout(() => {
                if (this.updateCollisionMask) {
                  this.updateCollisionMask();
                }
              }, 1);
              
              setTimeout(() => {
                if (this.updateCollisionMask) {
                  this.updateCollisionMask();
                }
              }, 50);
            }
            
            // Make collision bouncy for shield hit
            if (contact) {
              contact.restitution = 1.2;
            }
            
            return;
          }
          
          // Check if the other ball has an active shield and I'm hitting it
          if (otherShield && otherShield.isActive) {
            console.log(`🛡️ SHIELD BLOCKED! ${this.data.player} hit ${otherBallComponent.data.player}'s shield`);
            
            // CRITICAL FIX: Deactivate the other shield and update collision mask immediately
            if (otherBallComponent.isLocalPlayerBall && otherBallComponent.isLocalPlayerBall()) {
              console.log(`🛡️ Deactivating OTHER shield for ${otherBallComponent.data.player}`);
              otherShield.deactivateShield();
              otherShield.startCooldown();
              
              // TRIPLE IMMEDIATE collision mask updates to ensure it takes effect
              otherBallComponent.updateCollisionMask();
              // Other shield deactivated (debug spam removed)
              
              setTimeout(() => {
                if (otherBallComponent.updateCollisionMask) {
                  otherBallComponent.updateCollisionMask();
                }
              }, 1);
              
              setTimeout(() => {
                if (otherBallComponent.updateCollisionMask) {
                  otherBallComponent.updateCollisionMask();
                }
              }, 50);
            }
            
            // Make collision bouncy for shield hit
            if (contact) {
              contact.restitution = 1.2;
            }
            
            return;
          }
          
        },
        
        isLocalPlayerBall: function() {
          // Use getBallForPlayer to get the correct ball assignment
          const myBallNumber = getBallForPlayer(myPlayerId || 'player_0');
          const myBallId = `player${myBallNumber}`;
          
          return this.data.player === myBallId;
        },
        
        updateCollisionMask: function() {
          if (!this.body || this.isCaptureBall) return;
          
          const shieldElement = this.el.querySelector('.ball-shield');
          const hasActiveShield = shieldElement && 
                                 shieldElement.components['ball-shield'] && 
                                 shieldElement.components['ball-shield'].isActive;
          
          // USER SPECIFIED COLLISION MASK LOGIC:
          // 1. Ball not held = collision mask 6
          // 2. Ball held + shield active = collision mask 6  
          // 3. Ball held + shield deactivated = collision mask 4
          
          let newMask;
          if (!this.isGrabbed) {
            // Ball not held → collision mask 6
            newMask = 4 | 2; // 6
          } else if (this.isGrabbed && hasActiveShield) {
            // Ball held + shield active → collision mask 6
            newMask = 4 | 2; // 6
          } else if (this.isGrabbed && !hasActiveShield) {
            // Ball held + shield deactivated → collision mask 4
            newMask = 4;
          } else {
            // Fallback
            newMask = 4;
          }
          
          // Collision mask updated (debug spam removed)
          
          if (this.body.collisionFilterMask !== newMask) {
            const oldMask = this.body.collisionFilterMask;
            this.body.collisionFilterMask = newMask;
            // Mask updated silently
          }
        },
        
        // Ball shooting system for space shooter
        shootBall: function(controller) {
          const now = Date.now();
          
          // Fire rate limiting (500ms between shots)
          if (this.lastShot && now - this.lastShot < 500) {
            return;
          }
          this.lastShot = now;
          
          // Get controller position and direction
          const controllerPos = new THREE.Vector3();
          const controllerQuat = new THREE.Quaternion();
          controller.object3D.getWorldPosition(controllerPos);
          controller.object3D.getWorldQuaternion(controllerQuat);
          
          // Calculate shooting direction (same as thruster - pointing down from controller)
          const direction = new THREE.Vector3(0, -1, 0);
          direction.applyQuaternion(controllerQuat);
          
          // Set ball position to controller position
          this.body.position.set(controllerPos.x, controllerPos.y, controllerPos.z);
          this.el.object3D.position.copy(controllerPos);
          
          // Apply velocity in shooting direction
          const shootSpeed = 15;
          this.body.velocity.set(
            direction.x * shootSpeed,
            direction.y * shootSpeed, 
            direction.z * shootSpeed
          );
          
          // Ball will stay where it lands - no auto reset
          
          // Ball shot from controller
        },
        
        stunPlayer: function() {
          // Stun the player for 3 seconds
          const player = document.querySelector('[zerog-player]');
          if (player && player.components['zerog-player']) {
            const playerComponent = player.components['zerog-player'];
            
            // Check if player has stun immunity
            if (Date.now() < playerComponent.stunImmunityEndTime) {
              return;
            }
            
            // Stop player movement
            playerComponent.velocity.set(0, 0, 0);
            
            // Disable controls
            playerComponent.isStunned = true;
            playerComponent.stunEndTime = Date.now() + 3000; // 3 seconds
            playerComponent.stunImmunityEndTime = Date.now() + 13000; // 10 seconds immunity after stun ends
            
            // Release capture ball if holding it
            const captureBall = document.querySelector('#capture-ball');
            if (captureBall && captureBall.components['zerog-ball'] && 
                captureBall.components['zerog-ball'].isGrabbed) {
              captureBall.components['zerog-ball'].onRelease();
            }
            
          }
        },
        
        stunBot: function(botId) {
          // CRITICAL FIX: Stun specific bot based on botId parameter
          let bot = null;
          if (botId === 'bot-red') {
            bot = document.querySelector('#zerog-bot-red');
          } else if (botId === 'bot-blue') {
            bot = document.querySelector('#zerog-bot-blue');
          } else if (botId === 'bot-green') {
            bot = document.querySelector('#zerog-bot-green');
          } else {
            // Fallback to old behavior if no botId specified
            bot = document.querySelector('#zerog-bot-red') || document.querySelector('#zerog-bot-blue') || document.querySelector('#zerog-bot-green');
          }
          
          if (bot && bot.components['zerog-bot']) {
            const botComponent = bot.components['zerog-bot'];
            
            // Check if bot has stun immunity
            if (Date.now() < botComponent.stunImmunityEndTime) {

              return;
            }
            
            // Stop bot movement
            if (botComponent.body) {
              botComponent.body.velocity.set(0, 0, 0);
            }
            
            // Disable bot AI
            botComponent.isStunned = true;
            botComponent.stunEndTime = Date.now() + 3000; // 3 seconds
            botComponent.stunImmunityEndTime = Date.now() + 13000; // 10 seconds immunity after stun ends
            

          }
        },
        
        tick: function() {
          if (this.body) {
            // CRITICAL: Periodically verify collision mask matches shield state (every 500ms)
            if (!this.lastSyncCheck) this.lastSyncCheck = 0;
            if (Date.now() - this.lastSyncCheck > 500) {
              this.updateCollisionMask();
              this.lastSyncCheck = Date.now();
            }
 
             
            if (this.isGrabbed && this.grabbingHand) {
              // When grabbed, track hand movement and rotation for throwing
              const handPos = new THREE.Vector3();
              const handQuat = new THREE.Quaternion();
              this.grabbingHand.object3D.getWorldPosition(handPos);
              this.grabbingHand.object3D.getWorldQuaternion(handQuat);
              
              // Check for collision and apply force feedback to player
              const ballRadius = this.isCaptureBall ? 0.2 : 0.1;
              const collisionResult = this.checkBallCollisionWithFeedback(handPos, ballRadius);
              
              // Apply collision force back to player
              if (collisionResult.force.length() > 0) {
                const player = document.querySelector('[zerog-player]');
                if (player && player.components['zerog-player']) {
                  player.components['zerog-player'].applyCollisionForce(collisionResult.force, this.grabbingHand);
                }
              }
              
              // Update ball position AND rotation to match hand (with collision correction)
              this.el.object3D.position.copy(collisionResult.position);
              this.el.object3D.quaternion.copy(handQuat);
              this.body.position.copy(collisionResult.position);
              this.body.quaternion.copy(handQuat);
              this.body.velocity.set(0, 0, 0);
              this.body.angularVelocity.set(0, 0, 0);
              

              

              
              // Track velocity history for throwing
              const currentTime = performance.now();
              if (this.lastPositionTime > 0) {
                const deltaTime = Math.max((currentTime - this.lastPositionTime) / 1000, 0.001);
                const displacement = new THREE.Vector3().subVectors(handPos, this.lastPosition);
                const instantVelocity = displacement.divideScalar(deltaTime);
                
                this.velocityHistory.push(instantVelocity.clone());
                if (this.velocityHistory.length > this.maxHistorySize) {
                  this.velocityHistory.shift();
                }
              }
              
              this.lastPosition.copy(handPos);
              this.lastRotation = handQuat.clone();
              this.lastPositionTime = currentTime;
            } else {
              // When not grabbed, update visual position from physics
              // BUT: Don't override if this is a remote ball that was manually updated
              const isRemoteBall = this.el.hasAttribute('data-remote-update');
              
              // Always update visual position from physics body when not grabbed
              // This ensures the ball moves smoothly during auto-return and tractor beam
              if (!isRemoteBall && !this.isGrabbed) {
                this.el.object3D.position.copy(this.body.position);
                this.el.object3D.quaternion.copy(this.body.quaternion);
              }
              
              // CUSTOM COLLISION DETECTION (like player collision system)
              if (!this.isGrabbed) {
                this.checkCustomCollision();
              }
              
              // Check auto-return timeout (turn off after 2 seconds)
              if (this.autoReturnActive && Date.now() - this.autoReturnStartTime > this.autoReturnDuration) {
                // Auto-return removed for space shooter
              }
              
              // Tractor beam logic (only for current player's ball when A is held OR grip is held OR auto-return)
              if (this.shouldActivateTractorBeam()) {
                // Determine which ball belongs to the current player
                let currentPlayerBall = 'player2'; // Default for singleplayer
                if (isMultiplayer && myPlayerId) {
                  const ballNumber = getBallForPlayer(myPlayerId);
                  currentPlayerBall = `player${ballNumber}`;
                }
                
                // Only apply tractor beam to the current player's ball
                if (this.data.player === currentPlayerBall) {
                  this.applyTractorBeam();
                }
              }
              
              // Check for target hits each frame when moving
              this.checkTargetHit();
              
              // Keep zero gravity
              this.body.gravity.set(0, 0, 0);
              
              // Apply Magnus effect for spinning balls (matching index.html exactly)
              if (this.body.velocity.length() > 0.1) {
                const velocity = new THREE.Vector3(
                  this.body.velocity.x,
                  this.body.velocity.y,
                  this.body.velocity.z
                );

                const angularVelocity = new THREE.Vector3(
                  this.body.angularVelocity.x,
                  this.body.angularVelocity.y,
                  this.body.angularVelocity.z
                );

                const angularSpeed = angularVelocity.length();
                const linearSpeed = velocity.length();
                
                // Debug: Always log spin and speed when ball is moving to see what we're working with
                // if (linearSpeed > 0.5) {
                // }
                
                // Apply Magnus effect - subtle curve to existing motion
                if (angularSpeed > 0.1 && linearSpeed > 0.5) { // Much lower thresholds
                  // Calculate Magnus force as acceleration (not velocity change)
                  const magnusAcceleration = new THREE.Vector3()
                    .crossVectors(angularVelocity, velocity);
                  
                  // Small but noticeable effect - frame rate independent acceleration
                  const frameTime = 1/72; // Assume 72fps for consistent effect
                  const magnusStrength = 0.008; // Slightly stronger Magnus effect - more noticeable curvature
                  
                  // Scale acceleration by frame time and strength
                  magnusAcceleration.multiplyScalar(magnusStrength * frameTime);
                  
                  // Apply as acceleration (small velocity change per frame)
                  this.body.velocity.x += magnusAcceleration.x;
                  this.body.velocity.y += magnusAcceleration.y;
                  this.body.velocity.z += magnusAcceleration.z;
                  
                  // Log Magnus effect very rarely
                  // Magnus effect logging removed
                }

                // Add minimal damping only for very slow balls to prevent infinite bouncing
                const speed = velocity.length();
                const currentAngularSpeed = angularVelocity.length();
                if (speed < 0.5 && currentAngularSpeed < 1.0) { // Only damp if both linear and angular are slow
                  const damping = 0.995;
                  this.body.velocity.x *= damping;
                  this.body.velocity.y *= damping;
                  this.body.velocity.z *= damping;
                  this.body.angularVelocity.x *= damping;
                  this.body.angularVelocity.y *= damping;
                  this.body.angularVelocity.z *= damping;
                }
                
                // GLOBAL SPEED LIMIT: Prevent any ball from escaping the environment
                const maxGlobalSpeed = 12.0; // Maximum speed for any ball movement
                if (speed > maxGlobalSpeed) {
                  const scale = maxGlobalSpeed / speed;
                  this.body.velocity.x *= scale;
                  this.body.velocity.y *= scale;
                  this.body.velocity.z *= scale;
                  
                  // Also limit angular velocity to prevent excessive spinning
                  const maxAngularSpeed = 20.0;
                  if (currentAngularSpeed > maxAngularSpeed) {
                    const angularScale = maxAngularSpeed / currentAngularSpeed;
                    this.body.angularVelocity.x *= angularScale;
                    this.body.angularVelocity.y *= angularScale;
                    this.body.angularVelocity.z *= angularScale;
                  }
                }
              }
            }
          }
        },
        
        // NEW: Check if tractor beam should be activated (A button OR grip buttons OR auto-return)
        shouldActivateTractorBeam: function() {
          // CRITICAL: Don't activate tractor beam if ball is grabbed
          if (this.isGrabbed) {
            return false;
          }
          
          // Tractor beam removed for space shooter
          
          // Auto-return removed for space shooter
          
          return false;
        },
        
        checkBallCollisionWithFeedback: function(targetPos, ballRadius) {
          const correctedPos = targetPos.clone();
          const collisionMargin = 0.02; // 2cm safety margin like player
          const totalRadius = ballRadius + collisionMargin;
          let totalForce = new THREE.Vector3(0, 0, 0);
          
          // Check against all grab-surface objects (walls, floors, etc.)
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            const surfacePos = new THREE.Vector3();
            surface.object3D.getWorldPosition(surfacePos);
            const geometry = surface.getAttribute('geometry');
            
            if (!geometry) return;
            
            // Get the safe position and collision force
            const result = this.getSafePositionAndForce(correctedPos, totalRadius, surfacePos, geometry, targetPos);
            if (result.safePos) {
              correctedPos.copy(result.safePos);
              totalForce.add(result.force);
            }
          });
          
          return {
            position: correctedPos,
            force: totalForce
          };
        },
        
        getSafePositionAndForce: function(point, radius, surfacePos, geometry, originalTarget) {
          const forceMultiplier = 4.0; // Higher multiplier for more sensitive force detection
          
          if (geometry.primitive === 'box') {
            // Box collision - clamp to safe position outside box
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            
            if (distance < radius) {
              // Ball is too close or inside - calculate force and safe position
              let direction = relativePos.clone().sub(closestPoint);
              
              if (direction.length() === 0) {
                // Handle edge case where point is exactly at box center
                const distances = [
                  Math.abs(relativePos.x) - halfWidth,
                  Math.abs(relativePos.y) - halfHeight, 
                  Math.abs(relativePos.z) - halfDepth
                ];
                const minIndex = distances.indexOf(Math.min(...distances));
                
                if (minIndex === 0) direction.set(relativePos.x > 0 ? 1 : -1, 0, 0);
                else if (minIndex === 1) direction.set(0, relativePos.y > 0 ? 1 : -1, 0);
                else direction.set(0, 0, relativePos.z > 0 ? 1 : -1);
              }
              
              direction.normalize();
              const penetration = radius - distance;
              const force = direction.clone().multiplyScalar(penetration * forceMultiplier);
              const safePoint = closestPoint.clone().add(direction.multiplyScalar(radius));
              
              return {
                safePos: safePoint.add(surfacePos),
                force: force
              };
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision - clamp to safe position outside sphere
            const sphereRadius = geometry.radius || 1.0;
            const distance = point.distanceTo(surfacePos);
            const minDistance = radius + sphereRadius;
            
            if (distance < minDistance) {
              const direction = point.clone().sub(surfacePos);
              if (direction.length() === 0) {
                direction.set(0, 1, 0); // Default up direction
              }
              direction.normalize();
              const penetration = minDistance - distance;
              const force = direction.clone().multiplyScalar(penetration * forceMultiplier);
              
              return {
                safePos: surfacePos.clone().add(direction.multiplyScalar(minDistance)),
                force: force
              };
            }
          } else if (geometry.primitive === 'octahedron') {
            // Octahedron collision - clamp to safe position outside octahedron
            const octahedronRadius = geometry.radius || 1.0;
            const relativePos = point.clone().sub(surfacePos);
            const absX = Math.abs(relativePos.x);
            const absY = Math.abs(relativePos.y);
            const absZ = Math.abs(relativePos.z);
            const manhattanDistance = absX + absY + absZ;
            const minDistance = radius + octahedronRadius;
            
            if (manhattanDistance < minDistance) {
              // Scale the relative position to be exactly at safe distance
              const scale = minDistance / manhattanDistance;
              const safeRelativePos = relativePos.clone().multiplyScalar(scale);
              const penetration = minDistance - manhattanDistance;
              const direction = relativePos.clone().normalize();
              const force = direction.multiplyScalar(penetration * forceMultiplier);
              
              return {
                safePos: surfacePos.clone().add(safeRelativePos),
                force: force
              };
            }
          } else if (geometry.primitive === 'dodecahedron') {
            // Dodecahedron collision - clamp to safe position outside dodecahedron
            const dodecahedronRadius = geometry.radius || 1.0;
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            const minDistance = radius + dodecahedronRadius;
            
            if (distance < minDistance) {
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              const penetration = minDistance - distance;
              const force = direction.clone().multiplyScalar(penetration * forceMultiplier);
              
              return {
                safePos: surfacePos.clone().add(direction.multiplyScalar(minDistance)),
                force: force
              };
            }
          } else if (geometry.primitive === 'icosahedron') {
            // Icosahedron collision - clamp to safe position outside icosahedron
            const icosahedronRadius = geometry.radius || 1.0;
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            const minDistance = radius + icosahedronRadius;
            
            if (distance < minDistance) {
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              const penetration = minDistance - distance;
              const force = direction.clone().multiplyScalar(penetration * forceMultiplier);
              
              return {
                safePos: surfacePos.clone().add(direction.multiplyScalar(minDistance)),
                force: force
              };
            }
          }
          
          return { safePos: null, force: new THREE.Vector3(0, 0, 0) }; // No collision
        },
        
        // CUSTOM COLLISION DETECTION (identical to player collision system)
        checkCustomCollision: function() {
          // Convert CANNON.Vec3 to THREE.Vector3 for collision math
          const ballPos = new THREE.Vector3(this.body.position.x, this.body.position.y, this.body.position.z);
          const ballRadius = this.isCaptureBall ? 0.2 : 0.1; // Use actual ball radius
          const ballVelocity = new THREE.Vector3(this.body.velocity.x, this.body.velocity.y, this.body.velocity.z);
          
          // Use EXACT same selector as player collision system
          const surfaces = document.querySelectorAll('[grab-surface]');
          surfaces.forEach(surface => {
            const surfacePos = new THREE.Vector3();
            surface.object3D.getWorldPosition(surfacePos);
            const geometry = surface.getAttribute('geometry');
            
            if (!geometry) return;
            
            // Use the EXACT same collision response function as player
            const collision = this.getCollisionResponse(ballPos, ballRadius, surfacePos, geometry, surface);
            if (collision.length() > 0) {
              // Apply collision response to ball physics
              const newPos = ballPos.clone().add(collision);
              this.body.position.set(newPos.x, newPos.y, newPos.z);
              
              // Reflect velocity (bounce)
              const normal = collision.clone().normalize();
              const reflectedVelocity = ballVelocity.sub(normal.multiplyScalar(2 * ballVelocity.dot(normal)));
              
              // Apply some damping to the bounce
              reflectedVelocity.multiplyScalar(0.8);
              
              this.body.velocity.set(reflectedVelocity.x, reflectedVelocity.y, reflectedVelocity.z);
            }
          });
        },
        
        // Collision response math (identical to player collision system)
        getCollisionResponse: function(point, radius, surfacePos, geometry, element) {
          const response = new THREE.Vector3(0, 0, 0);
          const collisionMargin = 0.02; // Same as player collision margin
          
          if (geometry.primitive === 'box') {
            // Box collision
            const halfWidth = geometry.width / 2;
            const halfHeight = geometry.height / 2;
            const halfDepth = geometry.depth / 2;
            
            // Get point relative to box center
            const relativePos = point.clone().sub(surfacePos);
            
            // Find closest point on box surface
            const closestPoint = new THREE.Vector3(
              Math.max(-halfWidth, Math.min(halfWidth, relativePos.x)),
              Math.max(-halfHeight, Math.min(halfHeight, relativePos.y)),
              Math.max(-halfDepth, Math.min(halfDepth, relativePos.z))
            );
            
            // Distance from point to closest point on box
            const distance = relativePos.distanceTo(closestPoint);
            const penetration = radius + collisionMargin - distance;
            
            if (penetration > 0) {
              // Calculate push-out direction
              const direction = relativePos.clone().sub(closestPoint).normalize();
              if (direction.length() === 0) {
                // Point is exactly on surface, push up
                direction.set(0, 1, 0);
              }
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'sphere') {
            // Sphere collision
            const sphereRadius = geometry.radius;
            const distance = point.distanceTo(surfacePos);
            const penetration = radius + sphereRadius + collisionMargin - distance;
            
            if (penetration > 0) {
              const direction = point.clone().sub(surfacePos).normalize();
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'octahedron') {
            // Octahedron collision
            const octahedronRadius = geometry.radius || 1.0;
            
            // Get point relative to octahedron center
            const relativePos = point.clone().sub(surfacePos);
            
            // Calculate distance to octahedron surface
            const absX = Math.abs(relativePos.x);
            const absY = Math.abs(relativePos.y);
            const absZ = Math.abs(relativePos.z);
            const manhattanDistance = absX + absY + absZ;
            
            const distanceToSurface = manhattanDistance - octahedronRadius;
            const penetration = (radius + collisionMargin) - distanceToSurface;
            
            if (penetration > 0) {
              let direction = new THREE.Vector3();
              
              if (manhattanDistance > 0.001) {
                direction.x = relativePos.x >= 0 ? 1 : -1;
                direction.y = relativePos.y >= 0 ? 1 : -1;
                direction.z = relativePos.z >= 0 ? 1 : -1;
                direction.normalize();
              } else {
                direction.set(0, 1, 0);
              }
              
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'dodecahedron') {
            // Dodecahedron collision
            const dodecahedronRadius = geometry.radius || 1.0;
            
            // Get point relative to dodecahedron center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + collisionMargin + dodecahedronRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (geometry.primitive === 'icosahedron') {
            // Icosahedron collision
            const icosahedronRadius = geometry.radius || 1.0;
            
            // Get point relative to icosahedron center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + collisionMargin + icosahedronRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          } else if (!geometry && element.querySelector('a-gltf-model')) {
            // GLTF Model collision
            const scale = element.getAttribute('scale') || {x: 1, y: 1, z: 1};
            const avgScale = (scale.x + scale.y + scale.z) / 3;
            const modelRadius = avgScale * 1.0;
            
            // Get point relative to model center
            const relativePos = point.clone().sub(surfacePos);
            const distance = relativePos.length();
            
            // Calculate penetration using full radius to match physics body
            const penetration = radius + collisionMargin + modelRadius - distance;
            
            if (penetration > 0) {
              // Push away from center
              const direction = distance > 0.001 ? relativePos.clone().normalize() : new THREE.Vector3(0, 1, 0);
              response.copy(direction.multiplyScalar(penetration));
            }
          }
          
          return response;
        },
        
        // NEW: Start auto-return mode (called when ball hits target)
        startAutoReturn: function() {
          // Determine which ball belongs to the current player
          let currentPlayerBall = 'player2'; // Default for singleplayer
          if (isMultiplayer && myPlayerId) {
            const ballNumber = getBallForPlayer(myPlayerId);
            currentPlayerBall = `player${ballNumber}`;
          }
          
          if (this.data.player === currentPlayerBall) { // Only for current player's ball
            this.autoReturnActive = true;
            this.autoReturnStartTime = Date.now();
            // Auto-return activated
          }
        },
        
        // NEW: Tractor beam effect - attracts ball to position in front of player
        applyTractorBeam: function() {
          if (!this.body) return;
          
          // Get player camera (the "player" position)
          const camera = document.querySelector('[camera]');
          if (!camera) return;
          
          // Get camera world position and rotation
          const cameraWorldPos = new THREE.Vector3();
          const cameraWorldQuat = new THREE.Quaternion();
          camera.object3D.getWorldPosition(cameraWorldPos);
          camera.object3D.getWorldQuaternion(cameraWorldQuat);
          
          // Calculate target position: 30cm in front of camera, 30cm lower (chest height)
          const forwardDirection = new THREE.Vector3(0, 0, -1); // Forward in camera space
          forwardDirection.applyQuaternion(cameraWorldQuat);
          
          this.targetPosition.copy(cameraWorldPos);
          this.targetPosition.add(forwardDirection.multiplyScalar(0.3)); // 30cm forward
          this.targetPosition.y -= 0.3; // 30cm lower for chest height
          
          // Calculate attraction force toward target position
          const ballPos = new THREE.Vector3().copy(this.body.position);
          const attractionVector = new THREE.Vector3().subVectors(this.targetPosition, ballPos);
          const distance = attractionVector.length();
          
          if (distance > 0.01) { // Only apply force if not already at target
            // Normalize and apply force - stronger when farther away
            attractionVector.normalize();
            
            // Adaptive force: stronger for distant objects, gentler when close
            let forceMultiplier;
            if (distance > 2.0) {
              forceMultiplier = 25.0; // Strong force for distant balls
            } else if (distance > 0.5) {
              forceMultiplier = 15.0; // Medium force for medium distance
            } else {
              forceMultiplier = 8.0;  // Gentle force when close to avoid jitter
            }
            
            attractionVector.multiplyScalar(forceMultiplier);
            
            // Apply force to ball
            this.body.velocity.x += attractionVector.x * 0.016; // Assume ~60fps
            this.body.velocity.y += attractionVector.y * 0.016;
            this.body.velocity.z += attractionVector.z * 0.016;
            
            // Dampen velocity to prevent overshooting when close
            if (distance < 0.5) {
              this.body.velocity.x *= 0.9;
              this.body.velocity.y *= 0.9;
              this.body.velocity.z *= 0.9;
            }
            
            // Cap maximum tractor beam velocity for safety - much lower limit to prevent escaping
            const maxTractorSpeed = 6.0; // Reduced from 10.0 to 6.0 m/s
            const currentSpeed = Math.sqrt(
              this.body.velocity.x * this.body.velocity.x +
              this.body.velocity.y * this.body.velocity.y +
              this.body.velocity.z * this.body.velocity.z
            );
            
            if (currentSpeed > maxTractorSpeed) {
              const scale = maxTractorSpeed / currentSpeed;
              this.body.velocity.x *= scale;
              this.body.velocity.y *= scale;
              this.body.velocity.z *= scale;
            }
            
            // Additional safety: Check if ball is too far from environment center and gently pull it back
            const environmentCenter = new THREE.Vector3(0, 2, 0); // Center of the space
            const ballToCenter = new THREE.Vector3().subVectors(environmentCenter, ballPos);
            const distanceFromCenter = ballToCenter.length();
            
            if (distanceFromCenter > 15.0) { // If ball is more than 15m from center
              ballToCenter.normalize();
              // Gentle pull back toward center
              const pullForce = 2.0;
              this.body.velocity.x += ballToCenter.x * pullForce * 0.016;
              this.body.velocity.y += ballToCenter.y * pullForce * 0.016;
              this.body.velocity.z += ballToCenter.z * pullForce * 0.016;
              
            }
            
            // Debug info (occasional)
            if (Math.random() < 0.02) { // 2% chance per frame (~1.2 times per second at 60fps)
              let activationMethod;
              activationMethod = 'Unknown';
              
            }
          }
        }
        });


        // Ball Shield Component - Activates when ball is grabbed
        AFRAME.registerComponent('ball-shield', {
          init: function() {
            this.parentBall = this.el.parentElement;
            this.ballComponent = null;
            this.isActive = false;
            this.isOnCooldown = false;
            this.cooldownEndTime = 0;
            this.cooldownDuration = 6000; // 6 seconds
            this.lastStateChange = 0; // Throttling for state changes
            
            // Wait for parent ball to initialize
            setTimeout(() => {
              if (this.parentBall && this.parentBall.components['zerog-ball']) {
                this.ballComponent = this.parentBall.components['zerog-ball'];
                this.setupCollisionHandler();
              }
            }, 100);
          },
          
          setupCollisionHandler: function() {
            if (!this.ballComponent || !this.ballComponent.body) {
              return;
            }
            
            // Set up collision detection on the ball's physics body
            this.ballComponent.body.addEventListener('collide', (event) => {
              const otherBody = event.target === this.ballComponent.body ? event.body : event.target;
              
              if (this.isActive) {
                this.handleCollision(otherBody);
              }
            });
          },
          
          handleCollision: function(otherBody) {
            // Find the ball element that collided with us
            const otherBallEl = otherBody.el;
            if (!otherBallEl || !otherBallEl.components['zerog-ball']) {
              return;
            }
            
            const otherBallComponent = otherBallEl.components['zerog-ball'];
            if (otherBallComponent.isCaptureBall) {
              return; // Don't block capture ball
            }
            
            // Check if this is an opponent ball using team logic
            const otherBallIndex = parseInt(otherBallComponent.data.player.replace('player', ''));
            const myPlayerId_safe = myPlayerId || 'player_0';
            
            if (!shouldBallAffectTarget(otherBallIndex, myPlayerId_safe)) {
              return; // Same team
            }
            
            // SHIELD COLLISION: Reflect the other ball and deactivate shield
            console.log(`🛡️ SHIELD HIT! ${this.ballComponent.data.player} blocked ${otherBallComponent.data.player}`);
            
            // Reflect the other ball
            this.reflectBall(otherBody, otherBallEl);
            
            // Deactivate shield and start cooldown
            this.deactivateShield();
            this.startCooldown();
          },
          
          reflectBall: function(ballBody, ballEl) {
            // Calculate reflection direction from shield center (ball center)
            const shieldPos = new THREE.Vector3();
            this.parentBall.object3D.getWorldPosition(shieldPos);
            const ballPos = new THREE.Vector3();
            ballEl.object3D.getWorldPosition(ballPos);
            
            const reflectionDir = new THREE.Vector3().subVectors(ballPos, shieldPos).normalize();
            const reflectionSpeed = 8;
            
            // Apply reflection velocity
            ballBody.velocity.set(
              reflectionDir.x * reflectionSpeed,
              reflectionDir.y * reflectionSpeed,
              reflectionDir.z * reflectionSpeed
            );
          },
          
          tick: function() {
            // CRITICAL FIX: Only manage shields for LOCAL player's balls, not remote balls
            if (!this.ballComponent || !this.isLocalPlayerBall()) {
              return; // Don't manage remote player shields
            }
            
            // CRITICAL: Verify shield visual state matches collision expectations
            this.verifyShieldSync();
            
            // Check cooldown
            if (this.isOnCooldown && Date.now() >= this.cooldownEndTime) {
              this.isOnCooldown = false;
              console.log(`🛡️ Cooldown EXPIRED for ${this.ballComponent.data.player}`);
              
              // If ball is still grabbed after cooldown, reactivate shield
              if (this.ballComponent.isGrabbed && !this.isActive) {
                console.log(`🛡️ Auto-reactivating shield after cooldown for ${this.ballComponent.data.player}`);
                this.activateShield();
              }
            }
            
            // CRITICAL FIX: Only manage shield state for local player's ball
            const shouldBeActive = this.ballComponent.isGrabbed && !this.isOnCooldown;
            
            // Add throttling to prevent rapid state changes
            const now = Date.now();
            if (!this.lastStateChange || (now - this.lastStateChange) > 100) { // 100ms throttle
              // Shield should be active but isn't
              if (shouldBeActive && !this.isActive) {
                console.log(`🛡️ Tick: Activating shield for ${this.ballComponent.data.player} (grabbed: ${this.ballComponent.isGrabbed}, cooldown: ${this.isOnCooldown})`);
                this.activateShield();
                this.lastStateChange = now;
              }
              // Shield is active but shouldn't be
              else if (!shouldBeActive && this.isActive) {
                console.log(`🛡️ Tick: Deactivating shield for ${this.ballComponent.data.player} (grabbed: ${this.ballComponent.isGrabbed}, cooldown: ${this.isOnCooldown})`);
                this.deactivateShield();
                this.lastStateChange = now;
              }
            }
          },
          
          isLocalPlayerBall: function() {
            if (!this.ballComponent || !this.ballComponent.data) {
              return false;
            }
            
            // Get the ball's player ID (e.g., "player4")
            const ballPlayer = this.ballComponent.data.player;
            
            // Use getBallForPlayer to get the correct ball assignment
            const myBallNumber = getBallForPlayer(myPlayerId || 'player_0');
            const myBallId = `player${myBallNumber}`;
            
            return ballPlayer === myBallId;
          },
          
          activateShield: function() {
            if (this.isOnCooldown) {
              console.log(`🛡️ Shield activation FAILED: on cooldown for ${this.ballComponent?.data?.player}`);
              return false;
            }
            
            this.isActive = true;
            this.el.setAttribute('visible', true);
            console.log(`🛡️ Shield ACTIVATED for ${this.ballComponent?.data?.player}`);
            
            // CRITICAL FIX: Update collision mask based on new shield state
            if (this.ballComponent && this.ballComponent.updateCollisionMask) {
              this.ballComponent.updateCollisionMask();
              console.log(`🔄 Shield ACTIVATED: Updated collision mask for ${this.ballComponent.data.player}`);
              
              // FORCE IMMEDIATE UPDATE (ensure it takes effect)
              setTimeout(() => {
                if (this.ballComponent && this.ballComponent.updateCollisionMask) {
                  this.ballComponent.updateCollisionMask();
                  console.log(`🔄 FORCE: Double-checked collision mask after shield activation for ${this.ballComponent.data.player}`);
                }
              }, 50);
            } else {
              console.log(`🚨 ERROR: Cannot update collision mask for shield activation - ballComponent or updateCollisionMask missing`);
            }
            
            // Send shield state to other players in multiplayer
            this.sendShieldState(true);
            
            return true;
          },
          
          deactivateShield: function() {
            this.isActive = false;
            this.el.setAttribute('visible', false);
            console.log(`🛡️ Shield DEACTIVATED for ${this.ballComponent?.data?.player}`);
            
            // Clear any pending deactivate timer
            this.deactivateTimer = null;
            
            // CRITICAL FIX: Update collision mask based on new shield state
            if (this.ballComponent && this.ballComponent.updateCollisionMask) {
              this.ballComponent.updateCollisionMask();
            }
            
            // Send shield state to other players in multiplayer
            this.sendShieldState(false);
          },
          
          forceShieldSync: function() {
            // Force synchronization of shield visual state and collision mask
            console.log(`🔧 FORCE SYNC: Synchronizing shield for ${this.ballComponent?.data?.player}`);
            
            if (this.ballComponent && this.ballComponent.isGrabbed && !this.isOnCooldown) {
              // Ball is grabbed and not on cooldown - shield should be active
              if (!this.isActive) {
                console.log(`🔧 FORCE SYNC: Activating shield`);
                this.activateShield();
              }
            } else {
              // Ball not grabbed or on cooldown - shield should be inactive
              if (this.isActive) {
                console.log(`🔧 FORCE SYNC: Deactivating shield`);
                this.deactivateShield();
              }
            }
            
            // Always update collision mask after sync
            if (this.ballComponent && this.ballComponent.updateCollisionMask) {
              this.ballComponent.updateCollisionMask();
            }
          },
          
          verifyShieldSync: function() {
            // Verify that visual shield state matches collision mask expectations
            const isVisuallyActive = this.isActive && this.el.getAttribute('visible');
            const ballIsGrabbed = this.ballComponent && this.ballComponent.isGrabbed;
            const shouldHaveCollision = ballIsGrabbed && isVisuallyActive;
            
            if (this.ballComponent && this.ballComponent.body) {
              const currentMask = this.ballComponent.body.collisionFilterMask;
              const hasCollisionMask = (currentMask & 2) !== 0; // Check if group 2 (balls) is in mask
              
              if (shouldHaveCollision && !hasCollisionMask) {
                console.log(`🚨 SYNC ERROR: Shield visually ON but collision mask wrong! ${this.ballComponent.data.player} mask=${currentMask}`);
                // Force complete sync
                this.forceShieldSync();
              } else if (!shouldHaveCollision && hasCollisionMask && ballIsGrabbed) {
                console.log(`🚨 SYNC ERROR: Shield visually OFF but collision mask still active! ${this.ballComponent.data.player} mask=${currentMask}`);
                // Force complete sync
                this.forceShieldSync();
              }
            }
          },
          
          startCooldown: function() {
            this.isOnCooldown = true;
            this.cooldownEndTime = Date.now() + this.cooldownDuration;
            console.log(`🛡️ Cooldown STARTED for ${this.ballComponent?.data?.player} - ends at ${new Date(this.cooldownEndTime).toLocaleTimeString()}`);
            
            // Send cooldown state to other players
            this.sendShieldState(false);
          },
          
          sendShieldState: function(shieldActive) {
            if (isMultiplayer && activePlayers.size > 1 && this.ballComponent) {
              const data = {
                type: 'ball-shield-state',
                playerId: myPlayerId,
                ballId: this.ballComponent.data.player,
                shieldActive: shieldActive,
                cooldownEndTime: this.isOnCooldown ? this.cooldownEndTime : null,
                timestamp: Date.now()
              };
              
              console.log(`🛡️ Sending shield state: ${this.ballComponent.data.player} -> ${shieldActive ? 'ON' : 'OFF'} to ${connections.size} players`);
              
              connections.forEach((conn, playerId) => {
                if (conn && conn.open) {
                  conn.send(data);
                }
              });
            }
          }
      });

      // FPS counter
      AFRAME.registerComponent('fps-counter', {
        init: function() {
          // FPS Counter component initialized
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.fps = 0;
          this.fpsHistory = [];
          this.updateInterval = 500;
          this.lastUpdate = 0;
        },
        
        tick: function() {
          const currentTime = performance.now();
          this.frameCount++;
          
          if (currentTime - this.lastUpdate >= this.updateInterval) {
            const deltaTime = currentTime - this.lastTime;
            const currentFPS = Math.round((this.frameCount * 1000) / deltaTime);
            
            this.fpsHistory.push(currentFPS);
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift();
            }
            
            const avgFPS = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);
            this.fps = avgFPS;
            
            // FPS logging removed to reduce console spam
            this.updateVersionDisplay();
            
            this.frameCount = 0;
            this.lastTime = currentTime;
            this.lastUpdate = currentTime;
          }
        },
        
        updateVersionDisplay: function() {
          const versionDisplay = document.getElementById('version-display');
          if (versionDisplay) {
            versionDisplay.setAttribute('text', 'value', `Zero-G v1.36 | ${this.fps} FPS`);
          } else {
            console.warn('⚠️ FPS Counter: version-display element not found');
          }
        }
      });



      // Door Proximity Trigger Component
      AFRAME.registerComponent('door-proximity-trigger', {
        schema: {
          triggerDistance: {type: 'number', default: 2.0},
          doorObjects: {type: 'array', default: ['Misc01005', 'Misc01006']},
          animations: {type: 'array', default: ['DoorOpen', 'DoorOpen.001']},
          maxFrame: {type: 'number', default: 120}
        },
        
        init: function() {
          this.player = null;
          this.doorMeshes = [];
          this.isDoorsOpen = false;
          this.animationMixer = null;
          this.doorAnimations = [];
          this.lastPlayerDistance = Infinity;
          this.doorActions = []; // Store animation actions for better control
          this.isAnimating = false; // Track if doors are currently animating
          this.lastStateChange = 0; // Timestamp of last state change
          this.debounceDelay = 500; // 500ms debounce to prevent rapid state changes
          
          // Wait for model to load
          this.el.addEventListener('model-loaded', () => {
            this.setupDoorSystem();
          });
        },
        
        setupDoorSystem: function() {
          // Set up door system
          
          // Get the animation mixer component
          this.animationMixer = this.el.components['animation-mixer'];
          if (!this.animationMixer) {
            console.warn('Animation mixer not found on spaceship entity');
            return;
          }
          
          // Wait a bit more for the model to be fully loaded
          setTimeout(() => {
            this.findDoorMeshes();
          }, 500);
        },
        
        findDoorMeshes: function() {
          // Try multiple ways to get the model
          const model = this.el.getObject3D('mesh') || this.el.object3D;
          
          if (!model) {
            console.error('❌ No model found in spaceship entity!');
            console.log('Available object3D keys:', Object.keys(this.el.object3D));
            return;
          }
          
          
          // Find door meshes in the loaded model
          let allObjects = [];
          model.traverse((child) => {
            // Log ALL objects for debugging
            if (child.name) {
              allObjects.push(child.name);
            }
            
            if (this.data.doorObjects.includes(child.name)) {
              this.doorMeshes.push(child);
            }
          });
          
          
          if (this.doorMeshes.length === 0) {
            console.warn('⚠️ No door meshes found! Expected:', this.data.doorObjects);
            return;
          }
          
          // Initialize door animations and set to closed state
          this.initializeDoorAnimations();
          
          // Get player reference
        this.player = document.querySelector('#player') || document.querySelector('[camera]');
          if (!this.player) {
            // Retry finding player after a delay
            setTimeout(() => {
              this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('[zerog-player]');
              if (this.player) {
                this.rig = this.player.querySelector('#rig') || this.player;
              }
            }, 1000);
        } else {
          // Get the rig for actual position tracking
          this.rig = this.player.querySelector('#rig') || this.player;
          }
          
        },
        
        initializeDoorAnimations: function() {
          // Get animation actions and set doors to closed state (frame 0)
          this.data.animations.forEach((animName, index) => {
            if (this.animationMixer && this.animationMixer.mixer) {
              const action = this.animationMixer.mixer.clipAction(
                THREE.AnimationClip.findByName(this.animationMixer.mixer._root, animName)
              );
              if (action) {
                action.reset();
                action.setLoop(THREE.LoopOnce);
                action.clampWhenFinished = true;
                action.time = 0; // Start at frame 0 (closed)
                action.timeScale = 0; // Pause the animation
                action.play();
                this.doorActions.push(action);
              }
            }
          });
        },
        
        tick: function() {
          // Try to find player if we don't have one yet
          if (!this.player) {
            this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('[zerog-player]');
            if (this.player) {
              this.rig = this.player.querySelector('#rig') || this.player;
            } else {
              return; // Skip this tick if no player found
            }
          }
          
          // Check all players (local and remote) for proximity to doors
          let minDistance = Infinity;
          let closestDoor = null;
          
          // Check local player
          const playerWorldPos = new THREE.Vector3();
          const positionSource = this.rig || this.player;
          positionSource.object3D.getWorldPosition(playerWorldPos);
          
          // Check remote players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            activePlayers.forEach(playerId => {
              if (playerId !== myPlayerId) {
                const remotePlayer = document.querySelector(`#remote-target-${playerId.split('_')[1]}`);
                if (remotePlayer) {
                  const remoteWorldPos = new THREE.Vector3();
                  remotePlayer.object3D.getWorldPosition(remoteWorldPos);
                  
                  // Check distance to doors for this remote player
                  if (this.doorMeshes.length > 0) {
                    this.doorMeshes.forEach(doorMesh => {
                      const doorWorldPos = new THREE.Vector3();
                      doorMesh.getWorldPosition(doorWorldPos);
                      const distance = remoteWorldPos.distanceTo(doorWorldPos);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestDoor = doorMesh;
                      }
                    });
                  }
                }
              }
            });
          }
          
          // Check local player distance
          if (this.doorMeshes.length > 0) {
            this.doorMeshes.forEach(doorMesh => {
              const doorWorldPos = new THREE.Vector3();
              doorMesh.getWorldPosition(doorWorldPos);
              const distance = playerWorldPos.distanceTo(doorWorldPos);
              if (distance < minDistance) {
                minDistance = distance;
                closestDoor = doorMesh;
              }
            });
          } else {
            // Fallback: use spaceship center for proximity detection
            const spaceshipWorldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(spaceshipWorldPos);
            minDistance = playerWorldPos.distanceTo(spaceshipWorldPos);
          }
          
          if (this.doorMeshes.length > 0) {
            // Calculate minimum distance to any door
            this.doorMeshes.forEach(doorMesh => {
              const doorWorldPos = new THREE.Vector3();
              doorMesh.getWorldPosition(doorWorldPos);
              const distance = playerWorldPos.distanceTo(doorWorldPos);
              if (distance < minDistance) {
                minDistance = distance;
                closestDoor = doorMesh;
              }
            });
          } else {
            // Fallback: use spaceship center for proximity detection
            const spaceshipWorldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(spaceshipWorldPos);
            minDistance = playerWorldPos.distanceTo(spaceshipWorldPos);
          }
          
          // Check for state changes with debouncing
          const shouldOpen = minDistance <= this.data.triggerDistance;
          const now = Date.now();
          
          // Only change state if:
          // 1. The desired state is different from current state
          // 2. We're not currently animating, OR enough time has passed since last state change
          // 3. Enough time has passed since the last state change (debounce)
          // 4. In multiplayer, only the host can trigger door animations
          if (shouldOpen !== this.isDoorsOpen && 
              (!this.isAnimating || (now - this.lastStateChange) > this.debounceDelay) &&
              (!isMultiplayer || isHost)) {
            
            this.lastStateChange = now;
            
            if (shouldOpen) {
              this.openDoors();
            } else {
              this.closeDoors();
            }
          }
          
          this.lastPlayerDistance = minDistance;
        },
        
        openDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = true;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('open', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to open state
          this.doorActions.forEach((action, index) => {
            if (action) {
              // Get current time and duration for debugging
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // Set up forward animation
              action.timeScale = 1; // Forward playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove any existing event listeners to prevent duplicates
              action.getMixer().removeEventListener('finished', action._onFinished);
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // If animation was playing in reverse, continue from current position
              if (currentTime > 0 && currentTime < duration) {
                // Continue from current position
                action.play();
              } else {
                // Start from beginning
                action.reset();
                action.play();
              }
              
            }
          });
        },
        
        closeDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = false;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('close', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to closed state
          this.doorActions.forEach(action => {
            if (action) {
              // Get current time and duration
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // CRITICAL FIX: Reset the action if it's stuck at the end
              if (currentTime >= duration) {
                action.reset();
                action.time = duration; // Set to end position
                action.play();
                action.paused = true; // Pause it at the end
              }
              
              // Set up reverse animation
              action.timeScale = -1; // Reverse playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove existing event listeners
              if (action._onFinished) {
                action.getMixer().removeEventListener('finished', action._onFinished);
              }
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // Ensure the animation can play in reverse
              if (currentTime >= duration) {
                // If at the end, start from full duration and play in reverse
                action.time = duration;
                action.paused = false;
                action.play();
              } else if (currentTime > 0) {
                // If partway through, continue from current position in reverse
                action.paused = false;
                action.play();
              } else {
                // If already at start, just complete immediately
                onAnimationComplete();
                return;
              }
              
            }
          });
        },
        
        remove: function() {
          // Clean up animation actions
          this.doorActions = [];
        }
      });

      // Door Proximity Trigger Component 2 (for second door group)
      AFRAME.registerComponent('door-proximity-trigger-2', {
        schema: {
          triggerDistance: {type: 'number', default: 2.0},
          doorObjects: {type: 'array', default: ['Misc01003', 'Misc01004']},
          animations: {type: 'array', default: ['Misc01.003Action', 'Misc01.004Action']},
          maxFrame: {type: 'number', default: 120}
        },
        
        init: function() {
          this.player = null;
          this.doorMeshes = [];
          this.isDoorsOpen = false;
          this.animationMixer = null;
          this.doorAnimations = [];
          this.lastPlayerDistance = Infinity;
          this.doorActions = []; // Store animation actions for better control
          this.isAnimating = false; // Track if doors are currently animating
          this.lastStateChange = 0; // Timestamp of last state change
          this.debounceDelay = 500; // 500ms debounce to prevent rapid state changes
          
          // Wait for model to load
          this.el.addEventListener('model-loaded', () => {
            this.setupDoorSystem();
          });
        },
        
        setupDoorSystem: function() {
          // Set up door system 2
          
          // Get the animation mixer component
          this.animationMixer = this.el.components['animation-mixer'];
          if (!this.animationMixer) {
            console.warn('Animation mixer not found on spaceship entity');
            return;
          }
          
          // Wait a bit more for the model to be fully loaded
          setTimeout(() => {
            this.findDoorMeshes();
          }, 500);
        },
        
        findDoorMeshes: function() {
          // Try multiple ways to get the model
          const model = this.el.getObject3D('mesh') || this.el.object3D;
          
          if (!model) {
            console.error('❌ No model found in spaceship entity for door system 2!');
            console.log('Available object3D keys:', Object.keys(this.el.object3D));
            return;
          }
          
          
          // Find door meshes in the loaded model
          let allObjects = [];
          model.traverse((child) => {
            // Log ALL objects for debugging
            if (child.name) {
              allObjects.push(child.name);
            }
            
            if (this.data.doorObjects.includes(child.name)) {
              this.doorMeshes.push(child);
            }
          });
          
          
          if (this.doorMeshes.length === 0) {
            console.warn(`⚠️ No door objects found for door system 2! Looking for: ${this.data.doorObjects.join(', ')}`);
            console.log('Available objects:', allObjects.slice(0, 20).join(', '), allObjects.length > 20 ? '...' : '');
          }
          
          // Initialize door animations
          this.initializeDoorAnimations();
          
          // Find player
        this.player = document.querySelector('#player') || document.querySelector('[camera]');
          if (!this.player) {
            // Retry finding player after a delay
            setTimeout(() => {
              this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('[zerog-player]');
              if (this.player) {
                this.rig = this.player.querySelector('#rig') || this.player;
              }
            }, 1000);
        } else {
          // Get the rig for actual position tracking
          this.rig = this.player.querySelector('#rig') || this.player;
          }
          
        },
        
        initializeDoorAnimations: function() {
          if (!this.animationMixer || !this.animationMixer.mixer) {
            console.warn('Animation mixer not ready for door system 2');
            return;
          }
          
          // Initialize each door animation to closed state (frame 0)
          this.data.animations.forEach(animName => {
            const action = this.animationMixer.mixer.clipAction(animName);
            if (action) {
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              action.time = 0; // Start at closed position
              action.timeScale = 0; // Pause at frame 0
              action.play();
              this.doorActions.push(action);
            } else {
              console.warn(`⚠️ Animation not found for door system 2: ${animName}`);
            }
          });
        },
        
        tick: function() {
          // Try to find player if not found yet
          if (!this.player) {
            this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('a-camera');
            if (!this.player) return;
          }
          
          // Check all players (local and remote) for proximity to doors
          let minDistance = Infinity;
          let closestDoor = null;
          
          // Check local player
          const playerWorldPos = new THREE.Vector3();
          const positionSource = this.rig || this.player;
          positionSource.object3D.getWorldPosition(playerWorldPos);
          
          // Check remote players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            activePlayers.forEach(playerId => {
              if (playerId !== myPlayerId) {
                const remotePlayer = document.querySelector(`#remote-target-${playerId.split('_')[1]}`);
                if (remotePlayer) {
                  const remoteWorldPos = new THREE.Vector3();
                  remotePlayer.object3D.getWorldPosition(remoteWorldPos);
                  
                  // Check distance to doors for this remote player
                  if (this.doorMeshes.length > 0) {
                    this.doorMeshes.forEach(doorMesh => {
                      const doorWorldPos = new THREE.Vector3();
                      doorMesh.getWorldPosition(doorWorldPos);
                      const distance = remoteWorldPos.distanceTo(doorWorldPos);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestDoor = doorMesh;
                      }
                    });
                  }
                }
              }
            });
          }
          
          // Check local player distance
          if (this.doorMeshes.length > 0) {
            // Calculate minimum distance to any door in this group
            this.doorMeshes.forEach(doorMesh => {
              const doorWorldPos = new THREE.Vector3();
              doorMesh.getWorldPosition(doorWorldPos);
              const distance = playerWorldPos.distanceTo(doorWorldPos);
              if (distance < minDistance) {
                minDistance = distance;
                closestDoor = doorMesh;
              }
            });
          } else {
            return; // No doors to check
          }
          
          // Enhanced debugging every 300 frames (5 seconds at 60fps)
          if (!this.debugTick) this.debugTick = 0;
          if (this.debugTick % 300 === 0) {
            const shouldBeOpen = minDistance <= this.data.triggerDistance;
            const playerPos = `(${playerWorldPos.x.toFixed(1)}, ${playerWorldPos.y.toFixed(1)}, ${playerWorldPos.z.toFixed(1)})`;
            // Door 2 proximity check
            
            // Force state correction if there's a mismatch
            if (shouldBeOpen !== this.isDoorsOpen) {
              console.log(`⚠️ Door 2 state mismatch detected! Forcing correction...`);
              if (shouldBeOpen) {
                this.openDoors();
              } else {
                this.closeDoors();
              }
            }
          }
          this.debugTick++;
          
          // Check for state changes with debouncing
          const shouldOpen = minDistance <= this.data.triggerDistance;
          const now = Date.now();
          
          // Only change state if conditions are met
          // In multiplayer, only the host can trigger door animations
          if (shouldOpen !== this.isDoorsOpen && 
              (!this.isAnimating || (now - this.lastStateChange) > this.debounceDelay) &&
              (!isMultiplayer || isHost)) {
            
            this.lastStateChange = now;
            
            if (shouldOpen) {
              this.openDoors();
            } else {
              this.closeDoors();
            }
          }
          
          this.lastPlayerDistance = minDistance;
        },
        
        openDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = true;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('open', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to open state
          this.doorActions.forEach((action, index) => {
            if (action) {
              // Get current time and duration for debugging
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // Set up forward animation
              action.timeScale = 1; // Forward playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove any existing event listeners to prevent duplicates
              action.getMixer().removeEventListener('finished', action._onFinished);
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // If animation was playing in reverse, continue from current position
              if (currentTime > 0 && currentTime < duration) {
                // Continue from current position
                action.play();
              } else {
                // Start from beginning
                action.reset();
                action.play();
              }
              
            }
          });
        },
        
        closeDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = false;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('close', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to closed state
          this.doorActions.forEach(action => {
            if (action) {
              // Get current time and duration
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // CRITICAL FIX: Reset the action if it's stuck at the end
              if (currentTime >= duration) {
                console.log(`🔧 Resetting stuck animation 2 from time=${currentTime.toFixed(2)}`);
                action.reset();
                action.time = duration; // Set to end position
                action.play();
                action.paused = true; // Pause it at the end
              }
              
              // Set up reverse animation
              action.timeScale = -1; // Reverse playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove existing event listeners
              if (action._onFinished) {
                action.getMixer().removeEventListener('finished', action._onFinished);
              }
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // Ensure the animation can play in reverse
              if (currentTime >= duration) {
                // If at the end, start from full duration and play in reverse
                action.time = duration;
                action.paused = false;
                action.play();
              } else if (currentTime > 0) {
                // If partway through, continue from current position in reverse
                action.paused = false;
                action.play();
              } else {
                // If already at start, just complete immediately
                onAnimationComplete();
                return;
              }
              
            }
          });
        },
        
        remove: function() {
          // Clean up animation actions
          this.doorActions = [];
        }
      });

      // Door Proximity Trigger Component 3 (for third door group)
      AFRAME.registerComponent('door-proximity-trigger-3', {
        schema: {
          triggerDistance: {type: 'number', default: 2.0},
          doorObjects: {type: 'array', default: ['Misc01001', 'Misc01002']},
          animations: {type: 'array', default: ['Misc01.001Action', 'Misc01.002Action']},
          maxFrame: {type: 'number', default: 120}
        },
        
        init: function() {
          this.player = null;
          this.doorMeshes = [];
          this.isDoorsOpen = false;
          this.animationMixer = null;
          this.doorAnimations = [];
          this.lastPlayerDistance = Infinity;
          this.doorActions = []; // Store animation actions for better control
          this.isAnimating = false; // Track if doors are currently animating
          this.lastStateChange = 0; // Timestamp of last state change
          this.debounceDelay = 500; // 500ms debounce to prevent rapid state changes
          
          // Wait for model to load
          this.el.addEventListener('model-loaded', () => {
            this.setupDoorSystem();
          });
        },
        
        setupDoorSystem: function() {
          // Set up door system 3
          
          // Get the animation mixer component
          this.animationMixer = this.el.components['animation-mixer'];
          if (!this.animationMixer) {
            console.warn('Animation mixer not found on spaceship entity');
            return;
          }
          
          // Wait a bit more for the model to be fully loaded
          setTimeout(() => {
            this.findDoorMeshes();
          }, 500);
        },
        
        findDoorMeshes: function() {
          // Try multiple ways to get the model
          const model = this.el.getObject3D('mesh') || this.el.object3D;
          
          if (!model) {
            console.error('❌ No model found in spaceship entity for door system 3!');
            console.log('Available object3D keys:', Object.keys(this.el.object3D));
            return;
          }
          
          
          // Find door meshes in the loaded model
          let allObjects = [];
          model.traverse((child) => {
            // Log ALL objects for debugging
            if (child.name) {
              allObjects.push(child.name);
            }
            
            if (this.data.doorObjects.includes(child.name)) {
              this.doorMeshes.push(child);
            }
          });
          
          
          if (this.doorMeshes.length === 0) {
            console.warn(`⚠️ No door objects found for door system 3! Looking for: ${this.data.doorObjects.join(', ')}`);
            console.log('Available objects:', allObjects.slice(0, 20).join(', '), allObjects.length > 20 ? '...' : '');
          }
          
          // Initialize door animations
          this.initializeDoorAnimations();
          
          // Find player
        this.player = document.querySelector('#player') || document.querySelector('[camera]');
          if (!this.player) {
            // Retry finding player after a delay
            setTimeout(() => {
              this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('[zerog-player]');
              if (this.player) {
                this.rig = this.player.querySelector('#rig') || this.player;
              }
            }, 1000);
        } else {
          // Door proximity trigger - Player found
          // Get the rig for actual position tracking
          this.rig = this.player.querySelector('#rig') || this.player;
          // Door proximity trigger - Rig found
          }
          
        },
        
        initializeDoorAnimations: function() {
          if (!this.animationMixer || !this.animationMixer.mixer) {
            console.warn('Animation mixer not ready for door system 3');
            return;
          }
          
          // Initialize each door animation to closed state (frame 0)
          this.data.animations.forEach(animName => {
            const action = this.animationMixer.mixer.clipAction(animName);
            if (action) {
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              action.time = 0; // Start at closed position
              action.timeScale = 0; // Pause at frame 0
              action.play();
              this.doorActions.push(action);
            } else {
              console.warn(`⚠️ Animation not found for door system 3: ${animName}`);
            }
          });
        },
        
        tick: function() {
          // Try to find player if not found yet
          if (!this.player) {
            this.player = document.querySelector('#player') || document.querySelector('[camera]') || document.querySelector('a-camera');
            if (!this.player) return;
          }
          
          // Check all players (local and remote) for proximity to doors
          let minDistance = Infinity;
          let closestDoor = null;
          
          // Check local player
          const playerWorldPos = new THREE.Vector3();
          const positionSource = this.rig || this.player;
          positionSource.object3D.getWorldPosition(playerWorldPos);
          
          // Check remote players in multiplayer
          if (isMultiplayer && activePlayers.size > 1) {
            activePlayers.forEach(playerId => {
              if (playerId !== myPlayerId) {
                const remotePlayer = document.querySelector(`#remote-target-${playerId.split('_')[1]}`);
                if (remotePlayer) {
                  const remoteWorldPos = new THREE.Vector3();
                  remotePlayer.object3D.getWorldPosition(remoteWorldPos);
                  
                  // Check distance to doors for this remote player
                  if (this.doorMeshes.length > 0) {
                    this.doorMeshes.forEach(doorMesh => {
                      const doorWorldPos = new THREE.Vector3();
                      doorMesh.getWorldPosition(doorWorldPos);
                      const distance = remoteWorldPos.distanceTo(doorWorldPos);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestDoor = doorMesh;
                      }
                    });
                  }
                }
              }
            });
          }
          
          // Check local player distance
          if (this.doorMeshes.length > 0) {
            // Calculate minimum distance to any door in this group
            this.doorMeshes.forEach(doorMesh => {
              const doorWorldPos = new THREE.Vector3();
              doorMesh.getWorldPosition(doorWorldPos);
              const distance = playerWorldPos.distanceTo(doorWorldPos);
              if (distance < minDistance) {
                minDistance = distance;
                closestDoor = doorMesh;
              }
            });
          } else {
            return; // No doors to check
          }
          
          // Enhanced debugging every 300 frames (5 seconds at 60fps)
          if (!this.debugTick) this.debugTick = 0;
          if (this.debugTick % 300 === 0) {
            const shouldBeOpen = minDistance <= this.data.triggerDistance;
            const playerPos = `(${playerWorldPos.x.toFixed(1)}, ${playerWorldPos.y.toFixed(1)}, ${playerWorldPos.z.toFixed(1)})`;
            // Door 3 proximity check
            
            // Force state correction if there's a mismatch
            if (shouldBeOpen !== this.isDoorsOpen) {
              console.log(`⚠️ Door 3 state mismatch detected! Forcing correction...`);
              if (shouldBeOpen) {
                this.openDoors();
              } else {
                this.closeDoors();
              }
            }
          }
          this.debugTick++;
          
          // Check for state changes with debouncing
          const shouldOpen = minDistance <= this.data.triggerDistance;
          const now = Date.now();
          
          // Only change state if conditions are met
          // In multiplayer, only the host can trigger door animations
          if (shouldOpen !== this.isDoorsOpen && 
              (!this.isAnimating || (now - this.lastStateChange) > this.debounceDelay) &&
              (!isMultiplayer || isHost)) {
            
            this.lastStateChange = now;
            
            if (shouldOpen) {
              this.openDoors();
            } else {
              this.closeDoors();
            }
          }
          
          this.lastPlayerDistance = minDistance;
        },
        
        openDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = true;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('open', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to open state
          this.doorActions.forEach((action, index) => {
            if (action) {
              // Get current time and duration for debugging
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // Set up forward animation
              action.timeScale = 1; // Forward playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove any existing event listeners to prevent duplicates
              action.getMixer().removeEventListener('finished', action._onFinished);
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // If animation was playing in reverse, continue from current position
              if (currentTime > 0 && currentTime < duration) {
                // Continue from current position
                action.play();
              } else {
                // Start from beginning
                action.reset();
                action.play();
              }
              
            }
          });
        },
        
        closeDoors: function(fromMultiplayer = false) {
          this.isDoorsOpen = false;
          this.isAnimating = true;
          
          // Send door animation state to other players in multiplayer (only if not triggered by multiplayer)
          if (!fromMultiplayer && isMultiplayer && activePlayers.size > 1) {
            sendDoorAnimation('close', this.el.id);
          }
          
          let completedAnimations = 0;
          const totalAnimations = this.doorActions.length;
          
          // Callback when an animation completes
          const onAnimationComplete = () => {
            completedAnimations++;
            if (completedAnimations >= totalAnimations) {
              this.isAnimating = false;
            }
          };
          
          // Smoothly transition all door animations to closed state
          this.doorActions.forEach(action => {
            if (action) {
              // Get current time and duration
              const currentTime = action.time;
              const duration = action.getClip().duration;
              
              // CRITICAL FIX: Reset the action if it's stuck at the end
              if (currentTime >= duration) {
                console.log(`🔧 Resetting stuck animation 3 from time=${currentTime.toFixed(2)}`);
                action.reset();
                action.time = duration; // Set to end position
                action.play();
                action.paused = true; // Pause it at the end
              }
              
              // Set up reverse animation
              action.timeScale = -1; // Reverse playback
              action.setLoop(THREE.LoopOnce);
              action.clampWhenFinished = true;
              
              // Remove existing event listeners
              if (action._onFinished) {
                action.getMixer().removeEventListener('finished', action._onFinished);
              }
              
              // Add completion callback
              action._onFinished = (event) => {
                if (event.action === action) {
                  onAnimationComplete();
                }
              };
              action.getMixer().addEventListener('finished', action._onFinished);
              
              // Ensure the animation can play in reverse
              if (currentTime >= duration) {
                // If at the end, start from full duration and play in reverse
                action.time = duration;
                action.paused = false;
                action.play();
              } else if (currentTime > 0) {
                // If partway through, continue from current position in reverse
                action.paused = false;
                action.play();
              } else {
                // If already at start, just complete immediately
                onAnimationComplete();
                return;
              }
              
            }
          });
        },
        
        remove: function() {
          // Clean up animation actions
          this.doorActions = [];
        }
      });

      // Fix for hand-controls clipAction error
      AFRAME.registerComponent('custom-hand-controls', {
        init: function() {
          // Override the problematic animation methods to prevent clipAction errors
          setTimeout(() => {
            const handControls = this.el.components['hand-controls'];
            if (handControls) {
              // Store original methods
              this.originalAnimateGesture = handControls.animateGesture;
              this.originalPlayAnimation = handControls.playAnimation;
              
              // Override with no-op functions
              handControls.animateGesture = function() {};
              handControls.playAnimation = function() {};
              
            }
          }, 100);
        },
        
        remove: function() {
          // Restore original methods if needed
          const handControls = this.el.components['hand-controls'];
          if (handControls && this.originalAnimateGesture && this.originalPlayAnimation) {
            handControls.animateGesture = this.originalAnimateGesture;
            handControls.playAnimation = this.originalPlayAnimation;
          }
        }
      });

      // Arm Segment 3D Model Component
      AFRAME.registerComponent('arm-segment-model', {
        schema: {
          segmentLength: { type: 'number', default: 0.25 },
          segmentType: { type: 'string', default: 'forearm' } // 'forearm' or 'upperarm'
        },
        
        init: function() {
          // Original model dimensions: 20cm diameter x 2m length (Z-axis)
          this.originalDiameter = 0.20;
          this.originalLength = 2.0;
          
          // Target dimensions: 3cm thickness x dynamic length
          this.targetDiameter = 0.03;
          this.targetLength = this.data.segmentLength;
          
          // Calculate scale factors
          this.scaleX = this.targetDiameter / this.originalDiameter;
          this.scaleY = this.targetDiameter / this.originalDiameter;
          this.scaleZ = this.targetLength / this.originalLength;
          
          // Load and scale the model
          this.el.setAttribute('gltf-model', '#arm-segment-model');
          this.el.setAttribute('scale', `${this.scaleX} ${this.scaleY} ${this.scaleZ}`);
          this.el.setAttribute('visible', true);
          
        },
        
        update: function() {
          // Update scaling if segment length changes
          this.targetLength = this.data.segmentLength;
          this.scaleZ = this.targetLength / this.originalLength;
          this.el.setAttribute('scale', `${this.scaleX} ${this.scaleY} ${this.scaleZ}`);
        }
      });

      // Arm IK Visualizer Component - Shows line from wrist to estimated elbow position
      AFRAME.registerComponent('arm-ik-visualizer', {
        schema: {
          hand: { type: 'string', default: 'left' }, // 'left' or 'right'
          upperArmLength: { type: 'number', default: 0.3 }, // 30cm upper arm
          forearmLength: { type: 'number', default: 0.25 }, // 25cm forearm
          shoulderOffset: { type: 'number', default: 0.18 } // 18cm from center to shoulder
        },
        
        init: function() {
          this.forearmModel = this.el.querySelector('.forearm-model');
          this.upperarmModel = this.el.querySelector('.upperarm-model');
          this.elbowIndicator = this.el.querySelector('.elbow-indicator');
          this.rig = null;
          this.headset = null;
          this.isRemotePlayer = false;
          
          // Check if this is a remote player controller
          this.isRemotePlayer = this.el.closest('[id^="remote-player"]') !== null;
          
          // Wait for scene to load to get references
          this.el.sceneEl.addEventListener('loaded', () => {
            if (this.isRemotePlayer) {
              // For remote players, use the remote player entity as headset reference
              this.headset = this.el.closest('[id^="remote-player"]');
              this.rig = this.headset; // Use same entity for rig
            } else {
              // For local player, use camera and rig
              this.rig = document.querySelector('#rig');
              this.headset = document.querySelector('[camera]');
            }
          });
        },

        tick: function() {
          // Re-query elements if not found during init (they might load later)
          if (!this.forearmModel) {
            this.forearmModel = this.el.querySelector('.forearm-model');
          }
          if (!this.upperarmModel) {
            this.upperarmModel = this.el.querySelector('.upperarm-model');
          }
          if (!this.elbowIndicator) {
            this.elbowIndicator = this.el.querySelector('.elbow-indicator');
          }
          
          if (!this.forearmModel || !this.upperarmModel || !this.elbowIndicator || !this.headset) {
            return;
          }
          
          // For remote players, don't render arms if the remote player entity is not visible
          if (this.isRemotePlayer) {
            const remotePlayerEntity = this.el.closest('[id^="remote-player"]');
            const isVisible = remotePlayerEntity && remotePlayerEntity.getAttribute('visible') !== 'false' && remotePlayerEntity.getAttribute('visible') !== false;
            if (!isVisible) return;
          }

          // Calculate proper IK elbow and shoulder positions
          const result = this.calculateIKArm();
          
          if (result) {
            // Set elbow position
            if (this.elbowIndicator) {
              this.elbowIndicator.setAttribute('position', `${result.elbowPos.x} ${result.elbowPos.y} ${result.elbowPos.z}`);
            }
            
            // Position and orient forearm model (wrist to elbow)
            if (this.forearmModel) {
              this.positionArmSegment(this.forearmModel, 
                new THREE.Vector3(0, 0, 0), // wrist position (controller origin)
                result.elbowPos,
                this.data.forearmLength
              );
            }
            
            // Position and orient upper arm model (elbow to shoulder)
            if (this.upperarmModel) {
              this.positionArmSegment(this.upperarmModel,
                result.elbowPos,
                result.shoulderPos,
                this.data.upperArmLength
              );
            }
          }
        },

        positionArmSegment: function(modelElement, startPos, endPos, segmentLength) {
          if (!modelElement) return;
          
          // Calculate direction vector from start to end
          const direction = new THREE.Vector3().subVectors(endPos, startPos);
          const actualLength = direction.length();
          
          if (actualLength < 0.001) return;
          
          // Position at midpoint between start and end points
          const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
          modelElement.setAttribute('position', `${midpoint.x} ${midpoint.y} ${midpoint.z}`);
          
          // Scale the model to the actual segment length
          modelElement.setAttribute('arm-segment-model', `segmentLength: ${actualLength}`);
          
          // Calculate rotation to align model with direction vector
          const dx = direction.x / actualLength;
          const dy = direction.y / actualLength; 
          const dz = direction.z / actualLength;
          
          const pitch = Math.asin(-dy);
          const yaw = Math.atan2(dx, dz);
          
          let pitchDeg = THREE.MathUtils.radToDeg(pitch);
          const yawDeg = THREE.MathUtils.radToDeg(yaw);
          
          // Add 90° to align Blender Z-axis with direction vector
          pitchDeg += 90;
          
          modelElement.setAttribute('rotation', `${pitchDeg} ${yawDeg} 0`);
        },

        calculateIKArm: function() {
          // Get world positions
          const handWorldPos = new THREE.Vector3();
          const headsetWorldPos = new THREE.Vector3();
          const handWorldQuat = new THREE.Quaternion();
          const headsetWorldQuat = new THREE.Quaternion();
          
          this.el.object3D.getWorldPosition(handWorldPos);
          this.el.object3D.getWorldQuaternion(handWorldQuat);
          this.headset.object3D.getWorldPosition(headsetWorldPos);
          this.headset.object3D.getWorldQuaternion(headsetWorldQuat);

          // Calculate shoulder position (offset from headset position but using rig/body orientation)
          const shoulderOffset = new THREE.Vector3(
            this.data.hand === 'left' ? -this.data.shoulderOffset : this.data.shoulderOffset,
            -0.15, // Below head
            0.05   // Slightly forward
          );
          
          // Use different rotation logic for remote vs local players
          if (this.isRemotePlayer) {
            // For remote players, use the synced rig rotation data
            const remotePlayerEntity = this.el.closest('[id^="remote-player"]');
            const rigRotationData = remotePlayerEntity ? remotePlayerEntity.getAttribute('data-rig-rotation') : null;
            
            if (rigRotationData) {
              const rigRotParts = rigRotationData.split(' ');
              const rigEuler = new THREE.Euler(
                parseFloat(rigRotParts[0]),
                parseFloat(rigRotParts[1]), 
                parseFloat(rigRotParts[2]),
                'YXZ'
              );
              const rigQuat = new THREE.Quaternion().setFromEuler(rigEuler);
              
              // Only use Y-axis rotation for stability (same as local player)
              const bodyYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rigEuler.y);
              shoulderOffset.applyQuaternion(bodyYaw);
            }
            // If no rig data available, use shoulder offset as-is
          } else {
            // For local player, use rig (body) rotation instead of headset rotation for shoulders
            const rigWorldQuat = new THREE.Quaternion();
            if (this.rig) {
              this.rig.object3D.getWorldQuaternion(rigWorldQuat);
              shoulderOffset.applyQuaternion(rigWorldQuat);
            } else {
              // Fallback: use headset rotation but only Y-axis (yaw) to keep shoulders level
              const headsetEuler = new THREE.Euler().setFromQuaternion(headsetWorldQuat, 'YXZ');
              const bodyYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), headsetEuler.y);
              shoulderOffset.applyQuaternion(bodyYaw);
            }
          }
          
          const shoulderWorldPos = new THREE.Vector3().addVectors(headsetWorldPos, shoulderOffset);

          // Vector from shoulder to hand
          const shoulderToHand = new THREE.Vector3().subVectors(handWorldPos, shoulderWorldPos);
          const distance = shoulderToHand.length();

          // Arm segment lengths
          const upperArmLength = this.data.upperArmLength;
          const forearmLength = this.data.forearmLength;
          const totalArmLength = upperArmLength + forearmLength;

          // Handle edge cases
          if (distance < 0.05) return null; // Too close
          if (distance >= totalArmLength * 0.98) {
            // Arm fully extended - elbow along shoulder-hand line
            const elbowWorldPos = new THREE.Vector3().addVectors(
              shoulderWorldPos,
              shoulderToHand.normalize().multiplyScalar(upperArmLength)
            );
            return {
              elbowPos: this.worldToControllerLocal(elbowWorldPos),
              shoulderPos: this.worldToControllerLocal(shoulderWorldPos)
            };
          }

          // Two-bone IK using law of cosines
          const a = upperArmLength;  // shoulder to elbow
          const b = forearmLength;   // elbow to wrist  
          const c = distance;        // shoulder to wrist

          // Check if target is reachable
          if (c > (a + b)) {
            // Target too far - stretch arm but maintain proportions
            const stretchRatio = c / (a + b);
            const adjustedA = a * stretchRatio;
            const adjustedB = b * stretchRatio;
            
            // Place elbow along shoulder-hand line at proper ratio
            const elbowWorldPos = new THREE.Vector3().addVectors(
              shoulderWorldPos,
              shoulderToHand.normalize().multiplyScalar(adjustedA)
            );
            
            return {
              elbowPos: this.worldToControllerLocal(elbowWorldPos),
              shoulderPos: this.worldToControllerLocal(shoulderWorldPos)
            };
          }

          if (c < Math.abs(a - b)) {
            // Target too close - use minimum possible distance
            const minDistance = Math.abs(a - b);
            const elbowWorldPos = new THREE.Vector3().addVectors(
              shoulderWorldPos,
              shoulderToHand.normalize().multiplyScalar(a)
            );
            
            return {
              elbowPos: this.worldToControllerLocal(elbowWorldPos),
              shoulderPos: this.worldToControllerLocal(shoulderWorldPos)
            };
          }

          // Normal case - use law of cosines to find elbow angle
          const cosAngle = (a * a + c * c - b * b) / (2 * a * c);
          const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));

          // Direction from shoulder to hand
          const shoulderToHandDir = shoulderToHand.normalize();

          // Stable elbow bend direction with proper left/right mirroring
          
          // Get body orientation for elbow bend direction
          let bodyRotation;
          if (this.isRemotePlayer) {
            // For remote players, use the synced rig rotation data
            const remotePlayerEntity = this.el.closest('[id^="remote-player"]');
            const rigRotationData = remotePlayerEntity ? remotePlayerEntity.getAttribute('data-rig-rotation') : null;
            
            if (rigRotationData) {
              const rigRotParts = rigRotationData.split(' ');
              const rigEuler = new THREE.Euler(
                parseFloat(rigRotParts[0]),
                parseFloat(rigRotParts[1]), 
                parseFloat(rigRotParts[2]),
                'YXZ'
              );
              // Only use Y-axis rotation for stability (same as local player)
              bodyRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rigEuler.y);
            } else {
              // Fallback to identity rotation
              bodyRotation = new THREE.Quaternion();
            }
          } else {
            // For local player, prefer rig rotation but only Y-axis for stability
            if (this.rig) {
              const rigEuler = new THREE.Euler();
              const rigQuat = new THREE.Quaternion();
              this.rig.object3D.getWorldQuaternion(rigQuat);
              rigEuler.setFromQuaternion(rigQuat, 'YXZ');
              bodyRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rigEuler.y);
            } else {
              const headsetEuler = new THREE.Euler().setFromQuaternion(headsetWorldQuat, 'YXZ');
              bodyRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), headsetEuler.y);
            }
          }
          
          // Create stable bend direction based on controller's up vector
          const controllerUp = new THREE.Vector3(0, 1, 0);
          controllerUp.applyQuaternion(handWorldQuat);
          
          // Base bend direction: outward and down
          const handSign = this.data.hand === 'left' ? -1 : 1;
          let bendDir = new THREE.Vector3(
            handSign * 0.6,  // Outward from body
            -0.8,            // Downward (stronger component)
            0
          );
          
          // Apply body rotation
          bendDir.applyQuaternion(bodyRotation);
          
          // Modify bend based on controller orientation (subtle influence)
          const controllerInfluence = controllerUp.clone();
          controllerInfluence.y = Math.max(-0.5, controllerInfluence.y); // Prevent upward bending
          
          // Blend base direction with controller influence (90% base, 10% controller)
          bendDir.lerp(controllerInfluence, 0.1);
          bendDir.normalize();

          // Calculate elbow position
          const elbowDirection = new THREE.Vector3()
            .copy(shoulderToHandDir)
            .multiplyScalar(Math.cos(angle))
            .addScaledVector(bendDir, Math.sin(angle));

          const elbowWorldPos = new THREE.Vector3().addVectors(
            shoulderWorldPos,
            elbowDirection.multiplyScalar(upperArmLength)
          );


          // Validate that forearm length is correct
          const elbowToHand = new THREE.Vector3().subVectors(handWorldPos, elbowWorldPos);
          const actualForearmLength = elbowToHand.length();
          const expectedForearmLength = forearmLength;
          
          // If forearm length is significantly wrong, adjust elbow position
          if (Math.abs(actualForearmLength - expectedForearmLength) > 0.01) {
            // Move elbow closer/farther from hand to maintain correct forearm length
            const correctionDirection = elbowToHand.normalize();
            const correctionDistance = actualForearmLength - expectedForearmLength;
            elbowWorldPos.addScaledVector(correctionDirection, correctionDistance);
          }

          // Convert both positions to controller local space
          const elbowLocalPos = this.worldToControllerLocal(elbowWorldPos);
          const shoulderLocalPos = this.worldToControllerLocal(shoulderWorldPos);
          
          return {
            elbowPos: elbowLocalPos,
            shoulderPos: shoulderLocalPos
          };
        },

        worldToControllerLocal: function(worldPos) {
          const localPos = new THREE.Vector3();
          this.el.object3D.worldToLocal(localPos.copy(worldPos));
          return localPos;
        },

        calculateElbowPosition: function() {
          try {
            // Get hand world position
            const handWorldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(handWorldPos);

            // Get headset world position and rotation
            const headsetWorldPos = new THREE.Vector3();
            const headsetWorldQuat = new THREE.Quaternion();
            this.headset.object3D.getWorldPosition(headsetWorldPos);
            this.headset.object3D.getWorldQuaternion(headsetWorldQuat);

            // Calculate shoulder position (offset from headset)
            const shoulderOffset = new THREE.Vector3(
              this.data.hand === 'left' ? -this.data.shoulderOffset : this.data.shoulderOffset,
              -0.15, // Below head level
              0
            );
            
            // Apply headset rotation to shoulder offset
            shoulderOffset.applyQuaternion(headsetWorldQuat);
            const shoulderPos = new THREE.Vector3().addVectors(headsetWorldPos, shoulderOffset);

            // Vector from shoulder to hand
            const shoulderToHand = new THREE.Vector3().subVectors(handWorldPos, shoulderPos);
            const distance = shoulderToHand.length();
            
            // Prevent division by zero
            if (distance < 0.01) {
              return null;
            }

            const totalArmLength = this.data.upperArmLength + this.data.forearmLength;
            
            // Simple case: if arm is fully extended
            if (distance >= totalArmLength * 0.95) {
              const direction = shoulderToHand.normalize();
              return new THREE.Vector3().addVectors(
                shoulderPos,
                direction.multiplyScalar(this.data.upperArmLength)
              );
            }

            // Two-bone IK using law of cosines
            const a = this.data.upperArmLength;
            const b = this.data.forearmLength;
            const c = distance;

            // Calculate angle at shoulder
            const cosA = (a * a + c * c - b * b) / (2 * a * c);
            
            // Clamp to valid range
            if (cosA < -1 || cosA > 1) {
              return null;
            }
            
            const angleA = Math.acos(cosA);

            // Direction from shoulder to hand
            const shoulderToHandDir = shoulderToHand.normalize();
            
            // Create bend direction (perpendicular to shoulder-hand line)
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(headsetWorldQuat);
            
            let bendDir = new THREE.Vector3().crossVectors(shoulderToHandDir, forward);
            if (bendDir.length() < 0.1) {
              // Fallback if vectors are parallel
              const right = new THREE.Vector3(1, 0, 0);
              right.applyQuaternion(headsetWorldQuat);
              bendDir = new THREE.Vector3().crossVectors(shoulderToHandDir, right);
            }
            
            bendDir.normalize();
            
            // Flip bend direction for right hand
            if (this.data.hand === 'right') {
              bendDir.multiplyScalar(-1);
            }

            // Calculate elbow position
            const elbowDir = new THREE.Vector3()
              .copy(shoulderToHandDir)
              .multiplyScalar(Math.cos(angleA))
              .addScaledVector(bendDir, Math.sin(angleA));

            return new THREE.Vector3().addVectors(
              shoulderPos,
              elbowDir.multiplyScalar(a)
            );
            
          } catch (error) {
            console.warn('IK calculation error:', error);
            return null;
          }
        }
      });

      // Global tracking for which controller is hovering over which button
      const buttonHoverState = new Map(); // Maps button element ID to controller ID
      
      // Global tracking for which controller just pressed the trigger
      let lastTriggerController = null;
      let triggerPressTime = 0;
      const TRIGGER_TIMEOUT = 500; // ms to keep track of trigger press (increased for debugging)
      
      // Cursor listener component for menu interactions
      AFRAME.registerComponent('cursor-listener', {
        init: function() {
          this.el.addEventListener('click', this.onClick.bind(this));
          this.el.addEventListener('mouseenter', this.onHover.bind(this));
          this.el.addEventListener('mouseleave', this.onLeave.bind(this));
          
          // Track which controller is hovering
          this.hoveringControllerId = null;
        },
        
        getControllerIdFromRaycaster: function() {
          // Check which controller's raycaster is currently intersecting this button
          const leftHand = document.querySelector('#leftHand');
          const rightHand = document.querySelector('#rightHand');
          
          // Check left hand raycaster
          if (leftHand && leftHand.components.raycaster) {
            const intersections = leftHand.components.raycaster.intersections;
            if (intersections && intersections.length > 0) {
              // Check if this button is in the intersections
              for (let i = 0; i < intersections.length; i++) {
                if (intersections[i].object.el === this.el) {
                  return 'leftHand';
                }
              }
            }
          }
          
          // Check right hand raycaster
          if (rightHand && rightHand.components.raycaster) {
            const intersections = rightHand.components.raycaster.intersections;
            if (intersections && intersections.length > 0) {
              // Check if this button is in the intersections
              for (let i = 0; i < intersections.length; i++) {
                if (intersections[i].object.el === this.el) {
                  return 'rightHand';
                }
              }
            }
          }
          
          return null;
        },
        
        isEnabled: function() {
          // Check if the element is enabled and menu is visible
          const enabled = this.el.getAttribute('enabled') !== false;
          const menuVisible = getMenuVisibility();
          return enabled && menuVisible;
        },

        onClick: function(evt) {
          const id = this.el.id;
          
          console.log('🔵 onClick fired for:', id);
          console.log('  - Menu visible:', getMenuVisibility());
          console.log('  - Element enabled:', this.el.getAttribute('enabled'));
          console.log('  - lastTriggerController:', lastTriggerController);
          console.log('  - triggerPressTime:', triggerPressTime);
          console.log('  - timeSinceTrigger:', Date.now() - triggerPressTime);
          console.log('  - buttonHoverState:', buttonHoverState.get(id));
          
          // Check if component is enabled (menu visible and element enabled)
          if (!this.isEnabled()) {
            console.log('❌ Ignoring click - menu is closed or element disabled');
            return;
          }
          
          // CRITICAL: Check if a trigger was recently pressed
          const timeSinceTrigger = Date.now() - triggerPressTime;
          if (timeSinceTrigger > TRIGGER_TIMEOUT) {
            console.log('❌ Ignoring click on', id, '- no recent trigger press (timeSinceTrigger:', timeSinceTrigger, 'ms)');
            return;
          }
          
          // CRITICAL: Only allow the controller that is hovering over THIS button to trigger it
          const currentHoveringController = buttonHoverState.get(id);
          if (!currentHoveringController) {
            console.log('❌ Ignoring click on', id, '- no controller hovering');
            return;
          }
          
          // CRITICAL: Check if the controller that pressed the trigger matches the controller hovering this button
          if (lastTriggerController !== currentHoveringController) {
            console.log('❌ Ignoring click on', id, '- trigger from', lastTriggerController, 'but hovering controller is', currentHoveringController);
            return;
          }
          
          console.log('✅ Button clicked:', id, 'by controller:', currentHoveringController);
          
          // Prevent accidental clicks immediately after menu toggle
          const menuToggle = document.querySelector('[menu-toggle]');
          if (menuToggle && menuToggle.components['menu-toggle']) {
            const timeSinceToggle = Date.now() - menuToggle.components['menu-toggle'].lastMenuToggle;
            if (timeSinceToggle < 300) { // 300ms debounce after menu toggle
              console.log('Ignoring click - too soon after menu toggle:', timeSinceToggle + 'ms');
              return;
            }
          }
          
          if (id === 'menu-singleplayer') {
            this.switchToSingleplayer();
          } else if (id === 'menu-multiplayer') {
            this.switchToMultiplayer();
          } else if (id === 'menu-lobby-minus') {
            this.changeLobby(-1);
          } else if (id === 'menu-lobby-plus') {
            this.changeLobby(1);
          } else if (id === 'menu-connect') {
            this.connectToLobby();
          } else if (id === 'menu-auto-connect') {
            this.autoConnect();
          } else if (id === 'menu-team-red') {
            this.selectTeam('red');
          } else if (id === 'menu-team-blue') {
            this.selectTeam('blue');
          } else if (id === 'menu-toggle-spaceship') {
            this.toggleModel('spaceship');
          } else if (id === 'menu-toggle-asteroid-42') {
            this.toggleModel('asteroid-42');
          } else if (id === 'menu-toggle-bots') {
            this.toggleBots();
          } else if (id === 'menu-toggle-mesh-debug') {
            this.toggleMeshDebug();
          } else if (id === 'menu-toggle-smoke') {
            this.toggleSmoke();
          } else if (id === 'menu-toggle-ice-cube') {
            this.toggleIceCube();
          } else if (id === 'menu-toggle-sparks') {
            this.toggleSparks();
          } else if (id === 'menu-toggle-bloom') {
            this.toggleBloom();
            // No longer auto-closing menu since we're not toggling bloom
          } else if (id === 'menu-toggle-level') {
            this.toggleModel('level');
          } else if (id === 'menu-restart-match') {
            this.restartMatch();
          }
        },

        onHover: function(evt) {
          // Only highlight if component is enabled
          if (!this.isEnabled()) {
            return;
          }
          
          // Determine which controller is hovering
          const controllerId = this.getControllerIdFromRaycaster();
          if (controllerId) {
            // Store which controller is hovering over this button
            buttonHoverState.set(this.el.id, controllerId);
            this.hoveringControllerId = controllerId;
            console.log('Button', this.el.id, 'hovered by', controllerId);
          }
          
          // Highlight button on hover
          const material = this.el.getAttribute('material');
          this.originalColor = material.color;
          this.el.setAttribute('material', 'color', '#ffffff');
          this.el.setAttribute('material', 'opacity', 1.0);
        },

        onLeave: function() {
          // Only restore color if component is enabled
          if (!this.isEnabled()) {
            return;
          }
          
          // Clear the hover state for this button
          buttonHoverState.delete(this.el.id);
          this.hoveringControllerId = null;
          console.log('Button', this.el.id, 'no longer hovered');
          
          // Restore original color
          if (this.originalColor) {
            this.el.setAttribute('material', 'color', this.originalColor);
            this.el.setAttribute('material', 'opacity', 0.8);
          }
        },

        switchToSingleplayer: function() {
          // Prevent switching during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          isMultiplayer = false;
          
          // Hide lobby section and auto connect button
          const lobbySection = document.querySelector('#menu-lobby-section');
          const autoConnect = document.querySelector('#menu-auto-connect');
          
          if (lobbySection) {
            lobbySection.setAttribute('visible', false);
          }
          if (autoConnect) {
            autoConnect.setAttribute('visible', false);
          }
          
          // End any active multiplayer connection
          if (peer) {
            peer.destroy();
            peer = null;
          }
          connections.clear();
          connectionToPlayer.clear();
          activePlayers.clear();
          myPlayerId = null;
          
          // Reset player teams and set default for singleplayer
          // Team system removed.clear();
          // Team system removed.set('player_0', 'red'); // Default to red team in singleplayer
          
          // Update team display, ball colors, and player body color for singleplayer
          // Team display removed - space shooter doesn't use teams
          // Ball colors removed - space shooter uses fixed colors
          updatePlayerTeamColor('player_0', 'red');
          
          this.updateCurrentModeDisplay('Singleplayer');
        },

        switchToMultiplayer: function() {
          console.log('🔄 switchToMultiplayer called');
          
          // Prevent switching during reconnection
          if (window.isReconnecting) {
            console.log('❌ Blocked switchToMultiplayer - reconnection in progress');
            return;
          }
          
          isMultiplayer = true;
          console.log('✅ Set isMultiplayer = true');
          
          // Show lobby section and auto connect button with a small delay to prevent accidental clicks
          setTimeout(() => {
            const lobbySection = document.querySelector('#menu-lobby-section');
            const autoConnect = document.querySelector('#menu-auto-connect');
            
            if (lobbySection) {
              lobbySection.setAttribute('visible', true);
              console.log('✅ Showed lobby section (delayed)');
            }
            if (autoConnect) {
              autoConnect.setAttribute('visible', true);
              console.log('✅ Showed auto connect button (delayed)');
            }
          }, 200); // Small delay to prevent accidental clicks
          
          this.updateCurrentModeDisplay('Multiplayer - Select Lobby');
          console.log('✅ switchToMultiplayer completed - no connection initiated');
        },

        updateCurrentModeDisplay: function(mode) {
          const currentModeDisplay = document.querySelector('#menu-current-mode');
          if (currentModeDisplay) {
            currentModeDisplay.setAttribute('text', 'value', `Mode: ${mode}`);
            currentModeDisplay.setAttribute('text', 'color', '#ffffff');
          }
        },

        changeLobby: function(delta) {
          selectedLobby = Math.max(1, Math.min(MAX_LOBBIES, selectedLobby + delta));
          const lobbyNumber = document.querySelector('#menu-lobby-number');
          if (lobbyNumber) {
            lobbyNumber.setAttribute('text', 'value', selectedLobby.toString());
          }
        },

        connectToLobby: function() {
          // Prevent connecting during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          connectToLobby(selectedLobby);
        },

        autoConnect: function() {
          // Prevent auto-connecting during reconnection
          if (window.isReconnecting) {
            return;
          }
          
          autoConnect();
        },
        
        selectTeam: function(team) {
          // Set the player's team
          const currentPlayerId = myPlayerId || 'player_0';
          // Team system removed.set(currentPlayerId, team);
          
          // CRITICAL FIX: Use proper team colors now that green glow is eliminated
          const teamColor = team === 'red' ? '#ff0000' : '#0000ff';  // Pure red and blue
          updateLocalPlayerColor(teamColor);
          
          // CRITICAL: Force immediate visibility of local player target
          const playerTarget = document.querySelector('#player-target');
          if (playerTarget) {
            playerTarget.setAttribute('visible', true);
          }
          
          // Hide only the client's own remote player to prevent self-interference
          if (myPlayerId) {
            const playerIndex = parseInt(myPlayerId.split('_')[1]);
            const remotePlayer = document.querySelector(`#remote-player-${playerIndex}`);
            if (remotePlayer) {
              remotePlayer.setAttribute('visible', false);
            }
          }
          
          // Update ball colors for team assignments
          // Ball colors removed - space shooter uses fixed colors
          
          // CRITICAL FIX: Send team change to host if client, or to all clients if host
          if (isHost) {
            // Team assignments removed - space shooter doesn't use teams
          } else {
            // Client sends their team selection to host
            const hostConnection = connections.get('host');
            if (hostConnection && hostConnection.open) {
              hostConnection.send({
                type: 'client-team-selection',
                playerId: currentPlayerId,
                team: team
              });
            }
          }
          

          
          // Update bot ball assignments for team change
          const redBot = document.querySelector('#zerog-bot-red');
          const blueBot = document.querySelector('#zerog-bot-blue');
          const greenBot = document.querySelector('#zerog-bot-green');
          if (redBot && redBot.components['zerog-bot']) {
            redBot.components['zerog-bot'].updateBallAssignment();
          }
          if (blueBot && blueBot.components['zerog-bot']) {
            blueBot.components['zerog-bot'].updateBallAssignment();
          }
          if (greenBot && greenBot.components['zerog-bot']) {
            greenBot.components['zerog-bot'].updateBallAssignment();
          }
          
          // Force release any currently grabbed balls that are no longer owned
          this.releaseNonOwnedBalls();
          
          // Update the team display
          const currentTeamDisplay = document.querySelector('#menu-current-team');
          if (currentTeamDisplay) {
            currentTeamDisplay.setAttribute('text', 'value', `Team: ${team.toUpperCase()}`);
            currentTeamDisplay.setAttribute('text', 'color', team === 'red' ? '#ff0000' : '#0000ff');
          }
          
          // Update button highlighting
          const redButton = document.querySelector('#menu-team-red');
          const blueButton = document.querySelector('#menu-team-blue');
          
          if (redButton && blueButton) {
            if (team === 'red') {
              redButton.setAttribute('material', 'opacity', 1.0);
              blueButton.setAttribute('material', 'opacity', 0.5);
            } else {
              blueButton.setAttribute('material', 'opacity', 1.0);
              redButton.setAttribute('material', 'opacity', 0.5);
            }
          }
        },
        
        releaseNonOwnedBalls: function() {
          // Release any balls that are no longer owned by this player
          const currentPlayerId = myPlayerId || 'player_0';
          const myBallIndex = getBallForPlayer(currentPlayerId);
          
          // Check all balls and release any that are grabbed but not owned
          for (let i = 1; i <= 4; i++) {
            const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
            if (ball && ball.components['zerog-ball']) {
              const ballComponent = ball.components['zerog-ball'];
              if (ballComponent.isGrabbed && i !== myBallIndex && !ballComponent.isCaptureBall) {
                // This ball is grabbed but not owned by current player - release it
                ballComponent.onRelease();
                
                // Also clear the grab info from the player component
                const player = document.querySelector('[zerog-player]');
                if (player && player.components['zerog-player']) {
                  const playerComponent = player.components['zerog-player'];
                  ['left', 'right'].forEach(handKey => {
                    if (playerComponent.grabInfo[handKey] && 
                        playerComponent.grabInfo[handKey].surface === ball) {
                      playerComponent.grabInfo[handKey] = null;
                      playerComponent.isGrabbing[handKey] = false;
                    }
                  });
                }
              }
            }
          }
        },
        
        selectGameMode: function(mode) {
          // Switch the game mode
          switchGameMode(mode);
          
          
          // Update the mode display
          const currentModeDisplay = document.querySelector('#menu-current-mode-game');
          if (currentModeDisplay) {
            const displayText = mode === 'capture' ? 'Capture' : 'Dodge';
            currentModeDisplay.setAttribute('text', 'value', `Mode: ${displayText}`);
            currentModeDisplay.setAttribute('text', 'color', mode === 'capture' ? '#8800ff' : '#ff8800');
          }
          
          // Update button highlighting
          const dodgeButton = document.querySelector('#menu-mode-dodge');
          const captureButton = document.querySelector('#menu-mode-capture');
          
          if (dodgeButton && captureButton) {
            if (mode === 'capture') {
              captureButton.setAttribute('material', 'opacity', 1.0);
              dodgeButton.setAttribute('material', 'opacity', 0.5);
            } else {
              dodgeButton.setAttribute('material', 'opacity', 1.0);
              captureButton.setAttribute('material', 'opacity', 0.5);
            }
          }
          
          // Team selection is always visible since we're always in capture mode
          const teamSelection = document.querySelector('#menu-team-selection');
          if (teamSelection) {
            teamSelection.setAttribute('visible', true);
          }
        },
        
        restartMatch: function() {
          // Only host can start/restart match
          if (!isHost && isMultiplayer) {
            return;
          }
          
          // Get game manager and start/restart the match
          const gameManager = document.querySelector('[game-manager]');
          if (gameManager && gameManager.components['game-manager']) {
            const gameManagerComponent = gameManager.components['game-manager'];
            
            // If match is waiting, start it; otherwise restart it
            if (gameManagerComponent.matchState === 'WAITING') {
              // Start match with current players + bots to fill to 4 total
              gameManagerComponent.startMatchWithBots();
            } else {
              // Reset match to waiting state, then start new match
              gameManagerComponent.resetMatch();
              // Start new match immediately after reset
              gameManagerComponent.startMatchWithBots();
            }
          }
          
          // Close menu after starting/restarting
          const menuToggle = document.querySelector('[menu-toggle]');
          if (menuToggle && menuToggle.components['menu-toggle']) {
            menuToggle.components['menu-toggle'].toggleMenu();
          }
        },
        
        closeMenu: function() {
          // Force close the menu and disable laser pointers (only for Bloom button)
          const menuToggle = document.querySelector('[menu-toggle]');
          if (menuToggle && menuToggle.components['menu-toggle']) {
            // Force close menu regardless of current state
            menuToggle.components['menu-toggle'].menuVisible = false;
            isMenuVisible = false; // Update global state
            
            const menu = document.querySelector('#game-menu');
            const leftHand = document.querySelector('#leftHand');
            const rightHand = document.querySelector('#rightHand');
            
            // Force hide menu
            if (menu) {
              menu.setAttribute('visible', false);
            }
            
            // FORCE disable laser pointers - no matter what state they're in
            if (leftHand && leftHand.components.raycaster && leftHand.components.raycaster.data) {
              leftHand.components.raycaster.enabled = false;
              leftHand.components.raycaster.data.objects = '';
              leftHand.components.raycaster.data.lineOpacity = 0;
            }
            if (rightHand && rightHand.components.raycaster && rightHand.components.raycaster.data) {
              rightHand.components.raycaster.enabled = false;
              rightHand.components.raycaster.data.objects = '';
              rightHand.components.raycaster.data.lineOpacity = 0;
            }
            
            console.log('🔴 Laser pointers FORCE DISABLED - menu force closed after bloom toggle');
          }
        },
        
        toggleModel: function(modelType) {
          if (modelType === 'spaceship') {
            const spaceship = document.querySelector('#model-spaceship');
            const button = document.querySelector('#menu-toggle-spaceship');
            const buttonText = button.querySelector('a-text');
            
            if (spaceship.getAttribute('visible') !== false && spaceship.getAttribute('visible') !== 'false') {
              spaceship.setAttribute('visible', false);
              button.setAttribute('material', 'color', '#aa0000');
              buttonText.setAttribute('text', 'value', 'Spaceship: OFF');
              console.log('🚀 Spaceship model disabled - collision detection optimized');
            } else {
              spaceship.setAttribute('visible', true);
              button.setAttribute('material', 'color', '#00aa00');
              buttonText.setAttribute('text', 'value', 'Spaceship: ON');
              console.log('🚀 Spaceship model enabled - collision detection active');
            }
            
            // PERFORMANCE: Update global visibility state for BVH optimization
            updateModelVisibilityState();
            
            // Re-initialize BVH for collision detection when spaceship visibility changes
            const collisionSystem = document.querySelector('[collision-system]');
            if (collisionSystem && collisionSystem.components['collision-system']) {
              console.log('🔄 Re-initializing BVH due to spaceship visibility change');
              setTimeout(() => {
                collisionSystem.components['collision-system'].initializeBVH();
              }, 200); // Increased delay to ensure visibility change is processed
            }
          } else if (modelType === 'asteroid-42') {
            const asteroid = document.querySelector('#model-asteroid-42');
            const button = document.querySelector('#menu-toggle-asteroid-42');
            const buttonText = button.querySelector('a-text');
            
            if (asteroid.getAttribute('visible') !== false && asteroid.getAttribute('visible') !== 'false') {
              asteroid.setAttribute('visible', false);
              button.setAttribute('material', 'color', '#aa0000');
              buttonText.setAttribute('text', 'value', 'Asteroid: OFF');
            } else {
              asteroid.setAttribute('visible', true);
              button.setAttribute('material', 'color', '#00aa00');
              buttonText.setAttribute('text', 'value', 'Asteroid: ON');
            }
            
            // PERFORMANCE: Update global visibility state for BVH optimization
            updateModelVisibilityState();
            
            // Re-initialize BVH for single asteroid
            const collisionSystem = document.querySelector('[collision-system]');
            if (collisionSystem && collisionSystem.components['collision-system']) {
              console.log('🔄 Re-initializing BVH due to asteroid visibility change');
              setTimeout(() => {
                collisionSystem.components['collision-system'].initializeBVH();
              }, 200); // Increased delay to ensure visibility change is processed
            }
          } else if (modelType === 'level') {
            const level = document.querySelector('#model-level');
            const button = document.querySelector('#menu-toggle-level');
            const buttonText = button.querySelector('a-text');
            
            if (level.getAttribute('visible') !== false && level.getAttribute('visible') !== 'false') {
              level.setAttribute('visible', false);
              button.setAttribute('material', 'color', '#aa0000');
              buttonText.setAttribute('text', 'value', 'Level: OFF');
              console.log('🚀 Level model disabled - collision detection optimized');
            } else {
              level.setAttribute('visible', true);
              button.setAttribute('material', 'color', '#00aa00');
              buttonText.setAttribute('text', 'value', 'Level: ON');
              console.log('🚀 Level model enabled - collision detection active');
            }
            
            // PERFORMANCE: Update global visibility state for BVH optimization
            updateModelVisibilityState();
            
            // Re-initialize BVH for level model
            const collisionSystem = document.querySelector('[collision-system]');
            if (collisionSystem && collisionSystem.components['collision-system']) {
              console.log('🔄 Re-initializing BVH due to level model visibility change');
              setTimeout(() => {
                collisionSystem.components['collision-system'].initializeBVH();
              }, 200); // Increased delay to ensure visibility change is processed
            }
          }
        },
        
        toggleBots: function() {
          // Get all bot entities
          const bots = [
            document.querySelector('#zerog-bot-red'),
            document.querySelector('#zerog-bot-blue'),
            document.querySelector('#zerog-bot-green')
          ];
          
          const button = document.querySelector('#menu-toggle-bots');
          const buttonText = button.querySelector('a-text');
          
          // Check if any bot is currently enabled
          let anyBotEnabled = false;
          bots.forEach(bot => {
            if (bot && bot.getAttribute('zerog-bot')) {
              const botAttr = bot.getAttribute('zerog-bot');
              if (botAttr.enabled === true) {
                anyBotEnabled = true;
              }
            }
          });
          
          if (anyBotEnabled) {
            // Disable all bots
            bots.forEach(bot => {
              if (bot) {
                bot.setAttribute('zerog-bot', 'enabled', false);
              }
            });
            button.setAttribute('material', 'color', '#aa0000');
            buttonText.setAttribute('text', 'value', 'Bots: OFF');
            // Store the manual disable state in a reliable way
            button.setAttribute('data-bots-manually-disabled', 'true');
            // All bots disabled - AI logic stopped for performance
          } else {
            // Enable all bots
            bots.forEach(bot => {
              if (bot) {
                bot.setAttribute('zerog-bot', 'enabled', true);
              }
            });
            button.setAttribute('material', 'color', '#00aa00');
            buttonText.setAttribute('text', 'value', 'Bots: ON');
            // Clear the manual disable state
            button.removeAttribute('data-bots-manually-disabled');
            // All bots enabled - AI logic active
          }
          
          // Trigger bot management to respect the new state
          manageActivePlayersAndBots();
        },
        
        
        toggleMeshDebug: function() {
          // Get the zerog-player component to access showMeshDebug
          const player = document.querySelector('[zerog-player]');
          if (player && player.components && player.components['zerog-player']) {
            const playerComponent = player.components['zerog-player'];
            
            // Toggle the debug state
            playerComponent.showMeshDebug = !playerComponent.showMeshDebug;
            
            // Update button appearance
            const button = document.querySelector('#menu-toggle-mesh-debug');
            const buttonText = button.querySelector('a-text');
            
            if (playerComponent.showMeshDebug) {
              button.setAttribute('material', 'color', '#00aa00');
              buttonText.setAttribute('text', 'value', 'Debug: ON');
            } else {
              button.setAttribute('material', 'color', '#aa0000');
              buttonText.setAttribute('text', 'value', 'Debug: OFF');
              
              // Reset all mesh colors when turning off
              if (playerComponent.bvhMeshes) {
                playerComponent.bvhMeshes.forEach(mesh => {
                  if (mesh.material && !Array.isArray(mesh.material) && mesh.userData.hasOwnMaterial) {
                    mesh.material.color.setHex(mesh.userData.originalColor || 0x888888);
                  }
                });
              }
            }
          } else {
            console.warn('⚠️ zerog-player component not found for mesh debug toggle');
          }
        },
        
        toggleSmoke: function() {
          smokeEnabled = !smokeEnabled;
          const smokeEntity = document.querySelector('#webgpu-particles');
          if (smokeEntity) {
            smokeEntity.setAttribute('visible', smokeEnabled);
            // Enable/disable the component logic
            if (smokeEnabled) {
              smokeEntity.setAttribute('threejs-webgpu-particles', '');
            } else {
              smokeEntity.removeAttribute('threejs-webgpu-particles');
            }
          }
          
          // Update button appearance
          const button = document.querySelector('#menu-toggle-smoke');
          const buttonText = button.querySelector('a-text');
          
          if (smokeEnabled) {
            button.setAttribute('material', 'color', '#00aa00');
            buttonText.setAttribute('text', 'value', 'Smoke: ON');
          } else {
            button.setAttribute('material', 'color', '#aa0000');
            buttonText.setAttribute('text', 'value', 'Smoke: OFF');
          }
          
          console.log('Smoke:', smokeEnabled ? 'ON' : 'OFF');
        },
        
        toggleIceCube: function() {
          iceCubeEnabled = !iceCubeEnabled;
          const iceCubeEntity = document.querySelector('#ice-cube');
          if (iceCubeEntity) {
            iceCubeEntity.setAttribute('visible', iceCubeEnabled);
              // Enable/disable the component logic
              if (iceCubeEnabled) {
                iceCubeEntity.setAttribute('webgpu-parallax-uv', 
                  'colorMap: assets/textures/ice002/Ice002_2K-JPG_Color.jpg; ' +
                  'normalMap: assets/textures/ice002/Ice002_2K-JPG_NormalGL.jpg; ' +
                  'roughnessMap: assets/textures/ice002/Ice002_2K-JPG_Roughness.jpg; ' +
                  'displacementMap: assets/textures/ice002/Ice002_2K-JPG_Displacement.jpg');
                iceCubeEntity.setAttribute('grab-surface', '');
              } else {
                iceCubeEntity.removeAttribute('webgpu-parallax-uv');
                iceCubeEntity.removeAttribute('grab-surface');
              }
          }
          
          // Update button appearance
          const button = document.querySelector('#menu-toggle-ice-cube');
          const buttonText = button.querySelector('a-text');
          
          if (iceCubeEnabled) {
            button.setAttribute('material', 'color', '#00aa00');
            buttonText.setAttribute('text', 'value', 'Ice: ON');
          } else {
            button.setAttribute('material', 'color', '#aa0000');
            buttonText.setAttribute('text', 'value', 'Ice: OFF');
          }
          
          console.log('Ice Cube:', iceCubeEnabled ? 'ON' : 'OFF');
        },
        
        toggleSparks: function() {
          sparksEnabled = !sparksEnabled;
          const sparksEntity = document.querySelector('#spark-particles');
          const smokeEntity = document.querySelector('#spark-smoke');
          
          if (sparksEntity) {
            sparksEntity.setAttribute('visible', sparksEnabled);
            
          // Also control the smoke entity visibility
          if (smokeEntity) {
            smokeEntity.setAttribute('visible', sparksEnabled);
          }
          
          if (sparksEnabled) {
              // Simple particle system with burst controller
              sparksEntity.setAttribute('particle-system', 
                'preset: default; ' +
                'particleCount: 100; ' +
                'maxAge: 1.5; ' +
                'positionSpread: 0.02 0.02 0.02; ' +
                'velocityValue: 0 0 0; ' +
                'velocitySpread: 2 2 2; ' +
                'accelerationValue: 0 0 0; ' +
                'accelerationSpread: 0 0 0; ' +
                'color: #FFFF00,#FF8800,#FF4400,#4444FF,#8844FF,#220000; ' +
                'size: 0.02,0.01; ' +
                'opacity: 1.0,0.0; ' +
                'texture: assets/particles/sparkle.png; ' +
                'blending: 2; ' +
                'dragValue: 0; ' +
                'dragSpread: 0; ' +
                'randomise: false; ' +
                'hasPerspective: false; ' +
                'enabled: false'); // Start disabled, burst controller will manage
              
            // Add burst controller if not present
            if (!sparksEntity.components['spark-burst-controller']) {
              sparksEntity.setAttribute('spark-burst-controller', '');
            }
          } else {
              // Disable the particle system
              if (sparksEntity.components['particle-system']) {
                sparksEntity.components['particle-system'].stopParticles();
              }
              sparksEntity.removeAttribute('particle-system');
            }
          }
          
          // Update button appearance
          const button = document.querySelector('#menu-toggle-sparks');
          const buttonText = button.querySelector('a-text');
          
          if (sparksEnabled) {
            button.setAttribute('material', 'color', '#00aa00');
            buttonText.setAttribute('text', 'value', 'Sparks: ON');
          } else {
            button.setAttribute('material', 'color', '#aa0000');
            buttonText.setAttribute('text', 'value', 'Sparks: OFF');
          }
          
          console.log('Sparks:', sparksEnabled ? 'ON' : 'OFF');
        },
        
        toggleBloom: function() {
          console.log('🔧 Bloom toggle clicked');
          
          const scene = document.querySelector('a-scene');
          const button = document.querySelector('#menu-toggle-bloom');
          const buttonText = button ? button.querySelector('a-text') : null;
          
          if (!scene) {
            console.error('Scene not found');
            return;
          }
          
          // Check current bloom state
          const hasBloom = scene.hasAttribute('bloom');
          
          // PERFORMANCE OPTIMIZATION: Toggle bloom attribute to enable/disable post-processing
          if (hasBloom) {
            // Remove bloom attribute to disable post-processing
            scene.removeAttribute('bloom');
            console.log('✅ Bloom post-processing DISABLED - expect 40-50 FPS boost');
            
            // Update button appearance
            if (button && buttonText) {
              button.setAttribute('material', 'color', '#aa0000');
              buttonText.setAttribute('text', 'value', 'Bloom: OFF');
            }
          } else {
            // Add bloom attribute to enable post-processing
            scene.setAttribute('bloom', 'threshold: 0.98; strength: 0.3; radius: 0.15; toneMappingExposure: 1.0');
            console.log('✅ Bloom post-processing ENABLED');
            
            // Update button appearance
            if (button && buttonText) {
              button.setAttribute('material', 'color', '#00aa00');
              buttonText.setAttribute('text', 'value', 'Bloom: ON');
            }
          }
        }
      });
      
      } // End of registerAllComponents function
      
      // Wait for all critical components to be fully initialized
      function waitForCriticalComponents() {
        let timeoutId;
        let checkCount = 0;
        const maxChecks = 100; // 10 seconds at 100ms intervals
        
        // PERFORMANCE: Initialize model visibility state on startup
        setTimeout(() => {
          updateModelVisibilityState();
          console.log('🚀 Initial model visibility state set');
        }, 1000);
        
        const checkInterval = setInterval(() => {
          checkCount++;
          const scene = document.querySelector('a-scene');
          const playerController = scene?.querySelector('#player')?.components?.['zerog-player'];
          const fpsCounter = scene?.components?.['fps-counter'];
          const gameManager = scene?.components?.['game-manager'];
          
          // Debug component attachment - removed console spam
          
          // Debug logging every 10 checks (1 second) - removed console spam
          
          if (playerController && fpsCounter && gameManager) {
            clearInterval(checkInterval);
            clearTimeout(timeoutId); // Clear the timeout since we found components
            
            // CRITICAL: Ensure scene is playing and tick loop is active
            if (scene && !scene.is('vr-mode')) {
              console.log('🎬 Scene state before forcing play:', {
                isPlaying: scene.isPlaying,
                hasLoaded: scene.hasLoaded,
                time: scene.time,
                renderStarted: scene.renderStarted
              });
              
              // CRITICAL: Ensure FPS counter component is properly enabled
              if (fpsCounter) {
                // FPS Counter component found, ensuring it's enabled
                fpsCounter.enabled = true;
                // Force reinitialize if needed
                if (typeof fpsCounter.init === 'function') {
                  fpsCounter.init();
                  // FPS Counter component reinitialized
                }
              } else {
                console.warn('⚠️ FPS Counter component not found on scene!');
              }
              
              // Force scene to play if it's not already
              if (!scene.isPlaying) {
                console.log('🎬 Scene not playing - forcing scene.play()');
                scene.play();
              } else {
                console.log('🎬 Scene already playing');
              }
              
              // Verify scene tick is working
              setTimeout(() => {
                console.log('🎬 Scene state check:', {
                  isPlaying: scene.isPlaying,
                  hasLoaded: scene.hasLoaded,
                  time: scene.time,
                  renderStarted: scene.renderStarted
                });
                
                // Test if tick loop is actually running by checking if time is advancing
                const initialTime = scene.time;
                setTimeout(() => {
                  const finalTime = scene.time;
                  const timeAdvancing = finalTime > initialTime;
                  console.log('🎬 Tick loop test:', {
                    initialTime: initialTime,
                    finalTime: finalTime,
                    timeAdvancing: timeAdvancing,
                    timeDelta: finalTime - initialTime
                  });
                  
                  if (!timeAdvancing) {
                    console.error('🚨 CRITICAL: Scene tick loop is not running!');
                    console.log('🎬 Attempting to force scene restart...');
                    
                    // More aggressive restart
                    scene.pause();
                    setTimeout(() => {
                      // Force remove and re-add critical components to restart them
                      const fpsComponent = scene.components['fps-counter'];
                      if (fpsComponent) {
                        console.log('🎬 Restarting FPS counter component...');
                        // Force reinitialize the component
                        fpsComponent.init();
                      }
                      
                      scene.play();
                      console.log('🎬 Scene restarted with component reinitialization');
                    }, 100);
                  } else {
                    console.log('✅ Scene tick loop is running correctly');
                  }
                }, 100);
              }, 1000);
            }
            
            console.log('✅ All critical components initialized and operational');
            
            // CRITICAL: Track the complete initialization sequence
            // Starting post-initialization sequence check
            
            // Check if all critical systems are actually working
            setTimeout(() => {
              // Post-initialization sequence check (2 seconds later)
              
              // Check FPS counter tick function
              const fpsComponent = scene.components['fps-counter'];
              if (fpsComponent) {
                // FPS Counter status - removed console spam
              }
              
              // Check if performance optimization is running
              const playerComponent = scene.querySelector('#player')?.components?.['zerog-player'];
              if (playerComponent) {
                console.log('🎮 Player component status:', {
                  enabled: playerComponent.data?.enabled,
                  hasTickFunction: typeof playerComponent.tick === 'function',
                  velocity: playerComponent.velocity ? playerComponent.velocity.length() : 'N/A'
                });
              }
              
              // Check if other critical components are working
              const gameManagerComponent = scene.components['game-manager'];
              if (gameManagerComponent) {
                console.log('🎮 Game Manager status:', {
                  enabled: gameManagerComponent.enabled,
                  hasTickFunction: typeof gameManagerComponent.tick === 'function',
                  matchState: gameManagerComponent.matchState
                });
              }
              
              // Force trigger some systems to see if they respond
              // Testing system responsiveness
              if (fpsComponent && typeof fpsComponent.tick === 'function') {
                // Manually calling FPS counter tick function
                fpsComponent.tick(performance.now());
              }
              
              // CRITICAL: If systems are not responding, force restart the entire scene
              const systemsWorking = fpsComponent && fpsComponent.frameCount > 0;
              if (!systemsWorking) {
                console.error('🚨 CRITICAL: Systems not responding after initialization!');
                console.log('🔧 Attempting complete scene restart...');
                
                // AGGRESSIVE RESTART: Force scene to completely restart
                scene.pause();
                
                // Wait a bit, then force restart everything
        setTimeout(() => {
                  console.log('🔧 Force restarting scene and all components...');
                  
                  // Force restart all critical components
                  if (fpsComponent) {
                    fpsComponent.init();
                    // FPS Counter force restarted
                  }
                  
                  if (playerComponent) {
                    playerComponent.init();
                    console.log('🎮 Player component force restarted');
                  }
                  
                  if (gameManagerComponent) {
                    gameManagerComponent.init();
                    console.log('🎮 Game Manager force restarted');
                  }
                  
                  // Force scene to play
                  scene.play();
                  console.log('🎬 Scene force restarted');
                  
                  // Wait and verify the restart worked
                  setTimeout(() => {
                    const fpsAfterRestart = scene.components['fps-counter'];
                    if (fpsAfterRestart && fpsAfterRestart.frameCount > 0) {
                      console.log('✅ Scene restart successful - systems now working');
                    } else {
                      console.error('🚨 Scene restart failed - attempting page reload...');
                      // Last resort: reload the page
                      window.location.reload();
                    }
                  }, 2000);
                  
                }, 500);
              } else {
                console.log('✅ All systems responding correctly');
              }
              
            }, 2000);
            
            return;
          }
          
          // Check if we've exceeded max checks
          if (checkCount >= maxChecks) {
            clearInterval(checkInterval);
            clearTimeout(timeoutId);
            console.log('⚠️ Timeout reached - proceeding anyway');
          }
        }, 100);
        
        // Fallback timeout after 10 seconds (only if interval hasn't cleared it)
        timeoutId = setTimeout(() => {
          clearInterval(checkInterval);
          console.log('⚠️ Timeout reached - proceeding anyway');
        }, 10000);
      }
      
      // Start waiting for critical components
      waitForCriticalComponents();

    </script>

    <a-scene physics-world fps-counter game-manager sound-manager multiplayer-sync menu-toggle impact-effects-manager bullet-manager
             renderer="antialias: true; colorManagement: true; shadowMapEnabled: false; maxDeltaTime: 0.2"
             webxr="requiredFeatures: local-floor">
      
        <a-assets>
         <!-- Nebula Skybox Texture -->
         <img id="nebula-texture" src="assets/nebula_skybox_16k/textures/Material.001_baseColor.jpeg">
         
         <!-- Single Asteroid 3D Model -->
         <a-asset-item id="asteroid-42-model" src="assets/asteroid_42.glb"></a-asset-item>
         <!-- Spaceship 3D Model -->
         <a-asset-item id="spaceship-model" src="https://pub-65c21cd4f13345fcb1574dc28def6a19.r2.dev/SpaceShipAnim.glb"></a-asset-item>
         <!-- Level 3D Model -->
         <a-asset-item id="level-model" src="assets/level.glb"></a-asset-item>
         
         <!-- Arm Segment 3D Model -->
         <a-asset-item id="arm-segment-model" src="assets/test-arm.glb"></a-asset-item>
         
         <!-- Particle Textures -->
         <img id="fog-texture" src="assets/particles/fog-256.png">
         <img id="sparkle-texture" src="assets/particles/sparkle.png">
        </a-assets>
      
      



      

      <!-- Floating objects/balls (spawned at center) -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ff0000" 
                glow="color: #ff0000; intensity: 1.5"
                zerog-ball="player: player1; owner: bot">
        <a-entity light="type: point;
                       color: #ff0000;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2;"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff0000" material="wireframe: true; color: #ff0000; opacity: 0.5"></a-sphere>
        <!-- Ball Shield -->
        <a-sphere class="ball-shield" 
                  radius="0.2" 
                  material="transparent: true; opacity: 0.3; color: #ff0000" 
                  visible="false"
                  ball-shield>
        </a-sphere>
        <a-entity id="red-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#0000ff" 
                glow="color: #0000ff; intensity: 1.5"
                zerog-ball="player: player2; owner: human">
        <a-entity light="type: point; 
                       color: #0000ff;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#0000ff" material="wireframe: true; color: #0000ff; opacity: 0.5"></a-sphere>
        <!-- Ball Shield -->
        <a-sphere class="ball-shield" 
                  radius="0.2" 
                  material="transparent: true; opacity: 0.3; color: #0000ff" 
                  visible="false"
                  ball-shield>
        </a-sphere>
        <a-entity id="blue-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Ball 3 (Purple) - Blue Bot Ball -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#00ff00" 
                glow="color: #00ff00; intensity: 1.5"
                zerog-ball="player: player3; owner: bot">
        <a-entity light="type: point; 
                       color: #00ff00;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ff00ff" material="wireframe: true; color: #ff00ff; opacity: 0.5"></a-sphere>
        <!-- Ball Shield -->
        <a-sphere class="ball-shield" 
                  radius="0.2" 
                  material="transparent: true; opacity: 0.3; color: #ff00ff" 
                  visible="false"
                  ball-shield>
        </a-sphere>
        <a-entity id="purple-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Ball 4 (Yellow) - Human Player 1 Ball -->
      <a-sphere position="0 2 0" 
                radius="0.1"
                color="#ffff00" 
                glow="color: #ffff00; intensity: 1.5"
                zerog-ball="player: player4; owner: human">
        <a-entity light="type: point; 
                       color: #ffff00;
                       intensity: 1.5;     
                       distance: 5;       
                       decay: 2"  
                  position="0 0 0">
        </a-entity>
        <a-sphere radius="0.1" color="#ffff00" material="wireframe: true; color: #ffff00; opacity: 0.5"></a-sphere>
        <!-- Ball Shield -->
        <a-sphere class="ball-shield" 
                  radius="0.2" 
                  material="transparent: true; opacity: 0.3; color: #ffff00" 
                  visible="false"
                  ball-shield>
        </a-sphere>
        <a-entity id="yellow-ball-hum" sound="src: url(audio/electric-hum.wav); 
                        autoplay: false; 
                        loop: true; 
                        volume: 0.6;
                        positional: true;
                        distanceModel: inverse;
                        refDistance: 1;
                        maxDistance: 4;
                        rolloffFactor: 1;
                        poolSize: 1;">
        </a-entity>
      </a-sphere>

      <!-- Special white capture ball (twice the size, half max velocity) -->
      <!-- Capture ball removed for space shooter -->

      <!-- ACTUAL Three.js WebGPU particles implementation (disabled by default) -->
      <a-entity id="webgpu-particles" 
                position="0 6 12" 
                visible="false">
      </a-entity>
      
      <!-- Spark effect using proper aframe-particle-system-component (disabled by default) -->
      <a-entity id="spark-particles" 
                position="-6.242 5.988 1.867" 
                visible="false"
                world-spark-system
                enhanced-particles
                spark-burst-controller
                particle-system="
                  preset: default;
                  particleCount: 100;
                  maxAge: 1.5;
                  positionSpread: 0.02 0.02 0.02;
                  velocityValue: 0 0 0;
                  velocitySpread: 2 2 2;
                  accelerationValue: 0 0 0;
                  accelerationSpread: 0 0 0;
                  color: #FFFF00,#FF8800,#FF4400,#4444FF,#8844FF,#220000;
                  size: 0.02,0.01;
                  opacity: 1.0,0.0;
                  texture: assets/particles/sparkle.png;
                  blending: 2;
                  dragValue: 0;
                  dragSpread: 0;
                  randomise: false;
                  hasPerspective: false;
                  enabled: false">
        
        <!-- Small smoke puffs using proper Three.js smoke system -->
        <a-entity id="spark-smoke" 
                  spark-smoke-controller
                  threejs-smoke-puffs>
        </a-entity>
      </a-entity>

       <!-- Three.js WebGPU parallax UV ice cube (exact from reference, with physics and grabbable) -->
       <a-box id="ice-cube" 
              position="2 5.8 12" 
              width="1" height="1" depth="1"
              visible="false"
              material="color: #88ccff; transparent: true; opacity: 0.8"
              webgpu-parallax-uv="
                colorMap: assets/textures/ice002/Ice002_2K-JPG_Color.jpg;
                normalMap: assets/textures/ice002/Ice002_2K-JPG_NormalGL.jpg;
                roughnessMap: assets/textures/ice002/Ice002_2K-JPG_Roughness.jpg;
                displacementMap: assets/textures/ice002/Ice002_2K-JPG_Displacement.jpg">
       </a-box>

      <!-- DEBUG: Enhanced emissive sphere at player start position -->
      <a-sphere id="bloom-debug-sphere"
                position="0 5.3 12"
                radius="0.2"
                material="color: #ffff00; shader: standard; emissive: #ffff00; emissiveIntensity: 8.0; metalness: 0; roughness: 0"
                enhanced-emissive="intensity: 5.0; color: #ffff00"
                visible="true">
      </a-sphere>

      <!-- Player with zero-g physics -->
      <a-entity id="player" position="0 5.300 12" zerog-player="mass: 70; thrusterForce: 0.8">
        <a-entity id="rig" position="0 0 0">
          <a-entity camera look-controls="pointerLockEnabled: false">
            <!-- Player target sphere (like in original dodgeball project) -->
            <a-sphere id="player-target" 
                      radius="0.2" 
                      color="#888888" 
                      material="shader: standard; emissive: #888888; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                      position="0 0 0"
                      impact-effect="color: #888888"
                      player-damage=""
                      class="grabbable-player"
                      data-player-id="player_0">
              <a-entity light="type: point; color: #888888; intensity: 1; distance: 3"></a-entity>
              <!-- Impact sphere with animation component -->
              <a-sphere id="player-impact" radius="0.1" color="#888888" opacity="0" visible="false" material="side: double; transparent: true"
                animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
                animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
              </a-sphere>
            
            </a-sphere>
            
            <!-- HUD display -->
            <a-entity id="version-display" position="0 0.3 -0.5" text="value: Zero-G v1.0; align: center; width: 0.4; color: #ffffff"></a-entity>
            
            <!-- Game Status Display -->
            <a-entity id="hud-status" position="0 0.2 -0.5" text="value: ; align: center; width: 1.1; color: #ffffff" visible="false"></a-entity>
            
            <!-- Score Display in HUD -->
            <a-entity id="hud-score" position="0 0.1 -0.5" visible="false">
              <a-entity position="-0.15 0 0" text="value: 0; align: center; width: 1.5; color: #0099ff"></a-entity>
              <a-entity position="0.15 0 0" text="value: 0; align: center; width: 1.5; color: #ff4444"></a-entity>
              <a-entity position="-0.15 -0.1 0" text="value: Team; align: center; width: 0.8; color: #0099ff"></a-entity>
              <a-entity position="0.15 -0.1 0" text="value: Bots; align: center; width: 0.8; color: #ff4444"></a-entity>
            </a-entity>
            
            <!-- Timer Display in HUD -->
            <a-entity id="hud-timer" position="0 0.05 -0.5" text="value: Time: 3:00; align: center; width: 1.2; color: #ffff00" visible="false"></a-entity>
            
            <!-- Speed Display in HUD -->
            <a-entity id="hud-speed" position="0 -0.15 -0.5" text="value: 0.0 m/s; align: center; width: 0.5; color: #ffffff" visible="true"></a-entity>
            
            <!-- Power Bars in HUD - Separate for each hand -->
            <a-entity id="power-bars-container" position="0 -0.25 -0.5" visible="true">
              <!-- Left Hand Power Bar -->
              <a-entity id="left-power-container" position="-0.06 0 0">
                <a-text value="L" position="0 0.05 0" align="center" width="0.8" color="#ffffff"></a-text>
                <a-plane id="power-bar-bg-left" width="0.1" height="0.02" color="#333333" position="0 -0.02 0"></a-plane>
                <a-plane id="power-bar-left" width="0.1" height="0.02" color="#00ff00" position="0 -0.02 0.001"></a-plane>
              </a-entity>
              
              <!-- Right Hand Power Bar -->
              <a-entity id="right-power-container" position="0.06 0 0">
                <a-text value="R" position="0 0.05 0" align="center" width="0.8" color="#ffffff"></a-text>
                <a-plane id="power-bar-bg-right" width="0.1" height="0.02" color="#333333" position="0 -0.02 0"></a-plane>
                <a-plane id="power-bar-right" width="0.1" height="0.02" color="#00ff00" position="0 -0.02 0.001"></a-plane>
              </a-entity>
            </a-entity>
            
            <!-- Game Messages in HUD -->
             <a-entity id="hud-message" position="0 0 -0.5" text="value: ; align: center; width: 1.1; color: #ffffff" visible="false"></a-entity>
            
            <!-- Game Menu in HUD (initially hidden) -->
            <a-entity id="game-menu" position="0 0 -0.8" visible="false">
              <!-- Menu background panel -->
              <a-plane width="1.2" height="0.8" color="#000000" material="opacity: 0.9; transparent: true" position="0 0 -0.01"></a-plane>
              
              <!-- Menu title -->
              <a-text value="DODGE VR MENU" position="0 0.3 0" align="center" width="1.2" color="#ffffff"></a-text>

              <!-- Current mode display -->
              <a-text id="menu-current-mode" value="Mode: Singleplayer" position="0 0.25 0" align="center" width="1.1" color="#ffffff"></a-text>
              
              <!-- Singleplayer button -->
              <a-entity id="menu-singleplayer" position="-0.2 0.15 0" 
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #004499; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="SINGLE" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Multiplayer button -->
              <a-entity id="menu-multiplayer" position="0.2 0.15 0"
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #990044; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="MULTI" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Lobby selection (only visible in multiplayer) -->
              <a-entity id="menu-lobby-section" position="0 0.05 0" visible="false">
                <a-text value="Lobby:" position="-0.4 0 0" align="center" width="0.3" color="#ffffff"></a-text>
                <a-entity id="menu-lobby-minus" position="-0.075 0 0"
                          geometry="primitive: plane; width: 0.04; height: 0.04"
                          material="color: #ff4444; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="-" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
                <a-text id="menu-lobby-number" value="1" position="-0.02 0 0" align="center" width="1" color="#ffffff"></a-text>
                <a-entity id="menu-lobby-plus" position="0.05 0 0"
                          geometry="primitive: plane; width: 0.04; height: 0.04"
                          material="color: #44ff44; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="+" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-connect" position="0.15 0 0"
                          geometry="primitive: plane; width: 0.1; height: 0.04"
                          material="color: #4444ff; transparent: true; opacity: 0.8"
                          cursor-listener
                          class="clickable">
                  <a-text value="JOIN" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>
              
              <!-- Auto connect button -->
              <!--<a-entity id="menu-auto-connect" position="0.2 0.05 0"
                        geometry="primitive: plane; width: 0.25; height: 0.08"
                        material="color: #44aa44; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable"
                        visible="false">
                <a-text value="AUTO JOIN" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>-->
              
              <!-- Player slots display -->
              <!--<a-entity id="menu-player-slots" position="0 0 0">
                <a-text value="Players:" position="-0.4 0 0" align="center" width="0.3" color="#ffffff"></a-text>
                <a-entity id="menu-slot-0" position="-0.1 0 0">
                  <a-sphere radius="0.02" color="#ff0000" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P0" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-1" position="-0 0 0">
                  <a-sphere radius="0.02" color="#00ff00" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P1" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-2" position="0.1 0 0">
                  <a-sphere radius="0.02" color="#ff00ff" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P2" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
                <a-entity id="menu-slot-3" position="0.2 0 0">
                  <a-sphere radius="0.02" color="#ffff00" material="opacity: 0.5; transparent: true"></a-sphere>
                  <a-text value="P3" position="0 -0.04 0" align="center" width="0.2" color="#ffffff"></a-text>
                </a-entity>
              </a-entity>-->
              
              <!-- Game mode and team selection removed - space shooter is always dodgeball mode -->
              
              <!-- 3D Model Toggles for Performance Testing -->
              <a-text value="3D Models (Performance Test):" position="0 -0.05 0" align="center" width="0.8" color="#ffff00"></a-text>
              
              <!-- Spaceship Toggle -->
              <a-entity id="menu-toggle-spaceship" position="-0.3 -0.12 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Spaceship: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Bot AI Toggle -->
              <a-entity id="menu-toggle-bots" position="0 -0.12 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #00aa00; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Bots: ON" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Single Asteroid Toggle -->
              <a-entity id="menu-toggle-asteroid-42" position="0.3 -0.12 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Asteroid: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Mesh Debug Toggle -->
              <a-entity id="menu-toggle-mesh-debug" position="-0.3 -0.18 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Debug: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Smoke Effect Toggle -->
              <a-entity id="menu-toggle-smoke" position="0 -0.18 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Smoke: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Ice Cube Effect Toggle -->
              <a-entity id="menu-toggle-ice-cube" position="0.3 -0.18 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Ice: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Sparks Effect Toggle -->
              <a-entity id="menu-toggle-sparks" position="-0.3 -0.24 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Sparks: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Bloom Effect Toggle -->
              <a-entity id="menu-toggle-bloom" position="0 -0.24 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #aa0000; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Bloom: OFF" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Level Model Toggle -->
              <a-entity id="menu-toggle-level" position="0.3 -0.24 0"
                        geometry="primitive: plane; width: 0.18; height: 0.05"
                        material="color: #00aa00; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable">
                <a-text value="Level: ON" position="0 0 0.01" align="center" width="0.8" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Start/Restart Match Button (only visible for host) -->
              <a-entity id="menu-restart-match" position="0 -0.31 0"
                        geometry="primitive: plane; width: 0.3; height: 0.06"
                        material="color: #ff4400; transparent: true; opacity: 0.8"
                        cursor-listener
                        class="clickable"
                        visible="false">
                <a-text id="menu-restart-text" value="START MATCH" position="0 0 0.01" align="center" width="1" color="#ffffff"></a-text>
              </a-entity>
              
              <!-- Instructions -->
               <a-text value="X to close" 
                      position="0 -0.35 0" align="center" width="0.6" color="#ffffff"></a-text>
            </a-entity>
          </a-entity>
          
          <a-entity id="leftHand" 
                   hand-controls="hand: left"
                   oculus-touch-controls="hand: left"
                   laser-controls="hand: left"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   arm-ik-visualizer="hand: left"
                   gun="fireRate: 8; powerDrainRate: 25; rechargeRate: 25"
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
            
            <!-- IK Arm Visualization -->
            <!-- Forearm box (wrist to elbow) -->
            <a-entity class="forearm-model" 
                      arm-segment-model="segmentLength: 0.25; segmentType: forearm"
                      visible="true">
            </a-entity>
            
            <!-- Upper arm box (elbow to shoulder) -->
            <a-entity class="upperarm-model" 
                      arm-segment-model="segmentLength: 0.30; segmentType: upperarm"
                      visible="true">
            </a-entity>
            
            <!-- Elbow position indicator -->
            <a-sphere class="elbow-indicator"
                     radius="0.02"
                     color="#ff0000"
                     material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5"
                     visible="true">
            </a-sphere>
            
            <!-- Left hand shooting sound -->
            <a-entity id="left-hand-laser-sound"
                     sound="src: url(audio/laser-45816.mp3); volume: 0.3; autoplay: false; loop: false; positional: true; distanceModel: linear; refDistance: 1; maxDistance: 25">
            </a-entity>
          </a-entity>
          
          <a-entity id="rightHand" 
                   hand-controls="hand: right"
                   oculus-touch-controls="hand: right"
                   laser-controls="hand: right"
                   raycaster="objects: .clickable; lineColor: #ffffff; lineOpacity: 0"
                   hand-collider
                   hand-haptics
                   debug-controller
                   custom-hand-controls
                   arm-ik-visualizer="hand: right"
                   gun="fireRate: 8; powerDrainRate: 25; rechargeRate: 25"
                   >
            <!-- Thruster visual effect -->
            <a-cone class="thruster-vfx"
                    position="0 0 0.1"
                    radius-bottom="0.02"
                    radius-top="0.01"
                    height="0.1"
                    color="#00ffff"
                    material="shader: standard; emissive: #00ffff; emissiveIntensity: 1; transparent: true; opacity: 0.8"
                    visible="false">
            </a-cone>
            
            <!-- IK Arm Visualization -->
            <!-- Forearm box (wrist to elbow) -->
            <a-entity class="forearm-model" 
                      arm-segment-model="segmentLength: 0.25; segmentType: forearm"
                      visible="true">
            </a-entity>
            
            <!-- Upper arm box (elbow to shoulder) -->
            <a-entity class="upperarm-model" 
                      arm-segment-model="segmentLength: 0.30; segmentType: upperarm"
                      visible="true">
            </a-entity>
            
            <!-- Elbow position indicator -->
            <a-sphere class="elbow-indicator"
                     radius="0.02"
                     color="#ff0000"
                     material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5"
                     visible="true">
            </a-sphere>
            
            <!-- Right hand shooting sound -->
            <a-entity id="right-hand-laser-sound"
                     sound="src: url(audio/laser-45816.mp3); volume: 0.3; autoplay: false; loop: false; positional: true; distanceModel: linear; refDistance: 1; maxDistance: 25">
            </a-entity>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Remote players (for multiplayer) -->
      <a-entity id="remote-player-0" position="-2 0 -2" visible="false">
        <a-sphere id="remote-target-0" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                  impact-effect="color: #ff0000"
                  class="grabbable-player"
                  data-player-id="player_0">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-0" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
        
        <!-- Remote player arm visualization -->
        <a-entity class="remote-left-hand" arm-ik-visualizer="hand: left">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
        
        <a-entity class="remote-right-hand" arm-ik-visualizer="hand: right">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
      </a-entity>

      <a-entity id="remote-player-1" position="2 0 -2" visible="false">
        <a-sphere id="remote-target-1" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #000000; emissiveIntensity: 0; transparent: true; opacity: 0.7"
                  position="0 0 0"
                   impact-effect="color: #ff0000"
                   class="grabbable-player"
                   data-player-id="player_1">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-1" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
        
        <!-- Remote player arm visualization -->
        <a-entity class="remote-left-hand" arm-ik-visualizer="hand: left">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
        
        <a-entity class="remote-right-hand" arm-ik-visualizer="hand: right">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
      </a-entity>

      <a-entity id="remote-player-2" position="-2 0 2" visible="false">
        <a-sphere id="remote-target-2" 
                  radius="0.2" 
                  color="#ff00ff" 
                  material="shader: standard; emissive: #ff00ff; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                   impact-effect="color: #ff00ff"
                   class="grabbable-player"
                   data-player-id="player_2">
          <a-entity light="type: point; color: #ff00ff; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-2" radius="0.1" color="#ff00ff" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
        
        <!-- Remote player arm visualization -->
        <a-entity class="remote-left-hand" arm-ik-visualizer="hand: left">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
        
        <a-entity class="remote-right-hand" arm-ik-visualizer="hand: right">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
      </a-entity>

      <a-entity id="remote-player-3" position="2 0 2" visible="false">
        <a-sphere id="remote-target-3" 
                  radius="0.2" 
                  color="#ffff00" 
                  material="shader: standard; emissive: #ffff00; emissiveIntensity: 0.5; transparent: true; opacity: 0.7"
                  position="0 0 0"
                   impact-effect="color: #ffff00"
                   class="grabbable-player"
                   data-player-id="player_3">
          <a-entity light="type: point; color: #ffff00; intensity: 1; distance: 3"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="remote-impact-3" radius="0.1" color="#ffff00" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
        
        <!-- Remote player arm visualization -->
        <a-entity class="remote-left-hand" arm-ik-visualizer="hand: left">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
        
        <a-entity class="remote-right-hand" arm-ik-visualizer="hand: right">
          <a-entity class="forearm-model" arm-segment-model="segmentLength: 0.25; segmentType: forearm" visible="true"></a-entity>
          <a-entity class="upperarm-model" arm-segment-model="segmentLength: 0.30; segmentType: upperarm" visible="true"></a-entity>
          <a-sphere class="elbow-indicator" radius="0.02" color="#ff0000" material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5" visible="true"></a-sphere>
        </a-entity>
      </a-entity>

      <!-- Zero-G Bot Red Team (for singleplayer) -->
      <a-entity id="zerog-bot-red" position="4 5.8 10" zerog-bot="enabled: true; difficulty: medium; team: red; throwInterval: 12000" visible="true">
        <a-sphere id="bot-target" 
                  radius="0.2" 
                  color="#ff0000" 
                  material="shader: standard; emissive: #ff0000; emissiveIntensity: 0.5; wireframe: false"
                  position="0 0 0"
                   impact-effect="color: #ff0000"
                   class="grabbable-player"
                   data-player-id="bot_red">
          <a-entity light="type: point; color: #ff0000; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-impact" radius="0.1" color="#ff0000" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Zero-G Bot Blue Team (for singleplayer) -->
      <a-entity id="zerog-bot-blue" position="0 5.8 14" zerog-bot="enabled: true; difficulty: medium; team: blue; throwInterval: 12000" visible="true">
        <a-sphere id="bot-blue-target" 
                  radius="0.2" 
                  color="#0000ff" 
                  material="shader: standard; emissive: #0000ff; emissiveIntensity: 0.5; wireframe: false"
                  position="0 0 0"
                   impact-effect="color: #0000ff"
                   class="grabbable-player"
                   data-player-id="bot_blue">
          <a-entity light="type: point; color: #0000ff; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-blue-impact" radius="0.1" color="#0000ff" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

      <!-- Zero-G Bot Green (additional bot for 4-player support) -->
      <a-entity id="zerog-bot-green" position="-2 5.8 10" zerog-bot="enabled: true; difficulty: medium; team: green; throwInterval: 12000" visible="true">
        <a-sphere id="bot-green-target" 
                   radius="0.2" 
                   color="#ff00ff" 
                   material="shader: standard; emissive: #ff00ff; emissiveIntensity: 0.5; wireframe: false"
                   position="0 0 0"
                   impact-effect="color: #ff00ff"
                   class="grabbable-player"
                   data-player-id="bot_green">
          <a-entity light="type: point; color: #ff00ff; intensity: 1; distance: 4"></a-entity>
          <!-- Impact sphere with animation component -->
          <a-sphere id="bot-green-impact" radius="0.1" color="#ff00ff" opacity="0" visible="false" material="side: double; transparent: true"
            animation__grow="property: radius; from: 0.1; to: 1.5; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;"
            animation__fade="property: material.opacity; from: 0.5; to: 0; dur: 1000; easing: easeOutQuad; startEvents: impact; dir: normal; autoplay: false;">
          </a-sphere>
        </a-sphere>
      </a-entity>

       <!-- SPACESHIP AT CENTER -->
       <a-entity id="model-spaceship" position="53.953 -3.604 46.634" 
                 scale="1.0 1.0 1.0"
                 rotation="0 45 0"
                 visible="false"
                 animation-mixer="clip: *; loop: once; clampWhenFinished: true"
                 door-proximity-trigger="triggerDistance: 2.0; doorObjects: Misc01005, Misc01006; animations: DoorOpen, DoorOpen.001; maxFrame: 120"
                 door-proximity-trigger-2="triggerDistance: 2.0; doorObjects: Misc01003, Misc01004; animations: Misc01.003Action, Misc01.004Action; maxFrame: 120"
                 door-proximity-trigger-3="triggerDistance: 2.0; doorObjects: Misc01001, Misc01002; animations: Misc01.001Action, Misc01.002Action; maxFrame: 120">
         <a-gltf-model src="#spaceship-model"></a-gltf-model>
       </a-entity>

        <!-- LEVEL MODEL - OPPOSITE SIDE FROM SPACESHIP -->
        <a-entity id="model-level" position="-10 5 10" 
                  scale="1.0 1.0 1.0"
                  rotation="0 225 0"
                  visible="true">
          <a-gltf-model src="#level-model"></a-gltf-model>
        </a-entity>

      
      <!-- Single Asteroid 250m Away -->
      <a-entity id="model-asteroid-42" position="250 0 0" 
                scale="1.2 1.2 1.2"
                grab-surface="type: static"
                visible="false">
        <a-gltf-model src="#asteroid-42-model"></a-gltf-model>
      </a-entity>
      
      

      <!-- Add game manager entity with score display -->
      <a-entity id="game-manager" game-manager>
        <!-- Version display moved closer to top -->
        <!--<a-entity id="version-display-override" position="0 7 0" text="value: Zero-G v1.0; align: center; width: 0.5; color: #ffffff"></a-entity>
        
        <a-entity id="score-display" position="0 6.5 0">
          <a-entity position="-0.8 0.3 0" text="value: KILLS; align: center; width: 2; color: #00ff00"></a-entity>
          <a-entity id="blue-score" position="-0.8 0 0" text="value: 0; align: center; width: 4; color: #00ff00"></a-entity>
          
          <a-entity position="0 0 0" text="value: |; align: center; width: 4; color: #ffffff"></a-entity>
          
          <a-entity position="0.8 0.3 0" text="value: DEATHS; align: center; width: 2; color: #ff0000"></a-entity>
          <a-entity id="red-score" position="0.8 0 0" text="value: 0; align: center; width: 4; color: #ff0000"></a-entity>
        </a-entity>
        
        <a-entity id="timer-display" position="0 6 0" text="value: Time: 3:00; align: center; width: 2; color: #ffff00"></a-entity>
        <a-entity id="start-message" position="0 5.5 0" text="value: Press X to open menu; align: center; width: 2; color: #ffffff"></a-entity>-->
      </a-entity>

      <!-- Ambient space lighting -->
      <a-entity light="type: ambient; color: #404040; intensity: 0.75"></a-entity>
      
      <!-- Directional light simulating distant star -->
      <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="5 5 5"></a-entity>

      <!-- Add impact sound entities -->
      <a-entity id="impact-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 2;">
      </a-entity>

      <!-- Add bounce sound entity -->
      <a-entity id="bounce-sound" sound="src: url(audio/impact-cinematic-boom-5-352465.mp3); 
                                        autoplay: false; 
                                        loop: false; 
                                        volume: 0.7;
                                        positional: true;
                                        distanceModel: linear;
                                        refDistance: 1;
                                        maxDistance: 20;
                                        poolSize: 8;
                                        rate: 1.5;">
      </a-entity>

      <!-- Add laser sound entity -->
      <a-entity id="laser-sound" sound="src: url(audio/laser-45816.mp3); 
                                         autoplay: false; 
                                         loop: false; 
                                         volume: 0.8;
                                         positional: true;
                                         distanceModel: linear;
                                         refDistance: 1;
                                         maxDistance: 15;
                                         poolSize: 50;">
      </a-entity>

      <!-- Add electric hum sound entity -->
      <a-entity id="electric-hum-sound" sound="src: url(audio/electric-hum.wav); 
                                               autoplay: false; 
                                               loop: false; 
                                               volume: 0.8;
                                               positional: true;
                                               distanceModel: linear;
                                               refDistance: 1;
                                               maxDistance: 15;
                                               poolSize: 10;">
      </a-entity>

      <!-- Add metal hit sound entities -->
      <a-entity id="metal-hit-sound-1" sound="src: url(audio/metal-hit-92-200420.mp3); 
                                               autoplay: false; 
                                               loop: false; 
                                               volume: 0.1;
                                               positional: true;
                                               distanceModel: linear;
                                               refDistance: 1;
                                               maxDistance: 20;
                                               poolSize: 5;">
      </a-entity>
      <a-entity id="metal-hit-sound-2" sound="src: url(audio/metal-hit-94-200422.mp3); 
                                               autoplay: false; 
                                               loop: false; 
                                               volume: 0.1;
                                               positional: true;
                                               distanceModel: linear;
                                               refDistance: 1;
                                               maxDistance: 20;
                                               poolSize: 5;">
      </a-entity>
      <a-entity id="metal-hit-sound-3" sound="src: url(audio/metal-hit-95-200424.mp3); 
                                               autoplay: false; 
                                               loop: false; 
                                               volume: 0.1;
                                               positional: true;
                                               distanceModel: linear;
                                               refDistance: 1;
                                               maxDistance: 20;
                                               poolSize: 5;">
      </a-entity>

      <!-- Goal sound entity -->
      <a-entity id="goal-sound" sound="src: url(audio/sound-design-elements-impact-sfx-ps-084-353199.mp3); 
                                      autoplay: false; 
                                      loop: false; 
                                      volume: 1.0;
                                      positional: false;
                                      poolSize: 2;">
      </a-entity>

       <!-- Nebula Skybox -->
       <a-sky src="#nebula-texture"></a-sky>
    </a-scene>
    
    <script>
      

      
      // Test function to force send position data
      function testPositionSync() {
        // Testing position sync
        if (isMultiplayer && activePlayers.size > 1) {
          const camera = document.querySelector('[camera]');
          if (camera) {
            const worldPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(worldPos);
            const worldQuat = new THREE.Quaternion();
            camera.object3D.getWorldQuaternion(worldQuat);
            const worldRot = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');
            const playerState = {
              x: worldPos.x, y: worldPos.y, z: worldPos.z,
              rx: worldRot.x, ry: worldRot.y, rz: worldRot.z
            };
            sendPlayerState(playerState);
          }
        } else {
          // Not in multiplayer
        }
      }
      
      // Test function to check connection status
      function testConnection() {
        // Testing connection status
        
        if (isHost) {
        } else {
          const hostID = `dodgevr-host-${multiplayerStartType}-${selectedLobby}`;
        }
        
        // Force send test data
        if (isMultiplayer && activePlayers.size > 1) {
          const camera = document.querySelector('[camera]');
          if (camera) {
            const worldPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(worldPos);
            const playerState = {
              x: worldPos.x, y: worldPos.y, z: worldPos.z,
              rx: 0, ry: 0, rz: 0
            };
            sendPlayerState(playerState);
          }
        }
      }
      
      // Multiplayer state synchronization functions
      let remotePlayerStates = new Map();
      let remoteBallStates = new Map();
      
      function sendPlayerState(state) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        // CRITICAL FIX: Don't send if myPlayerId is invalid
        if (!myPlayerId || typeof myPlayerId !== 'string') {
          console.warn('❌ Cannot send player state - invalid myPlayerId:', myPlayerId);
          return;
        }
        
        const data = {
          type: 'player-state',
          state: state,
          playerId: myPlayerId
        };
        
        // Only log if there are connections to send to (throttled to once per 30 seconds)
        if (connections.size > 0) {
          if (!this.lastPlayerStateLog || Date.now() - this.lastPlayerStateLog > 30000) {
            this.lastPlayerStateLog = Date.now();
          }
        }
        
        // Send to all OTHER players (not to self)
        connections.forEach((conn, playerId) => {
          if (conn && conn.open && playerId !== myPlayerId) {
            conn.send(data);
          }
        });
      }
      
      // Game mode update function removed - space shooter is always dodgeball
      
      function sendBotState(botState) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
              
              const data = {
          type: 'bot-state',
          botState: botState,
                playerId: myPlayerId
              };
              
        // Send to all OTHER players (not to self)
              connections.forEach((conn, playerId) => {
          if (conn && conn.open && playerId !== myPlayerId) {
                  conn.send(data);
                }
              });
      }
      
      // Team assignment and goal functions removed - not used in space shooter

      function sendHitEffect(targetPlayerId) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const hitData = {
          type: 'hit-effect',
          targetPlayerId: targetPlayerId,
          shooterPlayerId: myPlayerId, // CRITICAL: Include who did the shooting
          timestamp: Date.now()
        };
        

        
        // Send to all connected players
        if (isHost) {
          connections.forEach(conn => {
            if (conn.open) {
              conn.send(hitData);
            }
          });
        } else {
          // Client sends to host, who will broadcast to all
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(hitData);
          }
        }
      }
      
      function sendDamageEffect(position, targetPlayerId) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        console.log('💥 Sending damage effect:', {
          targetPlayerId: targetPlayerId,
          shooterPlayerId: myPlayerId,
          position: position,
          isHost: isHost
        });
        
        const damageData = {
          type: 'damage-effect',
          position: { x: position.x, y: position.y, z: position.z },
          targetPlayerId: targetPlayerId,
          shooterPlayerId: myPlayerId,
          timestamp: Date.now()
        };
        
        // Send to all connected players
        if (isHost) {
          console.log('💥 Host sending damage effect to all clients');
          connections.forEach(conn => {
            if (conn.open) {
              conn.send(damageData);
            }
          });
        } else {
          // Client sends to host, who will broadcast to all
          console.log('💥 Client sending damage effect to host');
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(damageData);
          }
        }
      }
      
      function sendExplosionEffect(targetSelector, targetPlayerId) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const explosionData = {
          type: 'explosion-effect',
          targetSelector: targetSelector,
          targetPlayerId: targetPlayerId,
          shooterPlayerId: myPlayerId,
          timestamp: Date.now()
        };
        
        console.log('💥 Sending explosion effect:', explosionData);
        
        // Send to all connected players
        if (isHost) {
          connections.forEach(conn => {
            if (conn.open) {
              conn.send(explosionData);
            }
          });
        } else {
          // Client sends to host, who will broadcast to all
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(explosionData);
          }
        }
      }
      
      function sendHitSound(position, soundSelector, targetPlayerId) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const soundData = {
          type: 'hit-sound',
          position: { x: position.x, y: position.y, z: position.z },
          soundSelector: soundSelector,
          targetPlayerId: targetPlayerId,
          shooterPlayerId: myPlayerId,
          timestamp: Date.now()
        };
        
        // Send to all connected players
        if (isHost) {
          connections.forEach(conn => {
            if (conn.open) {
              conn.send(soundData);
            }
          });
        } else {
          // Client sends to host, who will broadcast to all
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(soundData);
          }
        }
      }
      
      function sendBotDamageState(botSelector, hitCount, isDead, respawn, position) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const botDamageData = {
          type: 'bot-damage-state',
          botSelector: botSelector,
          hitCount: hitCount,
          isDead: isDead,
          respawn: respawn,
          position: position ? { x: position.x, y: position.y, z: position.z } : null,
          timestamp: Date.now()
        };
        
        // Send to all connected players
        if (isHost) {
          connections.forEach(conn => {
            if (conn.open) {
              conn.send(botDamageData);
            }
          });
        } else {
          // Client sends to host, who will broadcast to all
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(botDamageData);
          }
        }
      }

      function handleHitEffect(data) {
        if (!data.targetPlayerId) return;
        
        const targetPlayerId = data.targetPlayerId;
        const shooterPlayerId = data.shooterPlayerId;
        const playerIndex = parseInt(targetPlayerId.split('_')[1]);
        
        // CRITICAL FIX: Host handles scoring when receiving hit effects
        if (isHost && shooterPlayerId && targetPlayerId.startsWith('bot-')) {
          // A player hit a bot - update the shooter's score
          const gameManager = document.querySelector('#game-manager');
          if (gameManager && gameManager.components['game-manager']) {
            const shooterIndex = parseInt(shooterPlayerId.split('_')[1]);
            gameManager.components['game-manager'].playerStats[shooterIndex].kills += 1;
            gameManager.components['game-manager'].playerScores[shooterIndex] = gameManager.components['game-manager'].playerStats[shooterIndex].kills;
            gameManager.components['game-manager'].updateMultiplayerScore();
            gameManager.components['game-manager'].sendScoreUpdate();
          }
        }
        
        // DON'T play explosion effects for individual hits anymore
        // The bullet/missile damage systems (player-damage, zerog-bot) handle all hit effects and sounds
        // This function is only used for scoring purposes now
      }

      function sendDoorAnimation(animationType, doorEntityId) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        const doorData = {
          type: 'door-animation',
          animationType: animationType, // 'open' or 'close'
          doorEntityId: doorEntityId,
          playerId: myPlayerId,
          timestamp: Date.now()
        };
        
        // Send to host if client, or to all clients if host
        if (isHost) {
          // Host broadcasts to all clients
          connections.forEach((conn, playerId) => {
            if (conn && conn.open && playerId !== myPlayerId) {
              conn.send(doorData);
            }
          });
        } else {
          // Client sends to host
          const hostConnection = connections.get('host');
          if (hostConnection && hostConnection.open) {
            hostConnection.send(doorData);
          }
        }
      }
      
      function sendBallState(ballState) {
        if (!isMultiplayer || activePlayers.size <= 1) return;
        
        // CRITICAL: Don't send ball state if this ball is being controlled locally
        const ballNumber = ballState.playerId;
        const currentPlayerIndex = myPlayerId ? parseInt(myPlayerId.split('_')[1]) : -1;
        const currentPlayerBallNumber = getBallForPlayer(myPlayerId || 'player_0'); // Use dynamic ball assignment
        
        // CRITICAL FIX: Always send ball state for our own ball - other players need to see it!
        // The receiving end (handleBallState) will decide whether to apply the update or not
        
        // CRITICAL FIX: For bot balls, use the bot's ball ID, not the host's player ID
        let senderPlayerId = myPlayerId;
        if (typeof ballState.playerId === 'number' && ballState.playerId >= 1 && ballState.playerId <= 4) {
          // This is a bot ball (player1, player2, player3, player4)
          senderPlayerId = `bot-player${ballState.playerId}`;
        } else if (ballState.playerId === 'capture') {
          // This is the capture ball
          senderPlayerId = myPlayerId; // Host controls capture ball
        }
        
        const data = {
          type: 'ball-state',
          ballState: ballState,
          playerId: senderPlayerId
        };
        
        // Only log if there are connections to send to (throttled to once per 30 seconds)
        if (connections.size > 0) {
          if (!this.lastBallStateLog || Date.now() - this.lastBallStateLog > 30000) {
            this.lastBallStateLog = Date.now();
          }
        }
        
        // Send to all connections with error handling
        connections.forEach((conn, playerId) => {
          if (conn && conn.open) {
            try {
            conn.send(data);
            } catch (error) {
              console.warn('Failed to send ball state to', playerId, ':', error);
              // Remove failed connection
              connections.delete(playerId);
            }
          }
        });
      }

      // Initialize multiplayer system when page loads (moved inside initializeApp)
      // This is now handled inside initializeApp function
      // Function to manage active players and bots
      function manageActivePlayersAndBots() {
        const humanPlayerCount = isMultiplayer ? activePlayers.size : 1;
        const maxPlayers = 4; // Always 4 players total in both modes
        const botsNeeded = Math.max(0, maxPlayers - humanPlayerCount); // Aim for 4 total players
        
        // Get bot entities
        const redBot = document.querySelector('#zerog-bot-red');
        const blueBot = document.querySelector('#zerog-bot-blue');
        const greenBot = document.querySelector('#zerog-bot-green');
        
        const bots = [redBot, blueBot, greenBot].filter(bot => bot); // Filter out null bots
        
        // Check if bots are manually disabled via toggle (using reliable data attribute)
        const botToggleButton = document.querySelector('#menu-toggle-bots');
        const isManuallyDisabled = botToggleButton && 
          botToggleButton.hasAttribute('data-bots-manually-disabled');
        
        // Enable/disable bots based on need, but respect manual toggle
        bots.forEach((bot, index) => {
          const shouldEnable = index < botsNeeded && !isManuallyDisabled;
          if (bot) {
            // Only set visibility and enabled if not manually disabled
            if (!isManuallyDisabled) {
            bot.setAttribute('visible', shouldEnable);
            if (bot.components['zerog-bot']) {
              bot.setAttribute('zerog-bot', 'enabled', shouldEnable);
              }
            } else {
              // When manually disabled, force both visible and enabled to false
              bot.setAttribute('visible', false);
              if (bot.components['zerog-bot']) {
                bot.setAttribute('zerog-bot', 'enabled', false);
              }
            }
          }
        });
        
        // Manage ball visibility
        manageBallVisibility();
        
        const actualBots = Math.min(botsNeeded, 3); // Now we have 3 bots available
        const totalPlayers = humanPlayerCount + actualBots;
      }

      // Function to manage ball visibility based on active players
      function manageBallVisibility() {
        const humanPlayerCount = isMultiplayer ? activePlayers.size : 1;
        
        // Always show capture ball in capture mode
        const captureBall = document.querySelector('#capture-ball');
        if (captureBall) {
          captureBall.setAttribute('visible', gameMode === 'capture');
        }
        
        // Show all player balls
        for (let i = 1; i <= 4; i++) {
          const ball = document.querySelector(`[zerog-ball*="player: player${i}"]`);
          if (ball) {
            ball.setAttribute('visible', true);
          }
        }
      }

      
      // Global debugging functions for shield sync
      window.forceShieldSync = function() {
        console.log('🔧 MANUAL: Force syncing all shields...');
        const shields = document.querySelectorAll('[ball-shield]');
        shields.forEach(shield => {
          const shieldComponent = shield.components['ball-shield'];
          if (shieldComponent && shieldComponent.forceShieldSync) {
            shieldComponent.forceShieldSync();
          }
        });
      };
      
      // Generate procedural noise textures for asteroids (optimized for normal maps)
      function generateNoiseTexture(canvasId, seed = 0) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(256, 256);
        const data = imageData.data;
        
        // Enhanced noise generation for better normal map detail
        for (let y = 0; y < 256; y++) {
          for (let x = 0; x < 256; x++) {
            const index = (y * 256 + x) * 4;
            
            // Multi-octave noise with crater-like patterns
            let noise = 0;
            let amplitude = 1;
            let frequency = 0.008;
            
            for (let octave = 0; octave < 5; octave++) {
              // Create more crater-like patterns
              const nx = (x + seed * 137) * frequency;
              const ny = (y + seed * 73) * frequency;
              
              // Combine sine/cosine with some turbulence
              let octaveNoise = Math.sin(nx) * Math.cos(ny);
              octaveNoise += Math.sin(nx * 2.1) * Math.cos(ny * 2.3) * 0.5;
              
              noise += amplitude * octaveNoise;
              amplitude *= 0.6;
              frequency *= 1.8;
            }
            
            // Add some sharp crater-like features
            const craterX = (x + seed * 200) * 0.02;
            const craterY = (y + seed * 150) * 0.02;
            const craterNoise = Math.pow(Math.sin(craterX) * Math.cos(craterY), 3) * 0.4;
            noise += craterNoise;
            
            // Add fine random detail
            noise += (Math.random() - 0.5) * 0.2;
            
            // Normalize to 0-255 range with better contrast
            const value = Math.max(0, Math.min(255, (noise + 1.2) * 100));
            
            data[index] = value;     // R
            data[index + 1] = value; // G  
            data[index + 2] = value; // B
            data[index + 3] = 255;   // A
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      window.debugShieldStates = function() {
        console.log('🔍 SHIELD DEBUG: Current shield states...');
        const shields = document.querySelectorAll('[ball-shield]');
        shields.forEach(shield => {
          const shieldComponent = shield.components['ball-shield'];
          const ballComponent = shield.parentElement?.components?.['zerog-ball'];
          if (shieldComponent && ballComponent) {
            const mask = ballComponent.body?.collisionFilterMask;
            const hasCollision = (mask & 2) !== 0;
            const visible = shield.getAttribute('visible');
            console.log(`🔍 ${ballComponent.data.player}: visual=${shieldComponent.isActive}, grabbed=${ballComponent.isGrabbed}, cooldown=${shieldComponent.isOnCooldown}, mask=${mask}, collision=${hasCollision}, visible=${visible}`);
          }
        });
      };
      
      window.testShieldCollision = function() {
        console.log('🧪 TEST: Forcing collision mask updates for all balls...');
        const balls = document.querySelectorAll('[zerog-ball]');
        balls.forEach(ball => {
          const ballComponent = ball.components['zerog-ball'];
          if (ballComponent && ballComponent.updateCollisionMask) {
            ballComponent.updateCollisionMask();
          }
        });
      };
      
    </script>
  </body>
</html> 


