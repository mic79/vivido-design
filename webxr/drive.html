<!DOCTYPE html>
<html>
<head>
    <title>WebXR Multiplayer Driving Game</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }

        #speedometer {
            color: #ffffff;
            background-color: #990000;
            position: absolute;
            bottom: 0px;
            padding: 5px;
            z-index: 1000;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
            z-index: 1000;
        }

        #vrButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: #333;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
            font-size: 14px;
        }

        a {
            color: #a06851;
        }

        /* Desktop HUD Styles */
        #desktopHUD {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            min-width: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        #desktopHUD .hud-line {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        #desktopHUD .hud-label {
            color: #aaa;
            margin-right: 15px;
        }
        
        #desktopHUD .hud-value {
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
            /* Hide desktop HUD in VR */
            .vr-mode #desktopHUD {
                display: none;
            }

            /* Version and FPS Display */
            #versionDisplay {
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 14px;
                font-weight: bold;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            /* Multiplayer Status Display */
            #multiplayerStatus {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 14px;
                font-weight: bold;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            /* Game Menu Styles */
            #gameMenu {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 2000;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .menu-background {
                background: rgba(20, 20, 20, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 12px;
                padding: 30px;
                min-width: 400px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            }

            .menu-content h2 {
                color: white;
                text-align: center;
                margin: 0 0 20px 0;
                font-size: 24px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            .menu-section {
                margin: 15px 0;
                text-align: center;
            }

            #currentModeDisplay {
                color: #00ff88;
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 15px;
            }

            .menu-button {
                background: linear-gradient(145deg, #333, #555);
                color: white;
                border: 2px solid #666;
                border-radius: 6px;
                padding: 10px 20px;
                margin: 5px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
            }

            .menu-button:hover {
                background: linear-gradient(145deg, #555, #777);
                border-color: #888;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            .menu-button.active {
                background: linear-gradient(145deg, #0066cc, #0088ff);
                border-color: #00aaff;
                box-shadow: 0 0 10px rgba(0, 136, 255, 0.5);
            }

            .lobby-controls {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin: 10px 0;
                color: white;
                font-weight: bold;
            }

            .lobby-btn {
                background: #444;
                color: white;
                border: 1px solid #666;
                border-radius: 4px;
                padding: 5px 10px;
                cursor: pointer;
                font-weight: bold;
            }

            .lobby-btn:hover {
                background: #666;
            }

            .bot-controls {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                color: white;
                font-weight: bold;
            }

            #botStatus {
                font-size: 12px;
                color: #aaa;
                font-style: italic;
            }

            /* Menu available in both desktop and VR modes */
            /* .vr-mode #gameMenu {
                display: none;
            } */
    </style>
</head>

<body>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>
    <div id="speedometer">0.0 km/h</div>
    
    <!-- Desktop HUD for non-VR users -->
    <div id="desktopHUD">
        <div class="hud-line">
            <span class="hud-label">LAP:</span>
            <span class="hud-value" id="desktopLapNumber">1</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">TIME:</span>
            <span class="hud-value" id="desktopCurrentTime">0:00.000</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">BEST:</span>
            <span class="hud-value" id="desktopBestTime">--:--.---</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">CHECKPOINT:</span>
            <span class="hud-value" id="desktopCheckpoint">0/0</span>
        </div>
    </div>

    <!-- Version and FPS Display -->
    <div id="versionDisplay">
        <span id="versionText">WebXR Drive v1.0</span> | <span id="fpsText">0 FPS</span>
    </div>

    <!-- Multiplayer Status Display -->
    <div id="multiplayerStatus">
        <span id="statusText">Disconnected</span>
    </div>

    <!-- Game Menu (initially hidden) -->
    <div id="gameMenu" style="display: none;">
        <div class="menu-background">
            <div class="menu-content">
                <h2>WEBXR DRIVE MENU</h2>
                
                <!-- Current mode display -->
                <div class="menu-section">
                    <div id="currentModeDisplay">Mode: Singleplayer</div>
                </div>
                
                <!-- Single/Multi buttons -->
                <div class="menu-section">
                    <button id="singleplayerBtn" class="menu-button active">SINGLE</button>
                    <button id="multiplayerBtn" class="menu-button">MULTI</button>
                </div>
                
                <!-- Lobby section (hidden by default) -->
                <div id="lobbySection" class="menu-section" style="display: none;">
                    <div class="lobby-controls">
                        <span>Lobby:</span>
                        <button id="lobbyMinus" class="lobby-btn">-</button>
                        <span id="lobbyNumber">1</span>
                        <button id="lobbyPlus" class="lobby-btn">+</button>
                    </div>
                    <button id="connectBtn" class="menu-button">CONNECT</button>
                    <button id="autoConnectBtn" class="menu-button">AUTO CONNECT</button>
                </div>
                
                <!-- Bot toggle section -->
                <div class="menu-section">
                    <div class="bot-controls">
                        <span>Bot:</span>
                        <button id="botToggle" class="menu-button active">ON</button>
                        <span id="botStatus">(Available in Single & Host)</span>
                    </div>
                </div>
                
                <!-- Close button -->
                <div class="menu-section">
                    <button id="closeMenuBtn" class="menu-button">CLOSE</button>
                </div>
            </div>
        </div>
    </div>
    <div id="info">WebXR Multiplayer Driving Game<br>WASD/VR Controllers to drive<br>B = Menu, C = Camera, Y = Reset</div>
    <button id="vrButton" style="display: none;">Enter VR</button>
    
    <!-- Background Music -->
    <audio id="backgroundMusic" loop preload="auto">
        <source src="audio/machina-tobias-voigt-main-version-19314-02-39.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://kripken.github.io/ammo.js/builds/ammo.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/Detector.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/OrbitControls.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/stats.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
        Ammo().then(function (Ammo) {

            // ========== MULTIPLAYER STATE VARIABLES ==========
            let isMultiplayer = false;
            let isHost = false;
            let peer = null;
            let connections = new Map(); // Map of playerId -> connection
            let connectionToPlayer = new Map(); // Map of connection -> playerId
            let activePlayers = new Map(); // Map of playerId -> player data
            let remoteCars = new Map(); // Map of playerId -> remote car mesh
            let playerCarSlots = []; // Array of 4 pre-created player cars
            let playerSlotAssignments = new Map(); // Map of playerId -> slot index
            let myPlayerId = null;
            let sessionID = null;
            let selectedLobby = 1;
            let MAX_LOBBIES = 10;
            let multiplayerStartType = 'webxr-drive';
            let connectionState = 'disconnected';
            let multiplayerStatus = 'Disconnected';
            let vrAudioStarted = false;
            
            // Bot control variables
            let botEnabled = true; // Bot is enabled by default
            
            // Menu state
            let isMenuVisible = false;
            let vrMenu = null;
            let vrMenuButtons = [];
            let vrMenuRaycaster = null;
            let vrMenuPointer = null;
            
            // VR Controllers
            let vrControllers = [];
            let vrControllerModels = [];
            let vrLaserPointers = [];
            
            // App version and FPS
            const APP_VERSION = 'WebXR Drive v1.0';
            let currentFPS = 0;
            let frameCount = 0;
            let lastFPSTime = performance.now();
            let fpsHistory = [];
            let lastFPSUpdate = 0;

            // Detects webgl
            if (!Detector.webgl) {
                Detector.addGetWebGLMessage();
                document.getElementById('container').innerHTML = "";
            }

            // - Global variables -
            var DISABLE_DEACTIVATION = 4;
            var TRANSFORM_AUX = new Ammo.btTransform();
            var ZERO_QUATERNION = new THREE.Quaternion(0, 0, 0, 1);

            // Graphics variables
            var container, stats, speedometer;
            var camera, controls, scene, renderer;
            var clock = new THREE.Clock();
            var materialDynamic, materialStatic, materialInteractive;

            // Physics variables
            var collisionConfiguration;
            var dispatcher;
            var broadphase;
            var solver;
            var physicsWorld;

            var syncList = [];
            var time = 0;
            var vehicleRef = null; // For reset functionality
            var raycastLines = []; // Visual debug lines for raycasting
            
            // Checkpoint system
            var playerCurrentCheckpoint = 1; // Next checkpoint to reach (1-based)
            var playerLastPassedCheckpoint = 0; // Last checkpoint passed (0-based)
            var nextCheckpointMarker = null;
            var checkpointMarkers = [];
            
            // Lap timing system
            var currentLapNumber = 1;
            var currentLapStartTime = 0;
            var currentLapTime = 0;
            var bestLapTime = null;
            var lapTimes = [];
            
            // LocalStorage key for best time
            var BEST_TIME_KEY = 'webxr-drive-best-time';
            
            // LOCALSTORAGE FUNCTIONS: Save and load best time
            function loadBestTime() {
                try {
                    var savedTime = localStorage.getItem(BEST_TIME_KEY);
                    if (savedTime !== null) {
                        bestLapTime = parseFloat(savedTime);
                        console.log('💾 Loaded best time from storage:', formatLapTime(bestLapTime));
                        return bestLapTime;
                    }
                } catch (error) {
                    console.warn('Failed to load best time from localStorage:', error);
                }
                return null;
            }
            
            function saveBestTime(time) {
                try {
                    localStorage.setItem(BEST_TIME_KEY, time.toString());
                    console.log('💾 Saved new best time to storage:', formatLapTime(time));
                } catch (error) {
                    console.warn('Failed to save best time to localStorage:', error);
                }
            }
            
            function clearBestTime() {
                try {
                    localStorage.removeItem(BEST_TIME_KEY);
                    bestLapTime = null;
                    console.log('🗑️ Cleared best time from storage');
                } catch (error) {
                    console.warn('Failed to clear best time from localStorage:', error);
                }
            }
            
            function formatLapTime(seconds) {
                if (seconds === null || seconds === undefined) return '--:--.---';
                var minutes = Math.floor(seconds / 60);
                var secs = (seconds % 60).toFixed(3);
                return minutes + ':' + (secs < 10 ? '0' : '') + secs;
            }
            
            // VR HUD elements
            var vrHUD = null;
            var lapNumberText = null;
            var currentTimeText = null;
            var bestTimeText = null;
            
            // Engine sound system
            var audioContext = null;
            var playerEngineSound = null;
            var botEngineSound = null;
            var backgroundMusic = null;
            
            // Road and path system
            var racingPath = null;
            var roadMesh = null;
            var roadPhysicsBody = null; // Physics body for the road surface
            var pathPoints = [];
            var denseWaypoints = []; // Dense waypoints every 1-2m for bot navigation
            
            // Bot car system
            var botCar = null;
            var botVehicleRef = null;
            var botTargetMarker = null; // Visual marker for bot's current target

            // Keyboard actions
            var actions = {};
            var keysActions = {
                "KeyW": 'acceleration',
                "KeyS": 'braking',
                "KeyA": 'left',
                "KeyD": 'right'
            };

            // Camera modes
            var cameraMode = 'firstperson'; // Start in first person for VR
            var firstPersonCamera = null;
            var orbitCamera = null;
            var cameraRig = null; // Container for VR camera positioning
            
            // VR fly camera variables
            var vrFlySpeed = 10; // meters per second
            var vrFlyPosition = new THREE.Vector3(0, 5, -20); // Starting fly position
            var vrFlyRotation = new THREE.Euler(0, 0, 0); // Camera rotation in fly mode

            // - Functions -

            function initGraphics() {

                container = document.getElementById('container');
                speedometer = document.getElementById('speedometer');

                scene = new THREE.Scene();

                // Create camera rig for VR positioning
                cameraRig = new THREE.Group();
                scene.add(cameraRig);

                // Orbit camera (backup)
                orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
                orbitCamera.position.x = -4.84;
                orbitCamera.position.y = 4.39;
                orbitCamera.position.z = -35.11;
                orbitCamera.lookAt(new THREE.Vector3(0.33, -0.40, 0.85));
                
                // First person camera
                firstPersonCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Add first person camera to the rig for VR
                cameraRig.add(firstPersonCamera);
                
                // Start with first person camera for VR
                camera = firstPersonCamera;
                controls = new THREE.OrbitControls(orbitCamera);
                controls.enabled = false; // Disabled by default

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setClearColor(0xbfd1e5);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Enable WebXR
                renderer.xr.enabled = true;

                var ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(10, 10, 5);
                scene.add(dirLight);

                materialDynamic = new THREE.MeshPhongMaterial({ color: 0xfca400 });
                materialStatic = new THREE.MeshPhongMaterial({ color: 0x999999 });
                materialInteractive = new THREE.MeshPhongMaterial({ color: 0x990000 });

                container.innerHTML = "";
                container.appendChild(renderer.domElement);

                // VR Button setup
                setupVRButton();

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = '1000';
                container.appendChild(stats.domElement);

                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', keydown);
                window.addEventListener('keyup', keyup);
            }

            function setupVRButton() {
                const vrButton = document.getElementById('vrButton');
                
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            vrButton.style.display = 'block';
                            vrButton.style.background = '#006600';
                            console.log('VR supported');
                        }
                    });
                }
                
                vrButton.addEventListener('click', async () => {
                    if (renderer.xr.isPresenting) {
                        renderer.xr.getSession().end();
                    } else {
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', {
                                optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                            });
                            renderer.xr.setSession(session);
                            console.log('VR session started');
                            // Set up VR HUD when VR starts
                            setupVRHUD();
                            // Set up VR controllers
                            setupVRControllers();
                            // Hide desktop HUD in VR mode
                            document.body.classList.add('vr-mode');
                            
                            // Start audio in VR session (VR counts as user interaction)
                            // Add a small delay to ensure audio system is ready
                            setTimeout(() => {
                                startEngineAudio();
                                console.log('🎵 VR audio started');
                            }, 100);
                            
                            // Listen for VR session end to restore desktop HUD
                            session.addEventListener('end', () => {
                                console.log('VR session ended');
                                document.body.classList.remove('vr-mode');
                                vrAudioStarted = false; // Reset for next VR session
                            });
                        } catch (error) {
                            console.error('VR not supported:', error);
                        }
                    }
                });
            }

            function onWindowResize() {
                // Update both cameras
                orbitCamera.aspect = window.innerWidth / window.innerHeight;
                orbitCamera.updateProjectionMatrix();
                
                firstPersonCamera.aspect = window.innerWidth / window.innerHeight;
                firstPersonCamera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function initPhysics() {
                // Physics configuration
                collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                broadphase = new Ammo.btDbvtBroadphase();
                solver = new Ammo.btSequentialImpulseConstraintSolver();
                physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0));
            }

            // FPS counter function
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastFPSUpdate >= 500) { // Update every 500ms
                    const deltaTime = currentTime - lastFPSTime;
                    const fps = Math.round((frameCount * 1000) / deltaTime);
                    
                    fpsHistory.push(fps);
                    if (fpsHistory.length > 5) {
                        fpsHistory.shift();
                    }
                    
                    const avgFPS = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
                    currentFPS = avgFPS;
                    
                    // Update version display
                    const versionText = document.getElementById('versionText');
                    const fpsText = document.getElementById('fpsText');
                    if (versionText) versionText.textContent = APP_VERSION;
                    if (fpsText) fpsText.textContent = currentFPS + ' FPS';
                    
                    frameCount = 0;
                    lastFPSTime = currentTime;
                    lastFPSUpdate = currentTime;
                }
            }

            function tick() {
                // Add player car slots interpolation to sync list (only once)
                if (!this.playerCarSlotsSyncAdded) {
                    syncList.push(updatePlayerCarSlotsInterpolation);
                    this.playerCarSlotsSyncAdded = true;
                    console.log('🔄 Added player car slots interpolation to sync list');
                }
                
                // Use WebXR-compatible animation loop
                renderer.setAnimationLoop(() => {
                    var dt = clock.getDelta();
                    for (var i = 0; i < syncList.length; i++)
                        syncList[i](dt);
                    physicsWorld.stepSimulation(dt, 10);
                    
                    // Only update orbit controls when in orbit mode
                    if (cameraMode === 'orbit') {
                        controls.update(dt);
                    }
                    
                    // Update FPS counter
                    updateFPS();
                    
                    renderer.render(scene, camera);
                    time += dt;
                    stats.update();
                });
            }

            function keyup(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = false;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }
            
            function keydown(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = true;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Menu toggle with 'B' key (like in DodgeVR)
                if (e.code === 'KeyB') {
                    toggleMenu();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Camera switching with 'C' key
                if (e.code === 'KeyC') {
                    switchCamera();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Reset car with 'Y' key
                if (e.code === 'KeyY') {
                    resetCar();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }
            
            function setupVRControllers() {
                console.log('Setting up VR controllers...');
                
                // Create controllers using proper WebXR approach
                for (let i = 0; i < 2; i++) {
                    // Controller for input events (invisible)
                    const controller = renderer.xr.getController(i);
                    controller.userData.controllerIndex = i; // Store controller index
                    controller.addEventListener('selectstart', onSelectStart);
                    controller.addEventListener('selectend', onSelectEnd);
                    controller.addEventListener('connected', function(event) {
                        console.log('Controller', i, 'connected:', event.data);
                        this.add(buildController(event.data));
                    });
                    controller.addEventListener('disconnected', function() {
                        console.log('Controller', i, 'disconnected');
                        this.remove(this.children[0]);
                    });
                    cameraRig.add(controller); // Add to cameraRig instead of scene
                    vrControllers.push(controller);
                    
                    // Controller grip for 3D model (visible)
                    const controllerGrip = renderer.xr.getControllerGrip(i);
                    controllerGrip.addEventListener('connected', function(event) {
                        console.log('Controller grip', i, 'connected');
                        const mesh = buildControllerModel(event.data);
                        this.add(mesh);
                    });
                    controllerGrip.addEventListener('disconnected', function() {
                        console.log('Controller grip', i, 'disconnected');
                        this.remove(this.children[0]);
                    });
                    cameraRig.add(controllerGrip); // Add to cameraRig instead of scene
                    vrControllerModels.push(controllerGrip);
                    
                    console.log(`VR Controller ${i} set up`);
                }
                
                // Add debug spheres at controller positions (always visible)
                addDebugControllerSpheres();
                
                // Add test spheres to scene for debugging
                addTestSpheres();
            }
            
            function addDebugControllerSpheres() {
                // Add always-visible debug spheres to track controller positions
                for (let i = 0; i < 2; i++) {
                    // Large, bright debug sphere
                    const debugGeometry = new THREE.SphereGeometry(0.05);
                    const debugMaterial = new THREE.MeshBasicMaterial({ 
                        color: i === 0 ? 0xff0000 : 0x00ff00, // Red for controller 0, green for controller 1
                        transparent: false,
                        opacity: 1.0
                    });
                    const debugSphere = new THREE.Mesh(debugGeometry, debugMaterial);
                    debugSphere.name = `debug-controller-${i}`;
                    
                    // Add to the controller for automatic position tracking
                    if (vrControllers[i]) {
                        vrControllers[i].add(debugSphere);
                        console.log(`Added debug sphere for controller ${i}`);
                        
                        // Also add a large cube for extra visibility
                        const cubeGeometry = new THREE.BoxGeometry(0.03, 0.03, 0.03);
                        const cubeMaterial = new THREE.MeshBasicMaterial({ 
                            color: i === 0 ? 0xff00ff : 0x00ffff, // Magenta for controller 0, cyan for controller 1
                            transparent: false
                        });
                        const debugCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        debugCube.position.set(0, 0.1, 0); // Offset above the sphere
                        vrControllers[i].add(debugCube);
                        console.log(`Added debug cube for controller ${i}`);
                    }
                }
            }
            
            function addTestSpheres() {
                // Add test spheres relative to cameraRig to verify visibility
                const testPositions = [
                    { x: 0.3, y: 0, z: -0.5, color: 0xff0000 }, // Red sphere at right controller area
                    { x: -0.3, y: 0, z: -0.5, color: 0x00ff00 }, // Green sphere at left controller area
                    { x: 0, y: 0.5, z: -1, color: 0x0000ff } // Blue sphere above head
                ];
                
                testPositions.forEach((pos, index) => {
                    const geometry = new THREE.SphereGeometry(0.05);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: pos.color,
                        transparent: false
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(pos.x, pos.y, pos.z);
                    sphere.name = `test-sphere-${index}`;
                    cameraRig.add(sphere); // Add to cameraRig so they move with player
                    console.log(`Added test sphere ${index} to cameraRig at position:`, pos);
                });
            }
            
            function buildController(data) {
                console.log('Building controller with targetRayMode:', data.targetRayMode);
                let geometry, material;
                
                switch (data.targetRayMode) {
                    case 'tracked-pointer':
                        // Create laser pointer with bright green color and thick line
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -5], 3));
                        
                        material = new THREE.LineBasicMaterial({
                            color: 0x00ff00,
                            transparent: false,
                            opacity: 1.0,
                            linewidth: 5 // Thick line
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.name = 'laser';
                        
                        // Also create a cylinder as backup visualization
                        const cylinderGeometry = new THREE.CylinderGeometry(0.002, 0.002, 5, 8);
                        const cylinderMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00,
                            transparent: false
                        });
                        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                        cylinder.position.set(0, 0, -2.5);
                        cylinder.rotation.x = Math.PI / 2;
                        line.add(cylinder);
                        
                        vrLaserPointers.push(line);
                        console.log('Created laser pointer with cylinder backup, total lasers:', vrLaserPointers.length);
                        return line;
                        
                    case 'gaze':
                        // Create dot for gaze-based input
                        geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
                        material = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000,
                            opacity: 0.8, 
                            transparent: true 
                        });
                        const gazeMesh = new THREE.Mesh(geometry, material);
                        console.log('Created gaze controller');
                        return gazeMesh;
                }
                
                console.log('Unknown targetRayMode, creating empty group');
                return new THREE.Group();
            }
            
            function buildControllerModel(data) {
                console.log('Building controller model for:', data);
                
                // Create a bright, visible controller model
                const geometry = new THREE.CylinderGeometry(0.02, 0.03, 0.15, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add a bright sphere at the tip
                const tipGeometry = new THREE.SphereGeometry(0.025);
                const tipMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 1.0
                });
                const tip = new THREE.Mesh(tipGeometry, tipMaterial);
                tip.position.set(0, 0.08, 0);
                mesh.add(tip);
                
                console.log('Created controller model with tip');
                return mesh;
            }
            
            function onSelectStart(event) {
                // Handle controller trigger press
                console.log('Controller select start');
            }
            
            function onSelectEnd(event) {
                // Handle controller trigger release
                console.log('Controller select end');
            }
            
            function updateLaserPointers() {
                // Show laser pointers only when menu is visible
                const showLasers = isMenuVisible && vrMenu && vrMenu.visible;
                
                vrLaserPointers.forEach((laser, index) => {
                    if (laser) {
                        laser.visible = showLasers;
                        // Make laser bright and visible when shown
                        if (laser.material && showLasers) {
                            laser.material.opacity = 1.0;
                            laser.material.color.setHex(0x00ff00); // Bright green
                        }
                    }
                });
                
                // Show/hide controller models based on menu visibility
                vrControllerModels.forEach((controllerGrip, index) => {
                    if (controllerGrip) {
                        controllerGrip.visible = showLasers;
                        
                        // Add fallback visualization if no controller model loaded (only once)
                        if (controllerGrip.children.length === 0) {
                            const fallbackGeometry = new THREE.SphereGeometry(0.05);
                            const fallbackMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xff0000,
                                transparent: true,
                                opacity: 1.0
                            });
                            const fallbackSphere = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                            controllerGrip.add(fallbackSphere);
                            console.log(`Added fallback visualization for controller ${index}`);
                        }
                    }
                });
                
                // Show/hide debug spheres and cubes on controllers
                vrControllers.forEach((controller, index) => {
                    if (controller) {
                        controller.children.forEach(child => {
                            if (child.name && child.name.startsWith('debug-controller')) {
                                child.visible = showLasers;
                            }
                        });
                    }
                });
            }

            function setupVRHUD() {
                if (vrHUD) return; // Already created
                
                // Create HUD group
                vrHUD = new THREE.Group();
                
                // Position HUD in front of player (relative to camera rig)
                vrHUD.position.set(0, 0.3, -1.5); // Above and in front
                
                // Create canvas for text rendering
                var canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                var context = canvas.getContext('2d');
                
                // Create texture from canvas
                var hudTexture = new THREE.CanvasTexture(canvas);
                hudTexture.needsUpdate = true;
                
                // Create HUD plane
                var hudGeometry = new THREE.PlaneGeometry(1, 0.5);
                var hudMaterial = new THREE.MeshBasicMaterial({
                    map: hudTexture,
                    transparent: true,
                    opacity: 0.8
                });
                
                var hudMesh = new THREE.Mesh(hudGeometry, hudMaterial);
                vrHUD.add(hudMesh);
                
                // Store references for updating
                vrHUD.userData = {
                    canvas: canvas,
                    context: context,
                    texture: hudTexture
                };
                
                // Add HUD to camera rig so it follows the player
                cameraRig.add(vrHUD);
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                
                console.log('🥽 VR HUD created');
            }
            
            // ENGINE SOUND SYSTEM: Procedural engine sound generation
            class EngineSound {
                constructor(audioContext, baseFrequency = 80, volume = 0.3) {
                    this.audioContext = audioContext;
                    this.baseFrequency = baseFrequency;
                    this.volume = volume;
                    
                    // Create audio nodes
                    this.oscillator1 = null;
                    this.oscillator2 = null;
                    this.oscillator3 = null;
                    this.noiseBuffer = null;
                    this.noiseSource = null;
                    this.gainNode = null;
                    this.filterNode = null;
                    
                    this.isPlaying = false;
                    this.currentRPM = 800; // Idle RPM
                    
                    this.setupAudioNodes();
                }
                
                setupAudioNodes() {
                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    // Create filter for engine character
                    this.filterNode = this.audioContext.createBiquadFilter();
                    this.filterNode.type = 'lowpass';
                    this.filterNode.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    this.filterNode.Q.setValueAtTime(1, this.audioContext.currentTime);
                    
                    // Connect filter to gain to output
                    this.filterNode.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                    
                    // Create noise buffer for engine texture
                    this.createNoiseBuffer();
                }
                
                createNoiseBuffer() {
                    var bufferSize = this.audioContext.sampleRate * 2; // 2 seconds of noise
                    this.noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    var output = this.noiseBuffer.getChannelData(0);
                    
                    // Generate pink noise for engine texture
                    for (var i = 0; i < bufferSize; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.1;
                    }
                }
                
                start() {
                    if (this.isPlaying) return;
                    
                    // Create oscillators for engine harmonics
                    this.oscillator1 = this.audioContext.createOscillator();
                    this.oscillator2 = this.audioContext.createOscillator();
                    this.oscillator3 = this.audioContext.createOscillator();
                    
                    // Set oscillator types and frequencies
                    this.oscillator1.type = 'sawtooth';
                    this.oscillator2.type = 'square';
                    this.oscillator3.type = 'triangle';
                    
                    // Create gain nodes for each oscillator
                    var gain1 = this.audioContext.createGain();
                    var gain2 = this.audioContext.createGain();
                    var gain3 = this.audioContext.createGain();
                    
                    gain1.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gain2.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gain3.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    
                    // Connect oscillators
                    this.oscillator1.connect(gain1);
                    this.oscillator2.connect(gain2);
                    this.oscillator3.connect(gain3);
                    
                    gain1.connect(this.filterNode);
                    gain2.connect(this.filterNode);
                    gain3.connect(this.filterNode);
                    
                    // Add noise source
                    this.noiseSource = this.audioContext.createBufferSource();
                    this.noiseSource.buffer = this.noiseBuffer;
                    this.noiseSource.loop = true;
                    
                    var noiseGain = this.audioContext.createGain();
                    noiseGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    
                    this.noiseSource.connect(noiseGain);
                    noiseGain.connect(this.filterNode);
                    
                    // Start all sources
                    this.oscillator1.start();
                    this.oscillator2.start();
                    this.oscillator3.start();
                    this.noiseSource.start();
                    
                    // Fade in
                    this.gainNode.gain.setTargetAtTime(this.volume, this.audioContext.currentTime, 0.1);
                    
                    this.isPlaying = true;
                    this.updateFrequencies();
                }
                
                stop() {
                    if (!this.isPlaying) return;
                    
                    // Fade out
                    this.gainNode.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
                    
                    // Stop sources after fade out
                    setTimeout(() => {
                        if (this.oscillator1) {
                            this.oscillator1.stop();
                            this.oscillator2.stop();
                            this.oscillator3.stop();
                            this.noiseSource.stop();
                        }
                        this.isPlaying = false;
                    }, 200);
                }
                
                updateEngine(speed, throttle, rpm) {
                    if (!this.isPlaying) return;
                    
                    // Calculate RPM based on speed and throttle
                    var targetRPM = 800 + (speed * 50) + (throttle * 2000); // Idle + speed + throttle
                    targetRPM = Math.min(targetRPM, 6000); // Max RPM
                    
                    // Smooth RPM changes
                    this.currentRPM += (targetRPM - this.currentRPM) * 0.1;
                    
                    this.updateFrequencies();
                    this.updateVolume(throttle);
                }
                
                updateFrequencies() {
                    if (!this.isPlaying || !this.oscillator1) return;
                    
                    var baseFreq = this.baseFrequency * (this.currentRPM / 1000);
                    
                    // Set frequencies for harmonics
                    this.oscillator1.frequency.setTargetAtTime(baseFreq, this.audioContext.currentTime, 0.01);
                    this.oscillator2.frequency.setTargetAtTime(baseFreq * 2, this.audioContext.currentTime, 0.01);
                    this.oscillator3.frequency.setTargetAtTime(baseFreq * 0.5, this.audioContext.currentTime, 0.01);
                    
                    // Update filter frequency based on RPM
                    var filterFreq = 400 + (this.currentRPM / 10);
                    this.filterNode.frequency.setTargetAtTime(filterFreq, this.audioContext.currentTime, 0.01);
                }
                
                updateVolume(throttle) {
                    if (!this.isPlaying) return;
                    
                    var targetVolume = this.volume * (0.3 + throttle * 0.7); // Idle + throttle volume
                    this.gainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.05);
                }
            }
            
            function initAudioSystem() {
                try {
                    // Create audio context
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create engine sounds (lowered pitch and volume for music prominence)
                    playerEngineSound = new EngineSound(audioContext, 55, 0.15); // Player car (reduced volume from 0.4 to 0.15)
                    botEngineSound = new EngineSound(audioContext, 60, 0.08);    // Bot car (reduced volume from 0.2 to 0.08)
                    
                    // Initialize background music
                    backgroundMusic = document.getElementById('backgroundMusic');
                    if (backgroundMusic) {
                        backgroundMusic.volume = 0.6; // Set to 60% volume to be more prominent than engine sounds
                        
                        // Add error handling for audio loading
                        backgroundMusic.addEventListener('error', function(e) {
                            console.warn('🎵 Background music failed to load:', e);
                        });
                        
                        backgroundMusic.addEventListener('canplaythrough', function() {
                            console.log('🎵 Background music loaded successfully');
                        });
                        
                        console.log('🎵 Background music initialized');
                    }
                    
                    console.log('🔊 Audio system initialized');
                    
                    // Start audio on first user interaction
                    var startAudioOnInteraction = function() {
                        startEngineAudio();
                        document.removeEventListener('click', startAudioOnInteraction);
                        document.removeEventListener('keydown', startAudioOnInteraction);
                        document.removeEventListener('touchstart', startAudioOnInteraction);
                    };
                    
                    document.addEventListener('click', startAudioOnInteraction);
                    document.addEventListener('keydown', startAudioOnInteraction);
                    document.addEventListener('touchstart', startAudioOnInteraction);
                    
                } catch (error) {
                    console.warn('Audio system not available:', error);
                }
            }

            // GLOBAL AUDIO CONTROL: Resume audio context and start engine sounds (requires user interaction)
            function startEngineAudio() {
                if (!audioContext || !playerEngineSound || !botEngineSound) {
                    console.warn('Audio system not initialized yet');
                    return;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playerEngineSound.start();
                        botEngineSound.start();
                        console.log('🔊 Engine sounds started (resumed context)');
                        // Start background music
                        if (backgroundMusic) {
                            backgroundMusic.play().then(() => {
                                console.log('🎵 Background music started');
                            }).catch(error => {
                                console.warn('Background music failed to start:', error);
                            });
                        }
                    }).catch(error => {
                        console.warn('Failed to resume audio context:', error);
                    });
                } else {
                    playerEngineSound.start();
                    botEngineSound.start();
                    console.log('🔊 Engine sounds started');
                    // Start background music
                    if (backgroundMusic) {
                        backgroundMusic.play().then(() => {
                            console.log('🎵 Background music started');
                        }).catch(error => {
                            console.warn('Background music failed to start:', error);
                        });
                    }
                }
            }

            function updateVRHUD() {
                if (!vrHUD || !vrHUD.userData) return;
                
                var canvas = vrHUD.userData.canvas;
                var context = vrHUD.userData.context;
                var texture = vrHUD.userData.texture;
                
                // Clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set up text styling
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = '#ffffff';
                context.font = 'bold 32px Arial';
                context.textAlign = 'left';
                
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Draw lap information
                var yPos = 50;
                var lineHeight = 40;
                
                // Lap number
                context.fillText('LAP: ' + currentLapNumber, 20, yPos);
                yPos += lineHeight;
                
                // Current lap time
                context.fillText('TIME: ' + formatTime(currentLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Best lap time
                context.fillText('BEST: ' + formatTime(bestLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Checkpoint progress
                var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                context.fillText('CHECKPOINT: ' + currentCheckpoint + '/' + totalCheckpoints, 20, yPos);
                yPos += lineHeight;
                
                // Update texture
                texture.needsUpdate = true;
            }

            // DESKTOP HUD UPDATE: Update desktop HUD with same info as VR HUD
            function updateDesktopHUD() {
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                } else {
                    console.warn('⚠️ Desktop HUD: currentLapStartTime not initialized:', currentLapStartTime);
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Update desktop HUD elements
                var lapElement = document.getElementById('desktopLapNumber');
                var timeElement = document.getElementById('desktopCurrentTime');
                var bestElement = document.getElementById('desktopBestTime');
                var checkpointElement = document.getElementById('desktopCheckpoint');
                
                if (lapElement) lapElement.textContent = currentLapNumber;
                if (timeElement) timeElement.textContent = formatTime(currentLapTime);
                if (bestElement) bestElement.textContent = formatTime(bestLapTime);
                
                // Update checkpoint progress
                if (checkpointElement) {
                    var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                    var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                    if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                    checkpointElement.textContent = currentCheckpoint + '/' + totalCheckpoints;
                }
            }

            // ========== MENU SYSTEM ==========
            function toggleMenu() {
                isMenuVisible = !isMenuVisible;
                
                if (renderer.xr.isPresenting) {
                    // VR Mode: Toggle 3D menu
                    console.log('VR Mode - Menu toggle. Current state:', isMenuVisible, 'VR Menu exists:', !!vrMenu);
                    if (vrMenu) {
                        vrMenu.visible = isMenuVisible;
                        console.log('VR Menu visibility set to:', isMenuVisible);
                        if (isMenuVisible) {
                            try {
                                updateVRMenuDisplay();
                                console.log('VR Menu display updated successfully');
                            } catch (error) {
                                console.error('Error updating VR menu display:', error);
                            }
                        }
                    } else if (isMenuVisible) {
                        console.log('Creating new VR menu...');
                        try {
                            createVRMenu();
                            console.log('VR Menu created successfully');
                        } catch (error) {
                            console.error('Error creating VR menu:', error);
                        }
                    }
                } else {
                    // Desktop Mode: Toggle HTML menu
                    const gameMenu = document.getElementById('gameMenu');
                    if (gameMenu) {
                        gameMenu.style.display = isMenuVisible ? 'flex' : 'none';
                    }
                }
                
                console.log('Menu toggled:', isMenuVisible ? 'visible' : 'hidden');
            }

            function createVRMenu() {
                if (vrMenu) return; // Already created
                
                vrMenu = new THREE.Group();
                
                // Position menu in front of user (simple fixed position)
                vrMenu.position.set(0, 0, -1.5); // 1.5 meters in front of camera
                
                // Add to camera rig so it follows the user's head
                if (cameraRig) {
                    cameraRig.add(vrMenu);
                    console.log('VR Menu added to camera rig');
                } else {
                    scene.add(vrMenu);
                    console.log('VR Menu added to scene (fallback)');
                }
                console.log('VR Menu positioned at:', vrMenu.position);
                
                // Menu background - barely transparent black
                const bgGeometry = new THREE.PlaneGeometry(1.4, 1.0);
                const bgMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000, // Black background
                    transparent: true, 
                    opacity: 0.1 // Barely visible
                });
                const background = new THREE.Mesh(bgGeometry, bgMaterial);
                background.position.z = -0.01;
                vrMenu.add(background);
                
                // Add border to make menu more visible
                const borderGeometry = new THREE.PlaneGeometry(1.45, 1.05);
                const borderMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff, // Blue border
                    transparent: true, 
                    opacity: 0.8 
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.z = -0.02;
                vrMenu.add(border);
                
                // Add bright test markers to make sure menu is visible
                const testGeometry = new THREE.SphereGeometry(0.03);
                const testMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                
                // Four corner markers
                const markers = [
                    { pos: [0.6, 0.4, 0.05] },   // Top right
                    { pos: [-0.6, 0.4, 0.05] },  // Top left
                    { pos: [0.6, -0.4, 0.05] },  // Bottom right
                    { pos: [-0.6, -0.4, 0.05] }  // Bottom left
                ];
                
                markers.forEach(marker => {
                    const testMarker = new THREE.Mesh(testGeometry, testMaterial);
                    testMarker.position.set(...marker.pos);
                    vrMenu.add(testMarker);
                });
                
                // Title
                const titleGeometry = new THREE.PlaneGeometry(0.8, 0.1);
                const titleCanvas = document.createElement('canvas');
                titleCanvas.width = 512;
                titleCanvas.height = 64;
                const titleCtx = titleCanvas.getContext('2d');
                titleCtx.fillStyle = '#ffffff';
                titleCtx.font = 'bold 32px Arial';
                titleCtx.textAlign = 'center';
                titleCtx.fillText('WEBXR DRIVE MENU', 256, 40);
                const titleTexture = new THREE.CanvasTexture(titleCanvas);
                const titleMaterial = new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true });
                const title = new THREE.Mesh(titleGeometry, titleMaterial);
                title.position.set(0, 0.35, 0);
                vrMenu.add(title);
                
                // Current mode display
                const modeGeometry = new THREE.PlaneGeometry(0.8, 0.08);
                const modeCanvas = document.createElement('canvas');
                modeCanvas.width = 512;
                modeCanvas.height = 48;
                const modeTexture = new THREE.CanvasTexture(modeCanvas);
                const modeMaterial = new THREE.MeshBasicMaterial({ map: modeTexture, transparent: true });
                const modeDisplay = new THREE.Mesh(modeGeometry, modeMaterial);
                modeDisplay.position.set(0, 0.25, 0);
                modeDisplay.userData = { type: 'display', id: 'mode-display', canvas: modeCanvas, texture: modeTexture };
                vrMenu.add(modeDisplay);
                
                // Single/Multi buttons
                const singleBtn = createVRButton('SINGLE', -0.25, 0.15, 0.25, 0.08, '#004499', 'singleplayer');
                const multiBtn = createVRButton('MULTI', 0.25, 0.15, 0.25, 0.08, '#990044', 'multiplayer');
                vrMenu.add(singleBtn);
                vrMenu.add(multiBtn);
                vrMenuButtons.push(singleBtn, multiBtn);
                
                // Lobby section (initially hidden)
                const lobbyGroup = new THREE.Group();
                lobbyGroup.position.set(0, 0.05, 0);
                lobbyGroup.visible = false;
                lobbyGroup.userData = { type: 'lobby-section' };
                
                // Lobby label
                const lobbyLabel = createVRText('Lobby:', -0.4, 0, 0.3);
                lobbyGroup.add(lobbyLabel);
                
                // Lobby controls
                const lobbyMinus = createVRButton('-', -0.15, 0, 0.06, 0.06, '#ff4444', 'lobby-minus');
                const lobbyPlus = createVRButton('+', -0.05, 0, 0.06, 0.06, '#44ff44', 'lobby-plus');
                const lobbyNumber = createVRText('1', -0.1, 0, 0.4);
                lobbyNumber.userData.type = 'display';
                lobbyNumber.userData.id = 'lobby-number';
                
                const connectBtn = createVRButton('CONNECT', 0.1, 0, 0.2, 0.06, '#4444ff', 'connect');
                const autoBtn = createVRButton('AUTO', 0.35, 0, 0.15, 0.06, '#44aa44', 'auto-connect');
                
                lobbyGroup.add(lobbyMinus, lobbyPlus, lobbyNumber, connectBtn, autoBtn);
                vrMenuButtons.push(lobbyMinus, lobbyPlus, connectBtn, autoBtn);
                vrMenu.add(lobbyGroup);
                
                // Bot toggle
                const botGroup = new THREE.Group();
                botGroup.position.set(0, -0.05, 0);
                
                const botLabel = createVRText('Bot:', -0.2, 0, 0.3);
                const botToggle = createVRButton('ON', 0, 0, 0.12, 0.06, '#00aa00', 'bot-toggle');
                const botStatus = createVRText('(Single & Host)', 0.25, 0, 0.25);
                botStatus.userData.type = 'display';
                botStatus.userData.id = 'bot-status';
                
                botGroup.add(botLabel, botToggle, botStatus);
                vrMenuButtons.push(botToggle);
                vrMenu.add(botGroup);
                
                // Start Race button
                const startBtn = createVRButton('START RACE', 0, -0.25, 0.25, 0.08, '#00aa00', 'start-race');
                vrMenu.add(startBtn);
                vrMenuButtons.push(startBtn);
                
                // Close button
                const closeBtn = createVRButton('CLOSE', 0, -0.35, 0.2, 0.08, '#666666', 'close');
                vrMenu.add(closeBtn);
                vrMenuButtons.push(closeBtn);
                
                // Status display
                const statusDisplay = createVRText('Disconnected', 0, -0.45, 0.4);
                statusDisplay.userData.type = 'display';
                statusDisplay.userData.id = 'status';
                vrMenu.add(statusDisplay);
                
                // Create raycaster for VR interaction
                vrMenuRaycaster = new THREE.Raycaster();
                
                console.log('VR Menu created with', vrMenuButtons.length, 'buttons');
            }

            function createVRButton(text, x, y, width, height, color, id) {
                const group = new THREE.Group();
                group.position.set(x, y, 0);
                group.userData = { type: 'button', id: id, active: false };
                
                // Button background
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(color), 
                    transparent: true, 
                    opacity: 0.8 
                });
                const button = new THREE.Mesh(geometry, material);
                group.add(button);
                
                // Button text
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 256;
                textCanvas.height = 64;
                const ctx = textCanvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.9, height * 0.7), textMaterial);
                textMesh.position.z = 0.001;
                group.add(textMesh);
                
                group.userData.originalColor = new THREE.Color(color);
                group.userData.material = material;
                group.userData.textCanvas = textCanvas;
                group.userData.textTexture = textTexture;
                
                return group;
            }

            function createVRText(text, x, y, scale) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const geometry = new THREE.PlaneGeometry(scale, scale * 0.25);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, 0);
                mesh.userData = { canvas: canvas, texture: texture };
                
                return mesh;
            }

            function updateVRMenuDisplay() {
                if (!vrMenu) return;
                
                // Update mode display
                const modeDisplay = vrMenu.children.find(child => 
                    child.userData.type === 'display' && child.userData.id === 'mode-display'
                );
                if (modeDisplay) {
                    const ctx = modeDisplay.userData.canvas.getContext('2d');
                    ctx.clearRect(0, 0, 512, 48);
                    ctx.fillStyle = '#00ff88';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    const modeText = isMultiplayer ? 
                        `Mode: Multiplayer (Lobby ${selectedLobby}) (${activePlayers.size || 1}/4)` : 
                        'Mode: Singleplayer';
                    ctx.fillText(modeText, 256, 30);
                    modeDisplay.userData.texture.needsUpdate = true;
                }
                
                // Update lobby section visibility
                const lobbySection = vrMenu.children.find(child => 
                    child.userData.type === 'lobby-section'
                );
                if (lobbySection) {
                    lobbySection.visible = isMultiplayer;
                    
                    // Update lobby number within the same section
                    const lobbyNumber = lobbySection.children.find(child => 
                        child.userData.type === 'display' && child.userData.id === 'lobby-number'
                    );
                    if (lobbyNumber && lobbyNumber.userData.canvas) {
                        const ctx = lobbyNumber.userData.canvas.getContext('2d');
                        ctx.clearRect(0, 0, 256, 64);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(selectedLobby.toString(), 128, 40);
                        lobbyNumber.userData.texture.needsUpdate = true;
                    }
                } else {
                    console.log('VR Menu - Lobby section not found');
                }
                
                // Update button states
                vrMenuButtons.forEach(button => {
                    const id = button.userData.id;
                    let active = false;
                    let disabled = false;
                    
                    if (id === 'singleplayer') active = !isMultiplayer;
                    else if (id === 'multiplayer') active = isMultiplayer;
                    else if (id === 'bot-toggle') active = botEnabled;
                    else if (id === 'connect') {
                        // Update connect button based on connection state
                        disabled = (connectionState === 'connecting');
                        active = connectionState === 'connected';
                        
                        // Update button text
                        if (button.userData.canvas) {
                            const ctx = button.userData.canvas.getContext('2d');
                            ctx.clearRect(0, 0, 256, 64);
                            ctx.fillStyle = disabled ? '#666666' : (active ? '#ffffff' : '#ffffff');
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            const buttonText = connectionState === 'connected' ? 'DISCONNECT' : 
                                             connectionState === 'connecting' ? 'CONNECTING...' : 'CONNECT';
                            ctx.fillText(buttonText, 128, 40);
                            button.userData.texture.needsUpdate = true;
                        }
                    }
                    
                    if (active !== button.userData.active || disabled !== button.userData.disabled) {
                        button.userData.active = active;
                        button.userData.disabled = disabled;
                        const material = button.userData.material;
                        
                        if (disabled) {
                            material.color.setHex(0x666666); // Gray when disabled
                            material.opacity = 0.5;
                        } else if (active) {
                            material.color.setHex(0x0088ff); // Blue when active/connected
                            material.opacity = 1.0;
                        } else {
                            material.color.copy(button.userData.originalColor);
                            material.opacity = 0.8;
                        }
                    }
                });
                
                // Update status
                const statusDisplay = vrMenu.children.find(child => 
                    child.userData.type === 'display' && child.userData.id === 'status'
                );
                if (statusDisplay && statusDisplay.userData.canvas) {
                    const ctx = statusDisplay.userData.canvas.getContext('2d');
                    ctx.clearRect(0, 0, 256, 64);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(multiplayerStatus, 128, 40);
                    statusDisplay.userData.texture.needsUpdate = true;
                }
            }

            function handleVRMenuClick(controllerIndex) {
                if (!vrMenuRaycaster || !vrMenu || vrControllers.length === 0) return;
                
                // Use the specific controller that triggered the click
                const controller = vrControllers[controllerIndex];
                if (!controller || !controller.matrixWorld) return;
                
                // Set raycaster from controller
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                
                vrMenuRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                vrMenuRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                // Check intersections with menu buttons
                const intersects = vrMenuRaycaster.intersectObjects(vrMenuButtons, true);
                
                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object.parent;
                    const buttonId = clickedObject.userData.id;
                    
                    // Check if button is disabled
                    if (clickedObject.userData.disabled) {
                        console.log('VR Menu button clicked but disabled:', buttonId);
                        return;
                    }
                    
                    console.log('VR Menu button clicked:', buttonId);
                    
                    // Handle button actions
                    switch (buttonId) {
                        case 'singleplayer':
                            console.log('Switching to singleplayer');
                            switchToSingleplayer();
                            break;
                        case 'multiplayer':
                            console.log('Switching to multiplayer');
                            switchToMultiplayer();
                            break;
                        case 'lobby-minus':
                            console.log('Lobby minus clicked');
                            changeLobby(-1);
                            break;
                        case 'lobby-plus':
                            console.log('Lobby plus clicked');
                            changeLobby(1);
                            break;
                        case 'connect':
                            if (connectionState === 'connected') {
                                disconnectFromLobby();
                            } else {
                                connectToLobby();
                            }
                            break;
                        case 'auto-connect':
                            autoConnect();
                            break;
                        case 'bot-toggle':
                            toggleBot();
                            break;
                        case 'start-race':
                            startRace();
                            break;
                        case 'close':
                            toggleMenu();
                            break;
                    }
                    
                    // Update menu display after action
                    if (vrMenu && vrMenu.visible) {
                        updateVRMenuDisplay();
                    }
                }
            }

            function updateVRMenuHover(controllerIndex) {
                if (!vrMenuRaycaster || !vrMenu || vrControllers.length === 0) return;
                
                // Use the specific controller for hover detection
                const controller = vrControllers[controllerIndex];
                if (!controller || !controller.matrixWorld) return;
                
                // Reset all buttons to normal state first
                vrMenuButtons.forEach(button => {
                    const material = button.userData.material;
                    if (!button.userData.active) {
                        material.color.copy(button.userData.originalColor);
                        material.opacity = 0.8;
                    }
                });
                
                // Set raycaster from this controller
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                
                vrMenuRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                vrMenuRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                // Check intersections with menu buttons
                const intersects = vrMenuRaycaster.intersectObjects(vrMenuButtons, true);
                
                // Highlight hovered button for this controller
                if (intersects.length > 0) {
                    const hoveredObject = intersects[0].object.parent;
                    const material = hoveredObject.userData.material;
                    if (material && !hoveredObject.userData.active && !hoveredObject.userData.disabled) {
                        material.color.setHex(0xffffff);
                        material.opacity = 1.0;
                    }
                }
            }

            function updateMenuDisplay() {
                const currentModeDisplay = document.getElementById('currentModeDisplay');
                const lobbySection = document.getElementById('lobbySection');
                const singleBtn = document.getElementById('singleplayerBtn');
                const multiBtn = document.getElementById('multiplayerBtn');
                const botToggle = document.getElementById('botToggle');
                const botStatus = document.getElementById('botStatus');
                const statusText = document.getElementById('statusText');
                const lobbyNumber = document.getElementById('lobbyNumber');

                if (currentModeDisplay) {
                    if (isMultiplayer) {
                        const playerCount = activePlayers.size || 1;
                        currentModeDisplay.textContent = `Mode: Multiplayer (Lobby ${selectedLobby}) (${playerCount}/4)`;
                    } else {
                        currentModeDisplay.textContent = 'Mode: Singleplayer';
                    }
                }

                if (lobbySection) {
                    lobbySection.style.display = isMultiplayer ? 'block' : 'none';
                }

                if (singleBtn && multiBtn) {
                    singleBtn.classList.toggle('active', !isMultiplayer);
                    multiBtn.classList.toggle('active', isMultiplayer);
                }

                if (botToggle && botStatus) {
                    botToggle.textContent = botEnabled ? 'ON' : 'OFF';
                    botToggle.classList.toggle('active', botEnabled);
                    
                    if (isMultiplayer && !isHost) {
                        botStatus.textContent = '(Host controls bot)';
                        botToggle.disabled = true;
                        botToggle.style.opacity = '0.5';
                    } else {
                        botStatus.textContent = '(Available in Single & Host)';
                        botToggle.disabled = false;
                        botToggle.style.opacity = '1';
                    }
                }

                if (statusText) {
                    statusText.textContent = multiplayerStatus;
                }

                if (lobbyNumber) {
                    lobbyNumber.textContent = selectedLobby.toString();
                }
            }

            function setupMenuEventListeners() {
                // Single/Multi buttons
                document.getElementById('singleplayerBtn')?.addEventListener('click', () => {
                    switchToSingleplayer();
                });
                
                document.getElementById('multiplayerBtn')?.addEventListener('click', () => {
                    switchToMultiplayer();
                });

                // Lobby controls
                document.getElementById('lobbyMinus')?.addEventListener('click', () => {
                    changeLobby(-1);
                });
                
                document.getElementById('lobbyPlus')?.addEventListener('click', () => {
                    changeLobby(1);
                });

                // Connection buttons
                document.getElementById('connectBtn')?.addEventListener('click', () => {
                    connectToLobby();
                });
                
                document.getElementById('autoConnectBtn')?.addEventListener('click', () => {
                    autoConnect();
                });

                // Bot toggle
                document.getElementById('botToggle')?.addEventListener('click', () => {
                    toggleBot();
                });

                // Close menu
                document.getElementById('closeMenuBtn')?.addEventListener('click', () => {
                    toggleMenu();
                });
            }

            function switchToSingleplayer() {
                if (isMultiplayer) {
                    // Disconnect from multiplayer
                    if (peer) {
                        peer.destroy();
                        peer = null;
                    }
                    connections.clear();
                    activePlayers.clear();
                    myPlayerId = null;
                }
                
                isMultiplayer = false;
                isHost = false;
                multiplayerStatus = 'Disconnected';
                
                updateMenuDisplay();
                updateVRMenuDisplay();
                console.log('Switched to singleplayer mode');
            }

            function switchToMultiplayer() {
                isMultiplayer = true;
                multiplayerStatus = 'Ready to connect';
                updateMenuDisplay();
                updateVRMenuDisplay();
                console.log('Switched to multiplayer mode');
            }

            function changeLobby(direction) {
                selectedLobby += direction;
                if (selectedLobby < 1) selectedLobby = MAX_LOBBIES;
                if (selectedLobby > MAX_LOBBIES) selectedLobby = 1;
                updateMenuDisplay();
                updateVRMenuDisplay(); // Also update VR menu
                console.log('Changed to lobby:', selectedLobby);
            }

            function toggleBot() {
                if (isMultiplayer && !isHost) {
                    console.log('Only host can control bot in multiplayer');
                    return;
                }
                
                botEnabled = !botEnabled;
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Enable/disable bot in the scene
                if (botCar && botCar.chassisMesh) {
                    botCar.chassisMesh.visible = botEnabled;
                    if (botCar.chassisBody) {
                        // Enable/disable physics
                        const flags = botCar.chassisBody.getCollisionFlags();
                        if (botEnabled) {
                            botCar.chassisBody.setCollisionFlags(flags & ~4); // Remove NO_CONTACT_RESPONSE
                        } else {
                            botCar.chassisBody.setCollisionFlags(flags | 4); // Add NO_CONTACT_RESPONSE
                        }
                    }
                }
                
                console.log('Bot', botEnabled ? 'enabled' : 'disabled');
            }

            function connectToLobby() {
                if (!isMultiplayer) return;
                
                // Prevent multiple connections
                if (peer && !peer.destroyed) {
                    console.log('Already connected or connecting, ignoring request');
                    return;
                }
                
                // Clean up any existing connections first
                if (peer) {
                    console.log('Cleaning up existing peer connection');
                    peer.destroy();
                    peer = null;
                }
                connections.clear();
                connectionState = 'connecting';
                
                console.log('Connecting to lobby', selectedLobby);
                multiplayerStatus = 'Connecting...';
                console.log('Set multiplayerStatus to:', multiplayerStatus);
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Try to connect as host first, then as client
                setupHost(selectedLobby).then(() => {
                    console.log('Connected as host to lobby', selectedLobby);
                    connectionState = 'connected';
                    multiplayerStatus = `Hosting - Lobby ${selectedLobby}`;
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                }).catch((hostError) => {
                    console.log('Host connection failed, trying as client:', hostError.message);
                    multiplayerStatus = 'Trying as client...';
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                    
                    // Host failed, try as client
                    setupPeer(selectedLobby).then(() => {
                        console.log('Connected as client to lobby', selectedLobby);
                        connectionState = 'connected';
                        multiplayerStatus = `Connected - Lobby ${selectedLobby}`;
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                    }).catch((clientError) => {
                        console.error('Failed to connect to lobby as client:', clientError);
                        connectionState = 'disconnected';
                        multiplayerStatus = 'Connection failed - No host available';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        
                        // Reset multiplayer state
                        isMultiplayer = false;
                        isHost = false;
                        if (peer) {
                            peer.destroy();
                            peer = null;
                        }
                        connections.clear();
                    });
                });
            }

            function autoConnect() {
                if (!isMultiplayer) return;
                
                multiplayerStatus = 'Auto-connecting...';
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Try lobbies 1-10 automatically
                let currentLobby = 1;
                
                function tryNextLobby() {
                    if (currentLobby > MAX_LOBBIES) {
                        multiplayerStatus = 'No available lobbies';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        return;
                    }
                    
                    selectedLobby = currentLobby;
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                    
                    setupPeer(currentLobby).then(() => {
                        console.log('Auto-connected to lobby', currentLobby);
                    }).catch(() => {
                        currentLobby++;
                        setTimeout(tryNextLobby, 1000);
                    });
                }
                
                tryNextLobby();
            }
            
            function startRace() {
                console.log('Starting/Restarting race...');
                // Reset player position
                resetCar();
                // Close menu
                toggleMenu();
                // Reset lap timer
                if (typeof playerLapStartTime !== 'undefined') {
                    playerLapStartTime = Date.now();
                }
            }
            
            function disconnectFromLobby() {
                console.log('Disconnecting from lobby...');
                
                // Clean up peer connection
                if (peer && !peer.destroyed) {
                    peer.destroy();
                }
                peer = null;
                
                // Clear all connections
                connections.clear();
                activePlayers.clear();
                
                // Reset state
                isMultiplayer = false;
                isHost = false;
                connectionState = 'disconnected';
                multiplayerStatus = 'Disconnected';
                myPlayerId = null;
                sessionID = null;
                
                // Update display
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                console.log('Disconnected from multiplayer');
            }

            // ========== PEERJS MULTIPLAYER FUNCTIONS ==========
            async function setupHost(lobbyNumber) {
                return new Promise((resolve, reject) => {
                    isMultiplayer = true;
                    isHost = true;
                    selectedLobby = lobbyNumber;
                    // Use simple host ID - only one host per lobby allowed
                    sessionID = `${multiplayerStartType}-host-${lobbyNumber}`;
                    
                    const iceServersConfig = [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ];
                    
                    peer = new Peer(sessionID, {
                        host: "0.peerjs.com",
                        port: 443,
                        secure: true,
                        config: { iceServers: iceServersConfig }
                    });
                    
                    peer.on("open", function() {
                        multiplayerStatus = `Host - Lobby ${lobbyNumber} (1/4)`;
                        myPlayerId = 'player_0';
                        activePlayers.set(myPlayerId, { isConnected: true, isHost: true });
                        
                        // Host uses physics car, not slot system
                        console.log('🏠 Host uses physics car, not slot system');
                        
                        updateMenuDisplay();
                        resolve();
                    });
                    
                    peer.on("connection", function(conn) {
                        const playerId = `player_${activePlayers.size}`;
                        connections.set(playerId, conn);
                        connectionToPlayer.set(conn, playerId);
                        
                        conn.on("open", function() {
                            activePlayers.set(playerId, { isConnected: true, isHost: false });
                            multiplayerStatus = `Host - Lobby ${lobbyNumber} (${activePlayers.size}/4)`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            
                            // Assign player to a car slot
                            const slotIndex = assignPlayerToSlot(playerId);
                            
                            // Send welcome message to new player
                            conn.send({
                                type: 'player-assignment',
                                playerId: playerId,
                                isHost: false,
                                slotIndex: slotIndex
                            });
                            
                            // Broadcast updated player list to all clients
                            broadcastPlayerList();
                            
                            console.log('Player connected:', playerId);
                        });
                        
                        conn.on("data", function(data) {
                            handleMultiplayerMessage(data, playerId);
                        });
                        
                        conn.on("close", function() {
                            activePlayers.delete(playerId);
                            connections.delete(playerId);
                            connectionToPlayer.delete(conn);
                            
                            // Remove player from car slot
                            removePlayerFromSlot(playerId);
                            
                            multiplayerStatus = `Host - Lobby ${lobbyNumber} (${activePlayers.size}/4)`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            
                            // Broadcast updated player list to remaining clients
                            broadcastPlayerList();
                            
                            console.log('Player disconnected:', playerId);
                        });
                    });
                    
                    peer.on("error", function(err) {
                        console.error('Host peer error:', err);
                        multiplayerStatus = 'Host failed, trying client...';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        if (err.type === 'unavailable-id' || err.message.includes('taken')) {
                            reject(new Error('unavailable-id'));
                        } else {
                            reject(err);
                        }
                    });
                });
            }

            async function setupPeer(lobbyNumber) {
                return new Promise((resolve, reject) => {
                    isMultiplayer = true;
                    isHost = false;
                    selectedLobby = lobbyNumber;
                    
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substr(2, 9);
                    sessionID = `${multiplayerStartType}-peer-${lobbyNumber}-${timestamp}-${randomId}`;
                    
                    const iceServersConfig = [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ];
                    
                    peer = new Peer(sessionID, {
                        host: "0.peerjs.com",
                        port: 443,
                        secure: true,
                        config: { iceServers: iceServersConfig }
                    });
                    
                    peer.on("open", function() {
                        multiplayerStatus = 'Connecting to host...';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        
                        const hostID = `${multiplayerStartType}-host-${lobbyNumber}`;
                        console.log('Attempting to connect to host:', hostID);
                        const conn = peer.connect(hostID);
                        connections.set('host', conn);
                        
                        conn.on("open", function() {
                            multiplayerStatus = `Connected - Lobby ${lobbyNumber}`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            resolve();
                        });
                        
                        conn.on("data", function(data) {
                            handleMultiplayerMessage(data, 'host');
                        });
                        
                        conn.on("close", function() {
                            multiplayerStatus = 'Disconnected';
                            connections.clear();
                            activePlayers.clear();
                            
                            // Clean up all player car slots
                            playerCarSlots.forEach((slot, index) => {
                                if (slot.isActive) {
                                    slot.isActive = false;
                                    slot.playerId = null;
                                    slot.mesh.visible = false;
                                    console.log(`Deactivated player car slot ${index}`);
                                }
                            });
                            playerSlotAssignments.clear();
                            
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            console.log('Disconnected from host');
                        });
                        
                        conn.on("error", function(err) {
                            console.error('Connection error:', err);
                            reject(err);
                        });
                    });
                    
                    peer.on("error", function(err) {
                        console.error('Peer error:', err);
                        reject(err);
                    });
                });
            }

            function handleMultiplayerMessage(data, fromPlayerId) {
                switch (data.type) {
                    case 'player-assignment':
                        myPlayerId = data.playerId;
                        console.log('Assigned player ID:', myPlayerId);
                        break;
                        
                    case 'player-list':
                        // Update the client's player list
                        activePlayers.clear();
                        if (data.players) {
                            data.players.forEach(player => {
                                activePlayers.set(player.id, player);
                            });
                        }
                        // Update the multiplayer status display
                        multiplayerStatus = `Connected - Lobby ${selectedLobby} (${activePlayers.size}/4)`;
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        console.log('Updated player list, total players:', activePlayers.size);
                        break;
                        
                    case 'car-state':
                        // Handle remote car state updates using slot system
                        // Throttled logging for received car states
                        if (!this.lastReceivedCarStateLog || (Date.now() - this.lastReceivedCarStateLog) > 2000) {
                            console.log(`🚗 Receiving car states from other players...`);
                            this.lastReceivedCarStateLog = Date.now();
                        }
                        updatePlayerCarSlot(data.playerId, data.state);
                        break;
                        
                    case 'bot-state':
                        // Handle bot state updates from host
                        if (!isHost && data.botState) {
                            updateRemoteBotState(data.botState);
                        }
                        break;
                        
                    case 'chat-message':
                        console.log(`Chat from ${fromPlayerId}: ${data.message}`);
                        break;
                        
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }

            function sendToAllPlayers(data) {
                connections.forEach((conn, playerId) => {
                    if (conn && conn.open) {
                        conn.send(data);
                    }
                });
            }
            
            function broadcastPlayerList() {
                if (!isHost) return;
                
                // Convert activePlayers Map to array for transmission
                const playerList = Array.from(activePlayers.entries()).map(([id, data]) => ({
                    id: id,
                    isConnected: data.isConnected,
                    isHost: data.isHost
                }));
                
                sendToAllPlayers({
                    type: 'player-list',
                    players: playerList
                });
                
                console.log('Broadcasted player list to all clients:', playerList.length, 'players');
            }

            // Old updateRemoteCarState function removed - now using updatePlayerCarSlot
            
            // Old createRemoteCarMesh function removed - now using createPlayerCarSlots

            function updateRemoteBotState(botState) {
                // TODO: Update bot position/rotation based on host's bot state
                console.log('Received bot state from host:', botState);
            }
            
            function createPlayerCarSlots() {
                console.log('🏗️ Creating 4 player car slots...');
                
                // Colors for each player slot
                const playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
                const playerNames = ['Player 1', 'Player 2', 'Player 3', 'Player 4'];
                
                for (let i = 0; i < 4; i++) {
                    const carGroup = new THREE.Group();
                    
                    // Car body
                    const bodyGeometry = new THREE.BoxGeometry(3.6, 1.2, 8.4);
                    const bodyMaterial = new THREE.MeshBasicMaterial({ 
                        color: playerColors[i],
                        transparent: false,
                        opacity: 1.0
                    });
                    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    bodyMesh.position.y = 0.6;
                    carGroup.add(bodyMesh);
                    
                    // White roof for visibility
                    const topGeometry = new THREE.BoxGeometry(3.0, 0.2, 7.0);
                    const topMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: false,
                        opacity: 1.0
                    });
                    const topMesh = new THREE.Mesh(topGeometry, topMaterial);
                    topMesh.position.y = 1.3;
                    carGroup.add(topMesh);
                    
                    // Wheels
                    const wheelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 8);
                    const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    
                    const wheelPositions = [
                        { x: -1.8, y: 0, z: 2.8 },  // Front left
                        { x: 1.8, y: 0, z: 2.8 },   // Front right
                        { x: -1.8, y: 0, z: -2.8 }, // Rear left
                        { x: 1.8, y: 0, z: -2.8 }   // Rear right
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.position.set(pos.x, pos.y, pos.z);
                        wheel.rotation.z = Math.PI / 2;
                        carGroup.add(wheel);
                    });
                    
                    // Tall marker for debugging
                    const markerGeometry = new THREE.BoxGeometry(0.5, 5.0, 0.5);
                    const markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: playerColors[i],
                        transparent: false,
                        opacity: 1.0
                    });
                    const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
                    markerMesh.position.y = 4.0;
                    carGroup.add(markerMesh);
                    
                    // Set initial position (spread them out)
                    carGroup.position.set(-22 + (i * 2), 1.0, 40 + (i * 2));
                    
                    // Initially hide all cars
                    carGroup.visible = false;
                    
                    // Store car data
                    const carSlot = {
                        mesh: carGroup,
                        slotIndex: i,
                        playerId: null,
                        isActive: false,
                        color: playerColors[i],
                        name: playerNames[i],
                        // Interpolation data
                        targetPosition: new THREE.Vector3(),
                        targetQuaternion: new THREE.Quaternion(),
                        currentPosition: new THREE.Vector3(),
                        currentQuaternion: new THREE.Quaternion(),
                        interpolationSpeed: 10.0
                    };
                    
                    playerCarSlots.push(carSlot);
                    scene.add(carGroup);
                    
                    console.log(`✅ Created player car slot ${i} (${playerNames[i]}) with color:`, playerColors[i].toString(16));
                }
                
                console.log(`🎮 Created ${playerCarSlots.length} player car slots`);
            }
            
            function assignPlayerToSlot(playerId) {
                // Host (player_0) should never be assigned to a slot - they use physics car
                if (playerId === 'player_0') {
                    console.log(`🏠 Host ${playerId} uses physics car, not slot system`);
                    return -1;
                }
                
                // Clients start from slot 1 (skip slot 0 which is reserved for host representation)
                for (let i = 1; i < playerCarSlots.length; i++) {
                    const slot = playerCarSlots[i];
                    if (!slot.isActive) {
                        slot.playerId = playerId;
                        slot.isActive = true;
                        slot.mesh.visible = true;
                        playerSlotAssignments.set(playerId, i);
                        
                        console.log(`🎯 Assigned ${playerId} to slot ${i} (${slot.name})`);
                        return i;
                    }
                }
                
                console.log(`⚠️ No available slots for ${playerId}`);
                return -1;
            }
            
            function removePlayerFromSlot(playerId) {
                const slotIndex = playerSlotAssignments.get(playerId);
                if (slotIndex !== undefined && slotIndex >= 0) {
                    const slot = playerCarSlots[slotIndex];
                    slot.playerId = null;
                    slot.isActive = false;
                    slot.mesh.visible = false;
                    playerSlotAssignments.delete(playerId);
                    
                    console.log(`🚫 Removed ${playerId} from slot ${slotIndex} (${slot.name})`);
                    return true;
                }
                
                console.log(`⚠️ Player ${playerId} not found in any slot`);
                return false;
            }
            
            function updatePlayerCarSlot(playerId, state) {
                // Skip updating our own car (host or client uses physics car, not slot)
                if (playerId === myPlayerId) {
                    return;
                }
                
                // Special handling for host (player_0) - use slot 0 for host representation
                if (playerId === 'player_0') {
                    const hostSlot = playerCarSlots[0];
                    if (hostSlot) {
                        // Activate host slot for remote representation
                        if (!hostSlot.isActive) {
                            hostSlot.isActive = true;
                            hostSlot.playerId = playerId;
                            hostSlot.mesh.visible = true;
                            console.log(`🏠 Activated host representation in slot 0`);
                        }
                        
                        // Update host position
                        if (state.position && state.quaternion) {
                            hostSlot.targetPosition.set(state.position.x, state.position.y, state.position.z);
                            hostSlot.targetQuaternion.set(state.quaternion.x, state.quaternion.y, state.quaternion.z, state.quaternion.w);
                            
                            if (hostSlot.currentPosition.length() === 0) {
                                hostSlot.currentPosition.copy(hostSlot.targetPosition);
                                hostSlot.currentQuaternion.copy(hostSlot.targetQuaternion);
                                hostSlot.mesh.position.copy(hostSlot.currentPosition);
                                hostSlot.mesh.quaternion.copy(hostSlot.currentQuaternion);
                                console.log(`🎯 Initial host position set in slot 0 at (${state.position.x.toFixed(1)}, ${state.position.y.toFixed(1)}, ${state.position.z.toFixed(1)})`);
                            }
                        }
                    }
                    return;
                }
                
                const slotIndex = playerSlotAssignments.get(playerId);
                if (slotIndex === undefined || slotIndex < 0) {
                    console.log(`⚠️ No slot assigned for ${playerId}`);
                    return;
                }
                
                const slot = playerCarSlots[slotIndex];
                if (!slot || !slot.isActive) {
                    console.log(`⚠️ Slot ${slotIndex} not active for ${playerId}`);
                    return;
                }
                
                // Update target position and rotation for smooth interpolation
                if (state.position && state.quaternion) {
                    slot.targetPosition.set(state.position.x, state.position.y, state.position.z);
                    slot.targetQuaternion.set(state.quaternion.x, state.quaternion.y, state.quaternion.z, state.quaternion.w);
                    
                    // If this is the first update, set current position immediately
                    if (slot.currentPosition.length() === 0) {
                        slot.currentPosition.copy(slot.targetPosition);
                        slot.currentQuaternion.copy(slot.targetQuaternion);
                        slot.mesh.position.copy(slot.currentPosition);
                        slot.mesh.quaternion.copy(slot.currentQuaternion);
                        console.log(`🎯 Initial position set for ${playerId} in slot ${slotIndex} at (${state.position.x.toFixed(1)}, ${state.position.y.toFixed(1)}, ${state.position.z.toFixed(1)})`);
                    }
                }
            }
            
            function updatePlayerCarSlotsInterpolation(dt) {
                if (!playerCarSlots || playerCarSlots.length === 0) return;
                
                // Count active slots
                const activeSlots = playerCarSlots.filter(slot => slot.isActive);
                if (activeSlots.length === 0) return;
                
                // Throttled logging for interpolation
                if (!this.lastSlotInterpolationLog || (Date.now() - this.lastSlotInterpolationLog) > 3000) {
                    console.log(`🔄 Interpolating ${activeSlots.length} active player car slots...`);
                    this.lastSlotInterpolationLog = Date.now();
                }
                
                playerCarSlots.forEach((slot, index) => {
                    if (!slot.isActive) return;
                    
                    // Smooth interpolation towards target position
                    const lerpFactor = Math.min(1.0, slot.interpolationSpeed * dt);
                    
                    // Store old position for logging
                    const oldPos = slot.mesh.position.clone();
                    
                    // Interpolate position
                    slot.currentPosition.lerp(slot.targetPosition, lerpFactor);
                    slot.mesh.position.copy(slot.currentPosition);
                    
                    // Interpolate rotation (slerp for quaternions)
                    slot.currentQuaternion.slerp(slot.targetQuaternion, lerpFactor);
                    slot.mesh.quaternion.copy(slot.currentQuaternion);
                    
                    // Log position changes occasionally
                    if (!this.lastSlotPositionLog || (Date.now() - this.lastSlotPositionLog) > 5000) {
                        const distance = oldPos.distanceTo(slot.mesh.position);
                        if (distance > 0.1) { // Only log if there's significant movement
                            console.log(`🚗 ${slot.playerId} (slot ${index}) moved ${distance.toFixed(2)}m to (${slot.mesh.position.x.toFixed(1)}, ${slot.mesh.position.y.toFixed(1)}, ${slot.mesh.position.z.toFixed(1)})`);
                            this.lastSlotPositionLog = Date.now();
                        }
                    }
                });
            }

            function switchCamera() {
                if (renderer.xr.isPresenting) {
                    // VR mode: cycle through firstperson -> fly -> firstperson
                    if (cameraMode === 'firstperson') {
                        cameraMode = 'fly';
                        // Initialize fly camera position if not set
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            vrFlyPosition.copy(vehicleRef.chassisMesh.position);
                            vrFlyPosition.y += 10; // Start 10m above the car
                        } else {
                            // Fallback position if car not ready yet
                            vrFlyPosition.set(0, 15, -20);
                        }
                        // Reset rotation when entering fly mode
                        vrFlyRotation.set(0, 0, 0);
                        console.log('Switched to VR fly camera');
                    } else if (cameraMode === 'fly') {
                        cameraMode = 'firstperson';
                        console.log('Switched to VR first-person camera');
                    } else {
                        // From orbit to firstperson in VR
                        cameraMode = 'firstperson';
                        cameraRig.remove(orbitCamera);
                        cameraRig.add(firstPersonCamera);
                        console.log('Switched to VR first-person camera');
                    }
                } else {
                    // Desktop mode: cycle through firstperson -> orbit -> firstperson
                    if (cameraMode === 'orbit') {
                        cameraMode = 'firstperson';
                        camera = firstPersonCamera;
                        controls.enabled = false; // Disable orbit controls in first person
                        
                        console.log('Switched to first-person camera');
                    } else {
                        cameraMode = 'orbit';
                        camera = orbitCamera;
                        controls.enabled = true; // Re-enable orbit controls
                        
                        console.log('Switched to orbit camera');
                    }
                }
            }

            function resetCar() {
                if (vehicleRef && vehicleRef.vehicle && vehicleRef.vehicleBody) {
                    try {
                        // Reset to last passed checkpoint
                        var resetPosition;
                        console.log('🔍 Reset Debug - Checkpoints:', checkpointMarkers ? checkpointMarkers.length : 'null', 'LastPassed:', playerLastPassedCheckpoint, 'Current:', playerCurrentCheckpoint);
                        
                        if (checkpointMarkers && checkpointMarkers.length > 0 && playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) {
                            var checkpoint = checkpointMarkers[playerLastPassedCheckpoint];
                            if (checkpoint && checkpoint.position) {
                                resetPosition = checkpoint.position.clone();
                                // Get the actual road surface elevation at this X,Z position
                                var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                
                                // Safety check: if calculated elevation is much lower than checkpoint, use checkpoint + extra height
                                var checkpointY = checkpoint.position.y;
                                if (actualRoadElevation < checkpointY - 10) {
                                    console.warn('⚠️ Calculated road elevation seems too low, using checkpoint elevation + safety margin');
                                    resetPosition.y = checkpointY + 2; // 2m above checkpoint position for safety
                                } else {
                                    resetPosition.y = actualRoadElevation + 1; // 1m above calculated road surface
                                }
                                console.log('🚗 Resetting to checkpoint', playerLastPassedCheckpoint);
                                console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                console.log('   Calculated road elevation:', actualRoadElevation.toFixed(1));
                                console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                            } else {
                                console.warn('Checkpoint', playerLastPassedCheckpoint, 'has no position data, using default');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        } else {
                            // If checkpoints exist but playerLastPassedCheckpoint is invalid, use checkpoint 0
                            if (checkpointMarkers && checkpointMarkers.length > 0) {
                                console.warn('Invalid playerLastPassedCheckpoint, using checkpoint 0');
                                var checkpoint = checkpointMarkers[0];
                                if (checkpoint && checkpoint.position) {
                                    resetPosition = checkpoint.position.clone();
                                    var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                    var checkpointY = checkpoint.position.y;
                                    if (actualRoadElevation < checkpointY - 10) {
                                        resetPosition.y = checkpointY + 2;
                                    } else {
                                        resetPosition.y = actualRoadElevation + 1;
                                    }
                                    console.log('🚗 Resetting to checkpoint 0 (fallback)');
                                    console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                    console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                                } else {
                                    console.warn('Checkpoint 0 has no position data, using default position');
                                    resetPosition = new THREE.Vector3(0, 0, -20);
                                    var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                    resetPosition.y = defaultRoadElevation + 1;
                                }
                            } else {
                                console.warn('No valid checkpoints available, using default position');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        }
                        
                        // Calculate orientation toward next checkpoint
                        var resetRotation = new THREE.Quaternion(0, 0, 0, 1); // Default rotation
                        if (checkpointMarkers && checkpointMarkers.length > 0) {
                            // Use valid checkpoint index for orientation calculation
                            var currentCheckpointIndex = (playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) ? playerLastPassedCheckpoint : 0;
                            var nextCheckpointIndex = (currentCheckpointIndex + 1) % checkpointMarkers.length;
                            var nextCheckpoint = checkpointMarkers[nextCheckpointIndex];
                            if (nextCheckpoint && nextCheckpoint.position) {
                                // Calculate direction to next checkpoint
                                var direction = new THREE.Vector3().subVectors(nextCheckpoint.position, resetPosition);
                                direction.y = 0; // Keep horizontal
                                direction.normalize();
                                
                                // Calculate rotation to face that direction
                                var angle = Math.atan2(direction.x, direction.z);
                                resetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                                
                                console.log('🧭 Player respawn facing toward checkpoint', nextCheckpointIndex, 'from current', currentCheckpointIndex);
                            }
                        }
                        
                        var resetTransform = new Ammo.btTransform();
                        resetTransform.setIdentity();
                        resetTransform.setOrigin(new Ammo.btVector3(resetPosition.x, resetPosition.y, resetPosition.z));
                        resetTransform.setRotation(new Ammo.btQuaternion(resetRotation.x, resetRotation.y, resetRotation.z, resetRotation.w));
                        
                        vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                        vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                        vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                        
                        console.log('✅ Car reset successfully to position:', resetPosition);
                    } catch (error) {
                        console.error('❌ Error during car reset:', error);
                        // Fallback to default position
                        try {
                            var fallbackPosition = new THREE.Vector3(0, 0, -20);
                            var fallbackRoadElevation = getRoadSurfaceElevation(0, -20);
                            fallbackPosition.y = fallbackRoadElevation + 1; // 1m above road surface
                            var resetTransform = new Ammo.btTransform();
                            resetTransform.setIdentity();
                            resetTransform.setOrigin(new Ammo.btVector3(fallbackPosition.x, fallbackPosition.y, fallbackPosition.z));
                            // Use default forward orientation for fallback
                            resetTransform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));
                            
                            vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                            vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                            vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                            
                            console.log('🔄 Fallback reset to default position successful');
                        } catch (fallbackError) {
                            console.error('❌ Fallback reset also failed:', fallbackError);
                        }
                    }
                } else {
                    console.warn('⚠️ Cannot reset car: vehicle reference not available');
                }
            }
            
            function checkCheckpointProgress(carPosition) {
                if (!checkpointMarkers || checkpointMarkers.length === 0) return;
                
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                // Check if player is close enough to the next checkpoint
                var distance = carPosition.distanceTo(checkpoint.position);
                if (distance < 15) { // 15 meter detection radius
                    // Checkpoint passed!
                    playerLastPassedCheckpoint = playerCurrentCheckpoint;
                    playerCurrentCheckpoint++;
                    
                    console.log('✅ Checkpoint', nextIndex, 'passed! Last:', playerLastPassedCheckpoint, 'Next:', playerCurrentCheckpoint);
                    
                    // Update visual indicator
                    updateNextCheckpointMarker();
                    
                    // Check for lap completion (when we've passed all checkpoints)
                    if (playerCurrentCheckpoint >= checkpointMarkers.length) {
                        // Lap completed!
                        var lapTime = (Date.now() - currentLapStartTime) / 1000;
                        lapTimes.push(lapTime);
                        
                        // Check if it's a new best time
                        if (bestLapTime === null || lapTime < bestLapTime) {
                            bestLapTime = lapTime;
                            saveBestTime(lapTime); // Save to localStorage
                            console.log('🏆 NEW BEST LAP TIME!', formatLapTime(lapTime));
                        } else {
                            console.log('🏁 LAP COMPLETED!', formatLapTime(lapTime));
                        }
                        
                        // Start new lap
                        currentLapNumber++;
                        currentLapStartTime = Date.now();
                        playerLastPassedCheckpoint = 0; // Reset checkpoint progress for new lap
                        playerCurrentCheckpoint = 1; // Reset current checkpoint to 1 (next checkpoint to reach)
                        
                        console.log('Starting lap', currentLapNumber, '- checkpoint progress reset to 0, next checkpoint: 1');
                    }
                }
                
                // Update pulsing animation for next checkpoint marker
                if (nextCheckpointMarker && nextCheckpointMarker.userData) {
                    nextCheckpointMarker.userData.pulseTime += 0.1;
                    var scale = 1 + 0.3 * Math.sin(nextCheckpointMarker.userData.pulseTime);
                    nextCheckpointMarker.scale.setScalar(scale);
                }
                
                // Update HUD displays
                if (renderer.xr.isPresenting) {
                    updateVRHUD(); // VR users see 3D HUD
                } else {
                    updateDesktopHUD(); // Desktop users see HTML HUD
                }
            }

            function createBox(pos, quat, w, l, h, mass, friction) {
                var material = mass > 0 ? materialDynamic : materialStatic;
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5));

                if (!mass) mass = 0;
                if (!friction) friction = 1;

                var mesh = new THREE.Mesh(shape, material);
                mesh.position.copy(pos);
                mesh.quaternion.copy(quat);
                scene.add(mesh);

                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);

                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(mass, localInertia);

                var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, geometry, localInertia);
                var body = new Ammo.btRigidBody(rbInfo);

                body.setFriction(friction);
                physicsWorld.addRigidBody(body);

                if (mass > 0) {
                    body.setActivationState(DISABLE_DEACTIVATION);
                    // Sync physics and graphics
                    function sync(dt) {
                        var ms = body.getMotionState();
                        if (ms) {
                            ms.getWorldTransform(TRANSFORM_AUX);
                            var p = TRANSFORM_AUX.getOrigin();
                            var q = TRANSFORM_AUX.getRotation();
                            mesh.position.set(p.x(), p.y(), p.z());
                            mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                        }
                    }
                    syncList.push(sync);
                }
            }

            function createWheelMesh(radius, width) {
                var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                t.rotateZ(Math.PI / 2);
                var mesh = new THREE.Mesh(t, materialInteractive);
                mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), materialInteractive));
                scene.add(mesh);
                return mesh;
            }

            function createChassisMesh(w, l, h) {
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var mesh = new THREE.Mesh(shape, materialInteractive);
                scene.add(mesh);
                return mesh;
            }

            function createBotVehicle(pos, quat, color) {
                // Vehicle constants (same as player car)
                var chassisWidth = 1.8;
                var chassisHeight = .6;
                var chassisLength = 4;
                var massVehicle = 800;

                var wheelAxisPositionBack = -1;
                var wheelRadiusBack = .4;
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1;
                var wheelAxisHeightBack = .3;

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1;
                var wheelAxisHeightFront = .3;
                var wheelRadiusFront = .35;
                var wheelWidthFront = .2;

                var friction = 1000;
                var suspensionStiffness = 20.0;
                var suspensionDamping = 2.3;
                var suspensionCompression = 4.4;
                var suspensionRestLength = 0.6;
                var rollInfluence = 0.2;

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2000;
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Ensure the bot body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                
                // Create bot chassis mesh with different color
                var botMaterial = new THREE.MeshPhongMaterial({ color: color || 0x0066ff });
                var chassisShape = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                var chassisMesh = new THREE.Mesh(chassisShape, botMaterial);
                scene.add(chassisMesh);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store bot vehicle reference
                var botRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh,
                    currentWaypointIndex: 0,
                    targetSpeed: 60, // km/h
                    waypointReachDistance: 8.0, // Distance to consider waypoint "reached" (increased)
                    debugCounter: 0,
                    // Predictive steering parameters
                    lookAheadWaypoints: 5, // Number of waypoints to look ahead
                    steeringSmoothing: 0.15, // Steering smoothing factor (0-1)
                    previousSteering: 0, // For smooth steering transitions
                    // Dynamic speed parameters
                    maxCornerSpeed: 80, // km/h - maximum speed through corners
                    brakingDistance: 25, // meters - distance to start braking before corners
                    cornerSpeedFactor: 0.6, // Speed reduction factor for tight corners
                    // Stuck detection parameters
                    lastPosition: new THREE.Vector3(-5, 0, -45), // Track last position
                    lastWaypointReached: 0, // Last successfully reached waypoint
                    stuckCheckInterval: 180, // Check every 3 seconds (60fps * 3)
                    stuckDistanceThreshold: 2.0, // If moved less than 2m in 3 seconds
                    stuckSpeedThreshold: 5.0, // If speed is below 5 km/h for too long
                    lowSpeedCounter: 0, // Counter for low speed duration
                    stuckCounter: 0, // Counter for stuck detection
                    lastRespawnTime: 0, // Prevent rapid respawning
                    // Obstacle avoidance parameters
                    avoidanceRayLength: 15, // meters - how far ahead to look for obstacles
                    avoidanceForce: 0.8, // Steering force when avoiding obstacles
                    sideRayAngle: 30, // degrees - angle for side detection rays
                    obstacleAvoidanceActive: false // Track if currently avoiding
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                
                var wheelMeshes = [];
                
                // Create visual target marker (10m high green column)
                var markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 8);
                var markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, // Bright green
                    transparent: true,
                    opacity: 0.8
                });
                botTargetMarker = new THREE.Mesh(markerGeometry, markerMaterial);
                botTargetMarker.position.set(0, 5, 0); // 5m high (half of 10m cylinder)
                scene.add(botTargetMarker);
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    // Create wheel mesh with bot color
                    var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                    t.rotateZ(Math.PI / 2);
                    var mesh = new THREE.Mesh(t, botMaterial);
                    mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), botMaterial));
                    scene.add(mesh);
                    wheelMeshes[index] = mesh;
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Bot AI sync function
                function botSync(dt) {
                    botRef.debugCounter++;
                    var speed = vehicle.getCurrentSpeedKmHour();

                    // Get current car position
                    var tm = vehicle.getChassisWorldTransform();
                    var p = tm.getOrigin();
                    var q = tm.getRotation();
                    var carPos = new THREE.Vector3(p.x(), p.y(), p.z());
                    var carQuat = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());

                    // Update chassis mesh
                    chassisMesh.position.set(p.x(), p.y(), p.z());
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    
                    // Send car state to other players (throttled to 10Hz)
                    if (isMultiplayer && connections.size > 0) {
                        if (!this.lastMultiplayerSync || (Date.now() - this.lastMultiplayerSync) > 100) {
                            const carState = {
                                type: 'car-state',
                                playerId: myPlayerId || 'player_0',
                                state: {
                                    position: { x: p.x(), y: p.y(), z: p.z() },
                                    quaternion: { x: q.x(), y: q.y(), z: q.z(), w: q.w() },
                                    speed: speed
                                }
                            };
                            // Throttled logging for car state sending
                            if (!this.lastCarStateLog || (Date.now() - this.lastCarStateLog) > 2000) {
                                console.log(`📡 Sending car state from ${carState.playerId} to ${connections.size} players`);
                                this.lastCarStateLog = Date.now();
                            }
                            sendToAllPlayers(carState);
                            this.lastMultiplayerSync = Date.now();
                        }
                    }

                    // Update wheel meshes
                    var n = vehicle.getNumWheels();
                    for (var i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        var wheelTm = vehicle.getWheelTransformWS(i);
                        var wheelP = wheelTm.getOrigin();
                        var wheelQ = wheelTm.getRotation();
                        wheelMeshes[i].position.set(wheelP.x(), wheelP.y(), wheelP.z());
                        wheelMeshes[i].quaternion.set(wheelQ.x(), wheelQ.y(), wheelQ.z(), wheelQ.w());
                    }


                    // Initialize forces
                    breakingForce = 0;
                    engineForce = 0;

                    // AI Navigation Logic - Advanced Predictive System
                    if (denseWaypoints.length > 0) {
                        // Get current target waypoint
                        var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                        var targetPoint = targetWaypoint.position;
                        
                        // Check if we've reached the current waypoint
                        var distanceToWaypoint = carPos.distanceTo(targetPoint);
                        
                        if (distanceToWaypoint < botRef.waypointReachDistance) {
                            // Move to next waypoint
                            var oldIndex = botRef.currentWaypointIndex;
                            botRef.lastWaypointReached = oldIndex; // Track last successful waypoint
                            botRef.currentWaypointIndex = (botRef.currentWaypointIndex + 1) % denseWaypoints.length;
                            // Only log lap completion (when reaching waypoint 0 again)
                            if (botRef.currentWaypointIndex === 0) {
                                console.log('🏁 Bot completed a lap!');
                            }
                            targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                            targetPoint = targetWaypoint.position;
                            distanceToWaypoint = carPos.distanceTo(targetPoint);
                            
                            // Reset stuck detection counters on successful waypoint reach
                            botRef.stuckCounter = 0;
                            botRef.lowSpeedCounter = 0;
                        }

                        // Get car's forward direction (positive Z is forward in our coordinate system)
                        var carForward = new THREE.Vector3(0, 0, 1);
                        carForward.applyQuaternion(carQuat);

                        // OBSTACLE AVOIDANCE: Check for obstacles and calculate avoidance steering
                        var avoidanceResult = checkObstacles(carPos, carQuat, carForward, speed, botRef);
                        
                        var finalSteerAmount;
                        if (avoidanceResult.shouldAvoid) {
                            // SMART OBSTACLE AVOIDANCE: Check if we should reverse or steer around
                            var distanceFromPath = findDistanceFromPath(carPos, botRef);
                            var maxPathDeviation = 15.0; // Maximum distance allowed from racing line
                            var obstacleDistance = avoidanceResult.closestDistance;
                            
                            // If obstacle is very close and we're already far from path, consider reversing
                            if (obstacleDistance < 8.0 && distanceFromPath > maxPathDeviation) {
                                console.log('🔄 OBSTACLE TOO CLOSE & FAR FROM PATH! Reversing to find alternate route');
                                finalSteerAmount = 0; // Don't steer while reversing
                                targetSpeedKmh = -20; // Reverse at 20 km/h
                                shouldBrake = false; // Don't brake while reversing
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If obstacle is blocking and we have multiple hits (surrounded), reverse
                            else if (avoidanceResult.multipleHits && obstacleDistance < 10.0) {
                                console.log('🚫 SURROUNDED BY OBSTACLES! Reversing to escape');
                                finalSteerAmount = avoidanceResult.avoidanceSteer * 0.5; // Gentle steering while reversing
                                targetSpeedKmh = -15; // Reverse slower when surrounded
                                shouldBrake = false;
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If we're close to path, try normal steering avoidance
                            else if (distanceFromPath < maxPathDeviation) {
                                console.log('🚧 STEERING AROUND OBSTACLE! Steer:', avoidanceResult.avoidanceSteer.toFixed(2), 'Distance:', obstacleDistance.toFixed(1) + 'm');
                                finalSteerAmount = avoidanceResult.avoidanceSteer;
                                targetSpeedKmh = Math.min(targetSpeedKmh, 25); // Slow down while avoiding
                                botRef.obstacleAvoidanceActive = true;
                            }
            // If too far from path, return to path first
            else {
                console.log('📍 TOO FAR FROM PATH! Returning to racing line first');
                try {
                    // Calculate direction back to nearest path point
                    var nearestPathPoint = findNearestPathPoint(carPos);
                    if (nearestPathPoint && nearestPathPoint.point) {
                        var backToPath = new THREE.Vector3().subVectors(nearestPathPoint.point, carPos).normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, backToPath);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 1.5));
                        targetSpeedKmh = Math.min(targetSpeedKmh, 30); // Moderate speed returning to path
                        botRef.obstacleAvoidanceActive = true;
                    } else {
                        // Fallback: use normal path following if nearest point not found
                        var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                        var toTarget = new THREE.Vector3().subVectors(lookAheadPoint, carPos);
                        var toTargetNormalized = toTarget.clone().normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 2.0));
                        botRef.obstacleAvoidanceActive = false;
                    }
                } catch (e) {
                    console.warn('Error calculating return to path:', e);
                    // Fallback to normal navigation
                    finalSteerAmount = 0;
                    botRef.obstacleAvoidanceActive = false;
                }
            }
                        } else {
                            // PREDICTIVE STEERING: Look ahead multiple waypoints
                            var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                            
                            // Calculate steering toward look-ahead point
                            var toTarget = new THREE.Vector3()
                                .subVectors(lookAheadPoint, carPos);
                            
                            var toTargetNormalized = toTarget.clone().normalize();

                            // Calculate raw steering using cross product
                            var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                            var rawSteerAmount = cross.y; // Raw steering direction (fixed with correct forward vector)
                            
                            finalSteerAmount = Math.max(-1.0, Math.min(1.0, rawSteerAmount * 2.0));
                            botRef.obstacleAvoidanceActive = false;
                        }
                        
                        // STEERING SMOOTHING: Blend with previous steering for realistic transitions
                        var steerAmount = botRef.previousSteering + (finalSteerAmount - botRef.previousSteering) * botRef.steeringSmoothing;
                        botRef.previousSteering = steerAmount;

                        // Apply smoothed steering
                        vehicleSteering = steerAmount;
                        
                        // Update visual target marker to show where bot is heading
                        if (botTargetMarker) {
                            botTargetMarker.position.set(targetPoint.x, 5, targetPoint.z);
                        }

                        // DYNAMIC SPEED CONTROL: Analyze upcoming corners and adjust speed
                        var speedAnalysis = calculateOptimalSpeed(carPos, speed, botRef);
                        var targetSpeedKmh = speedAnalysis.targetSpeed;
                        var shouldBrake = speedAnalysis.shouldBrake;

                        // Apply throttle/brake - always try to move forward
                        breakingForce = 0;
                        engineForce = 0;

                        var absSpeed = Math.abs(speed);
                        
                        // REALISTIC BRAKING AND ACCELERATION
                        if (shouldBrake || absSpeed > targetSpeedKmh + 3) {
                            // Brake for corners or overspeed
                            var brakeIntensity = shouldBrake ? 0.8 : 0.6;
                            breakingForce = maxBreakingForce * brakeIntensity;
                            engineForce = 0;
                        } else if (absSpeed < targetSpeedKmh - 3) {
                            // Accelerate when under target speed
                            var accelIntensity = (targetSpeedKmh - absSpeed) / targetSpeedKmh;
                            engineForce = maxEngineForce * Math.min(0.9, accelIntensity + 0.3);
                            breakingForce = 0;
                        } else if (absSpeed < 5) {
                            // If moving very slowly, give it a push
                            engineForce = maxEngineForce * 0.5;
                            breakingForce = 0;
                        } else {
                            // Maintain speed - slight throttle
                            engineForce = maxEngineForce * 0.2;
                            breakingForce = 0;
                        }

                        // STUCK DETECTION AND RECOVERY SYSTEM
                        var stuckDetected = checkIfStuck(carPos, speed, botRef);
                        if (stuckDetected) {
                            respawnBot(botRef);
                        }

                        // Minimal debug output - only show important events
                        if (botRef.debugCounter % 600 === 0) { // Every 10 seconds instead of 5
                            var status = '🏎️ Bot: ' + speed.toFixed(0) + 'km/h | WP:' + botRef.currentWaypointIndex + '/' + denseWaypoints.length;
                            if (botRef.stuckCounter > 0) status += ' ⚠️ STUCK:' + botRef.stuckCounter;
                            console.log(status);
                        }
                    } else {
                        // No racing path - simple forward movement for testing
                        if (botRef.debugCounter % 180 === 0) {
                            console.log('Bot: No racing path found, applying basic forward movement');
                        }
                        engineForce = maxEngineForce * 0.8; // More throttle
                        vehicleSteering = 0; // Straight
                    }

                    // Apply forces to vehicle
                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);
                    
                    // Update bot engine sound
                    if (botEngineSound) {
                        var throttle = Math.abs(engineForce) / maxEngineForce; // Normalize throttle (0-1)
                        var speedKmh = Math.abs(speed);
                        botEngineSound.updateEngine(speedKmh, throttle);
                    }
                    
                }

                // PREDICTIVE STEERING: Calculate look-ahead point based on speed and upcoming corners
                function calculateLookAheadPoint(carPos, speed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(speed);
                    
                    // Dynamic look-ahead distance based on speed (faster = look further ahead)
                    var baseLookAhead = Math.max(2, Math.min(8, absSpeed / 10)); // 2-8 waypoints
                    var lookAheadCount = Math.floor(baseLookAhead);
                    
                    // Find the look-ahead waypoint
                    var lookAheadIndex = (currentIndex + lookAheadCount) % denseWaypoints.length;
                    var lookAheadWaypoint = denseWaypoints[lookAheadIndex];
                    
                    // RACING LINE OPTIMIZATION: Adjust target point for optimal cornering
                    var optimizedPoint = calculateRacingLine(lookAheadWaypoint, lookAheadIndex, botRef);
                    
                    return optimizedPoint;
                }
                
                // RACING LINE: Calculate optimal path through corners
                function calculateRacingLine(waypoint, waypointIndex, botRef) {
                    var basePoint = waypoint.position.clone();
                    
                    // Analyze corner by looking at surrounding waypoints
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner direction and sharpness
                    var inVector = new THREE.Vector3().subVectors(basePoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, basePoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // If it's a corner (angle > threshold), optimize the racing line
                    if (cornerAngle > 0.3) { // ~17 degrees
                        // Calculate corner center and radius
                        var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                        var offsetDistance = Math.min(4, cornerSharpness * 6); // Max 4m offset
                        
                        // Determine if it's a left or right corner
                        var cross = new THREE.Vector3().crossVectors(inVector, outVector);
                        var isLeftCorner = cross.y > 0;
                        
                        // Calculate perpendicular offset for racing line
                        var perpendicular = new THREE.Vector3(-inVector.z, 0, inVector.x);
                        if (!isLeftCorner) perpendicular.multiplyScalar(-1);
                        
                        // Apply racing line offset (late apex)
                        basePoint.add(perpendicular.multiplyScalar(offsetDistance * 0.7));
                    }
                    
                    return basePoint;
                }
                
                // DYNAMIC SPEED CONTROL: Calculate optimal speed based on upcoming corners
                function calculateOptimalSpeed(carPos, currentSpeed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(currentSpeed);
                    var maxSpeed = botRef.targetSpeed;
                    var shouldBrake = false;
                    
                    // Look ahead for corners within braking distance
                    var lookAheadDistance = 0;
                    var minCornerSpeed = maxSpeed;
                    
                    for (var i = 0; i < 15; i++) { // Check next 15 waypoints (~30m ahead)
                        var checkIndex = (currentIndex + i) % denseWaypoints.length;
                        var waypoint = denseWaypoints[checkIndex];
                        
                        if (i > 0) {
                            var prevWaypoint = denseWaypoints[(currentIndex + i - 1) % denseWaypoints.length];
                            lookAheadDistance += waypoint.position.distanceTo(prevWaypoint.position);
                        }
                        
                        // Analyze corner sharpness
                        var cornerSpeed = analyzeCornerSpeed(checkIndex, botRef);
                        
                        if (cornerSpeed < minCornerSpeed) {
                            minCornerSpeed = cornerSpeed;
                            
                            // If we need to slow down significantly and we're within braking distance
                            if (absSpeed > cornerSpeed + 10 && lookAheadDistance < botRef.brakingDistance) {
                                shouldBrake = true;
                            }
                        }
                        
                        // Stop looking if we're far enough ahead
                        if (lookAheadDistance > botRef.brakingDistance) break;
                    }
                    
                    // Calculate target speed
                    var targetSpeed = Math.max(minCornerSpeed, maxSpeed * 0.4); // Minimum 40% of max speed
                    
                    // Smooth speed transitions
                    if (targetSpeed < absSpeed) {
                        targetSpeed = Math.max(targetSpeed, absSpeed - 15); // Don't brake too hard
                    }
                    
                    return {
                        targetSpeed: targetSpeed,
                        shouldBrake: shouldBrake,
                        cornerSpeed: minCornerSpeed
                    };
                }
                
                // Analyze corner speed based on turn radius and sharpness
                function analyzeCornerSpeed(waypointIndex, botRef) {
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var currentPoint = denseWaypoints[waypointIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner angle
                    var inVector = new THREE.Vector3().subVectors(currentPoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, currentPoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // Calculate safe corner speed based on angle
                    var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                    var baseCornerSpeed = botRef.maxCornerSpeed;
                    
                    if (cornerSharpness > 0.1) { // If it's actually a corner
                        // Sharper corners = slower speeds
                        var speedReduction = Math.pow(cornerSharpness, 0.7); // Smooth curve
                        baseCornerSpeed *= (1.0 - speedReduction * botRef.cornerSpeedFactor);
                    }
                    
                    return Math.max(baseCornerSpeed, 20); // Minimum 20 km/h
                }
                
                // STUCK DETECTION: Check if bot is stuck and needs respawning
                function checkIfStuck(currentPos, currentSpeed, botRef) {
                    var absSpeed = Math.abs(currentSpeed);
                    var currentTime = botRef.debugCounter;
                    
                    // Prevent rapid respawning (minimum 10 seconds between respawns)
                    if (currentTime - botRef.lastRespawnTime < 600) {
                        return false;
                    }
                    
                    // Get target waypoint for vertical position checking
                    var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                    var stuckByElevation = false;
                    
                    if (targetWaypoint) {
                        // Check if bot is at significantly wrong elevation
                        var targetY = targetWaypoint.position.y;
                        var currentY = currentPos.y;
                        var verticalDistance = Math.abs(currentY - targetY);
                        
                        // If bot is more than 8 meters above or below target elevation
                        if (verticalDistance > 8) {
                            botRef.verticalStuckCounter = (botRef.verticalStuckCounter || 0) + 1;
                            
                            // If stuck at wrong elevation for 5 seconds
                            if (botRef.verticalStuckCounter > 300) {
                                console.log('🏔️ Bot stuck at wrong elevation! Current Y:', currentY.toFixed(1), 'Target Y:', targetY.toFixed(1), 'Diff:', verticalDistance.toFixed(1) + 'm');
                                stuckByElevation = true;
                            }
                        } else {
                            botRef.verticalStuckCounter = 0; // Reset if elevation is good
                        }
                    }
                    
                    // Check if speed is too low for too long
                    if (absSpeed < botRef.stuckSpeedThreshold) {
                        botRef.lowSpeedCounter++;
                    } else {
                        botRef.lowSpeedCounter = 0; // Reset if speed is good
                    }
                    
                    // Check position movement every interval
                    if (botRef.debugCounter % botRef.stuckCheckInterval === 0) {
                        var distanceMoved = currentPos.distanceTo(botRef.lastPosition);
                        
                        // If bot hasn't moved much in the check interval
                        if (distanceMoved < botRef.stuckDistanceThreshold) {
                            botRef.stuckCounter++;
                            // Reduced stuck detection logging
                        } else {
                            botRef.stuckCounter = 0; // Reset if moving well
                        }
                        
                        // Update last position for next check
                        botRef.lastPosition.copy(currentPos);
                    }
                    
                    // Declare stuck if:
                    // 1. Low speed for more than 5 seconds (300 frames)
                    // 2. OR not moving for 2 consecutive checks (6 seconds)
                    // 3. OR wrong elevation for more than 5 seconds
                    var stuckBySpeed = botRef.lowSpeedCounter > 300;
                    var stuckByPosition = botRef.stuckCounter >= 2;
                    
                    if (stuckBySpeed || stuckByPosition || stuckByElevation) {
                        var reason = stuckByElevation ? 'WRONG ELEVATION' : 
                                   stuckBySpeed ? 'LOW SPEED' : 'NO MOVEMENT';
                        console.log('🚨 Bot STUCK (' + reason + ') - Respawning...');
                        return true;
                    }
                    
                    return false;
                }
                
                // RESPAWN BOT: Teleport bot to last reached waypoint with correct orientation
                function respawnBot(botRef) {
                    // Get respawn waypoint (last successfully reached waypoint)
                    var respawnWaypoint = denseWaypoints[botRef.lastWaypointReached];
                    var respawnPos = respawnWaypoint.position.clone();
                    
                    // Get the actual road surface elevation at this position
                    var actualRoadElevation = getRoadSurfaceElevation(respawnPos.x, respawnPos.z);
                    
                    // Safety check: if calculated elevation is much lower than waypoint, use waypoint + extra height
                    var waypointY = respawnWaypoint.position.y;
                    if (actualRoadElevation < waypointY - 10) {
                        console.warn('⚠️ Bot: Calculated road elevation seems too low, using waypoint elevation + safety margin');
                        respawnPos.y = waypointY + 2; // 2m above waypoint position for safety
                    } else {
                        respawnPos.y = actualRoadElevation + 1; // 1m above calculated road surface
                    }
                    
                    // Calculate orientation toward next waypoint
                    var nextWaypointIndex = (botRef.lastWaypointReached + 1) % denseWaypoints.length;
                    var nextWaypoint = denseWaypoints[nextWaypointIndex];
                    var directionToNext = new THREE.Vector3()
                        .subVectors(nextWaypoint.position, respawnPos)
                        .normalize();
                    
                    // Calculate rotation quaternion to face next waypoint
                    // Use Y-axis rotation (yaw) to face the target direction
                    var targetAngle = Math.atan2(directionToNext.x, directionToNext.z);
                    var quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    
                    console.log('🧭 Bot respawn facing toward waypoint', nextWaypointIndex);
                    
                    // Apply respawn transform to physics body
                    var transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin(new Ammo.btVector3(respawnPos.x, respawnPos.y, respawnPos.z));
                    transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
                    
                    // Reset physics body
                    botRef.vehicleBody.setWorldTransform(transform);
                    botRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.activate(); // Wake up the physics body
                    
                    // Reset bot state
                    botRef.currentWaypointIndex = nextWaypointIndex;
                    botRef.stuckCounter = 0;
                    botRef.lowSpeedCounter = 0;
                    botRef.lastRespawnTime = botRef.debugCounter;
                    botRef.previousSteering = 0; // Reset steering smoothing
                    
                    console.log('🔄 Bot respawned at waypoint', nextWaypointIndex);
                }
                
                // HELPER FUNCTION: Calculate distance from racing path
                function findDistanceFromPath(carPos, botRef) {
                    if (!denseWaypoints || denseWaypoints.length === 0) return 0;
                    
                    try {
                        var nearestPoint = findNearestPathPoint(carPos);
                        if (!nearestPoint || !nearestPoint.point) return 0;
                        return carPos.distanceTo(nearestPoint.point);
                    } catch (e) {
                        console.warn('Error calculating distance from path:', e);
                        return 0;
                    }
                }
                
                // VISUAL RAYCAST DEBUG: Create visible lines to show raycast directions
                function createRaycastVisuals() {
                    // Clear existing raycast lines
                    raycastLines.forEach(line => {
                        scene.remove(line);
                    });
                    raycastLines = [];
                }
                
                function addRaycastLine(start, end, color, hit) {
                    var geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                    var material = new THREE.LineBasicMaterial({ 
                        color: color,
                        linewidth: hit ? 3 : 1,
                        transparent: true,
                        opacity: hit ? 0.9 : 0.5
                    });
                    var line = new THREE.Line(geometry, material);
                    scene.add(line);
                    raycastLines.push(line);
                    
                    // Add a small sphere at hit point if there's a hit
                    if (hit) {
                        var sphereGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        var sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
                        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        sphere.position.copy(end);
                        scene.add(sphere);
                        raycastLines.push(sphere);
                    }
                }

                // OBSTACLE AVOIDANCE: Raycast-based obstacle detection
                function checkObstacles(carPos, carQuat, carForward, speed, botRef) {
                    var rayLength = botRef.avoidanceRayLength;
                    var shouldAvoid = false;
                    var avoidanceSteer = 0;
                    var closestDistance = rayLength;
                    
                    // Clear previous raycast visuals
                    createRaycastVisuals();
                    
                    // Create rays: forward, left, right
                    var rays = [
                        { direction: carForward.clone(), weight: 1.0, name: 'forward' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'left' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'right' }
                    ];
                    
                    var obstacleDetected = false;
                    var avoidanceDirection = 0; // -1 = left, +1 = right
                    var debugInfo = [];
                    var totalHits = 0;
                    
                    // Cast rays and check for collisions
                    for (var i = 0; i < rays.length; i++) {
                        var ray = rays[i];
                        var rayStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                        var rayEnd = new Ammo.btVector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayCallback = new Ammo.ClosestRayResultCallback(rayStart, rayEnd);
                        physicsWorld.rayTest(rayStart, rayEnd, rayCallback);
                        
                        var hitDetected = rayCallback.hasHit();
                        
                        // Visual debugging - create lines for each ray
                        var startPos = new THREE.Vector3(carPos.x, carPos.y, carPos.z);
                        var endPos = new THREE.Vector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayColor = 0x00ff00; // Green for no hit
                        var actualHitPos = endPos;
                        
                        if (hitDetected) {
                            // Check if the hit object is the road surface
                            var hitBody = rayCallback.get_m_collisionObject();
                            var isRoadHit = (roadPhysicsBody && hitBody.a === roadPhysicsBody.a);
                            
                            var hitPoint = rayCallback.get_m_hitPointWorld();
                            var hitDistance = Math.sqrt(
                                Math.pow(hitPoint.x() - carPos.x, 2) + 
                                Math.pow(hitPoint.y() - carPos.y, 2) + 
                                Math.pow(hitPoint.z() - carPos.z, 2)
                            );
                            
                            // Update visual end position to hit point
                            actualHitPos = new THREE.Vector3(hitPoint.x(), hitPoint.y(), hitPoint.z());
                            
                            if (isRoadHit) {
                                // Road hit - ignore for obstacle avoidance but show in debug
                                debugInfo.push(ray.name + ':ROAD-' + hitDistance.toFixed(1) + 'm');
                                rayColor = 0x888888; // Gray for road hits
                            } else {
                                totalHits++;
                                debugInfo.push(ray.name + ':' + hitDistance.toFixed(1) + 'm');
                                
                                // Ignore hits that are too close (probably the car itself) or road surface
                                if (hitDistance > 1.5 && hitDistance < rayLength) {
                                obstacleDetected = true;
                                shouldAvoid = true;
                                rayColor = 0xff0000; // Red for obstacle hit
                                
                                // Calculate avoidance based on which ray hit
                                if (ray.name === 'forward') {
                                    avoidanceDirection += (Math.random() > 0.5) ? 1 : -1;
                                } else if (ray.name === 'left') {
                                    avoidanceDirection += 1.0;
                                } else if (ray.name === 'right') {
                                    avoidanceDirection -= 1.0;
                                }
                                
                                if (hitDistance < closestDistance) {
                                    closestDistance = hitDistance;
                                }
                                } else {
                                    rayColor = 0xffff00; // Yellow for hit but ignored (too close/far)
                                }
                            }
                        }
                        
                        // Add visual ray line
                        addRaycastLine(startPos, actualHitPos, rayColor, hitDetected);
                        
                        // Clean up Ammo objects
                        Ammo.destroy(rayStart);
                        Ammo.destroy(rayEnd);
                        Ammo.destroy(rayCallback);
                    }
                    
                    // Debug raycast hits every 300 frames
                    if (botRef.debugCounter % 300 === 0) {
                        if (totalHits > 0) {
                            console.log('🎯 Raycast hits detected:', debugInfo.join(', '));
                        } else {
                            console.log('🔍 No raycast hits detected - all rays clear');
                        }
                        
                        // Check if player car is nearby but not detected
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            var playerPos = vehicleRef.chassisMesh.position;
                            var distanceToPlayer = carPos.distanceTo(playerPos);
                            if (distanceToPlayer < rayLength) {
                                console.log('⚠️ Player car nearby at', distanceToPlayer.toFixed(1) + 'm but not detected by raycast!');
                                
                                // Test if we can raycast directly to player
                                var dirToPlayer = new THREE.Vector3().subVectors(playerPos, carPos).normalize();
                                var testStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                                var testEnd = new Ammo.btVector3(
                                    carPos.x + dirToPlayer.x * distanceToPlayer,
                                    carPos.y,
                                    carPos.z + dirToPlayer.z * distanceToPlayer
                                );
                                
                                var testCallback = new Ammo.ClosestRayResultCallback(testStart, testEnd);
                                physicsWorld.rayTest(testStart, testEnd, testCallback);
                                
                                if (testCallback.hasHit()) {
                                    console.log('✅ Direct raycast TO player: HIT detected');
                                } else {
                                    console.log('❌ Direct raycast TO player: NO HIT - player car has no physics body for raycast!');
                                }
                                
                                Ammo.destroy(testStart);
                                Ammo.destroy(testEnd);
                                Ammo.destroy(testCallback);
                            }
                        }
                    }
                    
                    // Calculate final avoidance steering
                    if (shouldAvoid) {
                        var urgency = Math.max(0.3, 1.0 - (closestDistance / rayLength));
                        avoidanceSteer = Math.sign(avoidanceDirection) * botRef.avoidanceForce * urgency;
                        avoidanceSteer = Math.max(-1.0, Math.min(1.0, avoidanceSteer));
                        
                        console.log('🚧 OBSTACLE DETECTED! Distance:', closestDistance.toFixed(1) + 'm, Steer:', avoidanceSteer.toFixed(2), '|', debugInfo.join(', '));
                    }
                    
                    return {
                        shouldAvoid: shouldAvoid,
                        avoidanceSteer: avoidanceSteer,
                        closestDistance: closestDistance,
                        obstacleDetected: obstacleDetected,
                        multipleHits: totalHits >= 2 // True if multiple rays hit obstacles
                    };
                }
                

                syncList.push(botSync);
                return botRef;
            }

            function createVehicle(pos, quat) {
                // Vehicle constants
                var chassisWidth = 1.8;
                var chassisHeight = .6;
                var chassisLength = 4;
                var massVehicle = 800;

                var wheelAxisPositionBack = -1;
                var wheelRadiusBack = .4;
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1;
                var wheelAxisHeightBack = .3;

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1;
                var wheelAxisHeightFront = .3;
                var wheelRadiusFront = .35;
                var wheelWidthFront = .2;

                var friction = 1000;
                var suspensionStiffness = 20.0;
                var suspensionDamping = 2.3;
                var suspensionCompression = 4.4;
                var suspensionRestLength = 0.6;
                var rollInfluence = 0.2;

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2000;
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Ensure the player body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                var chassisMesh = createChassisMesh(chassisWidth, chassisHeight, chassisLength);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store vehicle reference for reset
                vehicleRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                var wheelMeshes = [];
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    wheelMeshes[index] = createWheelMesh(radius, width);
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Sync keyboard/VR actions and physics and graphics
                function sync(dt) {
                    var speed = vehicle.getCurrentSpeedKmHour();
                    speedometer.innerHTML = (speed < 0 ? '(R) ' : '') + Math.abs(speed).toFixed(1) + ' km/h';
                    
                    // Check for checkpoint progress
                    if (chassisMesh) {
                        checkCheckpointProgress(chassisMesh.position);
                    }
                    
                    // Update player engine sound
                    if (playerEngineSound) {
                        var throttle = Math.abs(engineForce) / 1500; // Normalize throttle (0-1)
                        var speedKmh = Math.abs(speed);
                        playerEngineSound.updateEngine(speedKmh, throttle);
                    }

                    breakingForce = 0;
                    engineForce = 0;

                    // Get VR controller input
                    var vrSteering = 0;
                    var vrAcceleration = 0;
                    var vrBraking = 0;
                    
                    if (renderer.xr.isPresenting) {
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                            for (let i = 0; i < session.inputSources.length; i++) {
                                const inputSource = session.inputSources[i];
                                const gamepad = inputSource.gamepad;
                                
                                if (gamepad && inputSource.handedness === 'right') {
                                    // Start audio on first VR controller interaction
                                    if (!vrAudioStarted && gamepad.buttons) {
                                        for (let j = 0; j < gamepad.buttons.length; j++) {
                                            if (gamepad.buttons[j] && gamepad.buttons[j].pressed) {
                                                startEngineAudio();
                                                vrAudioStarted = true;
                                                console.log('🎵 VR audio started via controller button press');
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Car controls (only when menu is not visible)
                                    if (!isMenuVisible) {
                                        // Thumbstick for steering
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            vrSteering = gamepad.axes[2] || 0;
                                        }
                                        
                                        // Trigger for acceleration
                                        if (gamepad.buttons && gamepad.buttons[0]) {
                                            vrAcceleration = gamepad.buttons[0].value || 0;
                                        }
                                        
                                        // Grip for braking
                                        if (gamepad.buttons && gamepad.buttons[1]) {
                                            vrBraking = gamepad.buttons[1].value || 0;
                                        }
                                    } else {
                                        // Reset car controls when menu is open
                                        vrSteering = 0;
                                        vrAcceleration = 0;
                                        vrBraking = 0;
                                    }
                                    
                                    // A button (index 4) for camera switching (only when menu is not visible)
                                    if (!isMenuVisible && gamepad.buttons && gamepad.buttons[4] && gamepad.buttons[4].pressed) {
                                        // Prevent rapid switching with a simple debounce
                                        if (!this.lastCameraSwitchTime || (Date.now() - this.lastCameraSwitchTime) > 500) {
                                            switchCamera();
                                            this.lastCameraSwitchTime = Date.now();
                                        }
                                    }
                                    
                                    // B button (index 5) for menu toggle
                                    if (gamepad.buttons && gamepad.buttons[5] && gamepad.buttons[5].pressed) {
                                        // Prevent rapid toggling with a simple debounce
                                        if (!this.lastMenuToggleTime || (Date.now() - this.lastMenuToggleTime) > 500) {
                                            toggleMenu();
                                            this.lastMenuToggleTime = Date.now();
                                        }
                                    }
                                    
                    // VR Menu interaction with trigger (index 0)
                    if (isMenuVisible && vrMenu && vrMenu.visible && gamepad.buttons && gamepad.buttons[0] && gamepad.buttons[0].pressed) {
                        if (!this.lastMenuClickTime || (Date.now() - this.lastMenuClickTime) > 300) {
                            // Find which controller this input source belongs to
                            let controllerIndex = -1;
                            const session = renderer.xr.getSession();
                            if (session && session.inputSources) {
                                for (let i = 0; i < session.inputSources.length; i++) {
                                    if (session.inputSources[i] === inputSource) {
                                        controllerIndex = i;
                                        break;
                                    }
                                }
                            }
                            if (controllerIndex >= 0) {
                                handleVRMenuClick(controllerIndex);
                            }
                            this.lastMenuClickTime = Date.now();
                        }
                    }
                    
                    // VR Menu raycasting for hover effects
                    if (isMenuVisible && vrMenu && vrMenu.visible) {
                        // Find which controller this input source belongs to
                        let controllerIndex = -1;
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                            for (let i = 0; i < session.inputSources.length; i++) {
                                if (session.inputSources[i] === inputSource) {
                                    controllerIndex = i;
                                    break;
                                }
                            }
                        }
                        if (controllerIndex >= 0) {
                            updateVRMenuHover(controllerIndex);
                        }
                    }
                    
                    // Update laser pointer visibility
                    updateLaserPointers();
                                    
                                    // Y button (index 3) for car reset (only when menu is not visible)
                                    if (!isMenuVisible && gamepad.buttons && gamepad.buttons[3] && gamepad.buttons[3].pressed) {
                                        if (!this.lastResetTime || (Date.now() - this.lastResetTime) > 500) {
                                            resetCar();
                                            this.lastResetTime = Date.now();
                                        }
                                    }
                                    
                                    // VR Fly Camera Controls (when in fly mode and menu is not visible)
                                    if (cameraMode === 'fly' && !isMenuVisible) {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Right thumbstick: X = strafe left/right, Y = forward/back movement (KEEP WORKING)
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var moveX = gamepad.axes[2] || 0; // Right thumbstick X = strafe
                                            var moveZ = gamepad.axes[3] || 0; // Right thumbstick Y = forward/back
                                            
                                            // Create movement vectors relative to current rotation
                                            var forward = new THREE.Vector3(0, 0, -1);
                                            var right = new THREE.Vector3(1, 0, 0);
                                            
                                            // Apply current Y rotation to movement vectors
                                            forward.applyEuler(vrFlyRotation);
                                            right.applyEuler(vrFlyRotation);
                                            
                                            // Apply movement
                                            vrFlyPosition.add(right.multiplyScalar(moveX * flyDelta));
                                            vrFlyPosition.add(forward.multiplyScalar(-moveZ * flyDelta));
                                        }
                                        
                                        // Trigger buttons for up/down movement
                                        if (gamepad.buttons && gamepad.buttons[0]) {
                                            var upMovement = gamepad.buttons[0].value || 0;
                                            vrFlyPosition.y += upMovement * flyDelta;
                                        }
                                        
                                        if (gamepad.buttons && gamepad.buttons[1]) {
                                            var downMovement = gamepad.buttons[1].value || 0;
                                            vrFlyPosition.y -= downMovement * flyDelta;
                                        }
                                        
                                        // Apply bounds to prevent flying too far
                                        vrFlyPosition.x = Math.max(-200, Math.min(200, vrFlyPosition.x));
                                        vrFlyPosition.y = Math.max(1, Math.min(100, vrFlyPosition.y)); // 1m to 100m height
                                        vrFlyPosition.z = Math.max(-200, Math.min(200, vrFlyPosition.z));
                                    }
                                }
                                
                                if (gamepad && inputSource.handedness === 'left') {
                                    // LEFT CONTROLLER - VR Fly Camera Controls (rotation and up/down)
                                    console.log('🎮 Left controller detected in fly mode');
                                    if (cameraMode === 'fly') {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Left controller thumbstick: X = rotation, Y = up/down movement
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var rotateY = gamepad.axes[2] || 0; // Left thumbstick X = Y rotation
                                            var moveY = gamepad.axes[3] || 0;   // Left thumbstick Y = vertical movement
                                            
                                            // Debug logging
                                            if (Math.abs(rotateY) > 0.1 || Math.abs(moveY) > 0.1) {
                                                console.log('🎮 Left controller - Rotate:', rotateY.toFixed(2), 'MoveY:', moveY.toFixed(2));
                                            }
                                            
                                            // Apply Y rotation (turning left/right) - inverted for natural feel
                                            vrFlyRotation.y -= rotateY * rotationSpeed * dt;
                                            
                                            // Apply vertical movement (up/down)
                                            vrFlyPosition.y -= moveY * flyDelta; // Inverted for natural feel
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Combine keyboard and VR input
                    var acceleration = actions.acceleration || (vrAcceleration > 0.1);
                    var braking = actions.braking || (vrBraking > 0.1);
                    var left = actions.left || (vrSteering < -0.1);
                    var right = actions.right || (vrSteering > 0.1);

                    // Calculate speed-dependent steering - less responsive at high speeds
                    var absSpeed = Math.abs(speed);
                    var speedFactor = Math.max(0.2, 1.0 - (absSpeed / 80)); // Reduce steering at speeds above 80 km/h
                    var steeringIncrement = baseSteeringIncrement * speedFactor;
                    
                    // Also reduce steering clamp at high speeds for more realistic handling
                    var dynamicSteeringClamp = steeringClamp * speedFactor;

                    if (acceleration) {
                        if (speed < -1)
                            breakingForce = maxBreakingForce;
                        else engineForce = maxEngineForce;
                    }
                    if (braking) {
                        if (speed > 1)
                            breakingForce = maxBreakingForce;
                        else engineForce = -maxEngineForce / 2;
                    }
                    
                    // Improved steering logic with speed-dependent response
                    if (left) {
                        if (vehicleSteering < dynamicSteeringClamp)
                            vehicleSteering += steeringIncrement;
                    }
                    else if (right) {
                        if (vehicleSteering > -dynamicSteeringClamp)
                            vehicleSteering -= steeringIncrement;
                    }
                    else {
                        // Return to center more gradually for better control
                        var returnRate = steeringIncrement * 1.5; // Slightly faster return to center
                        if (vehicleSteering < -returnRate) {
                            vehicleSteering += returnRate;
                        } else if (vehicleSteering > returnRate) {
                            vehicleSteering -= returnRate;
                        } else {
                            vehicleSteering = 0;
                        }
                    }

                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);

                    var tm, p, q, i;
                    var n = vehicle.getNumWheels();
                    for (i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        tm = vehicle.getWheelTransformWS(i);
                        p = tm.getOrigin();
                        q = tm.getRotation();
                        wheelMeshes[i].position.set(p.x(), p.y(), p.z());
                        wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }

                    tm = vehicle.getChassisWorldTransform();
                    p = tm.getOrigin();
                    q = tm.getRotation();
                    chassisMesh.position.set(p.x(), p.y(), p.z());
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    
                    // Send bot state to other players (host only, throttled to 10Hz)
                    if (isMultiplayer && isHost && connections.size > 0 && botEnabled) {
                        if (!this.lastBotSync || (Date.now() - this.lastBotSync) > 100) {
                            sendToAllPlayers({
                                type: 'bot-state',
                                botState: {
                                    position: { x: p.x(), y: p.y(), z: p.z() },
                                    quaternion: { x: q.x(), y: q.y(), z: q.z(), w: q.w() }
                                }
                            });
                            this.lastBotSync = Date.now();
                        }
                    }

                    // Update camera position (works for both desktop and VR)
                    if (cameraMode === 'firstperson') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Move the camera rig (which contains the VR camera)
                            var cameraOffset = new THREE.Vector3(0, 1.4, 1.2); // x, y(up), z(forward)
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            
                            // Rotate 180 degrees around Y axis to face forward
                            var forwardRotation = new THREE.Quaternion();
                            forwardRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                            carQuaternion.multiply(forwardRotation);
                            
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            cameraRig.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            cameraRig.quaternion.copy(carQuaternion);
                        } else {
                            // In Desktop: Move the first person camera directly
                            var cameraOffset = new THREE.Vector3(0, 1.4, 1.2); // x, y(up), z(forward)
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            firstPersonCamera.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            
                            // Make camera look forward relative to car
                            var lookDirection = new THREE.Vector3(0, 0, 5); // Look forward
                            lookDirection.applyQuaternion(carQuaternion);
                            var lookTarget = firstPersonCamera.position.clone().add(lookDirection);
                            firstPersonCamera.lookAt(lookTarget);
                        }
                    } else if (cameraMode === 'fly') {
                        if (renderer.xr.isPresenting) {
                            // VR Fly Camera: Position camera rig at fly position
                            cameraRig.position.copy(vrFlyPosition);
                            // Apply fly camera rotation (Y-axis rotation from thumbstick)
                            cameraRig.rotation.copy(vrFlyRotation);
                        }
                        // Fly mode is VR-only
                    } else if (cameraMode === 'orbit') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Position orbit camera in the rig
                            cameraRig.position.set(p.x() - 4.84, p.y() + 4.39, p.z() - 35.11);
                            var lookTarget = new THREE.Vector3(p.x(), p.y(), p.z());
                            cameraRig.lookAt(lookTarget);
                        }
                        // Desktop orbit camera is handled by OrbitControls
                    }
                }

                syncList.push(sync);
            }

            function createRacingPath() {
                // Define control points using the reference track layout
                const curvePoints = [
                    -6, 0, 10,
                    -1, 0, 10,
                     3, 0,  4,
                     6, 0,  1,
                    11, 0,  2,
                    13, 0,  6,
                     9, 1,  9,
                     4, 1,  7,
                     1, 1,  1,
                     0, 1, -5,
                     2, 0, -9,
                     8, 0,-10,
                    13, 0, -5,
                    14, 1,  2,
                    10, 3,  7,
                     2, 1,  8,
                    -4, 3,  7,
                    -8, 1,  1,
                    -9, 1, -4,
                    -6, 1, -9,
                     0, 1,-10,
                     7, 1, -7,
                     5, 2,  0,
                     0, 2,  2,
                    -5, 1,  0,
                    -7, 2, -5,
                    -8, 2, -9,
                   -11, 2,-10,
                   -14, 1, -7,
                   -13, 1, -2,
                   -14, 0,  3,
                   -11, 0, 10,
                    -6, 0, 10
                ];
                
                // Convert curvePoints array to Vector3 points with elevation smoothing
                var rawPoints = [];
                for (let i = 0; i < curvePoints.length; i += 3) {
                    rawPoints.push(new THREE.Vector3(
                        curvePoints[i] * 4,     // Scale up X by 4x
                        curvePoints[i + 1] * 6, // 6x Y for dramatic but manageable elevation
                        curvePoints[i + 2] * 4  // Scale up Z by 4x
                    ));
                }
                
                // Apply elevation smoothing to prevent overly steep sections
                pathPoints = [];
                for (let i = 0; i < rawPoints.length; i++) {
                    var point = rawPoints[i].clone();
                    
                    // Smooth elevation using weighted average with neighbors
                    if (i > 0 && i < rawPoints.length - 1) {
                        var prevY = rawPoints[i - 1].y;
                        var currentY = rawPoints[i].y;
                        var nextY = rawPoints[i + 1].y;
                        
                        // Calculate maximum allowed slope (in meters per horizontal unit)
                        var maxSlope = 0.3; // 30% grade maximum
                        var prevDist = rawPoints[i].distanceTo(rawPoints[i - 1]);
                        var nextDist = rawPoints[i].distanceTo(rawPoints[i + 1]);
                        
                        // Limit elevation change based on horizontal distance
                        var maxPrevChange = prevDist * maxSlope;
                        var maxNextChange = nextDist * maxSlope;
                        
                        // Clamp elevation changes
                        if (Math.abs(currentY - prevY) > maxPrevChange) {
                            currentY = prevY + Math.sign(currentY - prevY) * maxPrevChange;
                        }
                        if (Math.abs(nextY - currentY) > maxNextChange) {
                            currentY = nextY - Math.sign(nextY - currentY) * maxNextChange;
                        }
                        
                        // Apply additional smoothing (weighted average)
                        point.y = currentY * 0.6 + (prevY + nextY) * 0.2;
                    }
                    
                    pathPoints.push(point);
                }

                // Create smooth racing path using CatmullRom curve
                racingPath = new THREE.CatmullRomCurve3(pathPoints, true); // true = closed loop

                // Generate dense waypoints for bot navigation
                createDenseWaypoints();

                // Create visual road mesh
                createRoadMesh();
                
                // Create path markers for debugging/visualization (HIDDEN)
                // createPathMarkers();
                
                // Create checkpoint system (HIDDEN VISUALS, DATA ONLY)
                createCheckpointData();
                
                console.log('Racing path created with', pathPoints.length, 'control points and', denseWaypoints.length, 'dense waypoints');
            }

            function createDenseWaypoints() {
                denseWaypoints = [];
                
                // Calculate total path length
                var pathLength = racingPath.getLength();
                var waypointSpacing = 2.0; // 2 meters between waypoints
                var numWaypoints = Math.floor(pathLength / waypointSpacing);
                
                console.log('Creating', numWaypoints, 'waypoints with', waypointSpacing, 'm spacing along', pathLength.toFixed(1), 'm track');
                
                // Generate waypoints at regular intervals
                for (var i = 0; i < numWaypoints; i++) {
                    var t = i / numWaypoints; // Parameter from 0 to 1
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    denseWaypoints.push({
                        position: point,
                        direction: tangent,
                        index: i,
                        t: t
                    });
                }
                
                // Add visual markers for waypoints (every 10th waypoint to avoid clutter) - HIDDEN
                /*
                for (var i = 0; i < denseWaypoints.length; i += 10) {
                    var waypoint = denseWaypoints[i];
                    var markerGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                    var markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff // Cyan for waypoints
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(waypoint.position);
                    marker.position.y = 1; // Above ground
                    scene.add(marker);
                }
                */
                
                // Debug first few waypoints
                console.log('First 5 waypoints:');
                for (var i = 0; i < Math.min(5, denseWaypoints.length); i++) {
                    var wp = denseWaypoints[i];
                    console.log('Waypoint', i + ':', 
                        '(' + wp.position.x.toFixed(1) + ', ' + wp.position.z.toFixed(1) + ')',
                        'direction:', '(' + wp.direction.x.toFixed(2) + ', ' + wp.direction.z.toFixed(2) + ')'
                    );
                }
            }

            function createRoadMesh() {
                var roadWidth = 14; // 14 meter wide road as requested
                var borderWidth = 0.4; // 40cm white borders on each side
                var totalWidth = roadWidth + (borderWidth * 2); // Road + borders
                var segments = 800; // Very high resolution for maximum smoothness
                
                // Get points along the curve
                var pathPoints = [];
                var pathDirections = [];
                
                for (var i = 0; i <= segments; i++) {
                    var t = i / segments;
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    pathPoints.push(point);
                    pathDirections.push(tangent);
                }
                
                // Create road geometry as a flat surface
                var roadGeometry = new THREE.BufferGeometry();
                var vertices = [];
                var indices = [];
                var uvs = [];
                
                // Generate vertices for road surface with corner smoothing
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    
                    // Apply aggressive direction smoothing with wider window
                    var smoothDirection = direction.clone();
                    if (i > 1 && i < pathPoints.length - 2) {
                        var prevDir2 = pathDirections[i - 2];
                        var prevDir1 = pathDirections[i - 1];
                        var nextDir1 = pathDirections[i + 1];
                        var nextDir2 = pathDirections[i + 2];
                        
                        // 5-point weighted average for ultra-smooth transitions
                        smoothDirection = prevDir2.clone().multiplyScalar(0.1)
                            .add(prevDir1.clone().multiplyScalar(0.2))
                            .add(direction.clone().multiplyScalar(0.4))
                            .add(nextDir1.clone().multiplyScalar(0.2))
                            .add(nextDir2.clone().multiplyScalar(0.1));
                        smoothDirection.normalize();
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point average for edge cases
                        var prevDir = pathDirections[i - 1];
                        var nextDir = pathDirections[i + 1];
                        smoothDirection.add(prevDir).add(nextDir).divideScalar(3);
                        smoothDirection.normalize();
                    }
                    
                    // Calculate perpendicular vector (road width direction)
                    var perpendicular = new THREE.Vector3(-smoothDirection.z, 0, smoothDirection.x).normalize();
                    
                    // Create points for road with borders
                    var halfTotalWidth = totalWidth / 2;
                    var halfRoadWidth = roadWidth / 2;
                    
                    // Outer edges (including borders)
                    var leftBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(halfTotalWidth));
                    var leftBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(halfRoadWidth));
                    var rightBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(-halfRoadWidth));
                    var rightBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(-halfTotalWidth));
                    
                    // Apply aggressive elevation smoothing to eliminate bumps
                    var smoothY = point.y;
                    if (i > 2 && i < pathPoints.length - 3) {
                        // 7-point smoothing for ultra-smooth elevation transitions
                        var y_m3 = pathPoints[i - 3].y;
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        var y_p3 = pathPoints[i + 3].y;
                        
                        // Gaussian-like weighted average for maximum smoothness
                        smoothY = y_m3 * 0.05 + y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.3 + y_p1 * 0.2 + y_p2 * 0.1 + y_p3 * 0.05;
                    } else if (i > 1 && i < pathPoints.length - 2) {
                        // 5-point smoothing for edge areas
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        
                        smoothY = y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.4 + y_p1 * 0.2 + y_p2 * 0.1;
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point smoothing for corners
                        var prevY = pathPoints[i - 1].y;
                        var nextY = pathPoints[i + 1].y;
                        smoothY = prevY * 0.25 + point.y * 0.5 + nextY * 0.25;
                    }
                    
                    var roadThickness = 0.2; // 20cm thickness
                    
                    // Add TOP vertices (from left to right: outer border, inner border, inner border, outer border)
                    vertices.push(leftBorderOuter.x, smoothY + 0.05, leftBorderOuter.z);   // Left border outer
                    vertices.push(leftBorderInner.x, smoothY + 0.05, leftBorderInner.z);   // Left border inner (road edge)
                    vertices.push(rightBorderInner.x, smoothY + 0.05, rightBorderInner.z); // Right border inner (road edge)
                    vertices.push(rightBorderOuter.x, smoothY + 0.05, rightBorderOuter.z); // Right border outer
                    
                    // Add BOTTOM vertices (same order) - 20cm below top
                    vertices.push(leftBorderOuter.x, smoothY + 0.05 - roadThickness, leftBorderOuter.z);
                    vertices.push(leftBorderInner.x, smoothY + 0.05 - roadThickness, leftBorderInner.z);
                    vertices.push(rightBorderInner.x, smoothY + 0.05 - roadThickness, rightBorderInner.z);
                    vertices.push(rightBorderOuter.x, smoothY + 0.05 - roadThickness, rightBorderOuter.z);
                    
                    // Add UV coordinates for all 8 vertices per segment
                    // Top vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                    // Bottom vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                }
                
                // Create triangular faces for thick road with borders
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 8; // 8 vertices per segment now
                    
                    // TOP SURFACE - Left Border (2 triangles)
                    indices.push(base, base + 1, base + 8);      // Triangle 1
                    indices.push(base + 1, base + 9, base + 8);  // Triangle 2
                    
                    // TOP SURFACE - Main Road (2 triangles)
                    indices.push(base + 1, base + 2, base + 9);   // Triangle 1
                    indices.push(base + 2, base + 10, base + 9);  // Triangle 2
                    
                    // TOP SURFACE - Right Border (2 triangles)
                    indices.push(base + 2, base + 3, base + 10);  // Triangle 1
                    indices.push(base + 3, base + 11, base + 10); // Triangle 2
                    
                    // BOTTOM SURFACE - Left Border (2 triangles)
                    indices.push(base + 4, base + 12, base + 5);  // Triangle 1
                    indices.push(base + 5, base + 12, base + 13); // Triangle 2
                    
                    // BOTTOM SURFACE - Main Road (2 triangles)
                    indices.push(base + 5, base + 13, base + 6);  // Triangle 1
                    indices.push(base + 6, base + 13, base + 14); // Triangle 2
                    
                    // BOTTOM SURFACE - Right Border (2 triangles)
                    indices.push(base + 6, base + 14, base + 7);  // Triangle 1
                    indices.push(base + 7, base + 14, base + 15); // Triangle 2
                    
                    // SIDE FACES
                    // Left outer edge
                    indices.push(base, base + 8, base + 4);       // Triangle 1
                    indices.push(base + 8, base + 12, base + 4);  // Triangle 2
                    
                    // Right outer edge
                    indices.push(base + 3, base + 7, base + 11);  // Triangle 1
                    indices.push(base + 7, base + 15, base + 11); // Triangle 2
                }
                
                // Set geometry attributes
                roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                roadGeometry.setIndex(indices);
                roadGeometry.computeVertexNormals();
                
                // Create texture for road with white borders
                var canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 1;
                var ctx = canvas.getContext('2d');
                
                // Create gradient: white borders, gray road
                var gradient = ctx.createLinearGradient(0, 0, 256, 0);
                gradient.addColorStop(0, '#ffffff');    // Left border - white
                gradient.addColorStop(0.2, '#ffffff');  // Left border - white
                gradient.addColorStop(0.2, '#333333');  // Road start - gray
                gradient.addColorStop(0.8, '#333333');  // Road end - gray
                gradient.addColorStop(0.8, '#ffffff');  // Right border - white
                gradient.addColorStop(1, '#ffffff');    // Right border - white
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 256, 1);
                
                var roadTexture = new THREE.CanvasTexture(canvas);
                roadTexture.wrapS = THREE.ClampToEdgeWrapping;
                roadTexture.wrapT = THREE.RepeatWrapping;
                
                // Create road material with border texture
                var roadMaterial = new THREE.MeshLambertMaterial({ 
                    map: roadTexture,
                    side: THREE.DoubleSide,
                    transparent: false,
                    wireframe: false
                });
                
                // Create road mesh and add to scene
                roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                scene.add(roadMesh);
                
                // Create physics collision for the road surface
                createRoadPhysics(roadGeometry);
                
                console.log('🛣️ Ultra-smooth road mesh created with', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles, and', segments, 'segments');
                console.log('Road width:', roadWidth + 'm, Road segments:', segments);
                
                // Create center line as a thin strip
                var centerLineGeometry = new THREE.BufferGeometry();
                var centerVertices = [];
                var centerIndices = [];
                var centerUvs = [];
                
                var lineWidth = 0.3; // 30cm wide center line
                
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    var perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                    
                    var leftPoint = point.clone().add(perpendicular.clone().multiplyScalar(lineWidth / 2));
                    var rightPoint = point.clone().add(perpendicular.clone().multiplyScalar(-lineWidth / 2));
                    
                    centerVertices.push(leftPoint.x, leftPoint.y + 0.02, leftPoint.z);
                    centerVertices.push(rightPoint.x, rightPoint.y + 0.02, rightPoint.z);
                    
                    centerUvs.push(0, i / (pathPoints.length - 1));
                    centerUvs.push(1, i / (pathPoints.length - 1));
                }
                
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 2;
                    centerIndices.push(base, base + 1, base + 2);
                    centerIndices.push(base + 1, base + 3, base + 2);
                }
                
                centerLineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(centerVertices, 3));
                centerLineGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(centerUvs, 2));
                centerLineGeometry.setIndex(centerIndices);
                centerLineGeometry.computeVertexNormals();
                
                var centerLineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    side: THREE.DoubleSide
                });
                var centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
                scene.add(centerLine);
                
                console.log('Created flat road surface with', roadWidth + 'm width');
                
                // DEBUG: Create a simple test rectangle to verify road positioning
                var testGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                var testMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                var testPlane = new THREE.Mesh(testGeometry, testMaterial);
                testPlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
                testPlane.position.set(0, 0.1, 0); // Position at origin, slightly above ground
                scene.add(testPlane);
                console.log('Added red test plane for road visibility debugging');
            }
            
            // CREATE ROAD PHYSICS: Add collision mesh for elevated road surface
            function createRoadPhysics(roadGeometry) {
                // Get vertices and indices from the road geometry
                var vertices = roadGeometry.attributes.position.array;
                var indices = roadGeometry.index.array;
                
                // Create Ammo triangle mesh
                var mesh = new Ammo.btTriangleMesh(true, true);
                
                // Add triangles to the mesh
                for (var i = 0; i < indices.length; i += 3) {
                    var i1 = indices[i] * 3;
                    var i2 = indices[i + 1] * 3;
                    var i3 = indices[i + 2] * 3;
                    
                    var v1 = new Ammo.btVector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                    var v2 = new Ammo.btVector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                    var v3 = new Ammo.btVector3(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                    
                    mesh.addTriangle(v1, v2, v3, false);
                    
                    // Clean up vectors
                    Ammo.destroy(v1);
                    Ammo.destroy(v2);
                    Ammo.destroy(v3);
                }
                
                // Create collision shape from triangle mesh
                var roadShape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
                
                // Create rigid body (static, mass = 0)
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(0, 0, 0));
                
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                
                var rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, roadShape, localInertia);
                var roadBody = new Ammo.btRigidBody(rbInfo);
                
                // Set friction for good driving feel
                roadBody.setFriction(0.8);
                roadBody.setRestitution(0.1);
                
                // Store globally for obstacle detection filtering
                roadPhysicsBody = roadBody;
                
                // Add to physics world
                physicsWorld.addRigidBody(roadBody);
                
                console.log('Road physics collision mesh created with', indices.length / 3, 'triangles');
            }

            function createPathMarkers() {
                // Create visual markers at each control point
                for (var i = 0; i < pathPoints.length; i++) {
                    var markerGeometry = new THREE.SphereGeometry(2, 8, 8);
                    var markerMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xff0000 // Green for start, red for others
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(pathPoints[i]);
                    marker.position.y = pathPoints[i].y + 3; // Above road surface
                    scene.add(marker);
                }
            }
            
            function createCheckpoints() {
                // Create checkpoint markers at each path point
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    // Create checkpoint ring/gate
                    var ringGeometry = new THREE.RingGeometry(8, 12, 16);
                    var ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    var ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Position at path point
                    ring.position.copy(pathPoints[i]);
                    ring.position.y += 5; // Above the road
                    
                    // Rotate to face along the path
                    if (i < pathPoints.length - 2) {
                        var direction = new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]);
                        ring.lookAt(ring.position.clone().add(direction));
                    }
                    
                    // Add checkpoint number
                    var numberGeometry = new THREE.SphereGeometry(3, 8, 8);
                    var numberMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xffffff
                    });
                    var numberSphere = new THREE.Mesh(numberGeometry, numberMaterial);
                    numberSphere.position.copy(ring.position);
                    numberSphere.position.y += 2;
                    
                    scene.add(ring);
                    scene.add(numberSphere);
                    
                    checkpointMarkers.push({
                        ring: ring,
                        sphere: numberSphere,
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Create next checkpoint indicator
                updateNextCheckpointMarker();
                
                console.log('Created', checkpointMarkers.length, 'checkpoints');
            }
            
            function createCheckpointData() {
                // Create checkpoint data without visual elements
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    checkpointMarkers.push({
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Initialize the next checkpoint marker (yellow pulsing sphere)
                updateNextCheckpointMarker();
                
                // Log checkpoint elevations for debugging
                console.log('Created', checkpointMarkers.length, 'checkpoint data points with next checkpoint marker');
                if (checkpointMarkers.length > 0) {
                    var minY = Math.min(...checkpointMarkers.map(cp => cp.position.y));
                    var maxY = Math.max(...checkpointMarkers.map(cp => cp.position.y));
                    console.log('🏔️ Track elevation range: Min:', minY.toFixed(1) + 'm, Max:', maxY.toFixed(1) + 'm, Difference:', (maxY - minY).toFixed(1) + 'm');
                }
            }
            
            function updateNextCheckpointMarker() {
                // Remove old marker
                if (nextCheckpointMarker) {
                    scene.remove(nextCheckpointMarker);
                }
                
                // Create glowing marker for next checkpoint
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                if (checkpoint && checkpoint.position) {
                    var glowGeometry = new THREE.SphereGeometry(4, 16, 16);
                    var glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    });
                    nextCheckpointMarker = new THREE.Mesh(glowGeometry, glowMaterial);
                    nextCheckpointMarker.position.copy(checkpoint.position);
                    // Position marker relative to track elevation at this point
                    var trackElevation = checkpoint.position.y;
                    nextCheckpointMarker.position.y = trackElevation + 8; // 8m above track for visibility
                    
                    scene.add(nextCheckpointMarker);
                    
                    // Make it pulse
                    nextCheckpointMarker.userData = { pulseTime: 0 };
                    
                    console.log('📍 Next checkpoint marker updated at:', checkpoint.position);
                }
            }

            // ROAD SURFACE UTILITIES: Get actual road elevation at any point
            function getRoadSurfaceElevation(x, z) {
                if (!racingPath) {
                    console.warn('⚠️ No racing path available for elevation detection');
                    return 0;
                }
                
                // Find the closest point on the racing path with higher resolution
                var closestT = 0;
                var minDistance = Infinity;
                var samples = 200; // Increased samples for better accuracy
                
                for (var i = 0; i <= samples; i++) {
                    var t = i / samples;
                    var pathPoint = racingPath.getPoint(t);
                    var distance = Math.sqrt(Math.pow(pathPoint.x - x, 2) + Math.pow(pathPoint.z - z, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestT = t;
                    }
                }
                
                // Get the elevation at this point and apply the same smoothing used in road mesh
                var pathPoint = racingPath.getPoint(closestT);
                
                // Apply the same elevation smoothing algorithm used in createRoadMesh
                var segments = 800; // Same as road mesh
                var segmentIndex = Math.floor(closestT * segments);
                
                // Get neighboring points for smoothing (same as road mesh algorithm)
                var smoothY = pathPoint.y;
                if (segmentIndex > 2 && segmentIndex < segments - 3) {
                    // Sample points around this segment
                    var points = [];
                    for (var i = -3; i <= 3; i++) {
                        var sampleT = Math.max(0, Math.min(1, (segmentIndex + i) / segments));
                        points.push(racingPath.getPoint(sampleT));
                    }
                    
                    // Apply 7-point Gaussian smoothing (same as road mesh)
                    smoothY = points[0].y * 0.05 + points[1].y * 0.1 + points[2].y * 0.2 + 
                             points[3].y * 0.3 + points[4].y * 0.2 + points[5].y * 0.1 + points[6].y * 0.05;
                }
                
                // Add safety margin - if the calculated elevation seems too low, use the original path point
                var originalY = pathPoint.y;
                var finalY = Math.max(smoothY, originalY - 5); // Don't go more than 5m below original
                
                console.log('🛣️ Elevation at (' + x.toFixed(1) + ',' + z.toFixed(1) + '): original=' + originalY.toFixed(1) + ', smoothed=' + smoothY.toFixed(1) + ', final=' + finalY.toFixed(1));
                
                return finalY;
            }

            // Bot pathfinding utilities
            function getPathPosition(t) {
                // Get position along path (t = 0 to 1)
                return racingPath.getPoint(t);
            }

            function getPathDirection(t) {
                // Get direction vector at position t
                return racingPath.getTangent(t);
            }

            function findNearestPathPoint(position) {
                // Find closest point on path to given position
                var closestT = 0;
                var closestDistance = Infinity;
                
                // Sample path at regular intervals
                for (var t = 0; t <= 1; t += 0.01) {
                    var pathPoint = racingPath.getPoint(t);
                    var distance = position.distanceTo(pathPoint);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestT = t;
                    }
                }
                
                return {
                    t: closestT,
                    point: racingPath.getPoint(closestT),
                    distance: closestDistance,
                    direction: racingPath.getTangent(closestT)
                };
            }

            function createObjects() {
                // Create racing path first
                console.log('Creating racing path...');
                createRacingPath();
                console.log('Racing path created:', !!racingPath, 'Points:', pathPoints.length);
                
                // Ground (4x bigger) - lowered by 75cm total (raised by 25cm from -1.0m)
                createBox(new THREE.Vector3(0, -0.75, 0), ZERO_QUATERNION, 300, 1, 300, 0, 2);

                // Walls around the driving area
                createBox(new THREE.Vector3(0, 5, -150), ZERO_QUATERNION, 300, 10, 2, 0, 2);
                createBox(new THREE.Vector3(0, 5, 150), ZERO_QUATERNION, 300, 10, 2, 0, 2);
                createBox(new THREE.Vector3(150, 5, 0), ZERO_QUATERNION, 2, 10, 300, 0, 2);
                createBox(new THREE.Vector3(-150, 5, 0), ZERO_QUATERNION, 2, 10, 300, 0, 2);

                // Ramp
                var quaternion = new THREE.Quaternion(0, 0, 0, 1);
                quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 18);
                createBox(new THREE.Vector3(0, -1.5, 0), quaternion, 8, 4, 10, 0);

                // Stack of boxes (moved away from track)
                var size = .75;
                var nw = 8;
                var nh = 6;
                for (var j = 0; j < nw; j++)
                    for (var i = 0; i < nh; i++)
                        createBox(new THREE.Vector3(size * j - (size * (nw - 1)) / 2 + 120, size * i, 10), ZERO_QUATERNION, size, size, size, 10);

                // Random cones - fewer and away from track
                for (var c = 0; c < 25; c++) {
                    var x, z;
                    do {
                        x = (Math.random() - 0.5) * 280;
                        z = (Math.random() - 0.5) * 280;
                        
                        // Check if too close to racing path (only if path exists)
                        var testPos = new THREE.Vector3(x, 0, z);
                        var pathInfo = racingPath ? findNearestPathPoint(testPos) : {distance: 100};
                        
                    } while ((Math.abs(x) < 30 && Math.abs(z) < 30) || pathInfo.distance < 20);
                    
                    createBox(new THREE.Vector3(x, 2, z), ZERO_QUATERNION, 1, 4, 1, 10, 1);
                }

                // Create player and bot cars at the first checkpoint (start line)
                var playerStartPosition = new THREE.Vector3(0, 0, -50); // Default X,Z fallback
                var botStartPosition = new THREE.Vector3(-5, 0, -45); // Default X,Z fallback
                
                // Calculate proper Y positions for fallback
                var playerFallbackElevation = getRoadSurfaceElevation(0, -50);
                var botFallbackElevation = getRoadSurfaceElevation(-5, -45);
                playerStartPosition.y = playerFallbackElevation + 1; // 1m above road
                botStartPosition.y = botFallbackElevation + 1; // 1m above road
                
                if (checkpointMarkers && checkpointMarkers.length > 0) {
                    var firstCheckpoint = checkpointMarkers[0];
                    
                    // Player car at first checkpoint
                    playerStartPosition = firstCheckpoint.position.clone();
                    playerStartPosition.x += 2; // Slightly to the right
                    var playerRoadElevation = getRoadSurfaceElevation(playerStartPosition.x, playerStartPosition.z);
                    if (playerRoadElevation < firstCheckpoint.position.y - 10) {
                        playerStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        playerStartPosition.y = playerRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    // Bot car slightly behind and to the left
                    botStartPosition = firstCheckpoint.position.clone();
                    botStartPosition.x -= 2; // Slightly to the left
                    botStartPosition.z -= 5; // 5m behind
                    var botRoadElevation = getRoadSurfaceElevation(botStartPosition.x, botStartPosition.z);
                    if (botRoadElevation < firstCheckpoint.position.y - 10) {
                        botStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        botStartPosition.y = botRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    console.log('🏁 Starting positions at first checkpoint:');
                    console.log('🚗 Player:', playerStartPosition.x.toFixed(1), playerStartPosition.y.toFixed(1), playerStartPosition.z.toFixed(1));
                    console.log('🤖 Bot:', botStartPosition.x.toFixed(1), botStartPosition.y.toFixed(1), botStartPosition.z.toFixed(1));
                } else {
                    console.warn('⚠️ No checkpoints available, using default start positions');
                }
                
                // Create rotation quaternion for 90 degrees left (counter-clockwise around Y-axis)
                var leftRotation = new THREE.Quaternion();
                leftRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); // 90 degrees in radians
                console.log('🔄 Cars will be rotated 90° left at spawn');
                
                console.log('Creating player car...');
                createVehicle(playerStartPosition, leftRotation);
                
                console.log('Creating bot car...');
                botVehicleRef = createBotVehicle(botStartPosition, leftRotation, 0x0066ff);
                console.log('Bot car created, racing path available:', !!racingPath);
                
                // Create multiplayer player car slots
                createPlayerCarSlots();
                
                // Confirm both cars are starting at the correct positions
                console.log('✅ Both cars positioned at first checkpoint (start line)');
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                loadBestTime(); // Load saved best time from localStorage
                console.log('🏁 Lap timing started');
                
                // Initialize audio system
                initAudioSystem();
            }

            // - Init -
            initGraphics();
            initPhysics();
            createObjects();
            
            // Initialize menu system
            setupMenuEventListeners();
            updateMenuDisplay();
            
            tick();

        });
    </script>
</body>
</html>
