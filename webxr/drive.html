<!DOCTYPE html>
<html>
<head>
    <title>WebXR Multiplayer Driving Game</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }

        #speedometer {
            color: #ffffff;
            background-color: #990000;
            position: absolute;
            bottom: 0px;
            padding: 5px;
            z-index: 1000;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
            z-index: 1000;
        }

        #vrButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: #333;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
            font-size: 14px;
        }

        a {
            color: #a06851;
        }

        /* Desktop HUD Styles */
        #desktopHUD {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            min-width: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        #desktopHUD .hud-line {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        #desktopHUD .hud-label {
            color: #aaa;
            margin-right: 15px;
        }
        
        #desktopHUD .hud-value {
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
            /* Hide desktop HUD in VR */
            .vr-mode #desktopHUD {
                display: none;
            }

            /* Version and FPS Display */
            #versionDisplay {
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 14px;
                font-weight: bold;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            /* Multiplayer Status Display */
            #multiplayerStatus {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 14px;
                font-weight: bold;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            /* Game Menu Styles */
            #gameMenu {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 2000;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .menu-background {
                background: rgba(20, 20, 20, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 12px;
                padding: 30px;
                min-width: 400px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            }

            .menu-content h2 {
                color: white;
                text-align: center;
                margin: 0 0 20px 0;
                font-size: 24px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            .menu-section {
                margin: 15px 0;
                text-align: center;
            }

            #currentModeDisplay {
                color: #00ff88;
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 15px;
            }

            .menu-button {
                background: linear-gradient(145deg, #333, #555);
                color: white;
                border: 2px solid #666;
                border-radius: 6px;
                padding: 10px 20px;
                margin: 5px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
            }

            .menu-button:hover {
                background: linear-gradient(145deg, #555, #777);
                border-color: #888;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            .menu-button.active {
                background: linear-gradient(145deg, #0066cc, #0088ff);
                border-color: #00aaff;
                box-shadow: 0 0 10px rgba(0, 136, 255, 0.5);
            }

            .lobby-controls {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin: 10px 0;
                color: white;
                font-weight: bold;
            }

            .lobby-btn {
                background: #444;
                color: white;
                border: 1px solid #666;
                border-radius: 4px;
                padding: 5px 10px;
                cursor: pointer;
                font-weight: bold;
            }

            .lobby-btn:hover {
                background: #666;
            }

            .bot-controls {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                color: white;
                font-weight: bold;
            }

            #botStatus {
                font-size: 12px;
                color: #aaa;
                font-style: italic;
            }

            /* Menu available in both desktop and VR modes */
            /* .vr-mode #gameMenu {
                display: none;
            } */
    </style>
</head>

<body>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>
    <div id="speedometer">0.0 km/h</div>
    
    <!-- Desktop HUD for non-VR users -->
    <div id="desktopHUD">
        <div class="hud-line">
            <span class="hud-label">LAP:</span>
            <span class="hud-value" id="desktopLapNumber">1</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">TIME:</span>
            <span class="hud-value" id="desktopCurrentTime">0:00.000</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">BEST:</span>
            <span class="hud-value" id="desktopBestTime">--:--.---</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">CHECKPOINT:</span>
            <span class="hud-value" id="desktopCheckpoint">0/0</span>
        </div>
    </div>

    <!-- Version and FPS Display -->
    <div id="versionDisplay">
        <span id="versionText">WebXR Drive v1.0</span> | <span id="fpsText">0 FPS</span>
    </div>

    <!-- Multiplayer Status Display -->
    <div id="multiplayerStatus">
        <span id="statusText">Disconnected</span>
    </div>

    <!-- Game Menu (initially hidden) -->
    <div id="gameMenu" style="display: none;">
        <div class="menu-background">
            <div class="menu-content">
                <h2>WEBXR DRIVE MENU</h2>
                
                <!-- Current mode display -->
                <div class="menu-section">
                    <div id="currentModeDisplay">Mode: Singleplayer</div>
                </div>
                
                <!-- Single/Multi buttons -->
                <div class="menu-section">
                    <button id="singleplayerBtn" class="menu-button active">SINGLE</button>
                    <button id="multiplayerBtn" class="menu-button">MULTI</button>
                </div>
                
                <!-- Lobby section (hidden by default) -->
                <div id="lobbySection" class="menu-section" style="display: none;">
                    <div class="lobby-controls">
                        <span>Lobby:</span>
                        <button id="lobbyMinus" class="lobby-btn">-</button>
                        <span id="lobbyNumber">1</span>
                        <button id="lobbyPlus" class="lobby-btn">+</button>
                    </div>
                    <button id="connectBtn" class="menu-button">CONNECT</button>
                    <button id="autoConnectBtn" class="menu-button">AUTO CONNECT</button>
                </div>
                
                <!-- Bot toggle section -->
                <div class="menu-section">
                    <div class="bot-controls">
                        <span>Bot:</span>
                        <button id="botToggle" class="menu-button active">ON</button>
                        <span id="botStatus">(Available in Single & Host)</span>
                    </div>
                </div>
                
                <!-- Music toggle section -->
                <div class="menu-section">
                    <div class="bot-controls">
                        <span>Music:</span>
                        <button id="musicToggle" class="menu-button active">ON</button>
                        <span id="musicStatus">(Background Music)</span>
                    </div>
                </div>
                
                <!-- Close button -->
                <div class="menu-section">
                    <button id="closeMenuBtn" class="menu-button">CLOSE</button>
                </div>
            </div>
        </div>
    </div>
    <div id="info">WebXR Multiplayer Driving Game<br>WASD/VR Controllers to drive<br>B = Menu, C = Camera, R = Reset<br>Fly Mode: WASD = Move, Mouse = Look, Q/E = Up/Down</div>
    <button id="vrButton" style="display: none;">Enter VR</button>
    
    <!-- Background Music -->
    <audio id="backgroundMusic" loop preload="auto">
        <source src="audio/machina-tobias-voigt-main-version-19314-02-39.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://kripken.github.io/ammo.js/builds/ammo.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/Detector.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/OrbitControls.js"></script>
    <script src="https://rawcdn.githack.com/kripken/ammo.js/8f8b7187ef74994093318645e5e96b11d982688a/examples/js/three/stats.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
        Ammo().then(function (Ammo) {

            // ========== MULTIPLAYER STATE VARIABLES ==========
            let isMultiplayer = false;
            let isHost = false;
            let peer = null;
            let connections = new Map(); // Map of playerId -> connection
            let connectionToPlayer = new Map(); // Map of connection -> playerId
            let activePlayers = new Map(); // Map of playerId -> player data
            let remotePlayerStates = new Map(); // Map of playerId -> player state (like reference project)
            let myPlayerId = null;
            let sessionID = null;
            let selectedLobby = 1;
            let MAX_LOBBIES = 10;
            let multiplayerStartType = 'webxr-drive';
            let connectionState = 'disconnected';
            let multiplayerStatus = 'Disconnected';
            let vrAudioStarted = false;
            
            // Bot control variables
            let botEnabled = true;
            let musicEnabled = true; // Bot is enabled by default
            
            // Menu state
            let isMenuVisible = false;
            let vrMenu = null;
            let vrMenuButtons = [];
            let vrMenuRaycaster = null;
            let vrMenuPointer = null;
            
            // VR Controllers
            let vrControllers = [];
            let vrControllerModels = [];
            let vrLaserPointers = [];
            
            // App version and FPS
            const APP_VERSION = 'WebXR Drive v1.0';
            let currentFPS = 0;
            let frameCount = 0;
            let lastFPSTime = performance.now();
            let fpsHistory = [];
            let lastFPSUpdate = 0;

            // Detects webgl
            if (!Detector.webgl) {
                Detector.addGetWebGLMessage();
                document.getElementById('container').innerHTML = "";
            }

            // - Global variables -
            var DISABLE_DEACTIVATION = 4;
            var TRANSFORM_AUX = new Ammo.btTransform();
            var ZERO_QUATERNION = new THREE.Quaternion(0, 0, 0, 1);

            // Graphics variables
            var container, stats, speedometer;
            var camera, controls, scene, renderer;
            var clock = new THREE.Clock();
            var materialDynamic, materialStatic, materialInteractive;

            // Physics variables
            var collisionConfiguration;
            var dispatcher;
            var broadphase;
            var solver;
            var physicsWorld;

            var syncList = [];
            var time = 0;
            var vehicleRef = null; // For reset functionality
            var raycastLines = []; // Visual debug lines for raycasting
            
            // Checkpoint system
            var playerCurrentCheckpoint = 1; // Next checkpoint to reach (1-based)
            var playerLastPassedCheckpoint = 0; // Last checkpoint passed (0-based)
            var nextCheckpointMarker = null;
            var checkpointMarkers = [];
            
            // Lap timing system
            var currentLapNumber = 1;
            var currentLapStartTime = 0;
            var currentLapTime = 0;
            var bestLapTime = null;
            var lapTimes = [];
            
            // LocalStorage key for best time
            var BEST_TIME_KEY = 'webxr-drive-best-time';
            
            // LOCALSTORAGE FUNCTIONS: Save and load best time
            function loadBestTime() {
                try {
                    var savedTime = localStorage.getItem(BEST_TIME_KEY);
                    if (savedTime !== null) {
                        bestLapTime = parseFloat(savedTime);
                        console.log('💾 Loaded best time from storage:', formatLapTime(bestLapTime));
                        return bestLapTime;
                    }
                } catch (error) {
                    console.warn('Failed to load best time from localStorage:', error);
                }
                return null;
            }
            
            function saveBestTime(time) {
                try {
                    localStorage.setItem(BEST_TIME_KEY, time.toString());
                    console.log('💾 Saved new best time to storage:', formatLapTime(time));
                } catch (error) {
                    console.warn('Failed to save best time to localStorage:', error);
                }
            }
            
            function clearBestTime() {
                try {
                    localStorage.removeItem(BEST_TIME_KEY);
                    bestLapTime = null;
                    console.log('🗑️ Cleared best time from storage');
                } catch (error) {
                    console.warn('Failed to clear best time from localStorage:', error);
                }
            }
            
            function formatLapTime(seconds) {
                if (seconds === null || seconds === undefined) return '--:--.---';
                var minutes = Math.floor(seconds / 60);
                var secs = (seconds % 60).toFixed(3);
                return minutes + ':' + (secs < 10 ? '0' : '') + secs;
            }
            
            // VR HUD elements
            var vrHUD = null;
            var lapNumberText = null;
            var currentTimeText = null;
            var bestTimeText = null;
            
            // Engine sound system
            var audioContext = null;
            var playerEngineSound = null;
            var botEngineSound = null;
            var backgroundMusic = null;
            
            // Road and path system
            var racingPath = null;
            var roadMesh = null;
            var roadPhysicsBody = null; // Physics body for the road surface
            var pathPoints = [];
            var denseWaypoints = []; // Dense waypoints every 1-2m for bot navigation
            
            // Bot car system
            var botCar = null;
            var botVehicleRef = null;
            var botTargetMarker = null; // Visual marker for bot's current target

            // Keyboard actions
            var actions = {};
            var keysActions = {
                "KeyW": 'acceleration',
                "KeyS": 'braking',
                "KeyA": 'left',
                "KeyD": 'right'
            };

            // Camera modes
            var cameraMode = 'firstperson'; // Start in first person for VR
            var firstPersonCamera = null;
            var orbitCamera = null;
            var cameraRig = null; // Container for VR camera positioning
            
            // VR fly camera variables
            var vrFlySpeed = 10; // meters per second
            var vrFlyPosition = new THREE.Vector3(0, 5, -20); // Starting fly position
            var vrFlyRotation = new THREE.Euler(0, 0, 0); // Camera rotation in fly mode
            
            // Desktop fly camera variables
            var desktopFlySpeed = 15; // meters per second
            var desktopFlyPosition = new THREE.Vector3(0, 5, -20); // Starting fly position
            var desktopFlyRotation = new THREE.Euler(0, 0, 0); // Camera rotation in fly mode
            var isMouseLocked = false;
            
            // WebXR Cube Layer variables
            var cubeLayer = null;
            var gl = null;
            var threejsSkybox = null; // Fallback Three.js skybox
            
            // Materials
            var materialDynamic, materialStatic, materialInteractive, materialTransparent;

            // - Functions -
            
            function setupCubeLayer(session) {
                console.log('🌅 Setting up skybox...');
                
                // First, try to create a Three.js skybox as fallback
                createThreeJSSkybox();
                
                if (!session.supportedFrameLayers || !session.supportedFrameLayers.includes('cube')) {
                    console.log('❌ WebXR Cube layers not supported, using Three.js skybox fallback');
                    return;
                }
                
                console.log('✅ WebXR Cube layers supported, attempting to create...');
                
                // Get WebGL context
                gl = renderer.getContext();
                
                // Create cube layer
                cubeLayer = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeLayer);
                
                // Skybox image URLs - you can replace these with your own images
                const skyboxImages = [
                    'assets/mountains-cubemap/px.png', // Right (+X)
                    'assets/mountains-cubemap/nx.png', // Left (-X)
                    'assets/mountains-cubemap/py.png', // Top (+Y)
                    'assets/mountains-cubemap/ny.png', // Bottom (-Y)
                    'assets/mountains-cubemap/pz.png', // Front (+Z)
                    'assets/mountains-cubemap/nz.png'  // Back (-Z)
                ];
                
                const faces = [
                    gl.TEXTURE_CUBE_MAP_POSITIVE_X, // Right
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X, // Left  
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Y, // Top
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, // Bottom
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Z, // Front
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z  // Back
                ];
                
                let loadedImages = 0;
                const totalImages = skyboxImages.length;
                
                // Load each face image
                skyboxImages.forEach((url, index) => {
                    const image = new Image();
                    image.crossOrigin = 'anonymous';
                    
                    image.onload = function() {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeLayer);
                        gl.texImage2D(faces[index], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        
                        loadedImages++;
                        console.log(`Loaded skybox face ${index + 1}/${totalImages}`);
                        
                        // When all images are loaded, finalize the cube layer
                        if (loadedImages === totalImages) {
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            
                            // Create the XR cube layer
                            try {
                                const cubeLayerInit = {
                                    space: session.viewerSpace,
                                    viewPixelWidth: 2048,
                                    viewPixelHeight: 2048,
                                    layout: 'mono',
                                    isStatic: true
                                };
                                
                                const xrCubeLayer = session.requestFrameLayer('cube', cubeLayerInit);
                                if (xrCubeLayer) {
                                    xrCubeLayer.colorTexture = cubeLayer;
                                    session.updateRenderState({ layers: [xrCubeLayer] });
                                    console.log('✅ Cube layer created successfully with real skybox images');
                                }
                            } catch (error) {
                                console.warn('Failed to create cube layer:', error);
                            }
                        }
                    };
                    
                    image.onerror = function() {
                        console.warn(`Failed to load skybox image: ${url}`);
                        // Fallback to a solid color for this face
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        
                        // Create a simple gradient as fallback
                        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                        gradient.addColorStop(0, '#87CEEB'); // Sky blue
                        gradient.addColorStop(1, '#98FB98'); // Pale green
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 512, 512);
                        
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeLayer);
                        gl.texImage2D(faces[index], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                        
                        loadedImages++;
                        if (loadedImages === totalImages) {
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            
                            try {
                                const cubeLayerInit = {
                                    space: session.viewerSpace,
                                    viewPixelWidth: 2048,
                                    viewPixelHeight: 2048,
                                    layout: 'mono',
                                    isStatic: true
                                };
                                
                                const xrCubeLayer = session.requestFrameLayer('cube', cubeLayerInit);
                                if (xrCubeLayer) {
                                    xrCubeLayer.colorTexture = cubeLayer;
                                    session.updateRenderState({ layers: [xrCubeLayer] });
                                    console.log('✅ Cube layer created with fallback images');
                                }
                            } catch (error) {
                                console.warn('Failed to create cube layer:', error);
                            }
                        }
                    };
                    
                    image.src = url;
                });
            }
            
            function createThreeJSSkybox() {
                console.log('🎨 Creating Three.js skybox fallback...');
                
                // Skybox image URLs - same as WebXR cube layer
                const skyboxImages = [
                    'assets/mountains-cubemap/px.png', // Right (+X)
                    'assets/mountains-cubemap/nx.png', // Left (-X)
                    'assets/mountains-cubemap/py.png', // Top (+Y)
                    'assets/mountains-cubemap/ny.png', // Bottom (-Y)
                    'assets/mountains-cubemap/pz.png', // Front (+Z)
                    'assets/mountains-cubemap/nz.png'  // Back (-Z)
                ];
                
                console.log('🔍 Attempting to load skybox images:');
                skyboxImages.forEach((url, index) => {
                    console.log(`  ${index + 1}. ${url}`);
                });
                
                // Create cube texture loader
                const loader = new THREE.CubeTextureLoader();
                
                // Load the skybox
                loader.load(
                    skyboxImages,
                    function(texture) {
                        // Success - set as scene background
                        scene.background = texture;
                        console.log('✅ Three.js skybox loaded successfully');
                        
                        // Hide the WebXR cube layer if it exists (Three.js skybox takes priority)
                        if (threejsSkybox) {
                            scene.remove(threejsSkybox);
                        }
                        threejsSkybox = texture;
                    },
                    function(progress) {
                        console.log('📥 Loading skybox:', Math.round((progress.loaded / progress.total) * 100) + '%');
                    },
                    function(error) {
                        console.error('❌ Failed to load skybox images:', error);
                        console.log('🔍 Make sure these files exist:');
                        skyboxImages.forEach(url => console.log('  - ' + url));
                        
                        // Create a simple colored background as final fallback
                        scene.background = new THREE.Color(0x87CEEB); // Sky blue
                        console.log('🎨 Using solid color background as final fallback');
                    }
                );
            }

            function initGraphics() {

                container = document.getElementById('container');
                speedometer = document.getElementById('speedometer');

                scene = new THREE.Scene();
                
                // Set up skybox for both desktop and VR
                createThreeJSSkybox();

                // Create camera rig for VR positioning
                cameraRig = new THREE.Group();
                scene.add(cameraRig);

                // Orbit camera (backup)
                orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
                orbitCamera.position.x = -4.84;
                orbitCamera.position.y = 4.39;
                orbitCamera.position.z = -35.11;
                orbitCamera.lookAt(new THREE.Vector3(0.33, -0.40, 0.85));
                
                // First person camera
                firstPersonCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Add first person camera to the rig for VR
                cameraRig.add(firstPersonCamera);
                
                // Start with first person camera for VR
                camera = firstPersonCamera;
                controls = new THREE.OrbitControls(orbitCamera);
                controls.enabled = false; // Disabled by default

                // Quest optimization: reduce quality for performance
                const isQuest = navigator.userAgent.includes('Quest') || navigator.userAgent.includes('Oculus');
                
                renderer = new THREE.WebGLRenderer({ 
                    antialias: !isQuest, // Disable antialiasing on Quest
                    powerPreference: isQuest ? "high-performance" : "default"
                });
                renderer.setClearColor(0xbfd1e5);
                
                // Reduce pixel ratio on Quest for better performance
                const pixelRatio = isQuest ? Math.min(window.devicePixelRatio, 1.0) : window.devicePixelRatio;
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Enable WebXR
                renderer.xr.enabled = true;
                
                if (isQuest) {
                    console.log('📱 Quest optimizations applied: reduced pixel ratio, disabled antialiasing');
                }

                var ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(10, 10, 5);
                scene.add(dirLight);

                materialDynamic = new THREE.MeshPhongMaterial({ color: 0xfca400 });
                materialStatic = new THREE.MeshPhongMaterial({ color: 0x999999 });
                materialInteractive = new THREE.MeshPhongMaterial({ color: 0x990000 });
                
                // Transparent material for walls
                materialTransparent = new THREE.MeshPhongMaterial({ 
                    color: 0x999999, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });

                container.innerHTML = "";
                container.appendChild(renderer.domElement);

                // VR Button setup
                setupVRButton();

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = '1000';
                container.appendChild(stats.domElement);

                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', keydown);
                window.addEventListener('keyup', keyup);
                
                // Mouse movement for desktop fly camera
                document.addEventListener('mousemove', function(e) {
                    if (cameraMode === 'fly' && !renderer.xr.isPresenting && document.pointerLockElement) {
                        var sensitivity = 0.002;
                        desktopFlyRotation.y -= e.movementX * sensitivity; // Yaw (left/right)
                        desktopFlyRotation.x -= e.movementY * sensitivity; // Pitch (up/down)
                        desktopFlyRotation.z = 0; // Always keep roll at 0 to prevent tilt
                        
                        // Clamp pitch to prevent over-rotation
                        desktopFlyRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, desktopFlyRotation.x));
                    }
                });
            }

            function setupVRButton() {
                const vrButton = document.getElementById('vrButton');
                
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            vrButton.style.display = 'block';
                            vrButton.style.background = '#006600';
                            console.log('VR supported');
                        }
                    });
                }
                
                vrButton.addEventListener('click', async () => {
                    if (renderer.xr.isPresenting) {
                        renderer.xr.getSession().end();
                    } else {
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', {
                                optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers']
                            });
                            renderer.xr.setSession(session);
                            console.log('VR session started');
                            // Set up VR HUD when VR starts
                            setupVRHUD();
                            // Set up VR controllers
                            setupVRControllers();
                            // Set up cube layer for immersive background
                            setupCubeLayer(session);
                            // Hide desktop HUD in VR mode
                            document.body.classList.add('vr-mode');
                            
                            // Start audio in VR session (VR counts as user interaction)
                            // Add a small delay to ensure audio system is ready
                            setTimeout(() => {
                                startEngineAudio();
                                console.log('🎵 VR audio started');
                            }, 100);
                            
                            // Listen for VR session end to restore desktop HUD
                            session.addEventListener('end', () => {
                                console.log('VR session ended');
                                document.body.classList.remove('vr-mode');
                                vrAudioStarted = false; // Reset for next VR session
                            });
                        } catch (error) {
                            console.error('VR not supported:', error);
                        }
                    }
                });
            }

            function onWindowResize() {
                // Update both cameras
                orbitCamera.aspect = window.innerWidth / window.innerHeight;
                orbitCamera.updateProjectionMatrix();
                
                firstPersonCamera.aspect = window.innerWidth / window.innerHeight;
                firstPersonCamera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function initPhysics() {
                // Physics configuration
                collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                broadphase = new Ammo.btDbvtBroadphase();
                solver = new Ammo.btSequentialImpulseConstraintSolver();
                physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0));
            }

            // FPS counter function
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastFPSUpdate >= 500) { // Update every 500ms
                    const deltaTime = currentTime - lastFPSTime;
                    const fps = Math.round((frameCount * 1000) / deltaTime);
                    
                    fpsHistory.push(fps);
                    if (fpsHistory.length > 5) {
                        fpsHistory.shift();
                    }
                    
                    const avgFPS = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
                    currentFPS = avgFPS;
                    
                    // Update version display
                    const versionText = document.getElementById('versionText');
                    const fpsText = document.getElementById('fpsText');
                    if (versionText) versionText.textContent = APP_VERSION;
                    if (fpsText) fpsText.textContent = currentFPS + ' FPS';
                    
                    frameCount = 0;
                    lastFPSTime = currentTime;
                    lastFPSUpdate = currentTime;
                }
            }

            function tick() {
                // Add player state sending to sync list (only once)
                if (!this.playerStateSyncAdded) {
                    syncList.push(sendPlayerState);
                    this.playerStateSyncAdded = true;
                    console.log('🔄 Added player state sending to sync list');
                }
                
                // Add billboard update to sync list (only once)
                if (!this.billboardSyncAdded) {
                    syncList.push(updateTreeBillboards);
                    this.billboardSyncAdded = true;
                    console.log('🌲 Added tree billboard updates to sync list');
                }
                
                // Add vehicle collision detection to sync list (only once)
                if (!this.vehicleCollisionSyncAdded) {
                    syncList.push(checkVehicleCollisions);
                    this.vehicleCollisionSyncAdded = true;
                    console.log('🚗 Added vehicle collision detection to sync list');
                }
                
                // Use WebXR-compatible animation loop
                renderer.setAnimationLoop(() => {
                    var dt = clock.getDelta();
                    for (var i = 0; i < syncList.length; i++)
                        syncList[i](dt);
                    physicsWorld.stepSimulation(dt, 10);
                    
                    // Only update orbit controls when in orbit mode
                    if (cameraMode === 'orbit') {
                        controls.update(dt);
                    }
                    
                    // Update FPS counter
                    updateFPS();
                    
                    renderer.render(scene, camera);
                    time += dt;
                    stats.update();
                });
            }

            function keyup(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = false;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Desktop fly camera Q/E key release
                if (cameraMode === 'fly' && !renderer.xr.isPresenting) {
                    if (e.code === 'KeyQ') {
                        actions['flyDown'] = false;
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    if (e.code === 'KeyE') {
                        actions['flyUp'] = false;
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
            }
            
            function keydown(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = true;
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Menu toggle with 'B' key (like in DodgeVR)
                if (e.code === 'KeyB') {
                    toggleMenu();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Camera switching with 'C' key
                if (e.code === 'KeyC') {
                    switchCamera();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Toggle physics wireframe with 'P' key
                if (e.code === 'KeyP') {
                    togglePhysicsWireframe();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Reset car with 'R' key
                if (e.code === 'KeyR') {
                    resetCar();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                
                // Desktop fly camera Q/E for up/down (only in fly mode)
                if (cameraMode === 'fly' && !renderer.xr.isPresenting) {
                    if (e.code === 'KeyQ') {
                        actions['flyDown'] = true;
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    if (e.code === 'KeyE') {
                        actions['flyUp'] = true;
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
            }
            
            function setupVRControllers() {
                console.log('Setting up VR controllers...');
                
                // Create controllers using proper WebXR approach
                for (let i = 0; i < 2; i++) {
                    // Controller for input events (invisible)
                    const controller = renderer.xr.getController(i);
                    controller.userData.controllerIndex = i; // Store controller index
                    controller.addEventListener('selectstart', onSelectStart);
                    controller.addEventListener('selectend', onSelectEnd);
                    controller.addEventListener('connected', function(event) {
                        console.log('Controller', i, 'connected:', event.data);
                        this.add(buildController(event.data));
                    });
                    controller.addEventListener('disconnected', function() {
                        console.log('Controller', i, 'disconnected');
                        this.remove(this.children[0]);
                    });
                    cameraRig.add(controller); // Add to cameraRig instead of scene
                    vrControllers.push(controller);
                    
                    // Controller grip for 3D model (visible)
                    const controllerGrip = renderer.xr.getControllerGrip(i);
                    controllerGrip.addEventListener('connected', function(event) {
                        console.log('Controller grip', i, 'connected');
                        const mesh = buildControllerModel(event.data);
                        this.add(mesh);
                    });
                    controllerGrip.addEventListener('disconnected', function() {
                        console.log('Controller grip', i, 'disconnected');
                        this.remove(this.children[0]);
                    });
                    cameraRig.add(controllerGrip); // Add to cameraRig instead of scene
                    vrControllerModels.push(controllerGrip);
                    
                    // VR controller setup logging removed
                }
                
                // Debug elements removed for cleaner VR experience
            }
            
            // Debug functions removed for cleaner code
            
            function buildController(data) {
                // Controller building logging removed
                let geometry, material;
                
                switch (data.targetRayMode) {
                    case 'tracked-pointer':
                        // Create laser pointer with bright green color and thick line
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -5], 3));
                        
                        material = new THREE.LineBasicMaterial({
                            color: 0x00ff00,
                            transparent: false,
                            opacity: 1.0,
                            linewidth: 5 // Thick line
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.name = 'laser';
                        
                        // Also create a cylinder as backup visualization
                        const cylinderGeometry = new THREE.CylinderGeometry(0.002, 0.002, 5, 8);
                        const cylinderMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00,
                            transparent: false
                        });
                        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                        cylinder.position.set(0, 0, -2.5);
                        cylinder.rotation.x = Math.PI / 2;
                        line.add(cylinder);
                        
                        vrLaserPointers.push(line);
                        console.log('Created laser pointer with cylinder backup, total lasers:', vrLaserPointers.length);
                        return line;
                        
                    case 'gaze':
                        // Create dot for gaze-based input
                        geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
                        material = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000,
                            opacity: 0.8, 
                            transparent: true 
                        });
                        const gazeMesh = new THREE.Mesh(geometry, material);
                        console.log('Created gaze controller');
                        return gazeMesh;
                }
                
                console.log('Unknown targetRayMode, creating empty group');
                return new THREE.Group();
            }
            
            function buildControllerModel(data) {
                console.log('Building controller model for:', data);
                
                // Create a bright, visible controller model
                const geometry = new THREE.CylinderGeometry(0.02, 0.03, 0.15, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add a bright sphere at the tip
                const tipGeometry = new THREE.SphereGeometry(0.025);
                const tipMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 1.0
                });
                const tip = new THREE.Mesh(tipGeometry, tipMaterial);
                tip.position.set(0, 0.08, 0);
                mesh.add(tip);
                
                console.log('Created controller model with tip');
                return mesh;
            }
            
            function onSelectStart(event) {
                // Handle controller trigger press
                console.log('Controller select start');
            }
            
            function onSelectEnd(event) {
                // Handle controller trigger release
                console.log('Controller select end');
            }
            
            function updateLaserPointers() {
                // Show laser pointers only when menu is visible
                const showLasers = isMenuVisible && vrMenu && vrMenu.visible;
                
                vrLaserPointers.forEach((laser, index) => {
                    if (laser) {
                        laser.visible = showLasers;
                        // Make laser bright and visible when shown
                        if (laser.material && showLasers) {
                            laser.material.opacity = 1.0;
                            laser.material.color.setHex(0x00ff00); // Bright green
                        }
                    }
                });
                
                // Show/hide controller models based on menu visibility
                vrControllerModels.forEach((controllerGrip, index) => {
                    if (controllerGrip) {
                        controllerGrip.visible = showLasers;
                        
                        // Add fallback visualization if no controller model loaded (only once)
                        if (controllerGrip.children.length === 0) {
                            const fallbackGeometry = new THREE.SphereGeometry(0.05);
                            const fallbackMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xff0000,
                                transparent: true,
                                opacity: 1.0
                            });
                            const fallbackSphere = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                            controllerGrip.add(fallbackSphere);
                            console.log(`Added fallback visualization for controller ${index}`);
                        }
                    }
                });
                
                // Debug sphere code removed
            }

            function setupVRHUD() {
                if (vrHUD) return; // Already created
                
                // Create HUD group
                vrHUD = new THREE.Group();
                
                // Make HUD 25% of original size (half of previous 50%)
                vrHUD.scale.set(0.25, 0.25, 0.25);
                
                // Position HUD in front of player (relative to camera rig) - adjusted for new camera position
                vrHUD.position.set(0.25, 1.3, -0.15); // 25cm to the right, 10cm closer to camera
                
                // Create canvas for text rendering
                var canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                var context = canvas.getContext('2d');
                
                // Create texture from canvas
                var hudTexture = new THREE.CanvasTexture(canvas);
                hudTexture.needsUpdate = true;
                
                // Create HUD plane
                var hudGeometry = new THREE.PlaneGeometry(1, 0.5);
                var hudMaterial = new THREE.MeshBasicMaterial({
                    map: hudTexture,
                    transparent: true,
                    opacity: 0.8
                });
                
                var hudMesh = new THREE.Mesh(hudGeometry, hudMaterial);
                vrHUD.add(hudMesh);
                
                // Store references for updating
                vrHUD.userData = {
                    canvas: canvas,
                    context: context,
                    texture: hudTexture
                };
                
                // Add HUD to camera rig so it follows the player
                cameraRig.add(vrHUD);
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                
                console.log('🥽 VR HUD created');
            }
            
            // REALISTIC ENGINE SOUND SYSTEM: Advanced procedural engine sound generation
            class EngineSound {
                constructor(audioContext, baseFrequency = 45, volume = 0.25) {
                    this.audioContext = audioContext;
                    this.baseFrequency = baseFrequency;
                    this.volume = volume;
                    
                    // Engine characteristics
                    this.idleRPM = 800;
                    this.maxRPM = 7500;
                    this.currentRPM = this.idleRPM;
                    
                    // Audio nodes for complex engine sound
                    this.oscillators = [];
                    this.gainNodes = [];
                    this.noiseSource = null;
                    this.masterGain = null;
                    this.lowPassFilter = null;
                    this.highPassFilter = null;
                    this.distortion = null;
                    
                    this.isPlaying = false;
                    this.setupAudioNodes();
                }
                
                setupAudioNodes() {
                    // Master gain control
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    // High-pass filter to remove muddy low frequencies
                    this.highPassFilter = this.audioContext.createBiquadFilter();
                    this.highPassFilter.type = 'highpass';
                    this.highPassFilter.frequency.setValueAtTime(80, this.audioContext.currentTime);
                    this.highPassFilter.Q.setValueAtTime(0.7, this.audioContext.currentTime);
                    
                    // Low-pass filter for engine character
                    this.lowPassFilter = this.audioContext.createBiquadFilter();
                    this.lowPassFilter.type = 'lowpass';
                    this.lowPassFilter.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                    this.lowPassFilter.Q.setValueAtTime(2, this.audioContext.currentTime);
                    
                    // Distortion for engine growl
                    this.distortion = this.audioContext.createWaveShaper();
                    this.distortion.curve = this.createDistortionCurve(15);
                    this.distortion.oversample = '4x';
                    
                    // Connect audio chain: highpass -> lowpass -> distortion -> master gain -> output
                    this.highPassFilter.connect(this.lowPassFilter);
                    this.lowPassFilter.connect(this.distortion);
                    this.distortion.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Create noise buffer for engine texture
                    this.createAdvancedNoiseBuffer();
                }
                
                createDistortionCurve(amount) {
                    var samples = 44100;
                    var curve = new Float32Array(samples);
                    var deg = Math.PI / 180;
                    
                    for (var i = 0; i < samples; i++) {
                        var x = (i * 2) / samples - 1;
                        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                    }
                    
                    return curve;
                }
                
                createAdvancedNoiseBuffer() {
                    var bufferSize = this.audioContext.sampleRate * 3; // 3 seconds of noise
                    this.noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    var output = this.noiseBuffer.getChannelData(0);
                    
                    // Generate realistic engine noise with multiple frequency components
                    var b0, b1, b2, b3, b4, b5, b6;
                    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
                    
                    for (var i = 0; i < bufferSize; i++) {
                        var white = Math.random() * 2 - 1;
                        
                        // Pink noise filter (1/f noise for more natural engine sound)
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        
                        var pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        b6 = white * 0.115926;
                        
                        output[i] = pink * 0.08; // Reduced amplitude for mixing
                    }
                }
                
                start() {
                    if (this.isPlaying) return;
                    
                    // Create multiple oscillators for realistic engine harmonics
                    const oscillatorCount = 6;
                    this.oscillators = [];
                    this.gainNodes = [];
                    
                    // Engine harmonic frequencies and characteristics
                    const harmonics = [
                        { type: 'sawtooth', gain: 0.35, detune: 0 },      // Fundamental
                        { type: 'square', gain: 0.25, detune: -5 },       // Slightly detuned for beating
                        { type: 'triangle', gain: 0.20, detune: 3 },      // Higher harmonic
                        { type: 'sawtooth', gain: 0.15, detune: -2 },     // Sub-harmonic
                        { type: 'square', gain: 0.12, detune: 7 },        // Higher frequency component
                        { type: 'triangle', gain: 0.08, detune: -8 }      // Texture oscillator
                    ];
                    
                    for (let i = 0; i < oscillatorCount; i++) {
                        // Create oscillator and gain
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        // Set oscillator properties
                        osc.type = harmonics[i].type;
                        osc.detune.setValueAtTime(harmonics[i].detune, this.audioContext.currentTime);
                        
                        // Set gain
                        gain.gain.setValueAtTime(harmonics[i].gain, this.audioContext.currentTime);
                        
                        // Connect oscillator -> gain -> filter chain
                        osc.connect(gain);
                        gain.connect(this.highPassFilter);
                        
                        // Store references
                        this.oscillators.push(osc);
                        this.gainNodes.push(gain);
                        
                        // Start oscillator
                        osc.start();
                    }
                    
                    // Add realistic engine noise
                    this.noiseSource = this.audioContext.createBufferSource();
                    this.noiseSource.buffer = this.noiseBuffer;
                    this.noiseSource.loop = true;
                    
                    const noiseGain = this.audioContext.createGain();
                    noiseGain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    
                    this.noiseSource.connect(noiseGain);
                    noiseGain.connect(this.highPassFilter);
                    this.noiseSource.start();
                    
                    // Fade in engine sound
                    this.masterGain.gain.setTargetAtTime(this.volume, this.audioContext.currentTime, 0.2);
                    
                    this.isPlaying = true;
                    this.updateFrequencies();
                }
                
                stop() {
                    if (!this.isPlaying) return;
                    
                    // Fade out
                    this.masterGain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.2);
                    
                    // Stop all sources after fade out
                    setTimeout(() => {
                        this.oscillators.forEach(osc => {
                            if (osc) osc.stop();
                        });
                        if (this.noiseSource) {
                            this.noiseSource.stop();
                        }
                        this.oscillators = [];
                        this.gainNodes = [];
                        this.isPlaying = false;
                    }, 300);
                }
                
                updateEngine(speed, throttle, acceleration, braking) {
                    if (!this.isPlaying) return;
                    
                    // REALISTIC RPM calculation based on actual car behavior
                    const absSpeed = Math.abs(speed);
                    
                    // Simulate automatic transmission gear ratios
                    let gearRatio = 1;
                    if (absSpeed < 20) gearRatio = 1;      // 1st gear
                    else if (absSpeed < 40) gearRatio = 0.7;  // 2nd gear  
                    else if (absSpeed < 70) gearRatio = 0.5;  // 3rd gear
                    else if (absSpeed < 100) gearRatio = 0.4; // 4th gear
                    else gearRatio = 0.3;                     // 5th gear
                    
                    // Base RPM from speed with gear simulation
                    let speedRPM = this.idleRPM + (absSpeed * 50 * gearRatio);
                    
                    // Engine load based on acceleration demand vs actual acceleration
                    let engineLoad = 0;
                    if (throttle > 0.1) {
                        // Under throttle - RPM rises based on demand vs speed
                        engineLoad = Math.max(0, throttle - (absSpeed / 120)); // Less load at high speeds
                        engineLoad = Math.min(engineLoad, 1); // Cap at 1
                    }
                    
                    // RPM boost from engine load (not just throttle input)
                    let loadRPM = engineLoad * 3500; // Max 3500 RPM from load
                    
                    // Combine for realistic behavior
                    let targetRPM = speedRPM + loadRPM;
                    
                    // Deceleration behavior
                    if (braking > 0.3 || throttle < 0.05) {
                        // Engine braking or coasting - RPM follows speed more closely
                        targetRPM = Math.max(this.idleRPM, speedRPM * 0.8);
                    }
                    
                    // Rev limiter and idle
                    targetRPM = Math.max(this.idleRPM, Math.min(targetRPM, this.maxRPM));
                    
                    // Realistic RPM response - faster up, slower down
                    const rpmDiff = targetRPM - this.currentRPM;
                    let rpmRate;
                    if (rpmDiff > 0) {
                        // RPM rising - faster response under load
                        rpmRate = engineLoad > 0.3 ? 0.12 : 0.06;
                    } else {
                        // RPM falling - slower response (engine inertia)
                        rpmRate = 0.04;
                    }
                    
                    this.currentRPM += rpmDiff * rpmRate;
                    
                    // Update sound characteristics
                    this.updateFrequencies();
                    this.updateVolume(engineLoad, absSpeed);
                    this.updateFilters(engineLoad, absSpeed);
                }
                
                updateFrequencies() {
                    if (!this.isPlaying || this.oscillators.length === 0) return;
                    
                    // Calculate base frequency from RPM
                    const baseFreq = this.baseFrequency * (this.currentRPM / 1000);
                    
                    // Update each oscillator with realistic harmonic relationships
                    const harmonicMultipliers = [1.0, 2.1, 1.5, 0.7, 3.2, 0.4];
                    
                    this.oscillators.forEach((osc, index) => {
                        if (osc && index < harmonicMultipliers.length) {
                            const freq = baseFreq * harmonicMultipliers[index];
                            osc.frequency.setTargetAtTime(freq, this.audioContext.currentTime, 0.02);
                        }
                    });
                }
                
                updateVolume(throttle, speed) {
                    if (!this.isPlaying) return;
                    
                    // Dynamic volume based on throttle and RPM
                    const rpmFactor = (this.currentRPM - this.idleRPM) / (this.maxRPM - this.idleRPM);
                    const throttleFactor = Math.pow(throttle, 0.7); // Non-linear throttle response
                    
                    // Base volume varies with RPM and throttle
                    let targetVolume = this.volume * (0.4 + rpmFactor * 0.3 + throttleFactor * 0.5);
                    
                    // Add some engine load variation
                    if (throttle > 0.8 && speed > 60) {
                        targetVolume *= 1.2; // Louder under heavy load
                    }
                    
                    this.masterGain.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.08);
                }
                
                updateFilters(throttle, speed) {
                    if (!this.isPlaying) return;
                    
                    // Dynamic filter frequencies for realistic engine character
                    const rpmFactor = this.currentRPM / this.maxRPM;
                    
                    // Low-pass filter opens up with RPM for more aggressive sound
                    const lowPassFreq = 800 + (rpmFactor * 1200) + (throttle * 400);
                    this.lowPassFilter.frequency.setTargetAtTime(lowPassFreq, this.audioContext.currentTime, 0.05);
                    
                    // High-pass filter adjusts for engine load
                    const highPassFreq = 60 + (throttle * 40) + (rpmFactor * 30);
                    this.highPassFilter.frequency.setTargetAtTime(highPassFreq, this.audioContext.currentTime, 0.05);
                    
                    // Filter Q for more aggressive sound under load
                    const filterQ = 1.5 + (throttle * 1.0) + (rpmFactor * 0.8);
                    this.lowPassFilter.Q.setTargetAtTime(filterQ, this.audioContext.currentTime, 0.05);
                }
            }
            
            // TIRE SCREECH SOUND SYSTEM: For drifting and hard braking
            class TireScreechSound {
                constructor(audioContext, volume = 0.3) {
                    this.audioContext = audioContext;
                    this.volume = volume;
                    this.isPlaying = false;
                    
                    // Audio nodes
                    this.oscillator = null;
                    this.noiseSource = null;
                    this.gainNode = null;
                    this.filterNode = null;
                    this.noiseBuffer = null;
                    
                    this.setupAudioNodes();
                    this.createNoiseBuffer();
                }
                
                setupAudioNodes() {
                    // Master gain control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    // Band-pass filter for tire screech frequency range
                    this.filterNode = this.audioContext.createBiquadFilter();
                    this.filterNode.type = 'bandpass';
                    this.filterNode.frequency.setValueAtTime(2000, this.audioContext.currentTime);
                    this.filterNode.Q.setValueAtTime(8, this.audioContext.currentTime);
                    
                    // Connect audio chain
                    this.filterNode.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                }
                
                createNoiseBuffer() {
                    var bufferSize = this.audioContext.sampleRate * 2;
                    this.noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    var output = this.noiseBuffer.getChannelData(0);
                    
                    // Generate filtered white noise for tire screech
                    for (var i = 0; i < bufferSize; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.5;
                    }
                }
                
                start(intensity = 0.5) {
                    if (this.isPlaying) return;
                    
                    // Create noise source
                    this.noiseSource = this.audioContext.createBufferSource();
                    this.noiseSource.buffer = this.noiseBuffer;
                    this.noiseSource.loop = true;
                    this.noiseSource.connect(this.filterNode);
                    
                    // Start with fade in
                    this.noiseSource.start();
                    this.gainNode.gain.setTargetAtTime(this.volume * intensity, this.audioContext.currentTime, 0.1);
                    
                    this.isPlaying = true;
                }
                
                stop() {
                    if (!this.isPlaying) return;
                    
                    // Fade out
                    this.gainNode.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.2);
                    
                    setTimeout(() => {
                        if (this.noiseSource) {
                            this.noiseSource.stop();
                            this.noiseSource = null;
                        }
                        this.isPlaying = false;
                    }, 300);
                }
                
                updateIntensity(intensity, frequency = 2000) {
                    if (!this.isPlaying) return;
                    
                    // Update volume based on drift intensity
                    var targetVolume = this.volume * Math.min(intensity, 1);
                    this.gainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.05);
                    
                    // Update filter frequency based on speed/intensity
                    this.filterNode.frequency.setTargetAtTime(frequency, this.audioContext.currentTime, 0.05);
                }
            }
            
            // IMPACT SOUND SYSTEM: For collisions and crashes
            class ImpactSound {
                constructor(audioContext, volume = 0.4) {
                    this.audioContext = audioContext;
                    this.volume = volume;
                }
                
                playImpact(intensity = 1.0) {
                    // Create a short burst of noise for impact
                    var duration = 0.3 + (intensity * 0.2); // 0.3-0.5 seconds
                    
                    // Create oscillator for metallic crash sound
                    var oscillator = this.audioContext.createOscillator();
                    var noiseSource = this.audioContext.createBufferSource();
                    var gainNode = this.audioContext.createGain();
                    var filterNode = this.audioContext.createBiquadFilter();
                    
                    // Setup crash sound
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200 + (intensity * 300), this.audioContext.currentTime);
                    
                    // Create noise buffer for crash
                    var bufferSize = this.audioContext.sampleRate * duration;
                    var noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    var output = noiseBuffer.getChannelData(0);
                    
                    for (var i = 0; i < bufferSize; i++) {
                        var decay = 1 - (i / bufferSize); // Exponential decay
                        output[i] = (Math.random() * 2 - 1) * decay * 0.8;
                    }
                    
                    noiseSource.buffer = noiseBuffer;
                    
                    // Setup filter for crash character
                    filterNode.type = 'highpass';
                    filterNode.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    
                    // Connect and play
                    oscillator.connect(gainNode);
                    noiseSource.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Volume envelope
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.setTargetAtTime(this.volume * intensity, this.audioContext.currentTime, 0.01);
                    gainNode.gain.setTargetAtTime(0, this.audioContext.currentTime + duration * 0.7, duration * 0.3);
                    
                    // Start and stop
                    oscillator.start();
                    noiseSource.start();
                    
                    setTimeout(() => {
                        oscillator.stop();
                        noiseSource.stop();
                    }, duration * 1000);
                }
            }
            
            function initAudioSystem() {
                try {
                    // Create audio context
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create realistic engine sounds with growling characteristics
                    playerEngineSound = new EngineSound(audioContext, 42, 0.18); // Player car - deeper, more growling
                    botEngineSound = new EngineSound(audioContext, 48, 0.12);    // Bot car - slightly higher pitch, quieter
                    
                    // Create additional driving sounds
                    window.tireScreechSound = new TireScreechSound(audioContext, 0.25); // Tire screech for drifting
                    window.impactSound = new ImpactSound(audioContext, 0.35);           // Impact sounds for crashes
                    
                    // Initialize background music
                    backgroundMusic = document.getElementById('backgroundMusic');
                    if (backgroundMusic) {
                        backgroundMusic.volume = 0.6; // Set to 60% volume to be more prominent than engine sounds
                        
                        // Add error handling for audio loading
                        backgroundMusic.addEventListener('error', function(e) {
                            console.warn('🎵 Background music failed to load:', e);
                        });
                        
                        backgroundMusic.addEventListener('canplaythrough', function() {
                            console.log('🎵 Background music loaded successfully');
                        });
                        
                        console.log('🎵 Background music initialized');
                    }
                    
                    console.log('🔊 Audio system initialized');
                    
                    // Start audio on first user interaction
                    var startAudioOnInteraction = function() {
                        startEngineAudio();
                        document.removeEventListener('click', startAudioOnInteraction);
                        document.removeEventListener('keydown', startAudioOnInteraction);
                        document.removeEventListener('touchstart', startAudioOnInteraction);
                    };
                    
                    document.addEventListener('click', startAudioOnInteraction);
                    document.addEventListener('keydown', startAudioOnInteraction);
                    document.addEventListener('touchstart', startAudioOnInteraction);
                    
                } catch (error) {
                    console.warn('Audio system not available:', error);
                }
            }

            // GLOBAL AUDIO CONTROL: Resume audio context and start engine sounds (requires user interaction)
            function startEngineAudio() {
                if (!audioContext || !playerEngineSound || !botEngineSound) {
                    console.warn('Audio system not initialized yet');
                    return;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playerEngineSound.start();
                        botEngineSound.start();
                        console.log('🔊 Engine sounds started (resumed context)');
                        // Start background music if enabled
                        if (backgroundMusic && musicEnabled) {
                            backgroundMusic.play().then(() => {
                                console.log('🎵 Background music started');
                            }).catch(error => {
                                console.warn('Background music failed to start:', error);
                            });
                        }
                    }).catch(error => {
                        console.warn('Failed to resume audio context:', error);
                    });
                } else {
                    playerEngineSound.start();
                    botEngineSound.start();
                    console.log('🔊 Engine sounds started');
                    // Start background music if enabled
                    if (backgroundMusic && musicEnabled) {
                        backgroundMusic.play().then(() => {
                            console.log('🎵 Background music started');
                        }).catch(error => {
                            console.warn('Background music failed to start:', error);
                        });
                    }
                }
            }

            function updateVRHUD() {
                if (!vrHUD || !vrHUD.userData) return;
                
                var canvas = vrHUD.userData.canvas;
                var context = vrHUD.userData.context;
                var texture = vrHUD.userData.texture;
                
                // Clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set up text styling
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = '#ffffff';
                context.font = 'bold 32px Arial';
                context.textAlign = 'left';
                
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Draw lap information
                var yPos = 50;
                var lineHeight = 40;
                
                // Lap number
                context.fillText('LAP: ' + currentLapNumber, 20, yPos);
                yPos += lineHeight;
                
                // Current lap time
                context.fillText('TIME: ' + formatTime(currentLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Best lap time
                context.fillText('BEST: ' + formatTime(bestLapTime), 20, yPos);
                yPos += lineHeight;
                
                // Checkpoint progress
                var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                context.fillText('CHECKPOINT: ' + currentCheckpoint + '/' + totalCheckpoints, 20, yPos);
                yPos += lineHeight;
                
                // FPS display
                context.fillText('FPS: ' + currentFPS, 20, yPos);
                yPos += lineHeight;
                
                // Speedometer - get current speed from vehicle
                var currentSpeed = 0;
                if (typeof vehicleRef !== 'undefined' && vehicleRef && vehicleRef.vehicle) {
                    currentSpeed = Math.abs(vehicleRef.vehicle.getCurrentSpeedKmHour());
                }
                context.fillText('SPEED: ' + Math.round(currentSpeed) + ' km/h', 20, yPos);
                yPos += lineHeight;
                
                // Update texture
                texture.needsUpdate = true;
            }

            // DESKTOP HUD UPDATE: Update desktop HUD with same info as VR HUD
            function updateDesktopHUD() {
                // Calculate current lap time
                if (currentLapStartTime > 0) {
                    currentLapTime = (Date.now() - currentLapStartTime) / 1000;
                } else {
                    console.warn('⚠️ Desktop HUD: currentLapStartTime not initialized:', currentLapStartTime);
                }
                
                // Format time function
                function formatTime(seconds) {
                    if (seconds === null || seconds === undefined) return '--:--.---';
                    var minutes = Math.floor(seconds / 60);
                    var secs = (seconds % 60).toFixed(3);
                    return minutes + ':' + (secs < 10 ? '0' : '') + secs;
                }
                
                // Update desktop HUD elements
                var lapElement = document.getElementById('desktopLapNumber');
                var timeElement = document.getElementById('desktopCurrentTime');
                var bestElement = document.getElementById('desktopBestTime');
                var checkpointElement = document.getElementById('desktopCheckpoint');
                
                if (lapElement) lapElement.textContent = currentLapNumber;
                if (timeElement) timeElement.textContent = formatTime(currentLapTime);
                if (bestElement) bestElement.textContent = formatTime(bestLapTime);
                
                // Update checkpoint progress
                if (checkpointElement) {
                    var totalCheckpoints = checkpointMarkers ? checkpointMarkers.length : 0;
                    var currentCheckpoint = playerLastPassedCheckpoint + 1; // +1 because we show next checkpoint to reach
                    if (currentCheckpoint > totalCheckpoints) currentCheckpoint = totalCheckpoints;
                    checkpointElement.textContent = currentCheckpoint + '/' + totalCheckpoints;
                }
            }

            // ========== MENU SYSTEM ==========
            function toggleMenu() {
                isMenuVisible = !isMenuVisible;
                
                if (renderer.xr.isPresenting) {
                    // VR Mode: Toggle 3D menu
                    console.log('VR Mode - Menu toggle. Current state:', isMenuVisible, 'VR Menu exists:', !!vrMenu);
                    if (vrMenu) {
                        vrMenu.visible = isMenuVisible;
                        console.log('VR Menu visibility set to:', isMenuVisible);
                        if (isMenuVisible) {
                            try {
                                updateVRMenuDisplay();
                                console.log('VR Menu display updated successfully');
                            } catch (error) {
                                console.error('Error updating VR menu display:', error);
                            }
                        }
                    } else if (isMenuVisible) {
                        console.log('Creating new VR menu...');
                        try {
                            createVRMenu();
                            console.log('VR Menu created successfully');
                        } catch (error) {
                            console.error('Error creating VR menu:', error);
                        }
                    }
                    
                    // Hide/show VR HUD when menu is toggled in VR
                    if (vrHUD) {
                        vrHUD.visible = !isMenuVisible;
                        console.log('VR HUD visibility set to:', !isMenuVisible);
                    }
                } else {
                    // Desktop Mode: Toggle HTML menu
                    const gameMenu = document.getElementById('gameMenu');
                    if (gameMenu) {
                        gameMenu.style.display = isMenuVisible ? 'flex' : 'none';
                    }
                }
                
                // Hide/show desktop HUD and version display when menu is toggled
                const desktopHUD = document.getElementById('desktopHUD');
                const versionDisplay = document.getElementById('versionDisplay');
                if (desktopHUD) {
                    desktopHUD.style.display = isMenuVisible ? 'none' : 'block';
                }
                if (versionDisplay) {
                    versionDisplay.style.display = isMenuVisible ? 'none' : 'block';
                }
                
                console.log('Menu toggled:', isMenuVisible ? 'visible' : 'hidden');
            }

            function createVRMenu() {
                if (vrMenu) return; // Already created
                
                vrMenu = new THREE.Group();
                
                // Position menu in front of user (adjusted for new camera position)
                vrMenu.position.set(0, 2.0, -2.0); // 2m up, right in front of camera at 2m distance
                
                // Add to camera rig so it follows the user's head
                if (cameraRig) {
                    cameraRig.add(vrMenu);
                    console.log('VR Menu added to camera rig');
                } else {
                    scene.add(vrMenu);
                    console.log('VR Menu added to scene (fallback)');
                }
                console.log('VR Menu positioned at:', vrMenu.position);
                
                // Menu background - barely transparent black
                const bgGeometry = new THREE.PlaneGeometry(1.4, 1.0);
                const bgMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000, // Black background
                    transparent: true, 
                    opacity: 0.1 // Barely visible
                });
                const background = new THREE.Mesh(bgGeometry, bgMaterial);
                background.position.z = -0.01;
                vrMenu.add(background);
                
                // Add border to make menu more visible
                const borderGeometry = new THREE.PlaneGeometry(1.45, 1.05);
                const borderMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff, // Blue border
                    transparent: true, 
                    opacity: 0.8 
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.z = -0.02;
                vrMenu.add(border);
                
                
                // Title
                const titleGeometry = new THREE.PlaneGeometry(0.8, 0.1);
                const titleCanvas = document.createElement('canvas');
                titleCanvas.width = 512;
                titleCanvas.height = 64;
                const titleCtx = titleCanvas.getContext('2d');
                titleCtx.fillStyle = '#ffffff';
                titleCtx.font = 'bold 32px Arial';
                titleCtx.textAlign = 'center';
                titleCtx.fillText('WEBXR DRIVE MENU', 256, 40);
                const titleTexture = new THREE.CanvasTexture(titleCanvas);
                const titleMaterial = new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true });
                const title = new THREE.Mesh(titleGeometry, titleMaterial);
                title.position.set(0, 0.35, 0);
                vrMenu.add(title);
                
                // Current mode display
                const modeGeometry = new THREE.PlaneGeometry(0.8, 0.08);
                const modeCanvas = document.createElement('canvas');
                modeCanvas.width = 512;
                modeCanvas.height = 48;
                const modeTexture = new THREE.CanvasTexture(modeCanvas);
                const modeMaterial = new THREE.MeshBasicMaterial({ map: modeTexture, transparent: true });
                const modeDisplay = new THREE.Mesh(modeGeometry, modeMaterial);
                modeDisplay.position.set(0, 0.25, 0);
                modeDisplay.userData = { type: 'display', id: 'mode-display', canvas: modeCanvas, texture: modeTexture };
                vrMenu.add(modeDisplay);
                
                // Single/Multi buttons
                const singleBtn = createVRButton('SINGLE', -0.25, 0.15, 0.25, 0.08, '#004499', 'singleplayer');
                const multiBtn = createVRButton('MULTI', 0.25, 0.15, 0.25, 0.08, '#990044', 'multiplayer');
                vrMenu.add(singleBtn);
                vrMenu.add(multiBtn);
                vrMenuButtons.push(singleBtn, multiBtn);
                
                // Lobby section (initially hidden)
                const lobbyGroup = new THREE.Group();
                lobbyGroup.position.set(0, 0.05, 0);
                lobbyGroup.visible = false;
                lobbyGroup.userData = { type: 'lobby-section' };
                
                // Lobby label
                const lobbyLabel = createVRText('Lobby:', -0.4, 0, 0.3);
                lobbyGroup.add(lobbyLabel);
                
                // Lobby controls
                const lobbyMinus = createVRButton('-', -0.15, 0, 0.06, 0.06, '#ff4444', 'lobby-minus');
                const lobbyPlus = createVRButton('+', -0.05, 0, 0.06, 0.06, '#44ff44', 'lobby-plus');
                const lobbyNumber = createVRText('1', -0.1, 0, 0.4);
                lobbyNumber.userData.type = 'display';
                lobbyNumber.userData.id = 'lobby-number';
                
                const connectBtn = createVRButton('CONNECT', 0.1, 0, 0.2, 0.06, '#4444ff', 'connect');
                const autoBtn = createVRButton('AUTO', 0.35, 0, 0.15, 0.06, '#44aa44', 'auto-connect');
                
                lobbyGroup.add(lobbyMinus, lobbyPlus, lobbyNumber, connectBtn, autoBtn);
                vrMenuButtons.push(lobbyMinus, lobbyPlus, connectBtn, autoBtn);
                vrMenu.add(lobbyGroup);
                
                // Bot toggle
                const botGroup = new THREE.Group();
                botGroup.position.set(0, -0.05, 0);
                
                const botLabel = createVRText('Bot:', -0.2, 0, 0.3);
                const botToggle = createVRButton('ON', 0, 0, 0.12, 0.06, '#00aa00', 'bot-toggle');
                const botStatus = createVRText('(Single & Host)', 0.25, 0, 0.25);
                botStatus.userData.type = 'display';
                botStatus.userData.id = 'bot-status';
                
                botGroup.add(botLabel, botToggle, botStatus);
                vrMenuButtons.push(botToggle);
                vrMenu.add(botGroup);
                
                // Music toggle
                const musicGroup = new THREE.Group();
                musicGroup.position.set(0, -0.15, 0);
                
                const musicLabel = createVRText('Music:', -0.2, 0, 0.3);
                const musicToggle = createVRButton('ON', 0, 0, 0.12, 0.06, '#00aa00', 'music-toggle');
                const musicStatus = createVRText('(Background)', 0.25, 0, 0.25);
                musicStatus.userData.type = 'display';
                musicStatus.userData.id = 'music-status';
                
                musicGroup.add(musicLabel, musicToggle, musicStatus);
                vrMenuButtons.push(musicToggle);
                vrMenu.add(musicGroup);
                
                // Start Race button
                const startBtn = createVRButton('START RACE', 0, -0.35, 0.25, 0.08, '#00aa00', 'start-race');
                vrMenu.add(startBtn);
                vrMenuButtons.push(startBtn);
                
                // Close button
                const closeBtn = createVRButton('CLOSE', 0, -0.45, 0.2, 0.08, '#666666', 'close');
                vrMenu.add(closeBtn);
                vrMenuButtons.push(closeBtn);
                
                // Status display
                const statusDisplay = createVRText('Disconnected', 0, -0.55, 0.4);
                statusDisplay.userData.type = 'display';
                statusDisplay.userData.id = 'status';
                vrMenu.add(statusDisplay);
                
                // Create raycaster for VR interaction
                vrMenuRaycaster = new THREE.Raycaster();
                
                console.log('VR Menu created with', vrMenuButtons.length, 'buttons');
            }

            function createVRButton(text, x, y, width, height, color, id) {
                const group = new THREE.Group();
                group.position.set(x, y, 0);
                group.userData = { type: 'button', id: id, active: false };
                
                // Button background
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(color), 
                    transparent: true, 
                    opacity: 0.8 
                });
                const button = new THREE.Mesh(geometry, material);
                group.add(button);
                
                // Button text
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 256;
                textCanvas.height = 64;
                const ctx = textCanvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.9, height * 0.7), textMaterial);
                textMesh.position.z = 0.001;
                group.add(textMesh);
                
                group.userData.originalColor = new THREE.Color(color);
                group.userData.material = material;
                group.userData.textCanvas = textCanvas;
                group.userData.textTexture = textTexture;
                
                return group;
            }

            function createVRText(text, x, y, scale) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const geometry = new THREE.PlaneGeometry(scale, scale * 0.25);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, 0);
                mesh.userData = { canvas: canvas, texture: texture };
                
                return mesh;
            }

            function updateVRMenuDisplay() {
                if (!vrMenu) return;
                
                // Update mode display
                const modeDisplay = vrMenu.children.find(child => 
                    child.userData.type === 'display' && child.userData.id === 'mode-display'
                );
                if (modeDisplay) {
                    const ctx = modeDisplay.userData.canvas.getContext('2d');
                    ctx.clearRect(0, 0, 512, 48);
                    ctx.fillStyle = '#00ff88';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    const modeText = isMultiplayer ? 
                        `Mode: Multiplayer (Lobby ${selectedLobby}) (${activePlayers.size || 1}/4)` : 
                        'Mode: Singleplayer';
                    ctx.fillText(modeText, 256, 30);
                    modeDisplay.userData.texture.needsUpdate = true;
                }
                
                // Update lobby section visibility
                const lobbySection = vrMenu.children.find(child => 
                    child.userData.type === 'lobby-section'
                );
                if (lobbySection) {
                    lobbySection.visible = isMultiplayer;
                    
                    // Update lobby number within the same section
                    const lobbyNumber = lobbySection.children.find(child => 
                        child.userData.type === 'display' && child.userData.id === 'lobby-number'
                    );
                    if (lobbyNumber && lobbyNumber.userData.canvas) {
                        const ctx = lobbyNumber.userData.canvas.getContext('2d');
                        ctx.clearRect(0, 0, 256, 64);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(selectedLobby.toString(), 128, 40);
                        lobbyNumber.userData.texture.needsUpdate = true;
                    }
                } else {
                    console.log('VR Menu - Lobby section not found');
                }
                
                // Update button states
                vrMenuButtons.forEach(button => {
                    const id = button.userData.id;
                    let active = false;
                    let disabled = false;
                    
                    if (id === 'singleplayer') active = !isMultiplayer;
                    else if (id === 'multiplayer') active = isMultiplayer;
                    else if (id === 'bot-toggle') active = botEnabled;
                    else if (id === 'music-toggle') active = musicEnabled;
                    else if (id === 'connect') {
                        // Update connect button based on connection state
                        disabled = (connectionState === 'connecting');
                        active = connectionState === 'connected';
                        
                        // Update button text
                        if (button.userData.canvas) {
                            const ctx = button.userData.canvas.getContext('2d');
                            ctx.clearRect(0, 0, 256, 64);
                            ctx.fillStyle = disabled ? '#666666' : (active ? '#ffffff' : '#ffffff');
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            const buttonText = connectionState === 'connected' ? 'DISCONNECT' : 
                                             connectionState === 'connecting' ? 'CONNECTING...' : 'CONNECT';
                            ctx.fillText(buttonText, 128, 40);
                            button.userData.texture.needsUpdate = true;
                        }
                    }
                    
                    if (active !== button.userData.active || disabled !== button.userData.disabled) {
                        button.userData.active = active;
                        button.userData.disabled = disabled;
                        const material = button.userData.material;
                        
                        if (disabled) {
                            material.color.setHex(0x666666); // Gray when disabled
                            material.opacity = 0.5;
                        } else if (active) {
                            material.color.setHex(0x0088ff); // Blue when active/connected
                            material.opacity = 1.0;
                        } else {
                            material.color.copy(button.userData.originalColor);
                            material.opacity = 0.8;
                        }
                    }
                });
                
                // Update status
                const statusDisplay = vrMenu.children.find(child => 
                    child.userData.type === 'display' && child.userData.id === 'status'
                );
                if (statusDisplay && statusDisplay.userData.canvas) {
                    const ctx = statusDisplay.userData.canvas.getContext('2d');
                    ctx.clearRect(0, 0, 256, 64);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(multiplayerStatus, 128, 40);
                    statusDisplay.userData.texture.needsUpdate = true;
                }
            }

            function handleVRMenuClick(controllerIndex) {
                if (!vrMenuRaycaster || !vrMenu || vrControllers.length === 0) return;
                
                // Use the specific controller that triggered the click
                const controller = vrControllers[controllerIndex];
                if (!controller || !controller.matrixWorld) return;
                
                // Set raycaster from controller
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                
                vrMenuRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                vrMenuRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                // Check intersections with menu buttons
                const intersects = vrMenuRaycaster.intersectObjects(vrMenuButtons, true);
                
                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object.parent;
                    const buttonId = clickedObject.userData.id;
                    
                    // Check if button is disabled
                    if (clickedObject.userData.disabled) {
                        console.log('VR Menu button clicked but disabled:', buttonId);
                        return;
                    }
                    
                    console.log('VR Menu button clicked:', buttonId);
                    
                    // Handle button actions
                    switch (buttonId) {
                        case 'singleplayer':
                            console.log('Switching to singleplayer');
                            switchToSingleplayer();
                            break;
                        case 'multiplayer':
                            console.log('Switching to multiplayer');
                            switchToMultiplayer();
                            break;
                        case 'lobby-minus':
                            console.log('Lobby minus clicked');
                            changeLobby(-1);
                            break;
                        case 'lobby-plus':
                            console.log('Lobby plus clicked');
                            changeLobby(1);
                            break;
                        case 'connect':
                            if (connectionState === 'connected') {
                                disconnectFromLobby();
                            } else {
                                connectToLobby();
                            }
                            break;
                        case 'auto-connect':
                            autoConnect();
                            break;
                        case 'bot-toggle':
                            toggleBot();
                            break;
                        case 'music-toggle':
                            toggleMusic();
                            break;
                        case 'start-race':
                            startRace();
                            break;
                        case 'close':
                            toggleMenu();
                            break;
                    }
                    
                    // Update menu display after action
                    if (vrMenu && vrMenu.visible) {
                        updateVRMenuDisplay();
                    }
                }
            }

            function updateVRMenuHover(controllerIndex) {
                if (!vrMenuRaycaster || !vrMenu || vrControllers.length === 0) return;
                
                // Use the specific controller for hover detection
                const controller = vrControllers[controllerIndex];
                if (!controller || !controller.matrixWorld) return;
                
                // Reset all buttons to normal state first
                vrMenuButtons.forEach(button => {
                    const material = button.userData.material;
                    if (!button.userData.active) {
                        material.color.copy(button.userData.originalColor);
                        material.opacity = 0.8;
                    }
                });
                
                // Set raycaster from this controller
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                
                vrMenuRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                vrMenuRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                // Check intersections with menu buttons
                const intersects = vrMenuRaycaster.intersectObjects(vrMenuButtons, true);
                
                // Highlight hovered button for this controller
                if (intersects.length > 0) {
                    const hoveredObject = intersects[0].object.parent;
                    const material = hoveredObject.userData.material;
                    if (material && !hoveredObject.userData.active && !hoveredObject.userData.disabled) {
                        material.color.setHex(0xffffff);
                        material.opacity = 1.0;
                    }
                }
            }

            function updateMenuDisplay() {
                const currentModeDisplay = document.getElementById('currentModeDisplay');
                const lobbySection = document.getElementById('lobbySection');
                const singleBtn = document.getElementById('singleplayerBtn');
                const multiBtn = document.getElementById('multiplayerBtn');
                const botToggle = document.getElementById('botToggle');
                const botStatus = document.getElementById('botStatus');
                const musicToggle = document.getElementById('musicToggle');
                const musicStatus = document.getElementById('musicStatus');
                const statusText = document.getElementById('statusText');
                const lobbyNumber = document.getElementById('lobbyNumber');

                if (currentModeDisplay) {
                    if (isMultiplayer) {
                        const playerCount = activePlayers.size || 1;
                        currentModeDisplay.textContent = `Mode: Multiplayer (Lobby ${selectedLobby}) (${playerCount}/4)`;
                    } else {
                        currentModeDisplay.textContent = 'Mode: Singleplayer';
                    }
                }

                if (lobbySection) {
                    lobbySection.style.display = isMultiplayer ? 'block' : 'none';
                }

                if (singleBtn && multiBtn) {
                    singleBtn.classList.toggle('active', !isMultiplayer);
                    multiBtn.classList.toggle('active', isMultiplayer);
                }

                if (botToggle && botStatus) {
                    botToggle.textContent = botEnabled ? 'ON' : 'OFF';
                    botToggle.classList.toggle('active', botEnabled);
                    
                    if (isMultiplayer && !isHost) {
                        botStatus.textContent = '(Host controls bot)';
                        botToggle.disabled = true;
                        botToggle.style.opacity = '0.5';
                    } else {
                        botStatus.textContent = '(Available in Single & Host)';
                        botToggle.disabled = false;
                        botToggle.style.opacity = '1';
                    }
                }

                if (musicToggle && musicStatus) {
                    musicToggle.textContent = musicEnabled ? 'ON' : 'OFF';
                    musicToggle.classList.toggle('active', musicEnabled);
                    musicStatus.textContent = '(Background Music)';
                }

                if (statusText) {
                    statusText.textContent = multiplayerStatus;
                }

                if (lobbyNumber) {
                    lobbyNumber.textContent = selectedLobby.toString();
                }
            }

            function setupMenuEventListeners() {
                // Single/Multi buttons
                document.getElementById('singleplayerBtn')?.addEventListener('click', () => {
                    switchToSingleplayer();
                });
                
                document.getElementById('multiplayerBtn')?.addEventListener('click', () => {
                    switchToMultiplayer();
                });

                // Lobby controls
                document.getElementById('lobbyMinus')?.addEventListener('click', () => {
                    changeLobby(-1);
                });
                
                document.getElementById('lobbyPlus')?.addEventListener('click', () => {
                    changeLobby(1);
                });

                // Connection buttons
                document.getElementById('connectBtn')?.addEventListener('click', () => {
                    connectToLobby();
                });
                
                document.getElementById('autoConnectBtn')?.addEventListener('click', () => {
                    autoConnect();
                });

                // Bot toggle
                document.getElementById('botToggle')?.addEventListener('click', () => {
                    toggleBot();
                });

                // Music toggle
                document.getElementById('musicToggle')?.addEventListener('click', () => {
                    toggleMusic();
                });

                // Close menu
                document.getElementById('closeMenuBtn')?.addEventListener('click', () => {
                    toggleMenu();
                });
            }

            function switchToSingleplayer() {
                if (isMultiplayer) {
                    // Disconnect from multiplayer
                    if (peer) {
                        peer.destroy();
                        peer = null;
                    }
                    connections.clear();
                    activePlayers.clear();
                    myPlayerId = null;
                }
                
                isMultiplayer = false;
                isHost = false;
                multiplayerStatus = 'Disconnected';
                
                // Create bot if not already created and racing path exists
                if (!botVehicleRef && racingPath) {
                    console.log('Creating bot car for singleplayer...');
                    const botStartPosition = new THREE.Vector3(-26, 1, 35);
                    const leftRotation = new THREE.Quaternion();
                    leftRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
                    botVehicleRef = createBotVehicle(botStartPosition, leftRotation, 0x0066ff);
                    console.log('Bot car created for singleplayer mode');
                }
                
                updateMenuDisplay();
                updateVRMenuDisplay();
                console.log('Switched to singleplayer mode');
            }

            function switchToMultiplayer() {
                isMultiplayer = true;
                multiplayerStatus = 'Ready to connect';
                
                // Remove bot if it exists
                if (botVehicleRef) {
                    console.log('Removing bot car for multiplayer...');
                    // Remove bot from physics world
                    if (botVehicleRef.vehicle) {
                        physicsWorld.removeAction(botVehicleRef.vehicle);
                    }
                    if (botVehicleRef.chassisBody) {
                        physicsWorld.removeRigidBody(botVehicleRef.chassisBody);
                    }
                    // Remove bot from scene
                    if (botVehicleRef.chassisMesh) {
                        scene.remove(botVehicleRef.chassisMesh);
                    }
                    if (botVehicleRef.wheelMeshes) {
                        botVehicleRef.wheelMeshes.forEach(wheel => scene.remove(wheel));
                    }
                    botVehicleRef = null;
                    console.log('Bot car removed for multiplayer mode');
                }
                
                updateMenuDisplay();
                updateVRMenuDisplay();
                console.log('Switched to multiplayer mode');
            }

            function changeLobby(direction) {
                selectedLobby += direction;
                if (selectedLobby < 1) selectedLobby = MAX_LOBBIES;
                if (selectedLobby > MAX_LOBBIES) selectedLobby = 1;
                updateMenuDisplay();
                updateVRMenuDisplay(); // Also update VR menu
                console.log('Changed to lobby:', selectedLobby);
            }

            function toggleBot() {
                if (isMultiplayer && !isHost) {
                    console.log('Only host can control bot in multiplayer');
                    return;
                }
                
                botEnabled = !botEnabled;
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Enable/disable bot in the scene
                if (botCar && botCar.chassisMesh) {
                    botCar.chassisMesh.visible = botEnabled;
                    if (botCar.chassisBody) {
                        // Enable/disable physics
                        const flags = botCar.chassisBody.getCollisionFlags();
                        if (botEnabled) {
                            botCar.chassisBody.setCollisionFlags(flags & ~4); // Remove NO_CONTACT_RESPONSE
                        } else {
                            botCar.chassisBody.setCollisionFlags(flags | 4); // Add NO_CONTACT_RESPONSE
                        }
                    }
                }
                
                console.log('Bot', botEnabled ? 'enabled' : 'disabled');
            }

            function toggleMusic() {
                musicEnabled = !musicEnabled;
                
                if (backgroundMusic) {
                    if (musicEnabled) {
                        backgroundMusic.play().then(() => {
                            console.log('🎵 Background music enabled');
                        }).catch(error => {
                            console.warn('Background music failed to start:', error);
                        });
                    } else {
                        backgroundMusic.pause();
                        console.log('🎵 Background music disabled');
                    }
                }
                
                updateMenuDisplay();
                updateVRMenuDisplay(); // Also update VR menu
                console.log('Music', musicEnabled ? 'enabled' : 'disabled');
            }

            function connectToLobby() {
                if (!isMultiplayer) return;
                
                // Prevent multiple connections
                if (peer && !peer.destroyed) {
                    console.log('Already connected or connecting, ignoring request');
                    return;
                }
                
                // Clean up any existing connections first
                if (peer) {
                    console.log('Cleaning up existing peer connection');
                    peer.destroy();
                    peer = null;
                }
                connections.clear();
                connectionState = 'connecting';
                
                console.log('Connecting to lobby', selectedLobby);
                multiplayerStatus = 'Connecting...';
                console.log('Set multiplayerStatus to:', multiplayerStatus);
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Try to connect as host first, then as client
                setupHost(selectedLobby).then(() => {
                    console.log('Connected as host to lobby', selectedLobby);
                    connectionState = 'connected';
                    multiplayerStatus = `Hosting - Lobby ${selectedLobby}`;
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                }).catch((hostError) => {
                    console.log('Host connection failed, trying as client:', hostError.message);
                    multiplayerStatus = 'Trying as client...';
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                    
                    // Host failed, try as client
                    setupPeer(selectedLobby).then(() => {
                        console.log('Connected as client to lobby', selectedLobby);
                        connectionState = 'connected';
                        multiplayerStatus = `Connected - Lobby ${selectedLobby}`;
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                    }).catch((clientError) => {
                        console.error('Failed to connect to lobby as client:', clientError);
                        connectionState = 'disconnected';
                        multiplayerStatus = 'Connection failed - No host available';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        
                        // Reset multiplayer state
                        isMultiplayer = false;
                        isHost = false;
                        if (peer) {
                            peer.destroy();
                            peer = null;
                        }
                        connections.clear();
                    });
                });
            }

            function autoConnect() {
                if (!isMultiplayer) return;
                
                multiplayerStatus = 'Auto-connecting...';
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                // Try lobbies 1-10 automatically
                let currentLobby = 1;
                
                function tryNextLobby() {
                    if (currentLobby > MAX_LOBBIES) {
                        multiplayerStatus = 'No available lobbies';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        return;
                    }
                    
                    selectedLobby = currentLobby;
                    updateMenuDisplay();
                    updateVRMenuDisplay();
                    
                    setupPeer(currentLobby).then(() => {
                        console.log('Auto-connected to lobby', currentLobby);
                    }).catch(() => {
                        currentLobby++;
                        setTimeout(tryNextLobby, 1000);
                    });
                }
                
                tryNextLobby();
            }
            
            function startRace() {
                console.log('Starting/Restarting race...');
                // Reset player position
                resetCar();
                // Close menu
                toggleMenu();
                // Reset lap timer
                if (typeof playerLapStartTime !== 'undefined') {
                    playerLapStartTime = Date.now();
                }
            }
            
            function disconnectFromLobby() {
                console.log('Disconnecting from lobby...');
                
                // Clean up peer connection
                if (peer && !peer.destroyed) {
                    peer.destroy();
                }
                peer = null;
                
                // Clear all connections
                connections.clear();
                activePlayers.clear();
                
                // Reset state
                isMultiplayer = false;
                isHost = false;
                connectionState = 'disconnected';
                multiplayerStatus = 'Disconnected';
                myPlayerId = null;
                sessionID = null;
                
                // Update display
                updateMenuDisplay();
                updateVRMenuDisplay();
                
                console.log('Disconnected from multiplayer');
            }

            // ========== PEERJS MULTIPLAYER FUNCTIONS ==========
            async function setupHost(lobbyNumber) {
                return new Promise((resolve, reject) => {
                    isMultiplayer = true;
                    isHost = true;
                    selectedLobby = lobbyNumber;
                    // Use simple host ID - only one host per lobby allowed
                    sessionID = `${multiplayerStartType}-host-${lobbyNumber}`;
                    
                    const iceServersConfig = [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ];
                    
                    peer = new Peer(sessionID, {
                        host: "0.peerjs.com",
                        port: 443,
                        secure: true,
                        config: { iceServers: iceServersConfig }
                    });
                    
                    peer.on("open", function() {
                        multiplayerStatus = `Host - Lobby ${lobbyNumber} (1/4)`;
                        myPlayerId = 'player_0';
                        activePlayers.set(myPlayerId, { isConnected: true, isHost: true });
                        
                        // Host uses physics car, not slot system
                        console.log('🏠 Host uses physics car, not slot system');
                        
                        updateMenuDisplay();
                        resolve();
                    });
                    
                    peer.on("connection", function(conn) {
                        const playerId = `player_${activePlayers.size}`;
                        connections.set(playerId, conn);
                        connectionToPlayer.set(conn, playerId);
                        
                        conn.on("open", function() {
                            activePlayers.set(playerId, { isConnected: true, isHost: false });
                            multiplayerStatus = `Host - Lobby ${lobbyNumber} (${activePlayers.size}/4)`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            
                            // Send welcome message to new player
                            conn.send({
                                type: 'player-assignment',
                                playerId: playerId,
                                isHost: false
                            });
                            
                            // Broadcast updated player list to all clients
                            broadcastPlayerList();
                            
                            console.log('Player connected:', playerId);
                        });
                        
                        conn.on("data", function(data) {
                            handleMultiplayerMessage(data, playerId);
                        });
                        
                        conn.on("close", function() {
                            activePlayers.delete(playerId);
                            connections.delete(playerId);
                            connectionToPlayer.delete(conn);
                            
                            // Hide remote player car and remove from physics
                            const playerIndex = parseInt(playerId.split('_')[1]);
                            if (playerIndex >= 0 && playerIndex < remotePlayerCars.length) {
                                const remoteCarData = remotePlayerCars[playerIndex];
                                if (remoteCarData) {
                                    remoteCarData.mesh.visible = false;
                                    remoteCarData.playerId = null;
                                    
                                    // Remove physics body from world
                                    if (remoteCarData.inPhysicsWorld) {
                                        physicsWorld.removeRigidBody(remoteCarData.rigidBody);
                                        remoteCarData.inPhysicsWorld = false;
                                        // Physics body removal logging removed
                                    }
                                    
                                    console.log(`Hidden remote car for ${playerId}`);
                                }
                            }
                            
                            multiplayerStatus = `Host - Lobby ${lobbyNumber} (${activePlayers.size}/4)`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            
                            // Broadcast updated player list to remaining clients
                            broadcastPlayerList();
                            
                            console.log('Player disconnected:', playerId);
                        });
                    });
                    
                    peer.on("error", function(err) {
                        console.error('Host peer error:', err);
                        multiplayerStatus = 'Host failed, trying client...';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        if (err.type === 'unavailable-id' || err.message.includes('taken')) {
                            reject(new Error('unavailable-id'));
                        } else {
                            reject(err);
                        }
                    });
                });
            }

            async function setupPeer(lobbyNumber) {
                return new Promise((resolve, reject) => {
                    isMultiplayer = true;
                    isHost = false;
                    selectedLobby = lobbyNumber;
                    
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substr(2, 9);
                    sessionID = `${multiplayerStartType}-peer-${lobbyNumber}-${timestamp}-${randomId}`;
                    
                    const iceServersConfig = [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ];
                    
                    peer = new Peer(sessionID, {
                        host: "0.peerjs.com",
                        port: 443,
                        secure: true,
                        config: { iceServers: iceServersConfig }
                    });
                    
                    peer.on("open", function() {
                        multiplayerStatus = 'Connecting to host...';
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        
                        const hostID = `${multiplayerStartType}-host-${lobbyNumber}`;
                        console.log('Attempting to connect to host:', hostID);
                        const conn = peer.connect(hostID);
                        connections.set('host', conn);
                        
                        conn.on("open", function() {
                            multiplayerStatus = `Connected - Lobby ${lobbyNumber}`;
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            resolve();
                        });
                        
                        conn.on("data", function(data) {
                            handleMultiplayerMessage(data, 'host');
                        });
                        
                        conn.on("close", function() {
                            multiplayerStatus = 'Disconnected';
                            connections.clear();
                            activePlayers.clear();
                            
                            // Hide all remote player cars and remove from physics
                            remotePlayerCars.forEach((carData, index) => {
                                if (carData && carData.mesh) {
                                    carData.mesh.visible = false;
                                    carData.playerId = null;
                                    
                                    // Remove physics body from world
                                    if (carData.inPhysicsWorld) {
                                        physicsWorld.removeRigidBody(carData.rigidBody);
                                        carData.inPhysicsWorld = false;
                                        // Physics body removal logging removed
                                    }
                                    
                                    console.log(`Hidden remote car ${index}`);
                                }
                            });
                            
                            updateMenuDisplay();
                            updateVRMenuDisplay();
                            console.log('Disconnected from host');
                        });
                        
                        conn.on("error", function(err) {
                            console.error('Connection error:', err);
                            reject(err);
                        });
                    });
                    
                    peer.on("error", function(err) {
                        console.error('Peer error:', err);
                        reject(err);
                    });
                });
            }

            function handleMultiplayerMessage(data, fromPlayerId) {
                switch (data.type) {
                    case 'player-assignment':
                        myPlayerId = data.playerId;
                        console.log('Assigned player ID:', myPlayerId);
                        break;
                        
                    case 'player-list':
                        // Update the client's player list
                        activePlayers.clear();
                        if (data.players) {
                            data.players.forEach(player => {
                                activePlayers.set(player.id, player);
                            });
                        }
                        // Update the multiplayer status display
                        multiplayerStatus = `Connected - Lobby ${selectedLobby} (${activePlayers.size}/4)`;
                        updateMenuDisplay();
                        updateVRMenuDisplay();
                        console.log('Updated player list, total players:', activePlayers.size);
                        break;
                        
                    case 'car-state':
                        // Legacy car-state support - convert to player-state
                        handlePlayerState({
                            playerId: data.playerId,
                            state: {
                                x: data.state.position.x,
                                y: data.state.position.y,
                                z: data.state.position.z,
                                rx: data.state.quaternion.x,
                                ry: data.state.quaternion.y,
                                rz: data.state.quaternion.z
                            }
                        });
                        break;
                        
                    case 'player-state':
                        // Handle player state updates (like reference project)
                        handlePlayerState(data);
                        break;
                        
                    case 'bot-state':
                        // Handle bot state updates from host
                        if (!isHost && data.botState) {
                            updateRemoteBotState(data.botState);
                        }
                        break;
                        
                    case 'chat-message':
                        console.log(`Chat from ${fromPlayerId}: ${data.message}`);
                        break;
                        
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }

            function sendToAllPlayers(data) {
                connections.forEach((conn, playerId) => {
                    if (conn && conn.open) {
                        conn.send(data);
                    }
                });
            }
            
            function broadcastPlayerList() {
                if (!isHost) return;
                
                // Convert activePlayers Map to array for transmission
                const playerList = Array.from(activePlayers.entries()).map(([id, data]) => ({
                    id: id,
                    isConnected: data.isConnected,
                    isHost: data.isHost
                }));
                
                sendToAllPlayers({
                    type: 'player-list',
                    players: playerList
                });
                
                console.log('Broadcasted player list to all clients:', playerList.length, 'players');
            }

            // Remote player cars (simple Three.js objects like reference project)
            let remotePlayerCars = [];

            function createRemotePlayerCars() {
                console.log('🏗️ Creating remote player cars with physics...');
                
                const playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
                
                for (let i = 0; i < 4; i++) {
                    const carGroup = new THREE.Group();
                    
                    // Load dune buggy model for remote player (async)
                    loadDuneBuggyModel(1.0).then((model) => {
                        // Clear any existing children (temporary placeholder)
                        while (carGroup.children.length > 0) {
                            carGroup.remove(carGroup.children[0]);
                        }
                        
                        // Add the dune buggy model to the group
                        carGroup.add(model);
                        console.log(`🏎️ Remote player ${i} dune buggy model loaded`);
                    }).catch((error) => {
                        console.error(`❌ Failed to load remote player ${i} dune buggy model:`, error);
                        // Fallback already handled in loadDuneBuggyModel
                    });
                    
                    // Temporary placeholder until GLTF loads
                    const tempBodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 4);
                    const tempBodyMaterial = new THREE.MeshBasicMaterial({ color: playerColors[i], transparent: true, opacity: 0.3 });
                    const tempBodyMesh = new THREE.Mesh(tempBodyGeometry, tempBodyMaterial);
                    tempBodyMesh.position.y = 0.3;
                    carGroup.add(tempBodyMesh);
                    
                    // Create physics body for collision
                    const chassisShape = new Ammo.btBoxShape(new Ammo.btVector3(0.9, 0.3, 2.0)); // Half extents
                    const chassisLocalInertia = new Ammo.btVector3(0, 0, 0);
                    const chassisMass = 1500; // Same as player car for consistent collisions
                    chassisShape.calculateLocalInertia(chassisMass, chassisLocalInertia);
                    
                    const startTransform = new Ammo.btTransform();
                    startTransform.setIdentity();
                    startTransform.setOrigin(new Ammo.btVector3(-22 + (i * 2), 1.0, 40));
                    
                    const motionState = new Ammo.btDefaultMotionState(startTransform);
                    const rbInfo = new Ammo.btRigidBodyConstructionInfo(chassisMass, motionState, chassisShape, chassisLocalInertia);
                    const rigidBody = new Ammo.btRigidBody(rbInfo);
                    
                    // Make it dynamic but controlled (can collide properly with other dynamic bodies)
                    rigidBody.setCollisionFlags(0); // Dynamic object (default)
                    rigidBody.setActivationState(4); // DISABLE_DEACTIVATION
                    
                    // Add arcade-style collision properties (same as other vehicles)
                    rigidBody.setRestitution(0.3); // Some bounciness for fun collisions
                    rigidBody.setFriction(0.8); // Good grip but not too sticky
                    
                    // Disable gravity and damping so it's controlled by remote state
                    rigidBody.setGravity(new Ammo.btVector3(0, 0, 0));
                    rigidBody.setLinearFactor(new Ammo.btVector3(1, 1, 1));
                    rigidBody.setAngularFactor(new Ammo.btVector3(1, 1, 1));
                    
                    // Don't add to physics world initially - will be added when player connects
                    
                    // Set initial position
                    carGroup.position.set(-22 + (i * 2), 1.0, 40);
                    carGroup.visible = false; // Hidden by default
                    
                    // Store both mesh and physics body
                    remotePlayerCars[i] = {
                        mesh: carGroup,
                        rigidBody: rigidBody,
                        playerId: null,
                        inPhysicsWorld: false // Track if physics body is in world
                    };
                    scene.add(carGroup);
                    
                    // Remote car creation logging removed
                }
                
                console.log(`🎮 Created ${remotePlayerCars.length} remote player cars with physics`);
            }

            function handlePlayerState(data) {
                // Handle remote player position/rotation updates (like reference project)
                if (!this.lastPlayerStateReceiveTime || Date.now() - this.lastPlayerStateReceiveTime > 30000) {
                    console.log('🚗 Receiving player states from other players...');
                    this.lastPlayerStateReceiveTime = Date.now();
                }
                
                remotePlayerStates.set(data.playerId, data.state);
                
                // CRITICAL: Host forwards player states to other clients (like reference)
                if (isHost && isMultiplayer && activePlayers.size > 1) {
                    connections.forEach((conn, connectionKey) => {
                        if (conn && conn.open) {
                            conn.send({
                                type: 'player-state',
                                state: data.state,
                                playerId: data.playerId
                            });
                        }
                    });
                }
                
                // Update the corresponding remote player car
                const playerIndex = parseInt(data.playerId.split('_')[1]);
                if (playerIndex >= 0 && playerIndex < remotePlayerCars.length) {
                    const remoteCarData = remotePlayerCars[playerIndex];
                    if (remoteCarData && data.playerId !== myPlayerId) { // Don't show our own remote car
                        const remoteCar = remoteCarData.mesh;
                        const rigidBody = remoteCarData.rigidBody;
                        
                        // Update visual mesh
                        remoteCar.position.set(data.state.x, data.state.y, data.state.z);
                        remoteCar.rotation.set(data.state.rx, data.state.ry, data.state.rz);
                        remoteCar.visible = true;
                        
                        // Add physics body to world if not already added
                        if (!remoteCarData.inPhysicsWorld) {
                            physicsWorld.addRigidBody(rigidBody);
                            remoteCarData.inPhysicsWorld = true;
                            // Physics body addition logging removed
                        }
                        
                        // Update physics body position (dynamic body with controlled movement)
                        const currentTransform = rigidBody.getWorldTransform();
                        const currentPos = currentTransform.getOrigin();
                        
                        // Calculate velocity to move to target position smoothly
                        const targetPos = new Ammo.btVector3(data.state.x, data.state.y, data.state.z);
                        const velocity = new Ammo.btVector3(
                            (targetPos.x() - currentPos.x()) * 10, // Multiply by factor for responsiveness
                            (targetPos.y() - currentPos.y()) * 10,
                            (targetPos.z() - currentPos.z()) * 10
                        );
                        
                        // Set velocity instead of direct position for better collision
                        rigidBody.setLinearVelocity(velocity);
                        
                        // Set rotation directly (less critical for collision)
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromEuler(new THREE.Euler(data.state.rx, data.state.ry, data.state.rz));
                        const newTransform = new Ammo.btTransform();
                        newTransform.setIdentity();
                        newTransform.setOrigin(targetPos);
                        newTransform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
                        rigidBody.setWorldTransform(newTransform);
                        
                        rigidBody.activate(); // Wake up the physics body
                        
                        // Store player ID
                        remoteCarData.playerId = data.playerId;
                        
                        if (!this.lastRemotePlayerUpdateTime || Date.now() - this.lastRemotePlayerUpdateTime > 30000) {
                            console.log(`🎯 Updated remote player ${data.playerId} at (${data.state.x.toFixed(1)}, ${data.state.y.toFixed(1)}, ${data.state.z.toFixed(1)})`);
                            this.lastRemotePlayerUpdateTime = Date.now();
                        }
                    }
                }
            }

            function sendPlayerState() {
                if (!isMultiplayer || activePlayers.size <= 1) return;
                
                // Get player car position and rotation (from physics car)
                if (vehicleRef && vehicleRef.chassisMesh) {
                    const pos = vehicleRef.chassisMesh.position;
                    const rot = vehicleRef.chassisMesh.rotation;
                    
                    const playerState = {
                        x: pos.x, y: pos.y, z: pos.z,
                        rx: rot.x, ry: rot.y, rz: rot.z
                    };
                    
                    const data = {
                        type: 'player-state',
                        state: playerState,
                        playerId: myPlayerId
                    };
                    
                    // Send to all connections
                    connections.forEach((conn, playerId) => {
                        if (conn && conn.open) {
                            conn.send(data);
                        }
                    });
                    
                    // Throttled logging
                    if (!this.lastPlayerStateSendTime || Date.now() - this.lastPlayerStateSendTime > 2000) {
                        console.log(`📡 Sending car state from ${myPlayerId} to ${connections.size} players`);
                        this.lastPlayerStateSendTime = Date.now();
                    }
                }
            }

            function updateRemoteBotState(botState) {
                // TODO: Update bot position/rotation based on host's bot state
                console.log('Received bot state from host:', botState);
            }

            function cleanupRemotePlayerCars() {
                console.log('🧹 Cleaning up remote player cars...');
                remotePlayerCars.forEach((carData, index) => {
                    if (carData) {
                        // Remove from scene
                        if (carData.mesh) {
                            scene.remove(carData.mesh);
                        }
                        
                        // Remove from physics world
                        if (carData.rigidBody) {
                            physicsWorld.removeRigidBody(carData.rigidBody);
                        }
                        
                        console.log(`Cleaned up remote car ${index}`);
                    }
                });
                remotePlayerCars.length = 0; // Clear array
            }

            function switchCamera() {
                if (renderer.xr.isPresenting) {
                    // VR mode: cycle through firstperson -> fly -> firstperson
                    if (cameraMode === 'firstperson') {
                        cameraMode = 'fly';
                        // Initialize fly camera position if not set
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            vrFlyPosition.copy(vehicleRef.chassisMesh.position);
                            vrFlyPosition.y += 10; // Start 10m above the car
                        } else {
                            // Fallback position if car not ready yet
                            vrFlyPosition.set(0, 15, -20);
                        }
                        // Reset rotation when entering fly mode
                        vrFlyRotation.set(0, 0, 0);
                        console.log('Switched to VR fly camera');
                    } else if (cameraMode === 'fly') {
                        cameraMode = 'firstperson';
                        console.log('Switched to VR first-person camera');
                    } else {
                        // From orbit to firstperson in VR
                        cameraMode = 'firstperson';
                        cameraRig.remove(orbitCamera);
                        cameraRig.add(firstPersonCamera);
                        console.log('Switched to VR first-person camera');
                    }
                } else {
                    // Desktop mode: cycle through firstperson -> fly -> firstperson
                    if (cameraMode === 'firstperson') {
                        cameraMode = 'fly';
                        camera = firstPersonCamera; // Use first person camera for fly mode
                        controls.enabled = false; // Disable orbit controls
                        
                        // Initialize fly camera position
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            desktopFlyPosition.copy(vehicleRef.chassisMesh.position);
                            desktopFlyPosition.y += 10; // Start 10m above the car
                        } else {
                            desktopFlyPosition.set(0, 15, -20);
                        }
                        // Reset rotation when entering fly mode
                        desktopFlyRotation.set(0, 0, 0);
                        
                        // Lock mouse for free look
                        document.body.requestPointerLock();
                        
                        console.log('Switched to desktop fly camera');
                    } else if (cameraMode === 'fly') {
                        cameraMode = 'firstperson';
                        camera = firstPersonCamera;
                        controls.enabled = false;
                        
                        // Release mouse lock
                        if (document.pointerLockElement) {
                            document.exitPointerLock();
                        }
                        
                        console.log('Switched to first-person camera');
                    }
                }
            }
            
            function togglePhysicsWireframe() {
                var visible = true;
                
                // Toggle player physics wireframe
                if (vehicleRef && vehicleRef.physicsWireframe) {
                    vehicleRef.physicsWireframe.visible = !vehicleRef.physicsWireframe.visible;
                    visible = vehicleRef.physicsWireframe.visible;
                }
                
                // Toggle bot physics wireframe
                if (botRef && botRef.physicsWireframe) {
                    botRef.physicsWireframe.visible = visible;
                }
                
                console.log('🔧 Physics wireframes:', visible ? 'VISIBLE' : 'HIDDEN');
                console.log('📏 Physics body dimensions: 2.2m x 0.4m x 4.0m (W x H x L)');
                if (visible) {
                    console.log('💡 Green wireframe shows exact physics body position');
                    console.log('🎮 Press P again to hide wireframes');
                } else {
                    console.log('🎮 Press P to show physics wireframes again');
                }
            }

            function resetCar() {
                if (vehicleRef && vehicleRef.vehicle && vehicleRef.vehicleBody) {
                    try {
                        // Reset to last passed checkpoint
                        var resetPosition;
                        console.log('🔍 Reset Debug - Checkpoints:', checkpointMarkers ? checkpointMarkers.length : 'null', 'LastPassed:', playerLastPassedCheckpoint, 'Current:', playerCurrentCheckpoint);
                        
                        if (checkpointMarkers && checkpointMarkers.length > 0 && playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) {
                            var checkpoint = checkpointMarkers[playerLastPassedCheckpoint];
                            if (checkpoint && checkpoint.position) {
                                resetPosition = checkpoint.position.clone();
                                // Get the actual road surface elevation at this X,Z position
                                var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                
                                // Safety check: if calculated elevation is much lower than checkpoint, use checkpoint + extra height
                                var checkpointY = checkpoint.position.y;
                                if (actualRoadElevation < checkpointY - 10) {
                                    console.warn('⚠️ Calculated road elevation seems too low, using checkpoint elevation + safety margin');
                                    resetPosition.y = checkpointY + 2; // 2m above checkpoint position for safety
                                } else {
                                    resetPosition.y = actualRoadElevation + 1; // 1m above calculated road surface
                                }
                                console.log('🚗 Resetting to checkpoint', playerLastPassedCheckpoint);
                                console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                console.log('   Calculated road elevation:', actualRoadElevation.toFixed(1));
                                console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                            } else {
                                console.warn('Checkpoint', playerLastPassedCheckpoint, 'has no position data, using default');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        } else {
                            // If checkpoints exist but playerLastPassedCheckpoint is invalid, use checkpoint 0
                            if (checkpointMarkers && checkpointMarkers.length > 0) {
                                console.warn('Invalid playerLastPassedCheckpoint, using checkpoint 0');
                                var checkpoint = checkpointMarkers[0];
                                if (checkpoint && checkpoint.position) {
                                    resetPosition = checkpoint.position.clone();
                                    var actualRoadElevation = getRoadSurfaceElevation(resetPosition.x, resetPosition.z);
                                    var checkpointY = checkpoint.position.y;
                                    if (actualRoadElevation < checkpointY - 10) {
                                        resetPosition.y = checkpointY + 2;
                                    } else {
                                        resetPosition.y = actualRoadElevation + 1;
                                    }
                                    console.log('🚗 Resetting to checkpoint 0 (fallback)');
                                    console.log('   Checkpoint position:', checkpoint.position.x.toFixed(1), checkpoint.position.y.toFixed(1), checkpoint.position.z.toFixed(1));
                                    console.log('   Final spawn height:', resetPosition.y.toFixed(1), '(+1m above road)');
                                } else {
                                    console.warn('Checkpoint 0 has no position data, using default position');
                                    resetPosition = new THREE.Vector3(0, 0, -20);
                                    var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                    resetPosition.y = defaultRoadElevation + 1;
                                }
                            } else {
                                console.warn('No valid checkpoints available, using default position');
                                resetPosition = new THREE.Vector3(0, 0, -20); // Default X,Z position
                                var defaultRoadElevation = getRoadSurfaceElevation(0, -20);
                                resetPosition.y = defaultRoadElevation + 1; // 1m above road surface
                            }
                        }
                        
                        // Calculate orientation toward next checkpoint
                        var resetRotation = new THREE.Quaternion(0, 0, 0, 1); // Default rotation
                        if (checkpointMarkers && checkpointMarkers.length > 0) {
                            // Use valid checkpoint index for orientation calculation
                            var currentCheckpointIndex = (playerLastPassedCheckpoint >= 0 && playerLastPassedCheckpoint < checkpointMarkers.length) ? playerLastPassedCheckpoint : 0;
                            var nextCheckpointIndex = (currentCheckpointIndex + 1) % checkpointMarkers.length;
                            var nextCheckpoint = checkpointMarkers[nextCheckpointIndex];
                            if (nextCheckpoint && nextCheckpoint.position) {
                                // Calculate direction to next checkpoint
                                var direction = new THREE.Vector3().subVectors(nextCheckpoint.position, resetPosition);
                                direction.y = 0; // Keep horizontal
                                direction.normalize();
                                
                                // Calculate rotation to face that direction
                                var angle = Math.atan2(direction.x, direction.z);
                                resetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                                
                                console.log('🧭 Player respawn facing toward checkpoint', nextCheckpointIndex, 'from current', currentCheckpointIndex);
                            }
                        }
                        
                        var resetTransform = new Ammo.btTransform();
                        resetTransform.setIdentity();
                        resetTransform.setOrigin(new Ammo.btVector3(resetPosition.x, resetPosition.y, resetPosition.z));
                        resetTransform.setRotation(new Ammo.btQuaternion(resetRotation.x, resetRotation.y, resetRotation.z, resetRotation.w));
                        
                        vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                        vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                        vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                        
                        console.log('✅ Car reset successfully to position:', resetPosition);
                    } catch (error) {
                        console.error('❌ Error during car reset:', error);
                        // Fallback to default position
                        try {
                            var fallbackPosition = new THREE.Vector3(0, 0, -20);
                            var fallbackRoadElevation = getRoadSurfaceElevation(0, -20);
                            fallbackPosition.y = fallbackRoadElevation + 1; // 1m above road surface
                            var resetTransform = new Ammo.btTransform();
                            resetTransform.setIdentity();
                            resetTransform.setOrigin(new Ammo.btVector3(fallbackPosition.x, fallbackPosition.y, fallbackPosition.z));
                            // Use default forward orientation for fallback
                            resetTransform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));
                            
                            vehicleRef.vehicleBody.setWorldTransform(resetTransform);
                            vehicleRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                            vehicleRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                            
                            console.log('🔄 Fallback reset to default position successful');
                        } catch (fallbackError) {
                            console.error('❌ Fallback reset also failed:', fallbackError);
                        }
                    }
                } else {
                    console.warn('⚠️ Cannot reset car: vehicle reference not available');
                }
            }
            
            function checkCheckpointProgress(carPosition) {
                if (!checkpointMarkers || checkpointMarkers.length === 0) return;
                
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                // Check if player is close enough to the next checkpoint
                var distance = carPosition.distanceTo(checkpoint.position);
                if (distance < 15) { // 15 meter detection radius
                    // Checkpoint passed!
                    playerLastPassedCheckpoint = playerCurrentCheckpoint;
                    playerCurrentCheckpoint++;
                    
                    console.log('✅ Checkpoint', nextIndex, 'passed! Last:', playerLastPassedCheckpoint, 'Next:', playerCurrentCheckpoint);
                    
                    // Update visual indicator
                    updateNextCheckpointMarker();
                    
                    // Check for lap completion (when we've passed all checkpoints)
                    if (playerCurrentCheckpoint >= checkpointMarkers.length) {
                        // Lap completed!
                        var lapTime = (Date.now() - currentLapStartTime) / 1000;
                        lapTimes.push(lapTime);
                        
                        // Check if it's a new best time
                        if (bestLapTime === null || lapTime < bestLapTime) {
                            bestLapTime = lapTime;
                            saveBestTime(lapTime); // Save to localStorage
                            console.log('🏆 NEW BEST LAP TIME!', formatLapTime(lapTime));
                        } else {
                            console.log('🏁 LAP COMPLETED!', formatLapTime(lapTime));
                        }
                        
                        // Start new lap
                        currentLapNumber++;
                        currentLapStartTime = Date.now();
                        playerLastPassedCheckpoint = 0; // Reset checkpoint progress for new lap
                        playerCurrentCheckpoint = 1; // Reset current checkpoint to 1 (next checkpoint to reach)
                        
                        console.log('Starting lap', currentLapNumber, '- checkpoint progress reset to 0, next checkpoint: 1');
                    }
                }
                
                // Update pulsing animation for next checkpoint marker
                if (nextCheckpointMarker && nextCheckpointMarker.userData) {
                    nextCheckpointMarker.userData.pulseTime += 0.1;
                    var scale = 1 + 0.3 * Math.sin(nextCheckpointMarker.userData.pulseTime);
                    nextCheckpointMarker.scale.setScalar(scale);
                }
                
                // Update HUD displays
                if (renderer.xr.isPresenting) {
                    updateVRHUD(); // VR users see 3D HUD
                } else {
                    updateDesktopHUD(); // Desktop users see HTML HUD
                }
            }

            function createBox(pos, quat, w, l, h, mass, friction, customMaterial) {
                var material = customMaterial || (mass > 0 ? materialDynamic : materialStatic);
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5));

                if (!mass) mass = 0;
                if (!friction) friction = 1;

                var mesh = new THREE.Mesh(shape, material);
                mesh.position.copy(pos);
                mesh.quaternion.copy(quat);
                scene.add(mesh);

                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);

                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(mass, localInertia);

                var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, geometry, localInertia);
                var body = new Ammo.btRigidBody(rbInfo);

                body.setFriction(friction);
                physicsWorld.addRigidBody(body);

                if (mass > 0) {
                    body.setActivationState(DISABLE_DEACTIVATION);
                    // Sync physics and graphics
                    function sync(dt) {
                        var ms = body.getMotionState();
                        if (ms) {
                            ms.getWorldTransform(TRANSFORM_AUX);
                            var p = TRANSFORM_AUX.getOrigin();
                            var q = TRANSFORM_AUX.getRotation();
                            mesh.position.set(p.x(), p.y(), p.z());
                            mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                        }
                    }
                    syncList.push(sync);
                }
            }

            function createWheelMesh(radius, width) {
                var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                t.rotateZ(Math.PI / 2);
                var mesh = new THREE.Mesh(t, materialInteractive);
                mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), materialInteractive));
                scene.add(mesh);
                return mesh;
            }

            function createChassisMesh(w, l, h) {
                var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
                var mesh = new THREE.Mesh(shape, materialInteractive);
                scene.add(mesh);
                return mesh;
            }
            
            // GLTF TIRE LOADER: Load the tire model for wheels
            function loadTireModel(isRightSide = false, scale = 1.0) {
                return new Promise((resolve, reject) => {
                    const loader = new THREE.GLTFLoader();
                    
                    // Setup DRACOLoader for compressed GLTF files
                    const dracoLoader = new THREE.DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/');
                    dracoLoader.setDecoderConfig({ type: 'js' });
                    loader.setDRACOLoader(dracoLoader);
                    
                    loader.load(
                        'assets/dune-buggy/dunebuggy-tire.gltf',
                        function (gltf) {
                            console.log('🛞 Tire GLTF loaded successfully');
                            
                            const model = gltf.scene.clone();
                            
                            // Scale the model appropriately
                            model.scale.set(scale, scale, scale);
                            
                            // Preserve original textures and materials
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    // Keep original materials and textures - no color override
                                    // Just enable shadows
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            // Center the model
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            model.position.sub(center);
                            
                            // Rotate for right side tires (flip 180 degrees around Y axis)
                            if (isRightSide) {
                                model.rotation.y = Math.PI;
                            }
                            
                            // Add to scene
                            scene.add(model);
                            
                            console.log('🛞 Tire model added to scene, right side:', isRightSide);
                            
                            // Cleanup DRACOLoader
                            dracoLoader.dispose();
                            
                            resolve(model);
                        },
                        function (progress) {
                            console.log('🛞 Tire loading progress:', Math.round((progress.loaded / progress.total) * 100) + '%');
                        },
                        function (error) {
                            console.error('❌ Error loading tire GLTF:', error);
                            
                            // Fallback: create a simple cylinder tire
                            const fallbackGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
                            fallbackGeometry.rotateZ(Math.PI / 2);
                            const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                            const fallbackTire = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                            fallbackTire.castShadow = true;
                            fallbackTire.receiveShadow = true;
                            scene.add(fallbackTire);
                            
                            console.log('🛞 Using fallback tire model');
                            
                            // Cleanup DRACOLoader
                            dracoLoader.dispose();
                            
                            resolve(fallbackTire);
                        }
                    );
                });
            }
            
            // GLTF DUNE BUGGY LOADER: Load the dune buggy model for vehicles
            function loadDuneBuggyModel(scale = 1.0) {
                return new Promise((resolve, reject) => {
                    const loader = new THREE.GLTFLoader();
                    
                    // Setup DRACOLoader for compressed GLTF files
                    const dracoLoader = new THREE.DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/');
                    dracoLoader.setDecoderConfig({ type: 'js' });
                    loader.setDRACOLoader(dracoLoader);
                    
                    loader.load(
                        'assets/dune-buggy/dunebuggy.gltf',
                        function (gltf) {
                            console.log('🏎️ Dune buggy GLTF loaded successfully');
                            
                            const model = gltf.scene.clone();
                            
                            // Scale the model appropriately for the physics
                            model.scale.set(scale, scale, scale);
                            
                            // Preserve original textures and materials
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    // Keep original materials and textures - no color override
                                    // Just enable shadows
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            // Center the model and prepare for physics sync
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            model.position.sub(center);
                            
                            // Store offset for physics sync (lower by 55cm, centered horizontally, 20cm forward)
                            model.userData.chassisOffset = new THREE.Vector3(0, -0.55, -0.2);
                            
                            // Add to scene
                            scene.add(model);
                            
                            console.log('🏎️ Dune buggy model added to scene with original textures');
                            
                            // Cleanup DRACOLoader
                            dracoLoader.dispose();
                            
                            resolve(model);
                        },
                        function (progress) {
                            console.log('🏎️ Dune buggy loading progress:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function (error) {
                            console.error('❌ Error loading dune buggy GLTF:', error);
                            
                            // Cleanup DRACOLoader
                            dracoLoader.dispose();
                            
                            // Fallback to box geometry
                            console.log('🔄 Falling back to box geometry for vehicle');
                            const fallbackGeometry = new THREE.BoxGeometry(2.2, 0.4, 4);
                            const fallbackMaterial = new THREE.MeshPhongMaterial({ color: color });
                            const fallbackMesh = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                            scene.add(fallbackMesh);
                            resolve(fallbackMesh);
                        }
                    );
                });
            }

            function createBotVehicle(pos, quat, color) {
                // Vehicle constants - improved for stability (same as player car)
                var chassisWidth = 2.2;  // Wider for better stability (was 1.8)
                var chassisHeight = .4;  // Lower center of mass (was .6)
                var chassisLength = 4;
                var massVehicle = 1500; // Heavy for good collision physics (was 800)

                var wheelAxisPositionBack = -1.5; // Moved 50cm backwards
                var wheelRadiusBack = .5; // Reduced by 10cm from .6
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1.4; // Increased by 20cm for 40cm wider total span
                var wheelAxisHeightBack = .2; // Lower for stability (was .3)

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1.4; // Increased by 20cm for 40cm wider total span
                var wheelAxisHeightFront = .2; // Lower for stability (was .3)
                var wheelRadiusFront = .45; // Reduced by 10cm from .55
                var wheelWidthFront = .2;

                var friction = 2.5; // Touring car grip - good control but can still slide
                var suspensionStiffness = 25.0; // Touring car suspension - firm but comfortable
                var suspensionDamping = 3.5;    // Balanced damping for control
                var suspensionCompression = 5.0; // Moderate compression
                var suspensionRestLength = 0.4;  // Shorter for lower ride height (was 0.6)
                var rollInfluence = 0.15;        // Moderate roll influence for realistic handling (was 0.05)

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2500; // More power for arcade-style fun
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Lower center of mass for better stability
                var centerOfMass = new Ammo.btVector3(0, -0.3, 0); // Lower center of mass
                body.setCenterOfMassTransform(transform);
                
                // Add stability improvements (allow more rotation for realistic handling)
                body.setAngularFactor(new Ammo.btVector3(1, 1, 0.7)); // Allow more roll for realistic physics
                body.setLinearFactor(new Ammo.btVector3(1, 1, 1)); // Allow all linear movement
                
                // Add arcade-style collision properties
                body.setRestitution(0.3); // Some bounciness for fun collisions
                body.setFriction(0.8); // Good grip but not too sticky
                
                // Ensure the bot body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                
                // Create bot chassis mesh with GLTF dune buggy model
                var chassisMesh = null;
                
                // Load dune buggy model for bot (async)
                loadDuneBuggyModel(1.0).then((model) => {
                    // Remove temporary placeholder
                    if (chassisMesh && chassisMesh.parent) {
                        scene.remove(chassisMesh);
                    }
                    
                    chassisMesh = model;
                    // Update the bot reference
                    if (botRef) {
                        botRef.chassisMesh = chassisMesh;
                    }
                    console.log('🤖 Bot dune buggy model loaded and positioned');
                }).catch((error) => {
                    console.error('❌ Failed to load bot dune buggy model:', error);
                    // Fallback already handled in loadDuneBuggyModel
                });
                
                // Create bot material for wheels (needed for wheel creation)
                var botMaterial = new THREE.MeshPhongMaterial({ color: color || 0x0066ff });
                
                // Temporary placeholder until GLTF loads
                var tempMaterial = new THREE.MeshPhongMaterial({ color: color || 0x0066ff, transparent: true, opacity: 0.5 });
                var tempShape = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                chassisMesh = new THREE.Mesh(tempShape, tempMaterial);
                scene.add(chassisMesh);
                
                // Add physics body wireframe visualization (for debugging alignment)
                var wireframeGeometry = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                var wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true, 
                    transparent: true, 
                    opacity: 0.8 
                });
                var physicsWireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                physicsWireframe.position.set(pos.x, pos.y, pos.z);
                physicsWireframe.quaternion.set(quat.x, quat.y, quat.z, quat.w);
                scene.add(physicsWireframe);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                // Improve stability with custom tuning
                tuning.set_m_suspensionStiffness(suspensionStiffness);
                tuning.set_m_suspensionCompression(suspensionCompression);
                tuning.set_m_suspensionDamping(suspensionDamping);
                tuning.set_m_maxSuspensionTravelCm(30); // Limit suspension travel
                tuning.set_m_frictionSlip(2.5); // Touring car grip - forgiving but realistic
                
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store bot vehicle reference
                var botRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh,
                    physicsWireframe: physicsWireframe,
                    currentWaypointIndex: 0,
                    targetSpeed: 60, // km/h
                    waypointReachDistance: 8.0, // Distance to consider waypoint "reached" (increased)
                    debugCounter: 0,
                    // Predictive steering parameters
                    lookAheadWaypoints: 5, // Number of waypoints to look ahead
                    steeringSmoothing: 0.15, // Steering smoothing factor (0-1)
                    previousSteering: 0, // For smooth steering transitions
                    // Dynamic speed parameters
                    maxCornerSpeed: 80, // km/h - maximum speed through corners
                    brakingDistance: 25, // meters - distance to start braking before corners
                    cornerSpeedFactor: 0.6, // Speed reduction factor for tight corners
                    // Stuck detection parameters
                    lastPosition: new THREE.Vector3(-5, 0, -45), // Track last position
                    lastWaypointReached: 0, // Last successfully reached waypoint
                    stuckCheckInterval: 180, // Check every 3 seconds (60fps * 3)
                    stuckDistanceThreshold: 2.0, // If moved less than 2m in 3 seconds
                    stuckSpeedThreshold: 5.0, // If speed is below 5 km/h for too long
                    lowSpeedCounter: 0, // Counter for low speed duration
                    stuckCounter: 0, // Counter for stuck detection
                    lastRespawnTime: 0, // Prevent rapid respawning
                    // Obstacle avoidance parameters
                    avoidanceRayLength: 15, // meters - how far ahead to look for obstacles
                    avoidanceForce: 0.8, // Steering force when avoiding obstacles
                    sideRayAngle: 30, // degrees - angle for side detection rays
                    obstacleAvoidanceActive: false // Track if currently avoiding
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                
                var wheelMeshes = [];
                
                // Create visual target marker (10m high green column)
                var markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 8);
                var markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, // Bright green
                    transparent: true,
                    opacity: 0.8
                });
                botTargetMarker = new THREE.Mesh(markerGeometry, markerMaterial);
                botTargetMarker.position.set(0, 5, 0); // 5m high (half of 10m cylinder)
                scene.add(botTargetMarker);
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    // Determine if this is a right-side wheel (negative X position)
                    var isRightSide = pos.x() < 0;
                    
                    // Create temporary placeholder wheel with bot color
                    var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
                    t.rotateZ(Math.PI / 2);
                    var mesh = new THREE.Mesh(t, botMaterial);
                    mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius * .25, 1, 1, 1), botMaterial));
                    scene.add(mesh);
                    wheelMeshes[index] = mesh;
                    
                    // Load GLTF tire model (async)
                    loadTireModel(isRightSide, 1.0).then((tireModel) => {
                        // Remove temporary placeholder
                        if (wheelMeshes[index] && wheelMeshes[index].parent) {
                            scene.remove(wheelMeshes[index]);
                        }
                        
                        wheelMeshes[index] = tireModel;
                        console.log('🛞 Bot tire', index, 'loaded, right side:', isRightSide);
                    }).catch((error) => {
                        console.error('❌ Failed to load bot tire', index, ':', error);
                        // Keep the placeholder wheel
                    });
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Bot AI sync function
                function botSync(dt) {
                    botRef.debugCounter++;
                    var speed = vehicle.getCurrentSpeedKmHour();

                    // Get current car position
                    var tm = vehicle.getChassisWorldTransform();
                    var p = tm.getOrigin();
                    var q = tm.getRotation();
                    var carPos = new THREE.Vector3(p.x(), p.y(), p.z());
                    var carQuat = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());

                    // Update chassis mesh with offset for GLTF models
                    if (chassisMesh.userData && chassisMesh.userData.chassisOffset) {
                        const offset = chassisMesh.userData.chassisOffset.clone();
                        const carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                        offset.applyQuaternion(carQuaternion); // Rotate offset by car's rotation
                        chassisMesh.position.set(p.x() + offset.x, p.y() + offset.y, p.z() + offset.z);
                    } else {
                        chassisMesh.position.set(p.x(), p.y(), p.z());
                    }
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    
                    // Update physics wireframe (shows exact physics body position)
                    if (botRef && botRef.physicsWireframe) {
                        botRef.physicsWireframe.position.set(p.x(), p.y(), p.z());
                        botRef.physicsWireframe.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }
                    
                    // Send car state to other players (throttled to 10Hz)
                    // Car state sending now handled by sendPlayerState() in sync list

                    // Update wheel meshes
                    var n = vehicle.getNumWheels();
                    for (var i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        var wheelTm = vehicle.getWheelTransformWS(i);
                        var wheelP = wheelTm.getOrigin();
                        var wheelQ = wheelTm.getRotation();
                        wheelMeshes[i].position.set(wheelP.x(), wheelP.y(), wheelP.z());
                        wheelMeshes[i].quaternion.set(wheelQ.x(), wheelQ.y(), wheelQ.z(), wheelQ.w());
                    }


                    // Initialize forces
                    breakingForce = 0;
                    engineForce = 0;

                    // AI Navigation Logic - Advanced Predictive System
                    if (denseWaypoints.length > 0) {
                        // Get current target waypoint
                        var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                        var targetPoint = targetWaypoint.position;
                        
                        // Check if we've reached the current waypoint
                        var distanceToWaypoint = carPos.distanceTo(targetPoint);
                        
                        if (distanceToWaypoint < botRef.waypointReachDistance) {
                            // Move to next waypoint
                            var oldIndex = botRef.currentWaypointIndex;
                            botRef.lastWaypointReached = oldIndex; // Track last successful waypoint
                            botRef.currentWaypointIndex = (botRef.currentWaypointIndex + 1) % denseWaypoints.length;
                            // Only log lap completion (when reaching waypoint 0 again)
                            if (botRef.currentWaypointIndex === 0) {
                                console.log('🏁 Bot completed a lap!');
                            }
                            targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                            targetPoint = targetWaypoint.position;
                            distanceToWaypoint = carPos.distanceTo(targetPoint);
                            
                            // Reset stuck detection counters on successful waypoint reach
                            botRef.stuckCounter = 0;
                            botRef.lowSpeedCounter = 0;
                        }

                        // Get car's forward direction (positive Z is forward in our coordinate system)
                        var carForward = new THREE.Vector3(0, 0, 1);
                        carForward.applyQuaternion(carQuat);

                        // OBSTACLE AVOIDANCE: Check for obstacles and calculate avoidance steering
                        var avoidanceResult = checkObstacles(carPos, carQuat, carForward, speed, botRef);
                        
                        var finalSteerAmount;
                        if (avoidanceResult.shouldAvoid) {
                            // SMART OBSTACLE AVOIDANCE: Check if we should reverse or steer around
                            var distanceFromPath = findDistanceFromPath(carPos, botRef);
                            var maxPathDeviation = 15.0; // Maximum distance allowed from racing line
                            var obstacleDistance = avoidanceResult.closestDistance;
                            
                            // If obstacle is very close and we're already far from path, consider reversing
                            if (obstacleDistance < 8.0 && distanceFromPath > maxPathDeviation) {
                                console.log('🔄 OBSTACLE TOO CLOSE & FAR FROM PATH! Reversing to find alternate route');
                                finalSteerAmount = 0; // Don't steer while reversing
                                targetSpeedKmh = -20; // Reverse at 20 km/h
                                shouldBrake = false; // Don't brake while reversing
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If obstacle is blocking and we have multiple hits (surrounded), reverse
                            else if (avoidanceResult.multipleHits && obstacleDistance < 10.0) {
                                console.log('🚫 SURROUNDED BY OBSTACLES! Reversing to escape');
                                finalSteerAmount = avoidanceResult.avoidanceSteer * 0.5; // Gentle steering while reversing
                                targetSpeedKmh = -15; // Reverse slower when surrounded
                                shouldBrake = false;
                                botRef.obstacleAvoidanceActive = true;
                            }
                            // If we're close to path, try normal steering avoidance
                            else if (distanceFromPath < maxPathDeviation) {
                                console.log('🚧 STEERING AROUND OBSTACLE! Steer:', avoidanceResult.avoidanceSteer.toFixed(2), 'Distance:', obstacleDistance.toFixed(1) + 'm');
                                finalSteerAmount = avoidanceResult.avoidanceSteer;
                                targetSpeedKmh = Math.min(targetSpeedKmh, 25); // Slow down while avoiding
                                botRef.obstacleAvoidanceActive = true;
                            }
            // If too far from path, return to path first
            else {
                console.log('📍 TOO FAR FROM PATH! Returning to racing line first');
                try {
                    // Calculate direction back to nearest path point
                    var nearestPathPoint = findNearestPathPoint(carPos);
                    if (nearestPathPoint && nearestPathPoint.point) {
                        var backToPath = new THREE.Vector3().subVectors(nearestPathPoint.point, carPos).normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, backToPath);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 1.5));
                        targetSpeedKmh = Math.min(targetSpeedKmh, 30); // Moderate speed returning to path
                        botRef.obstacleAvoidanceActive = true;
                    } else {
                        // Fallback: use normal path following if nearest point not found
                        var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                        var toTarget = new THREE.Vector3().subVectors(lookAheadPoint, carPos);
                        var toTargetNormalized = toTarget.clone().normalize();
                        var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                        finalSteerAmount = Math.max(-1.0, Math.min(1.0, cross.y * 2.0));
                        botRef.obstacleAvoidanceActive = false;
                    }
                } catch (e) {
                    console.warn('Error calculating return to path:', e);
                    // Fallback to normal navigation
                    finalSteerAmount = 0;
                    botRef.obstacleAvoidanceActive = false;
                }
            }
                        } else {
                            // PREDICTIVE STEERING: Look ahead multiple waypoints
                            var lookAheadPoint = calculateLookAheadPoint(carPos, speed, botRef);
                            
                            // Calculate steering toward look-ahead point
                            var toTarget = new THREE.Vector3()
                                .subVectors(lookAheadPoint, carPos);
                            
                            var toTargetNormalized = toTarget.clone().normalize();

                            // Calculate raw steering using cross product
                            var cross = new THREE.Vector3().crossVectors(carForward, toTargetNormalized);
                            var rawSteerAmount = cross.y; // Raw steering direction (fixed with correct forward vector)
                            
                            finalSteerAmount = Math.max(-1.0, Math.min(1.0, rawSteerAmount * 2.0));
                            botRef.obstacleAvoidanceActive = false;
                        }
                        
                        // STEERING SMOOTHING: Blend with previous steering for realistic transitions
                        var steerAmount = botRef.previousSteering + (finalSteerAmount - botRef.previousSteering) * botRef.steeringSmoothing;
                        botRef.previousSteering = steerAmount;

                        // Apply smoothed steering
                        vehicleSteering = steerAmount;
                        
                        // Update visual target marker to show where bot is heading
                        if (botTargetMarker) {
                            botTargetMarker.position.set(targetPoint.x, 5, targetPoint.z);
                        }

                        // DYNAMIC SPEED CONTROL: Analyze upcoming corners and adjust speed
                        var speedAnalysis = calculateOptimalSpeed(carPos, speed, botRef);
                        var targetSpeedKmh = speedAnalysis.targetSpeed;
                        var shouldBrake = speedAnalysis.shouldBrake;

                        // Apply throttle/brake - always try to move forward
                        breakingForce = 0;
                        engineForce = 0;

                        var absSpeed = Math.abs(speed);
                        
                        // REALISTIC BRAKING AND ACCELERATION
                        if (shouldBrake || absSpeed > targetSpeedKmh + 3) {
                            // Brake for corners or overspeed
                            var brakeIntensity = shouldBrake ? 0.8 : 0.6;
                            breakingForce = maxBreakingForce * brakeIntensity;
                            engineForce = 0;
                        } else if (absSpeed < targetSpeedKmh - 3) {
                            // Accelerate when under target speed
                            var accelIntensity = (targetSpeedKmh - absSpeed) / targetSpeedKmh;
                            engineForce = maxEngineForce * Math.min(0.9, accelIntensity + 0.3);
                            breakingForce = 0;
                        } else if (absSpeed < 5) {
                            // If moving very slowly, give it a push
                            engineForce = maxEngineForce * 0.5;
                            breakingForce = 0;
                        } else {
                            // Maintain speed - slight throttle
                            engineForce = maxEngineForce * 0.2;
                            breakingForce = 0;
                        }

                        // STUCK DETECTION AND RECOVERY SYSTEM
                        var stuckDetected = checkIfStuck(carPos, speed, botRef);
                        if (stuckDetected) {
                            respawnBot(botRef);
                        }

                        // Minimal debug output - only show important events
                        if (botRef.debugCounter % 600 === 0) { // Every 10 seconds instead of 5
                            var status = '🏎️ Bot: ' + speed.toFixed(0) + 'km/h | WP:' + botRef.currentWaypointIndex + '/' + denseWaypoints.length;
                            if (botRef.stuckCounter > 0) status += ' ⚠️ STUCK:' + botRef.stuckCounter;
                            console.log(status);
                        }
                    } else {
                        // No racing path - simple forward movement for testing
                        if (botRef.debugCounter % 180 === 0) {
                            console.log('Bot: No racing path found, applying basic forward movement');
                        }
                        engineForce = maxEngineForce * 0.8; // More throttle
                        vehicleSteering = 0; // Straight
                    }

                    // Apply forces to vehicle
                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);
                    
                    // Update bot engine sound
                    if (botEngineSound) {
                        var throttle = Math.abs(engineForce) / maxEngineForce; // Normalize throttle (0-1)
                        var speedKmh = Math.abs(speed);
                        botEngineSound.updateEngine(speedKmh, throttle);
                    }
                    
                }

                // PREDICTIVE STEERING: Calculate look-ahead point based on speed and upcoming corners
                function calculateLookAheadPoint(carPos, speed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(speed);
                    
                    // Dynamic look-ahead distance based on speed (faster = look further ahead)
                    var baseLookAhead = Math.max(2, Math.min(8, absSpeed / 10)); // 2-8 waypoints
                    var lookAheadCount = Math.floor(baseLookAhead);
                    
                    // Find the look-ahead waypoint
                    var lookAheadIndex = (currentIndex + lookAheadCount) % denseWaypoints.length;
                    var lookAheadWaypoint = denseWaypoints[lookAheadIndex];
                    
                    // RACING LINE OPTIMIZATION: Adjust target point for optimal cornering
                    var optimizedPoint = calculateRacingLine(lookAheadWaypoint, lookAheadIndex, botRef);
                    
                    return optimizedPoint;
                }
                
                // RACING LINE: Calculate optimal path through corners
                function calculateRacingLine(waypoint, waypointIndex, botRef) {
                    var basePoint = waypoint.position.clone();
                    
                    // Analyze corner by looking at surrounding waypoints
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner direction and sharpness
                    var inVector = new THREE.Vector3().subVectors(basePoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, basePoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // If it's a corner (angle > threshold), optimize the racing line
                    if (cornerAngle > 0.3) { // ~17 degrees
                        // Calculate corner center and radius
                        var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                        var offsetDistance = Math.min(4, cornerSharpness * 6); // Max 4m offset
                        
                        // Determine if it's a left or right corner
                        var cross = new THREE.Vector3().crossVectors(inVector, outVector);
                        var isLeftCorner = cross.y > 0;
                        
                        // Calculate perpendicular offset for racing line
                        var perpendicular = new THREE.Vector3(-inVector.z, 0, inVector.x);
                        if (!isLeftCorner) perpendicular.multiplyScalar(-1);
                        
                        // Apply racing line offset (late apex)
                        basePoint.add(perpendicular.multiplyScalar(offsetDistance * 0.7));
                    }
                    
                    return basePoint;
                }
                
                // DYNAMIC SPEED CONTROL: Calculate optimal speed based on upcoming corners
                function calculateOptimalSpeed(carPos, currentSpeed, botRef) {
                    var currentIndex = botRef.currentWaypointIndex;
                    var absSpeed = Math.abs(currentSpeed);
                    var maxSpeed = botRef.targetSpeed;
                    var shouldBrake = false;
                    
                    // Look ahead for corners within braking distance
                    var lookAheadDistance = 0;
                    var minCornerSpeed = maxSpeed;
                    
                    for (var i = 0; i < 15; i++) { // Check next 15 waypoints (~30m ahead)
                        var checkIndex = (currentIndex + i) % denseWaypoints.length;
                        var waypoint = denseWaypoints[checkIndex];
                        
                        if (i > 0) {
                            var prevWaypoint = denseWaypoints[(currentIndex + i - 1) % denseWaypoints.length];
                            lookAheadDistance += waypoint.position.distanceTo(prevWaypoint.position);
                        }
                        
                        // Analyze corner sharpness
                        var cornerSpeed = analyzeCornerSpeed(checkIndex, botRef);
                        
                        if (cornerSpeed < minCornerSpeed) {
                            minCornerSpeed = cornerSpeed;
                            
                            // If we need to slow down significantly and we're within braking distance
                            if (absSpeed > cornerSpeed + 10 && lookAheadDistance < botRef.brakingDistance) {
                                shouldBrake = true;
                            }
                        }
                        
                        // Stop looking if we're far enough ahead
                        if (lookAheadDistance > botRef.brakingDistance) break;
                    }
                    
                    // Calculate target speed
                    var targetSpeed = Math.max(minCornerSpeed, maxSpeed * 0.4); // Minimum 40% of max speed
                    
                    // Smooth speed transitions
                    if (targetSpeed < absSpeed) {
                        targetSpeed = Math.max(targetSpeed, absSpeed - 15); // Don't brake too hard
                    }
                    
                    return {
                        targetSpeed: targetSpeed,
                        shouldBrake: shouldBrake,
                        cornerSpeed: minCornerSpeed
                    };
                }
                
                // Analyze corner speed based on turn radius and sharpness
                function analyzeCornerSpeed(waypointIndex, botRef) {
                    var prevIndex = (waypointIndex - 2 + denseWaypoints.length) % denseWaypoints.length;
                    var nextIndex = (waypointIndex + 2) % denseWaypoints.length;
                    
                    var prevPoint = denseWaypoints[prevIndex].position;
                    var currentPoint = denseWaypoints[waypointIndex].position;
                    var nextPoint = denseWaypoints[nextIndex].position;
                    
                    // Calculate corner angle
                    var inVector = new THREE.Vector3().subVectors(currentPoint, prevPoint).normalize();
                    var outVector = new THREE.Vector3().subVectors(nextPoint, currentPoint).normalize();
                    var cornerAngle = inVector.angleTo(outVector);
                    
                    // Calculate safe corner speed based on angle
                    var cornerSharpness = cornerAngle / Math.PI; // 0-1 scale
                    var baseCornerSpeed = botRef.maxCornerSpeed;
                    
                    if (cornerSharpness > 0.1) { // If it's actually a corner
                        // Sharper corners = slower speeds
                        var speedReduction = Math.pow(cornerSharpness, 0.7); // Smooth curve
                        baseCornerSpeed *= (1.0 - speedReduction * botRef.cornerSpeedFactor);
                    }
                    
                    return Math.max(baseCornerSpeed, 20); // Minimum 20 km/h
                }
                
                // STUCK DETECTION: Check if bot is stuck and needs respawning
                function checkIfStuck(currentPos, currentSpeed, botRef) {
                    var absSpeed = Math.abs(currentSpeed);
                    var currentTime = botRef.debugCounter;
                    
                    // Prevent rapid respawning (minimum 10 seconds between respawns)
                    if (currentTime - botRef.lastRespawnTime < 600) {
                        return false;
                    }
                    
                    // Get target waypoint for vertical position checking
                    var targetWaypoint = denseWaypoints[botRef.currentWaypointIndex];
                    var stuckByElevation = false;
                    
                    if (targetWaypoint) {
                        // Check if bot is at significantly wrong elevation
                        var targetY = targetWaypoint.position.y;
                        var currentY = currentPos.y;
                        var verticalDistance = Math.abs(currentY - targetY);
                        
                        // If bot is more than 8 meters above or below target elevation
                        if (verticalDistance > 8) {
                            botRef.verticalStuckCounter = (botRef.verticalStuckCounter || 0) + 1;
                            
                            // If stuck at wrong elevation for 5 seconds
                            if (botRef.verticalStuckCounter > 300) {
                                console.log('🏔️ Bot stuck at wrong elevation! Current Y:', currentY.toFixed(1), 'Target Y:', targetY.toFixed(1), 'Diff:', verticalDistance.toFixed(1) + 'm');
                                stuckByElevation = true;
                            }
                        } else {
                            botRef.verticalStuckCounter = 0; // Reset if elevation is good
                        }
                    }
                    
                    // Check if speed is too low for too long
                    if (absSpeed < botRef.stuckSpeedThreshold) {
                        botRef.lowSpeedCounter++;
                    } else {
                        botRef.lowSpeedCounter = 0; // Reset if speed is good
                    }
                    
                    // Check position movement every interval
                    if (botRef.debugCounter % botRef.stuckCheckInterval === 0) {
                        var distanceMoved = currentPos.distanceTo(botRef.lastPosition);
                        
                        // If bot hasn't moved much in the check interval
                        if (distanceMoved < botRef.stuckDistanceThreshold) {
                            botRef.stuckCounter++;
                            // Reduced stuck detection logging
                        } else {
                            botRef.stuckCounter = 0; // Reset if moving well
                        }
                        
                        // Update last position for next check
                        botRef.lastPosition.copy(currentPos);
                    }
                    
                    // Declare stuck if:
                    // 1. Low speed for more than 5 seconds (300 frames)
                    // 2. OR not moving for 2 consecutive checks (6 seconds)
                    // 3. OR wrong elevation for more than 5 seconds
                    var stuckBySpeed = botRef.lowSpeedCounter > 300;
                    var stuckByPosition = botRef.stuckCounter >= 2;
                    
                    if (stuckBySpeed || stuckByPosition || stuckByElevation) {
                        var reason = stuckByElevation ? 'WRONG ELEVATION' : 
                                   stuckBySpeed ? 'LOW SPEED' : 'NO MOVEMENT';
                        console.log('🚨 Bot STUCK (' + reason + ') - Respawning...');
                        return true;
                    }
                    
                    return false;
                }
                
                // RESPAWN BOT: Teleport bot to last reached waypoint with correct orientation
                function respawnBot(botRef) {
                    // Get respawn waypoint (last successfully reached waypoint)
                    var respawnWaypoint = denseWaypoints[botRef.lastWaypointReached];
                    var respawnPos = respawnWaypoint.position.clone();
                    
                    // Get the actual road surface elevation at this position
                    var actualRoadElevation = getRoadSurfaceElevation(respawnPos.x, respawnPos.z);
                    
                    // Safety check: if calculated elevation is much lower than waypoint, use waypoint + extra height
                    var waypointY = respawnWaypoint.position.y;
                    if (actualRoadElevation < waypointY - 10) {
                        console.warn('⚠️ Bot: Calculated road elevation seems too low, using waypoint elevation + safety margin');
                        respawnPos.y = waypointY + 2; // 2m above waypoint position for safety
                    } else {
                        respawnPos.y = actualRoadElevation + 1; // 1m above calculated road surface
                    }
                    
                    // Calculate orientation toward next waypoint
                    var nextWaypointIndex = (botRef.lastWaypointReached + 1) % denseWaypoints.length;
                    var nextWaypoint = denseWaypoints[nextWaypointIndex];
                    var directionToNext = new THREE.Vector3()
                        .subVectors(nextWaypoint.position, respawnPos)
                        .normalize();
                    
                    // Calculate rotation quaternion to face next waypoint
                    // Use Y-axis rotation (yaw) to face the target direction
                    var targetAngle = Math.atan2(directionToNext.x, directionToNext.z);
                    var quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    
                    console.log('🧭 Bot respawn facing toward waypoint', nextWaypointIndex);
                    
                    // Apply respawn transform to physics body
                    var transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin(new Ammo.btVector3(respawnPos.x, respawnPos.y, respawnPos.z));
                    transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
                    
                    // Reset physics body
                    botRef.vehicleBody.setWorldTransform(transform);
                    botRef.vehicleBody.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                    botRef.vehicleBody.activate(); // Wake up the physics body
                    
                    // Reset bot state
                    botRef.currentWaypointIndex = nextWaypointIndex;
                    botRef.stuckCounter = 0;
                    botRef.lowSpeedCounter = 0;
                    botRef.lastRespawnTime = botRef.debugCounter;
                    botRef.previousSteering = 0; // Reset steering smoothing
                    
                    console.log('🔄 Bot respawned at waypoint', nextWaypointIndex);
                }
                
                // HELPER FUNCTION: Calculate distance from racing path
                function findDistanceFromPath(carPos, botRef) {
                    if (!denseWaypoints || denseWaypoints.length === 0) return 0;
                    
                    try {
                        var nearestPoint = findNearestPathPoint(carPos);
                        if (!nearestPoint || !nearestPoint.point) return 0;
                        return carPos.distanceTo(nearestPoint.point);
                    } catch (e) {
                        console.warn('Error calculating distance from path:', e);
                        return 0;
                    }
                }
                
                // VISUAL RAYCAST DEBUG: Create visible lines to show raycast directions
                function createRaycastVisuals() {
                    // Clear existing raycast lines
                    raycastLines.forEach(line => {
                        scene.remove(line);
                    });
                    raycastLines = [];
                }
                
                function addRaycastLine(start, end, color, hit) {
                    var geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                    var material = new THREE.LineBasicMaterial({ 
                        color: color,
                        linewidth: hit ? 3 : 1,
                        transparent: true,
                        opacity: hit ? 0.9 : 0.5
                    });
                    var line = new THREE.Line(geometry, material);
                    scene.add(line);
                    raycastLines.push(line);
                    
                    // Add a small sphere at hit point if there's a hit
                    if (hit) {
                        var sphereGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        var sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
                        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        sphere.position.copy(end);
                        scene.add(sphere);
                        raycastLines.push(sphere);
                    }
                }

                // OBSTACLE AVOIDANCE: Raycast-based obstacle detection
                function checkObstacles(carPos, carQuat, carForward, speed, botRef) {
                    var rayLength = botRef.avoidanceRayLength;
                    var shouldAvoid = false;
                    var avoidanceSteer = 0;
                    var closestDistance = rayLength;
                    
                    // Clear previous raycast visuals
                    createRaycastVisuals();
                    
                    // Create rays: forward, left, right
                    var rays = [
                        { direction: carForward.clone(), weight: 1.0, name: 'forward' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'left' },
                        { direction: carForward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), botRef.sideRayAngle * Math.PI / 180), weight: 0.7, name: 'right' }
                    ];
                    
                    var obstacleDetected = false;
                    var avoidanceDirection = 0; // -1 = left, +1 = right
                    var debugInfo = [];
                    var totalHits = 0;
                    
                    // Cast rays and check for collisions
                    for (var i = 0; i < rays.length; i++) {
                        var ray = rays[i];
                        var rayStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                        var rayEnd = new Ammo.btVector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayCallback = new Ammo.ClosestRayResultCallback(rayStart, rayEnd);
                        physicsWorld.rayTest(rayStart, rayEnd, rayCallback);
                        
                        var hitDetected = rayCallback.hasHit();
                        
                        // Visual debugging - create lines for each ray
                        var startPos = new THREE.Vector3(carPos.x, carPos.y, carPos.z);
                        var endPos = new THREE.Vector3(
                            carPos.x + ray.direction.x * rayLength,
                            carPos.y,
                            carPos.z + ray.direction.z * rayLength
                        );
                        
                        var rayColor = 0x00ff00; // Green for no hit
                        var actualHitPos = endPos;
                        
                        if (hitDetected) {
                            // Check if the hit object is the road surface
                            var hitBody = rayCallback.get_m_collisionObject();
                            var isRoadHit = (roadPhysicsBody && hitBody.a === roadPhysicsBody.a);
                            
                            var hitPoint = rayCallback.get_m_hitPointWorld();
                            var hitDistance = Math.sqrt(
                                Math.pow(hitPoint.x() - carPos.x, 2) + 
                                Math.pow(hitPoint.y() - carPos.y, 2) + 
                                Math.pow(hitPoint.z() - carPos.z, 2)
                            );
                            
                            // Update visual end position to hit point
                            actualHitPos = new THREE.Vector3(hitPoint.x(), hitPoint.y(), hitPoint.z());
                            
                            if (isRoadHit) {
                                // Road hit - ignore for obstacle avoidance but show in debug
                                debugInfo.push(ray.name + ':ROAD-' + hitDistance.toFixed(1) + 'm');
                                rayColor = 0x888888; // Gray for road hits
                            } else {
                                totalHits++;
                                debugInfo.push(ray.name + ':' + hitDistance.toFixed(1) + 'm');
                                
                                // Ignore hits that are too close (probably the car itself) or road surface
                                if (hitDistance > 1.5 && hitDistance < rayLength) {
                                obstacleDetected = true;
                                shouldAvoid = true;
                                rayColor = 0xff0000; // Red for obstacle hit
                                
                                // Calculate avoidance based on which ray hit
                                if (ray.name === 'forward') {
                                    avoidanceDirection += (Math.random() > 0.5) ? 1 : -1;
                                } else if (ray.name === 'left') {
                                    avoidanceDirection += 1.0;
                                } else if (ray.name === 'right') {
                                    avoidanceDirection -= 1.0;
                                }
                                
                                if (hitDistance < closestDistance) {
                                    closestDistance = hitDistance;
                                }
                                } else {
                                    rayColor = 0xffff00; // Yellow for hit but ignored (too close/far)
                                }
                            }
                        }
                        
                        // Add visual ray line
                        addRaycastLine(startPos, actualHitPos, rayColor, hitDetected);
                        
                        // Clean up Ammo objects
                        Ammo.destroy(rayStart);
                        Ammo.destroy(rayEnd);
                        Ammo.destroy(rayCallback);
                    }
                    
                    // Debug raycast hits every 300 frames
                    if (botRef.debugCounter % 300 === 0) {
                        if (totalHits > 0) {
                            // Raycast debug logging removed for cleaner console
                        }
                        
                        // Check if player car is nearby but not detected
                        if (vehicleRef && vehicleRef.chassisMesh) {
                            var playerPos = vehicleRef.chassisMesh.position;
                            var distanceToPlayer = carPos.distanceTo(playerPos);
                            if (distanceToPlayer < rayLength) {
                                // Player proximity debug logging removed
                                
                                // Test if we can raycast directly to player
                                var dirToPlayer = new THREE.Vector3().subVectors(playerPos, carPos).normalize();
                                var testStart = new Ammo.btVector3(carPos.x, carPos.y, carPos.z);
                                var testEnd = new Ammo.btVector3(
                                    carPos.x + dirToPlayer.x * distanceToPlayer,
                                    carPos.y,
                                    carPos.z + dirToPlayer.z * distanceToPlayer
                                );
                                
                                var testCallback = new Ammo.ClosestRayResultCallback(testStart, testEnd);
                                physicsWorld.rayTest(testStart, testEnd, testCallback);
                                
                                // Direct raycast debug logging removed
                                
                                Ammo.destroy(testStart);
                                Ammo.destroy(testEnd);
                                Ammo.destroy(testCallback);
                            }
                        }
                    }
                    
                    // Calculate final avoidance steering
                    if (shouldAvoid) {
                        var urgency = Math.max(0.3, 1.0 - (closestDistance / rayLength));
                        avoidanceSteer = Math.sign(avoidanceDirection) * botRef.avoidanceForce * urgency;
                        avoidanceSteer = Math.max(-1.0, Math.min(1.0, avoidanceSteer));
                        
                        console.log('🚧 OBSTACLE DETECTED! Distance:', closestDistance.toFixed(1) + 'm, Steer:', avoidanceSteer.toFixed(2), '|', debugInfo.join(', '));
                    }
                    
                    return {
                        shouldAvoid: shouldAvoid,
                        avoidanceSteer: avoidanceSteer,
                        closestDistance: closestDistance,
                        obstacleDetected: obstacleDetected,
                        multipleHits: totalHits >= 2 // True if multiple rays hit obstacles
                    };
                }
                

                // Only add bot sync in singleplayer mode
                if (!isMultiplayer) {
                    syncList.push(botSync);
                }
                return botRef;
            }

            function createVehicle(pos, quat) {
                // Vehicle constants - improved for stability
                var chassisWidth = 2.2;  // Wider for better stability (was 1.8)
                var chassisHeight = .4;  // Lower center of mass (was .6)
                var chassisLength = 4;
                var massVehicle = 1500; // Heavy for good collision physics (was 800)

                var wheelAxisPositionBack = -1.5; // Moved 50cm backwards
                var wheelRadiusBack = .5; // Reduced by 10cm from .6
                var wheelWidthBack = .3;
                var wheelHalfTrackBack = 1.4; // Increased by 20cm for 40cm wider total span
                var wheelAxisHeightBack = .2; // Lower for stability (was .3)

                var wheelAxisFrontPosition = 1.7;
                var wheelHalfTrackFront = 1.4; // Increased by 20cm for 40cm wider total span
                var wheelAxisHeightFront = .2; // Lower for stability (was .3)
                var wheelRadiusFront = .45; // Reduced by 10cm from .55
                var wheelWidthFront = .2;

                var friction = 2.5; // Touring car grip - good control but can still slide
                var suspensionStiffness = 25.0; // Touring car suspension - firm but comfortable
                var suspensionDamping = 3.5;    // Balanced damping for control
                var suspensionCompression = 5.0; // Moderate compression
                var suspensionRestLength = 0.4;  // Shorter for lower ride height (was 0.6)
                var rollInfluence = 0.15;        // Moderate roll influence for realistic handling (was 0.05)

                var baseSteeringIncrement = .04;
                var steeringClamp = .5;
                var maxEngineForce = 2500; // More power for arcade-style fun
                var maxBreakingForce = 100;

                // Chassis
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                geometry.calculateLocalInertia(massVehicle, localInertia);
                var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
                body.setActivationState(DISABLE_DEACTIVATION);
                
                // Lower center of mass for better stability
                var centerOfMass = new Ammo.btVector3(0, -0.3, 0); // Lower center of mass
                body.setCenterOfMassTransform(transform);
                
                // Add stability improvements (allow more rotation for realistic handling)
                body.setAngularFactor(new Ammo.btVector3(1, 1, 0.7)); // Allow more roll for realistic physics
                body.setLinearFactor(new Ammo.btVector3(1, 1, 1)); // Allow all linear movement
                
                // Add arcade-style collision properties
                body.setRestitution(0.3); // Some bounciness for fun collisions
                body.setFriction(0.8); // Good grip but not too sticky
                
                // Ensure the player body can be detected by raycasts
                body.setCollisionFlags(body.getCollisionFlags() & ~2); // Remove CF_NO_CONTACT_RESPONSE flag
                
                physicsWorld.addRigidBody(body);
                
                // Create player chassis mesh with GLTF dune buggy model
                var chassisMesh = null;
                
                // Load dune buggy model for player (async)
                loadDuneBuggyModel(1.0).then((model) => {
                    // Remove temporary placeholder
                    if (chassisMesh && chassisMesh.parent) {
                        scene.remove(chassisMesh);
                    }
                    
                    chassisMesh = model;
                    // Update the vehicle reference
                    if (vehicleRef) {
                        vehicleRef.chassisMesh = chassisMesh;
                    }
                    console.log('🏎️ Player dune buggy model loaded and positioned');
                }).catch((error) => {
                    console.error('❌ Failed to load player dune buggy model:', error);
                    // Fallback already handled in loadDuneBuggyModel
                });
                
                // Temporary placeholder until GLTF loads
                var tempMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600, transparent: true, opacity: 0.5 });
                var tempShape = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                chassisMesh = new THREE.Mesh(tempShape, tempMaterial);
                scene.add(chassisMesh);
                
                // Add physics body wireframe visualization (for debugging alignment)
                var wireframeGeometry = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
                var wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true, 
                    transparent: true, 
                    opacity: 0.8 
                });
                var physicsWireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                physicsWireframe.position.set(pos.x, pos.y, pos.z);
                physicsWireframe.quaternion.set(quat.x, quat.y, quat.z, quat.w);
                scene.add(physicsWireframe);

                // Raycast Vehicle
                var engineForce = 0;
                var vehicleSteering = 0;
                var breakingForce = 0;
                var tuning = new Ammo.btVehicleTuning();
                // Improve stability with custom tuning
                tuning.set_m_suspensionStiffness(suspensionStiffness);
                tuning.set_m_suspensionCompression(suspensionCompression);
                tuning.set_m_suspensionDamping(suspensionDamping);
                tuning.set_m_maxSuspensionTravelCm(30); // Limit suspension travel
                tuning.set_m_frictionSlip(2.5); // Touring car grip - forgiving but realistic
                
                var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
                var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
                vehicle.setCoordinateSystem(0, 1, 2);
                physicsWorld.addAction(vehicle);

                // Store vehicle reference for reset
                vehicleRef = {
                    vehicle: vehicle,
                    vehicleBody: body,
                    chassisMesh: chassisMesh,
                    physicsWireframe: physicsWireframe
                };

                // Wheels
                var FRONT_LEFT = 0;
                var FRONT_RIGHT = 1;
                var BACK_LEFT = 2;
                var BACK_RIGHT = 3;
                var wheelMeshes = [];
                var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
                var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

                function addWheel(isFront, pos, radius, width, index) {
                    var wheelInfo = vehicle.addWheel(
                        pos,
                        wheelDirectionCS0,
                        wheelAxleCS,
                        suspensionRestLength,
                        radius,
                        tuning,
                        isFront);

                    wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
                    wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
                    wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
                    wheelInfo.set_m_frictionSlip(friction);
                    wheelInfo.set_m_rollInfluence(rollInfluence);

                    // Determine if this is a right-side wheel (negative X position)
                    var isRightSide = pos.x() < 0;
                    
                    // Create temporary placeholder wheel
                    wheelMeshes[index] = createWheelMesh(radius, width);
                    
                    // Load GLTF tire model (async)
                    loadTireModel(isRightSide, 1.0).then((tireModel) => {
                        // Remove temporary placeholder
                        if (wheelMeshes[index] && wheelMeshes[index].parent) {
                            scene.remove(wheelMeshes[index]);
                        }
                        
                        wheelMeshes[index] = tireModel;
                        console.log('🛞 Tire', index, 'loaded, right side:', isRightSide);
                    }).catch((error) => {
                        console.error('❌ Failed to load tire', index, ':', error);
                        // Keep the placeholder wheel
                    });
                }

                addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
                addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
                addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
                addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);

                // Sync keyboard/VR actions and physics and graphics
                function sync(dt) {
                    var speed = vehicle.getCurrentSpeedKmHour();
                    speedometer.innerHTML = (speed < 0 ? '(R) ' : '') + Math.abs(speed).toFixed(1) + ' km/h';
                    
                    // Check for checkpoint progress
                    if (chassisMesh) {
                        checkCheckpointProgress(chassisMesh.position);
                    }
                    
                    // Update player engine sound with realistic parameters
                    if (playerEngineSound) {
                        var throttleInput = Math.abs(engineForce) / maxEngineForce; // Normalize throttle (0-1)
                        var brakeInput = Math.abs(breakingForce) / maxBreakingForce; // Normalize braking (0-1)
                        var speedKmh = Math.abs(speed);
                        var isAccelerating = acceleration ? 1 : 0;
                        
                        playerEngineSound.updateEngine(speedKmh, throttleInput, isAccelerating, brakeInput);
                    }

                    breakingForce = 0;
                    engineForce = 0;

                    // Get VR controller input
                    var vrSteering = 0;
                    var vrAcceleration = 0;
                    var vrBraking = 0;
                    
                    if (renderer.xr.isPresenting) {
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                            for (let i = 0; i < session.inputSources.length; i++) {
                                const inputSource = session.inputSources[i];
                                const gamepad = inputSource.gamepad;
                                
                                if (gamepad && inputSource.handedness === 'right') {
                                    // Start audio on first VR controller interaction
                                    if (!vrAudioStarted && gamepad.buttons) {
                                        for (let j = 0; j < gamepad.buttons.length; j++) {
                                            if (gamepad.buttons[j] && gamepad.buttons[j].pressed) {
                                                startEngineAudio();
                                                vrAudioStarted = true;
                                                console.log('🎵 VR audio started via controller button press');
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Car controls (only when menu is not visible and not in fly mode)
                                    if (!isMenuVisible && cameraMode !== 'fly') {
                                        // Thumbstick for steering
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            vrSteering = gamepad.axes[2] || 0;
                                        }
                                        
                                        // Trigger for acceleration
                                        if (gamepad.buttons && gamepad.buttons[0]) {
                                            vrAcceleration = gamepad.buttons[0].value || 0;
                                        }
                                        
                                        // Grip for braking
                                        if (gamepad.buttons && gamepad.buttons[1]) {
                                            vrBraking = gamepad.buttons[1].value || 0;
                                        }
                                    } else {
                                        // Reset car controls when menu is open or in fly mode
                                        vrSteering = 0;
                                        vrAcceleration = 0;
                                        vrBraking = 0;
                                    }
                                    
                                    // A button (index 4) for camera switching (only when menu is not visible)
                                    if (!isMenuVisible && gamepad.buttons && gamepad.buttons[4] && gamepad.buttons[4].pressed) {
                                        // Prevent rapid switching with a simple debounce
                                        if (!this.lastCameraSwitchTime || (Date.now() - this.lastCameraSwitchTime) > 500) {
                                            switchCamera();
                                            this.lastCameraSwitchTime = Date.now();
                                        }
                                    }
                                    
                                    // B button (index 5) for menu toggle
                                    if (gamepad.buttons && gamepad.buttons[5] && gamepad.buttons[5].pressed) {
                                        // Prevent rapid toggling with a simple debounce
                                        if (!this.lastMenuToggleTime || (Date.now() - this.lastMenuToggleTime) > 500) {
                                            toggleMenu();
                                            this.lastMenuToggleTime = Date.now();
                                        }
                                    }
                                    
                    // VR Menu interaction with trigger (index 0)
                    if (isMenuVisible && vrMenu && vrMenu.visible && gamepad.buttons && gamepad.buttons[0] && gamepad.buttons[0].pressed) {
                        if (!this.lastMenuClickTime || (Date.now() - this.lastMenuClickTime) > 300) {
                            // Find which controller this input source belongs to
                            let controllerIndex = -1;
                            const session = renderer.xr.getSession();
                            if (session && session.inputSources) {
                                for (let i = 0; i < session.inputSources.length; i++) {
                                    if (session.inputSources[i] === inputSource) {
                                        controllerIndex = i;
                                        break;
                                    }
                                }
                            }
                            if (controllerIndex >= 0) {
                                handleVRMenuClick(controllerIndex);
                            }
                            this.lastMenuClickTime = Date.now();
                        }
                    }
                    
                    // VR Menu raycasting for hover effects
                    if (isMenuVisible && vrMenu && vrMenu.visible) {
                        // Find which controller this input source belongs to
                        let controllerIndex = -1;
                        const session = renderer.xr.getSession();
                        if (session && session.inputSources) {
                            for (let i = 0; i < session.inputSources.length; i++) {
                                if (session.inputSources[i] === inputSource) {
                                    controllerIndex = i;
                                    break;
                                }
                            }
                        }
                        if (controllerIndex >= 0) {
                            updateVRMenuHover(controllerIndex);
                        }
                    }
                    
                    // Update laser pointer visibility
                    updateLaserPointers();
                                    
                                    // Y button (index 3) for car reset (only when menu is not visible)
                                    if (!isMenuVisible && gamepad.buttons && gamepad.buttons[3] && gamepad.buttons[3].pressed) {
                                        if (!this.lastResetTime || (Date.now() - this.lastResetTime) > 500) {
                                            resetCar();
                                            this.lastResetTime = Date.now();
                                        }
                                    }
                                    
                                    // VR Fly Camera Controls (when in fly mode and menu is not visible)
                                    if (cameraMode === 'fly' && !isMenuVisible) {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Right thumbstick: X = strafe left/right, Y = forward/back movement (KEEP WORKING)
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var moveX = gamepad.axes[2] || 0; // Right thumbstick X = strafe
                                            var moveZ = gamepad.axes[3] || 0; // Right thumbstick Y = forward/back
                                            
                                            // Create movement vectors relative to current rotation
                                            var forward = new THREE.Vector3(0, 0, -1);
                                            var right = new THREE.Vector3(1, 0, 0);
                                            
                                            // Apply current Y rotation to movement vectors
                                            forward.applyEuler(vrFlyRotation);
                                            right.applyEuler(vrFlyRotation);
                                            
                                            // Apply movement
                                            vrFlyPosition.add(right.multiplyScalar(moveX * flyDelta));
                                            vrFlyPosition.add(forward.multiplyScalar(-moveZ * flyDelta));
                                        }
                                        
                                        // Trigger buttons for up/down movement
                                        if (gamepad.buttons && gamepad.buttons[0]) {
                                            var upMovement = gamepad.buttons[0].value || 0;
                                            vrFlyPosition.y += upMovement * flyDelta;
                                        }
                                        
                                        if (gamepad.buttons && gamepad.buttons[1]) {
                                            var downMovement = gamepad.buttons[1].value || 0;
                                            vrFlyPosition.y -= downMovement * flyDelta;
                                        }
                                        
                                        // Apply bounds to prevent flying too far
                                        vrFlyPosition.x = Math.max(-200, Math.min(200, vrFlyPosition.x));
                                        vrFlyPosition.y = Math.max(1, Math.min(100, vrFlyPosition.y)); // 1m to 100m height
                                        vrFlyPosition.z = Math.max(-200, Math.min(200, vrFlyPosition.z));
                                    }
                                }
                                
                                if (gamepad && inputSource.handedness === 'left') {
                                    // LEFT CONTROLLER - VR Fly Camera Controls (rotation and up/down)
                                    // VR controller debug logging removed
                                    if (cameraMode === 'fly') {
                                        var flyDelta = dt * vrFlySpeed;
                                        var rotationSpeed = 2.0; // Rotation speed multiplier
                                        
                                        // Left controller thumbstick: X = rotation, Y = up/down movement
                                        if (gamepad.axes && gamepad.axes.length >= 4) {
                                            var rotateY = gamepad.axes[2] || 0; // Left thumbstick X = Y rotation
                                            var moveY = gamepad.axes[3] || 0;   // Left thumbstick Y = vertical movement
                                            
                                            // Debug logging
                                            if (Math.abs(rotateY) > 0.1 || Math.abs(moveY) > 0.1) {
                                                console.log('🎮 Left controller - Rotate:', rotateY.toFixed(2), 'MoveY:', moveY.toFixed(2));
                                            }
                                            
                                            // Apply Y rotation (turning left/right) - inverted for natural feel
                                            vrFlyRotation.y -= rotateY * rotationSpeed * dt;
                                            
                                            // Apply vertical movement (up/down)
                                            vrFlyPosition.y -= moveY * flyDelta; // Inverted for natural feel
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Combine keyboard and VR input (but disable car controls in desktop fly mode)
                    var isDesktopFlyMode = (cameraMode === 'fly' && !renderer.xr.isPresenting);
                    var acceleration = (isDesktopFlyMode ? false : actions.acceleration) || (vrAcceleration > 0.1);
                    var braking = (isDesktopFlyMode ? false : actions.braking) || (vrBraking > 0.1);
                    var left = (isDesktopFlyMode ? false : actions.left) || (vrSteering < -0.1);
                    var right = (isDesktopFlyMode ? false : actions.right) || (vrSteering > 0.1);

                    // Arcade-style steering - more responsive and forgiving
                    var absSpeed = Math.abs(speed);
                    var speedFactor = Math.max(0.6, 1.0 - (absSpeed / 120)); // Less speed penalty, kicks in later
                    var steeringIncrement = baseSteeringIncrement * speedFactor;
                    
                    // Keep most steering ability at high speeds for arcade feel
                    var dynamicSteeringClamp = steeringClamp * Math.max(0.8, speedFactor);
                    
                    // Calculate dynamic tire friction - Touring car style (more forgiving)
                    var baseFriction = 2.5;
                    var speedGripFactor = Math.max(0.7, 1.0 - (Math.abs(speed) / 150)); // More grip at high speeds
                    var steeringGripFactor = Math.max(0.8, 1.0 - (Math.abs(vehicleSteering) * 0.4)); // Less penalty for steering
                    var dynamicFriction = baseFriction * speedGripFactor * steeringGripFactor;

                    if (acceleration) {
                        if (speed < -1)
                            breakingForce = maxBreakingForce;
                        else {
                            // Reduce engine force when tires are slipping (low grip)
                            var gripFactor = dynamicFriction / baseFriction; // How much grip we have
                            var adjustedEngineForce = maxEngineForce;
                            
                            // Light traction control - only kick in when really sliding
                            if (gripFactor < 0.5 && Math.abs(speed) > 40) {
                                adjustedEngineForce *= (0.8 + gripFactor * 0.2); // Gentle power reduction
                            }
                            
                            engineForce = adjustedEngineForce;
                        }
                    }
                    if (braking) {
                        if (speed > 1)
                            breakingForce = maxBreakingForce;
                        else engineForce = -maxEngineForce / 2;
                    }
                    
                    // Improved steering logic with speed-dependent response
                    if (left) {
                        if (vehicleSteering < dynamicSteeringClamp)
                            vehicleSteering += steeringIncrement;
                    }
                    else if (right) {
                        if (vehicleSteering > -dynamicSteeringClamp)
                            vehicleSteering -= steeringIncrement;
                    }
                    else {
                        // Return to center more gradually for better control
                        var returnRate = steeringIncrement * 1.5; // Slightly faster return to center
                        if (vehicleSteering < -returnRate) {
                            vehicleSteering += returnRate;
                        } else if (vehicleSteering > returnRate) {
                            vehicleSteering -= returnRate;
                        } else {
                            vehicleSteering = 0;
                        }
                    }

                    vehicle.applyEngineForce(engineForce, BACK_LEFT);
                    vehicle.applyEngineForce(engineForce, BACK_RIGHT);

                    vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
                    vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
                    vehicle.setBrake(breakingForce, BACK_LEFT);
                    vehicle.setBrake(breakingForce, BACK_RIGHT);

                    vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
                    vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);
                    
                    // Apply dynamic friction to all wheels
                    for (var w = 0; w < vehicle.getNumWheels(); w++) {
                        var wheelInfo = vehicle.getWheelInfo(w);
                        wheelInfo.set_m_frictionSlip(dynamicFriction);
                    }
                    
                    // DRIVING SOUND EFFECTS: Detect drifting, hard braking, etc.
                    if (window.tireScreechSound) {
                        var vehicleBody = vehicle.getRigidBody();
                        var velocity = vehicleBody.getLinearVelocity();
                        
                        // Calculate if car is drifting (lateral velocity vs forward velocity)
                        var transform = vehicleBody.getWorldTransform();
                        var rotation = transform.getRotation();
                        
                        // Get forward direction vector
                        var forward = new THREE.Vector3(0, 0, 1);
                        var quaternion = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                        forward.applyQuaternion(quaternion);
                        
                        // Calculate forward and lateral velocity components
                        var velocityVector = new THREE.Vector3(velocity.x(), velocity.y(), velocity.z());
                        var forwardVel = velocityVector.dot(forward);
                        var right = new THREE.Vector3(1, 0, 0);
                        right.applyQuaternion(quaternion);
                        var lateralVel = Math.abs(velocityVector.dot(right));
                        
                        // Detect drifting conditions
                        var isDrifting = false;
                        var driftIntensity = 0;
                        
                        if (Math.abs(speed) > 30) { // Only at reasonable speeds
                            // High lateral velocity = drifting
                            if (lateralVel > 5) {
                                isDrifting = true;
                                driftIntensity = Math.min(lateralVel / 15, 1); // Normalize to 0-1
                            }
                            
                            // Hard braking while turning
                            if (braking && Math.abs(vehicleSteering) > 0.3 && Math.abs(speed) > 40) {
                                isDrifting = true;
                                driftIntensity = Math.max(driftIntensity, brakeInput * 0.8);
                            }
                            
                            // High steering input at speed
                            if (Math.abs(vehicleSteering) > 0.6 && Math.abs(speed) > 50) {
                                isDrifting = true;
                                driftIntensity = Math.max(driftIntensity, Math.abs(vehicleSteering) * 0.6);
                            }
                        }
                        
                        // Control tire screech sound
                        if (isDrifting && driftIntensity > 0.2) {
                            if (!window.tireScreechSound.isPlaying) {
                                window.tireScreechSound.start(driftIntensity);
                            } else {
                                // Update intensity and frequency based on speed
                                var screechFreq = 1500 + (Math.abs(speed) * 15); // Higher pitch at higher speeds
                                window.tireScreechSound.updateIntensity(driftIntensity, screechFreq);
                            }
                        } else {
                            if (window.tireScreechSound.isPlaying) {
                                window.tireScreechSound.stop();
                            }
                        }
                    }
                    
                    // Simplified arcade-style physics - more stable
                    if (Math.abs(speed) > 60) { // Only at higher speeds
                        var vehicleBody = vehicle.getRigidBody();
                        var angularVel = vehicleBody.getAngularVelocity();
                        
                        // Only prevent dangerous rolling - no complex lateral velocity manipulation
                        if (Math.abs(angularVel.z()) > 4.0) {
                            vehicleBody.setAngularVelocity(new Ammo.btVector3(
                                angularVel.x(),
                                angularVel.y(), 
                                angularVel.z() * 0.9 // Light roll damping
                            ));
                        }
                        
                        // Prevent excessive yaw spinning
                        if (Math.abs(angularVel.y()) > 6.0) {
                            vehicleBody.setAngularVelocity(new Ammo.btVector3(
                                angularVel.x(),
                                angularVel.y() * 0.95, // Light yaw damping
                                angularVel.z()
                            ));
                        }
                    }

                    var tm, p, q, i;
                    var n = vehicle.getNumWheels();
                    for (i = 0; i < n; i++) {
                        vehicle.updateWheelTransform(i, true);
                        tm = vehicle.getWheelTransformWS(i);
                        p = tm.getOrigin();
                        q = tm.getRotation();
                        wheelMeshes[i].position.set(p.x(), p.y(), p.z());
                        wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }

                    tm = vehicle.getChassisWorldTransform();
                    p = tm.getOrigin();
                    q = tm.getRotation();
                    
                    // Update chassis mesh with offset for GLTF models
                    if (chassisMesh.userData && chassisMesh.userData.chassisOffset) {
                        const offset = chassisMesh.userData.chassisOffset.clone();
                        const carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                        offset.applyQuaternion(carQuaternion); // Rotate offset by car's rotation
                        chassisMesh.position.set(p.x() + offset.x, p.y() + offset.y, p.z() + offset.z);
                    } else {
                        chassisMesh.position.set(p.x(), p.y(), p.z());
                    }
                    chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    
                    // Update physics wireframe (shows exact physics body position)
                    if (vehicleRef && vehicleRef.physicsWireframe) {
                        vehicleRef.physicsWireframe.position.set(p.x(), p.y(), p.z());
                        vehicleRef.physicsWireframe.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }
                    
                    // Send bot state to other players (host only, throttled to 10Hz)
                    if (isMultiplayer && isHost && connections.size > 0 && botEnabled) {
                        if (!this.lastBotSync || (Date.now() - this.lastBotSync) > 100) {
                            sendToAllPlayers({
                                type: 'bot-state',
                                botState: {
                                    position: { x: p.x(), y: p.y(), z: p.z() },
                                    quaternion: { x: q.x(), y: q.y(), z: q.z(), w: q.w() }
                                }
                            });
                            this.lastBotSync = Date.now();
                        }
                    }

                    // Update camera position (works for both desktop and VR)
                    if (cameraMode === 'firstperson') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Move the camera rig (which contains the VR camera)
                            var cameraOffset = new THREE.Vector3(-0.5, -0.6, -0.3); // x(left), y(up), z(forward) - 50cm left, 50cm lower, forward
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            
                            // Rotate 180 degrees around Y axis to face forward
                            var forwardRotation = new THREE.Quaternion();
                            forwardRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                            carQuaternion.multiply(forwardRotation);
                            
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            cameraRig.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            cameraRig.quaternion.copy(carQuaternion);
                        } else {
                            // In Desktop: Move the first person camera directly
                            var cameraOffset = new THREE.Vector3(0, 1.4, 1.2); // x, y(up), z(forward)
                            var carQuaternion = new THREE.Quaternion(q.x(), q.y(), q.z(), q.w());
                            cameraOffset.applyQuaternion(carQuaternion);
                            
                            firstPersonCamera.position.set(
                                p.x() + cameraOffset.x,
                                p.y() + cameraOffset.y,
                                p.z() + cameraOffset.z
                            );
                            
                            // Make camera look forward relative to car
                            var lookDirection = new THREE.Vector3(0, 0, 5); // Look forward
                            lookDirection.applyQuaternion(carQuaternion);
                            var lookTarget = firstPersonCamera.position.clone().add(lookDirection);
                            firstPersonCamera.lookAt(lookTarget);
                        }
                    } else if (cameraMode === 'fly') {
                        if (renderer.xr.isPresenting) {
                            // VR Fly Camera: Position camera rig at fly position
                            cameraRig.position.copy(vrFlyPosition);
                            // Apply fly camera rotation (Y-axis rotation from thumbstick)
                            cameraRig.rotation.copy(vrFlyRotation);
                        } else {
                            // Desktop Fly Camera: Handle WASD movement and Q/E for up/down
                            var flyDelta = dt * desktopFlySpeed;
                            
                            // Create movement vectors - only use YAW for horizontal movement to prevent roll
                            var yawRotation = new THREE.Euler(0, desktopFlyRotation.y, 0, 'YXZ');
                            var forward = new THREE.Vector3(0, 0, -1);
                            var right = new THREE.Vector3(1, 0, 0);
                            var up = new THREE.Vector3(0, 1, 0); // World up, not camera up
                            
                            // Apply only yaw rotation to horizontal movement vectors
                            forward.applyEuler(yawRotation);
                            right.applyEuler(yawRotation);
                            
                            // WASD movement
                            if (actions['acceleration']) { // W - forward
                                desktopFlyPosition.add(forward.clone().multiplyScalar(flyDelta));
                            }
                            if (actions['braking']) { // S - backward
                                desktopFlyPosition.add(forward.clone().multiplyScalar(-flyDelta));
                            }
                            if (actions['left']) { // A - strafe left
                                desktopFlyPosition.add(right.clone().multiplyScalar(-flyDelta));
                            }
                            if (actions['right']) { // D - strafe right
                                desktopFlyPosition.add(right.clone().multiplyScalar(flyDelta));
                            }
                            
                            // Q/E for up/down movement (always world up/down)
                            if (actions['flyUp']) { // E - up
                                desktopFlyPosition.add(up.clone().multiplyScalar(flyDelta));
                            }
                            if (actions['flyDown']) { // Q - down
                                desktopFlyPosition.add(up.clone().multiplyScalar(-flyDelta));
                            }
                            
                            // Apply position and rotation to camera (prevent roll/tilt)
                            firstPersonCamera.position.copy(desktopFlyPosition);
                            firstPersonCamera.rotation.order = 'YXZ'; // Ensure proper rotation order
                            firstPersonCamera.rotation.set(
                                desktopFlyRotation.x, // Pitch (up/down)
                                desktopFlyRotation.y, // Yaw (left/right)
                                0                     // Roll (always 0 to prevent tilt)
                            );
                        }
                    } else if (cameraMode === 'orbit') {
                        if (renderer.xr.isPresenting) {
                            // In VR: Position orbit camera in the rig
                            cameraRig.position.set(p.x() - 4.84, p.y() + 4.39, p.z() - 35.11);
                            var lookTarget = new THREE.Vector3(p.x(), p.y(), p.z());
                            cameraRig.lookAt(lookTarget);
                        }
                        // Desktop orbit camera is handled by OrbitControls
                    }
                }

                syncList.push(sync);
            }

            function createRacingPath() {
                // Define control points using the reference track layout
                const curvePoints = [
                    -6, 0, 10,
                    -1, 0, 10,
                     3, 0,  4,
                     6, 0,  1,
                    11, 0,  2,
                    13, 0,  6,
                     9, 1,  9,
                     4, 1,  7,
                     1, 1,  1,
                     0, 1, -5,
                     2, 0, -9,
                     8, 0,-10,
                    13, 0, -5,
                    14, 1,  2,
                    10, 3,  7,
                     2, 1,  8,
                    -4, 3,  7,
                    -8, 1,  1,
                    -9, 1, -4,
                    -6, 1, -9,
                     0, 1,-10,
                     7, 1, -7,
                     5, 2,  0,
                     0, 2,  2,
                    -5, 1,  0,
                    -7, 2, -5,
                    -8, 2, -9,
                   -11, 2,-10,
                   -14, 1, -7,
                   -13, 1, -2,
                   -14, 0,  3,
                   -11, 0, 10,
                    -6, 0, 10
                ];
                
                // Convert curvePoints array to Vector3 points with elevation smoothing
                var rawPoints = [];
                for (let i = 0; i < curvePoints.length; i += 3) {
                    rawPoints.push(new THREE.Vector3(
                        curvePoints[i] * 8,     // Scale up X by 8x (doubled from 4x)
                        curvePoints[i + 1] * 6, // 6x Y for dramatic but manageable elevation (unchanged)
                        curvePoints[i + 2] * 8  // Scale up Z by 8x (doubled from 4x)
                    ));
                }
                
                // Apply elevation smoothing to prevent overly steep sections
                pathPoints = [];
                for (let i = 0; i < rawPoints.length; i++) {
                    var point = rawPoints[i].clone();
                    
                    // Smooth elevation using weighted average with neighbors
                    if (i > 0 && i < rawPoints.length - 1) {
                        var prevY = rawPoints[i - 1].y;
                        var currentY = rawPoints[i].y;
                        var nextY = rawPoints[i + 1].y;
                        
                        // Calculate maximum allowed slope (in meters per horizontal unit)
                        var maxSlope = 0.3; // 30% grade maximum
                        var prevDist = rawPoints[i].distanceTo(rawPoints[i - 1]);
                        var nextDist = rawPoints[i].distanceTo(rawPoints[i + 1]);
                        
                        // Limit elevation change based on horizontal distance
                        var maxPrevChange = prevDist * maxSlope;
                        var maxNextChange = nextDist * maxSlope;
                        
                        // Clamp elevation changes
                        if (Math.abs(currentY - prevY) > maxPrevChange) {
                            currentY = prevY + Math.sign(currentY - prevY) * maxPrevChange;
                        }
                        if (Math.abs(nextY - currentY) > maxNextChange) {
                            currentY = nextY - Math.sign(nextY - currentY) * maxNextChange;
                        }
                        
                        // Apply additional smoothing (weighted average)
                        point.y = currentY * 0.6 + (prevY + nextY) * 0.2;
                    }
                    
                    pathPoints.push(point);
                }

                // Create smooth racing path using CatmullRom curve
                racingPath = new THREE.CatmullRomCurve3(pathPoints, true); // true = closed loop

                // Generate dense waypoints for bot navigation
                createDenseWaypoints();

                // Create visual road mesh
                createRoadMesh();
                
                // Create path markers for debugging/visualization (HIDDEN)
                // createPathMarkers();
                
                // Create checkpoint system (HIDDEN VISUALS, DATA ONLY)
                createCheckpointData();
                
                console.log('Racing path created with', pathPoints.length, 'control points and', denseWaypoints.length, 'dense waypoints');
            }

            function createDenseWaypoints() {
                denseWaypoints = [];
                
                // Calculate total path length
                var pathLength = racingPath.getLength();
                var waypointSpacing = 2.0; // 2 meters between waypoints
                var numWaypoints = Math.floor(pathLength / waypointSpacing);
                
                console.log('Creating', numWaypoints, 'waypoints with', waypointSpacing, 'm spacing along', pathLength.toFixed(1), 'm track');
                
                // Generate waypoints at regular intervals
                for (var i = 0; i < numWaypoints; i++) {
                    var t = i / numWaypoints; // Parameter from 0 to 1
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    denseWaypoints.push({
                        position: point,
                        direction: tangent,
                        index: i,
                        t: t
                    });
                }
                
                // Add visual markers for waypoints (every 10th waypoint to avoid clutter) - HIDDEN
                /*
                for (var i = 0; i < denseWaypoints.length; i += 10) {
                    var waypoint = denseWaypoints[i];
                    var markerGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                    var markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff // Cyan for waypoints
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(waypoint.position);
                    marker.position.y = 1; // Above ground
                    scene.add(marker);
                }
                */
                
                // Debug first few waypoints
                console.log('First 5 waypoints:');
                for (var i = 0; i < Math.min(5, denseWaypoints.length); i++) {
                    var wp = denseWaypoints[i];
                    console.log('Waypoint', i + ':', 
                        '(' + wp.position.x.toFixed(1) + ', ' + wp.position.z.toFixed(1) + ')',
                        'direction:', '(' + wp.direction.x.toFixed(2) + ', ' + wp.direction.z.toFixed(2) + ')'
                    );
                }
            }

            function createRoadMesh() {
                var roadWidth = 14; // 14 meter wide road as requested
                var borderWidth = 0.4; // 40cm white borders on each side
                var totalWidth = roadWidth + (borderWidth * 2); // Road + borders
                // Adjust road complexity based on platform
                const isQuest = renderer.xr.isPresenting || navigator.userAgent.includes('Quest');
                var segments = isQuest ? 200 : 800; // Lower resolution for Quest performance
                
                // Get points along the curve
                var pathPoints = [];
                var pathDirections = [];
                
                for (var i = 0; i <= segments; i++) {
                    var t = i / segments;
                    var point = racingPath.getPoint(t);
                    var tangent = racingPath.getTangent(t);
                    
                    pathPoints.push(point);
                    pathDirections.push(tangent);
                }
                
                // Create road geometry as a flat surface
                var roadGeometry = new THREE.BufferGeometry();
                var vertices = [];
                var indices = [];
                var uvs = [];
                
                // Generate vertices for road surface with corner smoothing
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    
                    // Apply aggressive direction smoothing with wider window
                    var smoothDirection = direction.clone();
                    if (i > 1 && i < pathPoints.length - 2) {
                        var prevDir2 = pathDirections[i - 2];
                        var prevDir1 = pathDirections[i - 1];
                        var nextDir1 = pathDirections[i + 1];
                        var nextDir2 = pathDirections[i + 2];
                        
                        // 5-point weighted average for ultra-smooth transitions
                        smoothDirection = prevDir2.clone().multiplyScalar(0.1)
                            .add(prevDir1.clone().multiplyScalar(0.2))
                            .add(direction.clone().multiplyScalar(0.4))
                            .add(nextDir1.clone().multiplyScalar(0.2))
                            .add(nextDir2.clone().multiplyScalar(0.1));
                        smoothDirection.normalize();
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point average for edge cases
                        var prevDir = pathDirections[i - 1];
                        var nextDir = pathDirections[i + 1];
                        smoothDirection.add(prevDir).add(nextDir).divideScalar(3);
                        smoothDirection.normalize();
                    }
                    
                    // Calculate perpendicular vector (road width direction)
                    var perpendicular = new THREE.Vector3(-smoothDirection.z, 0, smoothDirection.x).normalize();
                    
                    // Create points for road with borders
                    var halfTotalWidth = totalWidth / 2;
                    var halfRoadWidth = roadWidth / 2;
                    
                    // Outer edges (including borders)
                    var leftBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(halfTotalWidth));
                    var leftBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(halfRoadWidth));
                    var rightBorderInner = point.clone().add(perpendicular.clone().multiplyScalar(-halfRoadWidth));
                    var rightBorderOuter = point.clone().add(perpendicular.clone().multiplyScalar(-halfTotalWidth));
                    
                    // Apply aggressive elevation smoothing to eliminate bumps
                    var smoothY = point.y;
                    if (i > 2 && i < pathPoints.length - 3) {
                        // 7-point smoothing for ultra-smooth elevation transitions
                        var y_m3 = pathPoints[i - 3].y;
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        var y_p3 = pathPoints[i + 3].y;
                        
                        // Gaussian-like weighted average for maximum smoothness
                        smoothY = y_m3 * 0.05 + y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.3 + y_p1 * 0.2 + y_p2 * 0.1 + y_p3 * 0.05;
                    } else if (i > 1 && i < pathPoints.length - 2) {
                        // 5-point smoothing for edge areas
                        var y_m2 = pathPoints[i - 2].y;
                        var y_m1 = pathPoints[i - 1].y;
                        var y_0 = point.y;
                        var y_p1 = pathPoints[i + 1].y;
                        var y_p2 = pathPoints[i + 2].y;
                        
                        smoothY = y_m2 * 0.1 + y_m1 * 0.2 + y_0 * 0.4 + y_p1 * 0.2 + y_p2 * 0.1;
                    } else if (i > 0 && i < pathPoints.length - 1) {
                        // 3-point smoothing for corners
                        var prevY = pathPoints[i - 1].y;
                        var nextY = pathPoints[i + 1].y;
                        smoothY = prevY * 0.25 + point.y * 0.5 + nextY * 0.25;
                    }
                    
                    var roadThickness = 0.2; // 20cm thickness
                    
                    // Add TOP vertices (from left to right: outer border, inner border, inner border, outer border)
                    vertices.push(leftBorderOuter.x, smoothY + 0.05, leftBorderOuter.z);   // Left border outer
                    vertices.push(leftBorderInner.x, smoothY + 0.05, leftBorderInner.z);   // Left border inner (road edge)
                    vertices.push(rightBorderInner.x, smoothY + 0.05, rightBorderInner.z); // Right border inner (road edge)
                    vertices.push(rightBorderOuter.x, smoothY + 0.05, rightBorderOuter.z); // Right border outer
                    
                    // Add BOTTOM vertices (same order) - 20cm below top
                    vertices.push(leftBorderOuter.x, smoothY + 0.05 - roadThickness, leftBorderOuter.z);
                    vertices.push(leftBorderInner.x, smoothY + 0.05 - roadThickness, leftBorderInner.z);
                    vertices.push(rightBorderInner.x, smoothY + 0.05 - roadThickness, rightBorderInner.z);
                    vertices.push(rightBorderOuter.x, smoothY + 0.05 - roadThickness, rightBorderOuter.z);
                    
                    // Add UV coordinates for all 8 vertices per segment
                    // Top vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                    // Bottom vertices
                    uvs.push(0, i / (pathPoints.length - 1));    // Left border outer
                    uvs.push(0.2, i / (pathPoints.length - 1));  // Left border inner
                    uvs.push(0.8, i / (pathPoints.length - 1));  // Right border inner
                    uvs.push(1, i / (pathPoints.length - 1));    // Right border outer
                }
                
                // Create triangular faces for thick road with borders
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 8; // 8 vertices per segment now
                    
                    // TOP SURFACE - Left Border (2 triangles)
                    indices.push(base, base + 1, base + 8);      // Triangle 1
                    indices.push(base + 1, base + 9, base + 8);  // Triangle 2
                    
                    // TOP SURFACE - Main Road (2 triangles)
                    indices.push(base + 1, base + 2, base + 9);   // Triangle 1
                    indices.push(base + 2, base + 10, base + 9);  // Triangle 2
                    
                    // TOP SURFACE - Right Border (2 triangles)
                    indices.push(base + 2, base + 3, base + 10);  // Triangle 1
                    indices.push(base + 3, base + 11, base + 10); // Triangle 2
                    
                    // BOTTOM SURFACE - Left Border (2 triangles)
                    indices.push(base + 4, base + 12, base + 5);  // Triangle 1
                    indices.push(base + 5, base + 12, base + 13); // Triangle 2
                    
                    // BOTTOM SURFACE - Main Road (2 triangles)
                    indices.push(base + 5, base + 13, base + 6);  // Triangle 1
                    indices.push(base + 6, base + 13, base + 14); // Triangle 2
                    
                    // BOTTOM SURFACE - Right Border (2 triangles)
                    indices.push(base + 6, base + 14, base + 7);  // Triangle 1
                    indices.push(base + 7, base + 14, base + 15); // Triangle 2
                    
                    // SIDE FACES
                    // Left outer edge
                    indices.push(base, base + 8, base + 4);       // Triangle 1
                    indices.push(base + 8, base + 12, base + 4);  // Triangle 2
                    
                    // Right outer edge
                    indices.push(base + 3, base + 7, base + 11);  // Triangle 1
                    indices.push(base + 7, base + 15, base + 11); // Triangle 2
                }
                
                // Set geometry attributes
                roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                roadGeometry.setIndex(indices);
                roadGeometry.computeVertexNormals();
                
                // Create texture for road with white borders
                var canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 1;
                var ctx = canvas.getContext('2d');
                
                // Create gradient: white borders, gray road
                var gradient = ctx.createLinearGradient(0, 0, 256, 0);
                gradient.addColorStop(0, '#ffffff');    // Left border - white
                gradient.addColorStop(0.2, '#ffffff');  // Left border - white
                gradient.addColorStop(0.2, '#333333');  // Road start - gray
                gradient.addColorStop(0.8, '#333333');  // Road end - gray
                gradient.addColorStop(0.8, '#ffffff');  // Right border - white
                gradient.addColorStop(1, '#ffffff');    // Right border - white
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 256, 1);
                
                var roadTexture = new THREE.CanvasTexture(canvas);
                roadTexture.wrapS = THREE.ClampToEdgeWrapping;
                roadTexture.wrapT = THREE.RepeatWrapping;
                
                // Create road material with border texture
                var roadMaterial = new THREE.MeshLambertMaterial({ 
                    map: roadTexture,
                    side: THREE.DoubleSide,
                    transparent: false,
                    wireframe: false
                });
                
                // Create road mesh and add to scene
                roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                scene.add(roadMesh);
                
                // Create physics collision for the road surface
                createRoadPhysics(roadGeometry);
                
                console.log('🛣️ Ultra-smooth road mesh created with', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles, and', segments, 'segments');
                console.log('Road width:', roadWidth + 'm, Road segments:', segments);
                
                // Create center line as a thin strip
                var centerLineGeometry = new THREE.BufferGeometry();
                var centerVertices = [];
                var centerIndices = [];
                var centerUvs = [];
                
                var lineWidth = 0.3; // 30cm wide center line
                
                for (var i = 0; i < pathPoints.length; i++) {
                    var point = pathPoints[i];
                    var direction = pathDirections[i];
                    var perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                    
                    var leftPoint = point.clone().add(perpendicular.clone().multiplyScalar(lineWidth / 2));
                    var rightPoint = point.clone().add(perpendicular.clone().multiplyScalar(-lineWidth / 2));
                    
                    centerVertices.push(leftPoint.x, leftPoint.y + 0.02, leftPoint.z);
                    centerVertices.push(rightPoint.x, rightPoint.y + 0.02, rightPoint.z);
                    
                    centerUvs.push(0, i / (pathPoints.length - 1));
                    centerUvs.push(1, i / (pathPoints.length - 1));
                }
                
                for (var i = 0; i < pathPoints.length - 1; i++) {
                    var base = i * 2;
                    centerIndices.push(base, base + 1, base + 2);
                    centerIndices.push(base + 1, base + 3, base + 2);
                }
                
                centerLineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(centerVertices, 3));
                centerLineGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(centerUvs, 2));
                centerLineGeometry.setIndex(centerIndices);
                centerLineGeometry.computeVertexNormals();
                
                var centerLineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    side: THREE.DoubleSide
                });
                var centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
                scene.add(centerLine);
                
                console.log('Created flat road surface with', roadWidth + 'm width');
                
                // DEBUG: Create a simple test rectangle to verify road positioning
                var testGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                var testMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                var testPlane = new THREE.Mesh(testGeometry, testMaterial);
                testPlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
                testPlane.position.set(0, 0.1, 0); // Position at origin, slightly above ground
                scene.add(testPlane);
                console.log('Added red test plane for road visibility debugging');
            }
            
            // CREATE ROAD PHYSICS: Add collision mesh for elevated road surface
            function createRoadPhysics(roadGeometry) {
                // Get vertices and indices from the road geometry
                var vertices = roadGeometry.attributes.position.array;
                var indices = roadGeometry.index.array;
                
                // Create Ammo triangle mesh
                var mesh = new Ammo.btTriangleMesh(true, true);
                
                // Add triangles to the mesh
                for (var i = 0; i < indices.length; i += 3) {
                    var i1 = indices[i] * 3;
                    var i2 = indices[i + 1] * 3;
                    var i3 = indices[i + 2] * 3;
                    
                    var v1 = new Ammo.btVector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                    var v2 = new Ammo.btVector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                    var v3 = new Ammo.btVector3(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                    
                    mesh.addTriangle(v1, v2, v3, false);
                    
                    // Clean up vectors
                    Ammo.destroy(v1);
                    Ammo.destroy(v2);
                    Ammo.destroy(v3);
                }
                
                // Create collision shape from triangle mesh
                var roadShape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
                
                // Create rigid body (static, mass = 0)
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(0, 0, 0));
                
                var motionState = new Ammo.btDefaultMotionState(transform);
                var localInertia = new Ammo.btVector3(0, 0, 0);
                
                var rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, roadShape, localInertia);
                var roadBody = new Ammo.btRigidBody(rbInfo);
                
                // Set friction for good driving feel
                roadBody.setFriction(0.8);
                roadBody.setRestitution(0.1);
                
                // Store globally for obstacle detection filtering
                roadPhysicsBody = roadBody;
                
                // Add to physics world
                physicsWorld.addRigidBody(roadBody);
                
                console.log('Road physics collision mesh created with', indices.length / 3, 'triangles');
            }

            function createPathMarkers() {
                // Create visual markers at each control point
                for (var i = 0; i < pathPoints.length; i++) {
                    var markerGeometry = new THREE.SphereGeometry(2, 8, 8);
                    var markerMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xff0000 // Green for start, red for others
                    });
                    var marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(pathPoints[i]);
                    marker.position.y = pathPoints[i].y + 3; // Above road surface
                    scene.add(marker);
                }
            }
            
            function createCheckpoints() {
                // Create checkpoint markers at each path point
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    // Create checkpoint ring/gate
                    var ringGeometry = new THREE.RingGeometry(8, 12, 16);
                    var ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    var ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Position at path point
                    ring.position.copy(pathPoints[i]);
                    ring.position.y += 5; // Above the road
                    
                    // Rotate to face along the path
                    if (i < pathPoints.length - 2) {
                        var direction = new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]);
                        ring.lookAt(ring.position.clone().add(direction));
                    }
                    
                    // Add checkpoint number
                    var numberGeometry = new THREE.SphereGeometry(3, 8, 8);
                    var numberMaterial = new THREE.MeshBasicMaterial({
                        color: i === 0 ? 0x00ff00 : 0xffffff
                    });
                    var numberSphere = new THREE.Mesh(numberGeometry, numberMaterial);
                    numberSphere.position.copy(ring.position);
                    numberSphere.position.y += 2;
                    
                    scene.add(ring);
                    scene.add(numberSphere);
                    
                    checkpointMarkers.push({
                        ring: ring,
                        sphere: numberSphere,
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Create next checkpoint indicator
                updateNextCheckpointMarker();
                
                console.log('Created', checkpointMarkers.length, 'checkpoints');
            }
            
            function createCheckpointData() {
                // Create checkpoint data without visual elements
                checkpointMarkers = [];
                
                for (var i = 0; i < pathPoints.length - 1; i++) { // -1 because last point is same as first
                    checkpointMarkers.push({
                        position: pathPoints[i].clone(),
                        index: i
                    });
                }
                
                // Initialize the next checkpoint marker (yellow pulsing sphere)
                updateNextCheckpointMarker();
                
                // Log checkpoint elevations for debugging
                console.log('Created', checkpointMarkers.length, 'checkpoint data points with next checkpoint marker');
                if (checkpointMarkers.length > 0) {
                    var minY = Math.min(...checkpointMarkers.map(cp => cp.position.y));
                    var maxY = Math.max(...checkpointMarkers.map(cp => cp.position.y));
                    console.log('🏔️ Track elevation range: Min:', minY.toFixed(1) + 'm, Max:', maxY.toFixed(1) + 'm, Difference:', (maxY - minY).toFixed(1) + 'm');
                }
            }
            
            function updateNextCheckpointMarker() {
                // Remove old marker
                if (nextCheckpointMarker) {
                    scene.remove(nextCheckpointMarker);
                }
                
                // Create glowing marker for next checkpoint
                var nextIndex = playerCurrentCheckpoint % checkpointMarkers.length;
                var checkpoint = checkpointMarkers[nextIndex];
                
                if (checkpoint && checkpoint.position) {
                    var glowGeometry = new THREE.SphereGeometry(4, 16, 16);
                    var glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    });
                    nextCheckpointMarker = new THREE.Mesh(glowGeometry, glowMaterial);
                    nextCheckpointMarker.position.copy(checkpoint.position);
                    // Position marker relative to track elevation at this point
                    var trackElevation = checkpoint.position.y;
                    nextCheckpointMarker.position.y = trackElevation + 8; // 8m above track for visibility
                    
                    scene.add(nextCheckpointMarker);
                    
                    // Make it pulse
                    nextCheckpointMarker.userData = { pulseTime: 0 };
                    
                    console.log('📍 Next checkpoint marker updated at:', checkpoint.position);
                }
            }

            // ROAD SURFACE UTILITIES: Get actual road elevation at any point
            function getRoadSurfaceElevation(x, z) {
                if (!racingPath) {
                    console.warn('⚠️ No racing path available for elevation detection');
                    return 0;
                }
                
                // Find the closest point on the racing path with higher resolution
                var closestT = 0;
                var minDistance = Infinity;
                var samples = 200; // Increased samples for better accuracy
                
                for (var i = 0; i <= samples; i++) {
                    var t = i / samples;
                    var pathPoint = racingPath.getPoint(t);
                    var distance = Math.sqrt(Math.pow(pathPoint.x - x, 2) + Math.pow(pathPoint.z - z, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestT = t;
                    }
                }
                
                // Get the elevation at this point and apply the same smoothing used in road mesh
                var pathPoint = racingPath.getPoint(closestT);
                
                // Apply the same elevation smoothing algorithm used in createRoadMesh
                var segments = 800; // Same as road mesh
                var segmentIndex = Math.floor(closestT * segments);
                
                // Get neighboring points for smoothing (same as road mesh algorithm)
                var smoothY = pathPoint.y;
                if (segmentIndex > 2 && segmentIndex < segments - 3) {
                    // Sample points around this segment
                    var points = [];
                    for (var i = -3; i <= 3; i++) {
                        var sampleT = Math.max(0, Math.min(1, (segmentIndex + i) / segments));
                        points.push(racingPath.getPoint(sampleT));
                    }
                    
                    // Apply 7-point Gaussian smoothing (same as road mesh)
                    smoothY = points[0].y * 0.05 + points[1].y * 0.1 + points[2].y * 0.2 + 
                             points[3].y * 0.3 + points[4].y * 0.2 + points[5].y * 0.1 + points[6].y * 0.05;
                }
                
                // Add safety margin - if the calculated elevation seems too low, use the original path point
                var originalY = pathPoint.y;
                var finalY = Math.max(smoothY, originalY - 5); // Don't go more than 5m below original
                
                console.log('🛣️ Elevation at (' + x.toFixed(1) + ',' + z.toFixed(1) + '): original=' + originalY.toFixed(1) + ', smoothed=' + smoothY.toFixed(1) + ', final=' + finalY.toFixed(1));
                
                return finalY;
            }

            // Bot pathfinding utilities
            function getPathPosition(t) {
                // Get position along path (t = 0 to 1)
                return racingPath.getPoint(t);
            }

            function getPathDirection(t) {
                // Get direction vector at position t
                return racingPath.getTangent(t);
            }

            function findNearestPathPoint(position) {
                // Find closest point on path to given position
                var closestT = 0;
                var closestDistance = Infinity;
                
                // Sample path at regular intervals
                for (var t = 0; t <= 1; t += 0.01) {
                    var pathPoint = racingPath.getPoint(t);
                    var distance = position.distanceTo(pathPoint);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestT = t;
                    }
                }
                
                return {
                    t: closestT,
                    point: racingPath.getPoint(closestT),
                    distance: closestDistance,
                    direction: racingPath.getTangent(closestT)
                };
            }

            function createBasicGround() {
                console.log('🌍 Creating basic ground (always works)...');
                
                // Create basic ground box - this always works (doubled for larger track)
                createBox(new THREE.Vector3(0, -0.75, 0), ZERO_QUATERNION, 600, 1, 600, 0, 2);
                
                console.log('✅ Basic ground created with physics');
            }

            function loadGroundModel() {
                console.log('🌍 Loading ground model from assets/ground/...');
                
                // Try different possible filenames
                const possibleFiles = [
                    'assets/ground/forest_ground_04_8k.gltf',
                    'assets/ground/scene.gltf',
                    'assets/ground/model.gltf',
                    'assets/ground/terrain.gltf'
                ];
                
                let currentFileIndex = 0;
                
                function tryLoadFile() {
                    if (currentFileIndex >= possibleFiles.length) {
                        console.log('❌ No GLTF files found, trying textured plane approach...');
                        createTexturedGround();
                        return;
                    }
                    
                    const filename = possibleFiles[currentFileIndex];
                    console.log(`🔍 Trying to load: ${filename}`);
                    
                    const loader = new THREE.GLTFLoader();
                    loader.load(
                        filename,
                        function(gltf) {
                            console.log(`✅ Ground GLTF loaded successfully: ${filename}`);
                            
                            const groundModel = gltf.scene;
                            
                            // Debug: Log model info
                            console.log('📊 GLTF Model info:', {
                                children: groundModel.children.length,
                                position: groundModel.position,
                                scale: groundModel.scale,
                                boundingBox: new THREE.Box3().setFromObject(groundModel)
                            });
                            
                            // Position and scale the ground model
                            groundModel.position.set(0, -0.73, 0); // Slightly above basic ground
                            
                            // Try different scales to make it visible
                            const scale = 50; // Make it much larger
                            groundModel.scale.set(scale, scale, scale);
                            
                            // Ensure all materials are visible
                            groundModel.traverse(function(child) {
                                if (child.isMesh) {
                                    console.log('🎨 Found mesh:', child.name, 'Material:', child.material?.name || 'unnamed');
                                    if (child.material) {
                                        child.material.side = THREE.DoubleSide; // Visible from both sides
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                }
                            });
                            
                            // Add to scene (basic ground already exists, this enhances it)
                            scene.add(groundModel);
                            
                            console.log(`🌍 Enhanced GLTF ground model added at scale ${scale}x`);
                        },
                        function(progress) {
                            console.log(`📥 Loading ${filename}:`, Math.round((progress.loaded / progress.total) * 100) + '%');
                        },
                        function(error) {
                            console.log(`❌ Failed to load ${filename}, trying next...`);
                            currentFileIndex++;
                            tryLoadFile();
                        }
                    );
                }
                
                tryLoadFile();
            }
            
            function createTexturedGround() {
                console.log('🌍 Creating simple ground plane for VR performance...');
                
                // Check if running on Quest (standalone VR)
                const isQuest = renderer.xr.isPresenting || navigator.userAgent.includes('Quest');
                
                if (isQuest) {
                    // QUEST OPTIMIZATION: Simple low-poly ground
                    console.log('📱 Quest detected - using simple ground for performance');
                    const groundGeometry = new THREE.PlaneGeometry(600, 600, 4, 4); // Very low poly
                    const groundMaterial = new THREE.MeshLambertMaterial({
                        color: 0x4a5d23, // Forest green-brown color
                        fog: true
                    });
                    
                    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                    groundMesh.rotation.x = -Math.PI / 2;
                    groundMesh.position.set(0, -0.75, 0);
                    groundMesh.receiveShadow = false; // Disable shadows for performance
                    scene.add(groundMesh);
                } else {
                    // DESKTOP: Full quality ground
                    console.log('🖥️ Desktop detected - using full quality ground');
                    const groundGeometry = new THREE.PlaneGeometry(600, 600, 128, 128);
                    const groundMaterial = new THREE.MeshLambertMaterial({
                        color: 0x4a5d23, // Forest green-brown color
                    });
                    
                    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                    groundMesh.rotation.x = -Math.PI / 2;
                    groundMesh.position.set(0, -0.75, 0);
                    groundMesh.receiveShadow = true;
                    scene.add(groundMesh);
                    
                    // Only load complex textures on desktop
                    tryLoadForestTextures(groundMesh);
                }
                
                // Create physics collision box (same for both)
                const groundPhysics = new Ammo.btBoxShape(new Ammo.btVector3(300, 0.5, 300));
                const groundTransform = new Ammo.btTransform();
                groundTransform.setIdentity();
                groundTransform.setOrigin(new Ammo.btVector3(0, -0.75, 0));
                
                const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
                const groundRigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundPhysics, new Ammo.btVector3(0, 0, 0));
                const groundRigidBody = new Ammo.btRigidBody(groundRigidBodyInfo);
                groundRigidBody.setFriction(2);
                physicsWorld.addRigidBody(groundRigidBody);
                
                console.log('✅ Ground plane created with physics');
            }
            
            function tryLoadForestTextures(groundMesh) {
                const textureLoader = new THREE.TextureLoader();
                
                // Try different possible paths for your textures
                const possiblePaths = [
                    'assets/ground/textures/',
                    ''
                ];
                
                const textureNames = [
                    'forest_ground_04_diff_8k.jpg',
                    'forest_ground_04_nor_gl_8k.jpg', 
                    'forest_ground_04_rough_8k.jpg'
                ];
                
                let currentPathIndex = 0;
                
                function tryPath() {
                    if (currentPathIndex >= possiblePaths.length) {
                        console.log('ℹ️ No forest textures found at any path, keeping solid color ground');
                        return;
                    }
                    
                    const basePath = possiblePaths[currentPathIndex];
                    console.log(`🔍 Trying texture path: ${basePath}`);
                    
                    // Try to load diffuse texture from current path
                    textureLoader.load(
                        basePath + textureNames[0],
                        function(diffuseTexture) {
                            console.log(`✅ Found textures at: ${basePath}`);
                            loadAllTexturesFromPath(basePath, groundMesh);
                        },
                        undefined,
                        function(error) {
                            console.log(`❌ No textures at: ${basePath}`);
                            currentPathIndex++;
                            tryPath();
                        }
                    );
                }
                
                tryPath();
            }
            
            function loadAllTexturesFromPath(basePath, groundMesh) {
                const textureLoader = new THREE.TextureLoader();
                
                console.log(`🌲 Loading all forest textures from: ${basePath}`);
                
                const diffuseTexture = textureLoader.load(basePath + 'forest_ground_04_diff_8k.jpg');
                const normalTexture = textureLoader.load(basePath + 'forest_ground_04_nor_gl_8k.jpg');
                const roughnessTexture = textureLoader.load(basePath + 'forest_ground_04_rough_8k.jpg');
                
                // Use the normal map as displacement for height variation
                const displacementTexture = textureLoader.load(basePath + 'forest_ground_04_nor_gl_8k.jpg');
                
                // Configure texture tiling with aggressive pattern breaking
                diffuseTexture.wrapS = THREE.RepeatWrapping;
                diffuseTexture.wrapT = THREE.RepeatWrapping;
                diffuseTexture.repeat.set(32, 32);
                diffuseTexture.offset.set(0.1, 0.15); // Offset to break alignment
                
                normalTexture.wrapS = THREE.RepeatWrapping;
                normalTexture.wrapT = THREE.RepeatWrapping;
                normalTexture.repeat.set(29.3, 34.7); // Much more different scaling
                normalTexture.offset.set(0.3, 0.7); // Different offset
                normalTexture.rotation = 0.05; // Small rotation
                
                roughnessTexture.wrapS = THREE.RepeatWrapping;
                roughnessTexture.wrapT = THREE.RepeatWrapping;
                roughnessTexture.repeat.set(35.1, 28.9); // Very different scaling
                roughnessTexture.offset.set(0.6, 0.2); // Different offset
                roughnessTexture.rotation = -0.03; // Opposite rotation
                
                displacementTexture.wrapS = THREE.RepeatWrapping;
                displacementTexture.wrapT = THREE.RepeatWrapping;
                displacementTexture.repeat.set(27.8, 36.4); // Significantly different
                displacementTexture.offset.set(0.8, 0.4); // Different offset
                displacementTexture.rotation = 0.08; // Larger rotation
                
                // Create enhanced PBR material with displacement
                const enhancedMaterial = new THREE.MeshStandardMaterial({
                    map: diffuseTexture,
                    normalMap: normalTexture,
                    roughnessMap: roughnessTexture,
                    displacementMap: displacementTexture,
                    displacementScale: 0.5, // Moderate depth (halved again from 1.0)
                    roughness: 0.8,
                    metalness: 0.0
                });
                
                // Update the ground mesh material
                groundMesh.material = enhancedMaterial;
                console.log('🌲 Ground enhanced with forest PBR textures!');
                
                // Add billboard trees for background atmosphere (desktop only)
                const isQuest = renderer.xr.isPresenting || navigator.userAgent.includes('Quest');
                if (!isQuest) {
                    createBillboardTrees();
                } else {
                    console.log('📱 Skipping billboard trees on Quest for performance');
                }
            }
            
            function createBillboardTrees() {
                console.log('🌲 Creating billboard trees for background...');
                
                // Load real tree sprite textures
                const treeTextures = loadTreeSprites();
                
                // Generate dense forest around the track
                const treePositions = [];
                
                // Dense forest layers - multiple rings around the track (doubled for larger track)
                const forestRings = [
                    {minRadius: 140, maxRadius: 170, density: 8}, // Inner forest ring (doubled)
                    {minRadius: 170, maxRadius: 220, density: 12}, // Middle forest ring (doubled)
                    {minRadius: 220, maxRadius: 280, density: 16}, // Outer forest ring (doubled)
                    {minRadius: 280, maxRadius: 340, density: 20} // Far background forest (doubled)
                ];
                
                forestRings.forEach(ring => {
                    for (let i = 0; i < ring.density; i++) {
                        const angle = (i / ring.density) * Math.PI * 2;
                        const radius = ring.minRadius + Math.random() * (ring.maxRadius - ring.minRadius);
                        
                        // Add some randomness to break perfect circles
                        const angleOffset = (Math.random() - 0.5) * 0.3;
                        const radiusOffset = (Math.random() - 0.5) * 10;
                        
                        const x = Math.cos(angle + angleOffset) * (radius + radiusOffset);
                        const z = Math.sin(angle + angleOffset) * (radius + radiusOffset);
                        
                        // Scale trees based on distance (perspective) - updated for larger track
                        const distanceScale = 0.7 + (radius / 340) * 0.8; // Far trees slightly smaller (doubled max radius)
                        const randomScale = 0.8 + Math.random() * 0.6; // Random size variation
                        
                        treePositions.push({
                            x: x,
                            z: z,
                            scale: distanceScale * randomScale,
                            type: Math.floor(Math.random() * 5) // 5 tree types now
                        });
                    }
                });
                
                // Add some scattered trees in gaps (doubled for larger track)
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 120 + Math.random() * 240; // Doubled from 60 + 120
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // Make sure not too close to track center (doubled)
                    if (Math.sqrt(x*x + z*z) > 110) { // Doubled from 55
                        treePositions.push({
                            x: x,
                            z: z,
                            scale: 0.6 + Math.random() * 0.8,
                            type: Math.floor(Math.random() * 5)
                        });
                    }
                }
                
                // Create billboard trees once textures are loaded
                treeTextures.then(textures => {
                    const treeBillboards = []; // Store references for manual billboard updates
                    
                    treePositions.forEach(pos => {
                        // Use PlaneGeometry instead of Sprite for manual billboard control
                        const treeGeometry = new THREE.PlaneGeometry(12 * pos.scale, 16 * pos.scale);
                        const treeMaterial = new THREE.MeshBasicMaterial({
                            map: textures[pos.type % textures.length],
                            transparent: true,
                            alphaTest: 0.1,
                            side: THREE.DoubleSide
                        });
                        
                        const treeMesh = new THREE.Mesh(treeGeometry, treeMaterial);
                        treeMesh.position.set(pos.x, 8 * pos.scale, pos.z);
                        
                        // Store reference for manual billboard updates
                        treeBillboards.push(treeMesh);
                        scene.add(treeMesh);
                    });
                    
                    // Store billboard references globally for updates
                    window.treeBillboards = treeBillboards;
                    
                    console.log(`✅ Created ${treePositions.length} billboard trees with real sprites`);
                }).catch(error => {
                    console.log('❌ Failed to load tree sprites, falling back to procedural trees');
                    // Fallback to procedural trees with manual billboard control
                    const proceduralTextures = createProceduralTreeTextures();
                    const treeBillboards = [];
                    
                    treePositions.forEach(pos => {
                        const treeGeometry = new THREE.PlaneGeometry(12 * pos.scale, 16 * pos.scale);
                        const treeMaterial = new THREE.MeshBasicMaterial({
                            map: proceduralTextures[pos.type % proceduralTextures.length],
                            transparent: true,
                            alphaTest: 0.1,
                            side: THREE.DoubleSide
                        });
                        
                        const treeMesh = new THREE.Mesh(treeGeometry, treeMaterial);
                        treeMesh.position.set(pos.x, 8 * pos.scale, pos.z);
                        
                        treeBillboards.push(treeMesh);
                        scene.add(treeMesh);
                    });
                    
                    // Store billboard references globally for updates
                    window.treeBillboards = treeBillboards;
                    console.log(`✅ Created ${treePositions.length} billboard trees with procedural fallback`);
                });
            }
            
            function checkVehicleCollisions(dt) {
                // Arcade-style vehicle collision detection and response
                if (!physicsWorld) return;
                
                // Only run collision detection in multiplayer or when bot is present
                if (!isMultiplayer && !botEnabled) return;
                
                // Get all vehicles that could collide
                const vehicles = [];
                
                // Add player vehicle (check if vehicleRef exists first)
                if (typeof vehicleRef !== 'undefined' && vehicleRef && vehicleRef.vehicleBody) {
                    vehicles.push({
                        body: vehicleRef.vehicleBody,
                        vehicle: vehicleRef.vehicle,
                        type: 'player',
                        mesh: vehicleRef.chassisMesh
                    });
                }
                
                // Add bot vehicle (check if botRef exists first)
                if (typeof botRef !== 'undefined' && botRef && botRef.chassisBody) {
                    vehicles.push({
                        body: botRef.chassisBody,
                        vehicle: botRef.vehicle,
                        type: 'bot',
                        mesh: botRef.chassisMesh
                    });
                }
                
                // Add remote player vehicles
                if (remotePlayerCars) {
                    remotePlayerCars.forEach((remoteCar, index) => {
                        if (remoteCar && remoteCar.rigidBody && remoteCar.inPhysicsWorld) {
                            vehicles.push({
                                body: remoteCar.rigidBody,
                                vehicle: null, // Remote cars don't have vehicle objects
                                type: 'remote',
                                mesh: remoteCar.mesh,
                                index: index
                            });
                        }
                    });
                }
                
                // Check collisions between all vehicles
                for (let i = 0; i < vehicles.length; i++) {
                    for (let j = i + 1; j < vehicles.length; j++) {
                        checkVehiclePairCollision(vehicles[i], vehicles[j], dt);
                    }
                }
            }
            
            function checkVehiclePairCollision(vehicle1, vehicle2, dt) {
                // Check if two vehicles are colliding using Bullet physics
                const numManifolds = physicsWorld.getDispatcher().getNumManifolds();
                
                for (let i = 0; i < numManifolds; i++) {
                    const contactManifold = physicsWorld.getDispatcher().getManifoldByIndexInternal(i);
                    const body0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
                    const body1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);
                    
                    // Check if this manifold involves our two vehicles
                    const isCollision = (body0 === vehicle1.body && body1 === vehicle2.body) ||
                                       (body0 === vehicle2.body && body1 === vehicle1.body);
                    
                    if (isCollision && contactManifold.getNumContacts() > 0) {
                        // Get collision details
                        const contactPoint = contactManifold.getContactPoint(0);
                        const impulse = contactPoint.getAppliedImpulse();
                        
                        // Only process significant collisions (raised threshold to reduce false positives)
                        if (impulse > 150) { // Higher threshold for meaningful collision
                            applyArcadeCollisionResponse(vehicle1, vehicle2, contactPoint, impulse, dt);
                        }
                    }
                }
            }
            
            function applyArcadeCollisionResponse(vehicle1, vehicle2, contactPoint, impulse, dt) {
                // Arcade-style collision response - more controlled for stability
                const collisionForce = Math.min(impulse / 200, 5); // Reduced force scaling and cap
                
                // Get collision normal and positions
                const normal = contactPoint.get_m_normalWorldOnB();
                const pos1 = vehicle1.body.getCenterOfMassPosition();
                const pos2 = vehicle2.body.getCenterOfMassPosition();
                
                // Calculate relative velocity for more dramatic effects
                const vel1 = vehicle1.body.getLinearVelocity();
                const vel2 = vehicle2.body.getLinearVelocity();
                const relativeSpeed = Math.sqrt(
                    Math.pow(vel1.x() - vel2.x(), 2) + 
                    Math.pow(vel1.z() - vel2.z(), 2)
                );
                
                // Scale effects based on speed - more controlled response
                const speedMultiplier = Math.min(relativeSpeed / 30, 2); // Reduced multiplier and cap
                const finalForce = collisionForce * (1 + speedMultiplier * 0.5); // Reduced speed influence
                
                // Apply lateral forces to create spin-outs (reduced for stability)
                const lateralForce = new Ammo.btVector3(
                    normal.z() * finalForce * 1.2, // Reduced perpendicular force
                    0,
                    -normal.x() * finalForce * 1.2
                );
                
                const backwardForce = new Ammo.btVector3(
                    -normal.x() * finalForce * 0.8, // Reduced backward force
                    0,
                    -normal.z() * finalForce * 0.8
                );
                
                // Apply forces to both vehicles (reduced torque for stability)
                // Vehicle 1 gets pushed in collision direction
                vehicle1.body.applyCentralImpulse(backwardForce);
                vehicle1.body.applyTorqueImpulse(new Ammo.btVector3(0, lateralForce.x() * 0.3, 0)); // Reduced torque
                
                // Vehicle 2 gets pushed in opposite direction  
                const oppositeForce = new Ammo.btVector3(
                    normal.x() * finalForce * 0.8, // Reduced opposite force
                    0,
                    normal.z() * finalForce * 0.8
                );
                const oppositeLateral = new Ammo.btVector3(
                    -lateralForce.x(),
                    0,
                    -lateralForce.z()
                );
                
                vehicle2.body.applyCentralImpulse(oppositeForce);
                vehicle2.body.applyTorqueImpulse(new Ammo.btVector3(0, oppositeLateral.x() * 0.3, 0)); // Reduced torque
                
                // Add some vertical bounce for dramatic effect (reduced)
                if (finalForce > 2) {
                    const bounceForce = new Ammo.btVector3(0, finalForce * 0.15, 0); // Reduced bounce
                    vehicle1.body.applyCentralImpulse(bounceForce);
                    vehicle2.body.applyCentralImpulse(bounceForce);
                }
                
                // Play impact sound for collisions
                if (window.impactSound && finalForce > 1.5) {
                    var impactIntensity = Math.min(finalForce / 5, 1); // Normalize to 0-1
                    window.impactSound.playImpact(impactIntensity);
                }
                
                // Reduced console logging for performance
                if (finalForce > 4) { // Only log significant collisions
                    console.log(`🚗💥 Vehicle collision! Force: ${finalForce.toFixed(1)}, Speed: ${relativeSpeed.toFixed(1)} km/h`);
                }
            }
            
            function updateTreeBillboards(dt) {
                // Update tree billboards to face camera (Y-axis rotation only)
                if (window.treeBillboards && window.treeBillboards.length > 0) {
                    // Get current camera position
                    const cameraPosition = camera.position.clone();
                    
                    // Update each tree billboard
                    window.treeBillboards.forEach(treeMesh => {
                        // Calculate direction from tree to camera (horizontal only)
                        const treePosition = treeMesh.position;
                        const direction = new THREE.Vector3();
                        direction.subVectors(cameraPosition, treePosition);
                        direction.y = 0; // Remove vertical component - only horizontal rotation
                        direction.normalize();
                        
                        // Calculate Y-axis rotation to face camera
                        const angle = Math.atan2(direction.x, direction.z);
                        
                        // Apply only Y-axis rotation (yaw), keep trees upright
                        treeMesh.rotation.set(0, angle, 0);
                    });
                }
            }
            
            function loadTreeSprites() {
                return new Promise((resolve, reject) => {
                    console.log('🌲 Loading tree sprite images...');
                    
                    // Define available tree sprites (trying common naming patterns)
                    const treeSprites = [
                        'assets/tree-sprites/Tree_Pine_diff.png',
                        'assets/tree-sprites/Tree_PiceaA_diff.png',
                        'assets/tree-sprites/Tree_PiceaB_diff.png',
                        'assets/tree-sprites/Tree_PiceaC_diff.png',
                        'assets/tree-sprites/Tree_Pseudo_diff.png'
                    ];
                    
                    const textureLoader = new THREE.TextureLoader();
                    const loadedTextures = [];
                    let loadedCount = 0;
                    let hasError = false;
                    
                    if (treeSprites.length === 0) {
                        reject('No tree sprites defined');
                        return;
                    }
                    
                    treeSprites.forEach((spritePath, index) => {
                        textureLoader.load(
                            spritePath,
                            // Success callback
                            function(texture) {
                                texture.transparent = true;
                                texture.alphaTest = 0.1;
                                loadedTextures[index] = texture;
                                loadedCount++;
                                
                                console.log(`✅ Loaded tree sprite: ${spritePath}`);
                                
                                if (loadedCount === treeSprites.length) {
                                    console.log(`🌲 All ${loadedCount} tree sprites loaded successfully`);
                                    resolve(loadedTextures);
                                }
                            },
                            // Progress callback
                            function(progress) {
                                // Optional progress tracking
                            },
                            // Error callback
                            function(error) {
                                console.log(`❌ Failed to load tree sprite: ${spritePath}`);
                                hasError = true;
                                loadedCount++;
                                
                                if (loadedCount === treeSprites.length) {
                                    if (hasError && loadedTextures.filter(t => t).length === 0) {
                                        reject('Failed to load any tree sprites');
                                    } else {
                                        // Return only successfully loaded textures
                                        const validTextures = loadedTextures.filter(t => t);
                                        console.log(`🌲 Loaded ${validTextures.length}/${treeSprites.length} tree sprites`);
                                        resolve(validTextures);
                                    }
                                }
                            }
                        );
                    });
                });
            }
            
            function createProceduralTreeTextures() {
                const textures = [];
                
                // Create 5 different realistic tree types
                const treeTypes = [
                    {name: 'Oak', trunkColor: [30, 50, 20], foliageColor: [95, 60, 30], shape: 'round'},
                    {name: 'Pine', trunkColor: [25, 40, 25], foliageColor: [120, 70, 25], shape: 'conical'},
                    {name: 'Birch', trunkColor: [0, 0, 85], foliageColor: [85, 55, 35], shape: 'oval'},
                    {name: 'Maple', trunkColor: [20, 45, 22], foliageColor: [100, 65, 28], shape: 'irregular'},
                    {name: 'Spruce', trunkColor: [28, 35, 18], foliageColor: [130, 75, 20], shape: 'tall_conical'}
                ];
                
                treeTypes.forEach((treeType, i) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256; // Higher resolution for realism
                    canvas.height = 384;
                    const ctx = canvas.getContext('2d');
                    
                    // Clear with transparency
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // More realistic trunk with texture
                    const trunkWidth = 12 + Math.random() * 8;
                    const trunkHeight = 80 + Math.random() * 40;
                    
                    // Trunk gradient for 3D effect
                    const trunkGradient = ctx.createLinearGradient(
                        canvas.width/2 - trunkWidth/2, 0,
                        canvas.width/2 + trunkWidth/2, 0
                    );
                    const [h, s, l] = treeType.trunkColor;
                    trunkGradient.addColorStop(0, `hsl(${h}, ${s}%, ${l - 5}%)`); // Darker left
                    trunkGradient.addColorStop(0.3, `hsl(${h}, ${s}%, ${l + 5}%)`); // Lighter center-left
                    trunkGradient.addColorStop(0.7, `hsl(${h}, ${s}%, ${l}%)`); // Normal center-right
                    trunkGradient.addColorStop(1, `hsl(${h}, ${s - 10}%, ${l - 8}%)`); // Darker right
                    
                    ctx.fillStyle = trunkGradient;
                    ctx.fillRect(canvas.width/2 - trunkWidth/2, canvas.height - trunkHeight, trunkWidth, trunkHeight);
                    
                    // Add trunk texture lines
                    ctx.strokeStyle = `hsla(${h}, ${s}%, ${l - 15}%, 0.6)`;
                    ctx.lineWidth = 1;
                    for (let line = 0; line < 5; line++) {
                        const y = canvas.height - trunkHeight + line * (trunkHeight / 5) + Math.random() * 10;
                        ctx.beginPath();
                        ctx.moveTo(canvas.width/2 - trunkWidth/2, y);
                        ctx.lineTo(canvas.width/2 + trunkWidth/2, y);
                        ctx.stroke();
                    }
                    
                    // Create realistic foliage based on tree type
                    const [fh, fs, fl] = treeType.foliageColor;
                    
                    if (treeType.shape === 'round') {
                        // Oak-style round crown
                        createRoundCrown(ctx, canvas.width/2, canvas.height - trunkHeight - 30, 50, fh, fs, fl);
                    } else if (treeType.shape === 'conical' || treeType.shape === 'tall_conical') {
                        // Pine/Spruce-style conical crown
                        const height = treeType.shape === 'tall_conical' ? 120 : 80;
                        createConicalCrown(ctx, canvas.width/2, canvas.height - trunkHeight, height, fh, fs, fl);
                    } else if (treeType.shape === 'oval') {
                        // Birch-style oval crown
                        createOvalCrown(ctx, canvas.width/2, canvas.height - trunkHeight - 25, 45, 65, fh, fs, fl);
                    } else if (treeType.shape === 'irregular') {
                        // Maple-style irregular crown
                        createIrregularCrown(ctx, canvas.width/2, canvas.height - trunkHeight - 35, 55, fh, fs, fl);
                    }
                    
                    // Create Three.js texture
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    textures.push(texture);
                });
                
                return textures;
                
                // Helper functions for different crown shapes
                function createRoundCrown(ctx, centerX, centerY, radius, h, s, l) {
                    // Main crown circle with gradient
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, `hsl(${h}, ${s}%, ${l + 8}%)`);
                    gradient.addColorStop(0.7, `hsl(${h}, ${s}%, ${l}%)`);
                    gradient.addColorStop(1, `hsl(${h}, ${s - 10}%, ${l - 12}%)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add foliage clusters for texture
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * radius * 0.7;
                        const x = centerX + Math.cos(angle) * dist;
                        const y = centerY + Math.sin(angle) * dist;
                        const size = 8 + Math.random() * 12;
                        
                        ctx.fillStyle = `hsla(${h + (Math.random() - 0.5) * 20}, ${s}%, ${l + (Math.random() - 0.5) * 15}%, 0.8)`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                function createConicalCrown(ctx, centerX, baseY, height, h, s, l) {
                    // Create triangular/conical shape with layers
                    const layers = 6;
                    for (let layer = 0; layer < layers; layer++) {
                        const y = baseY - (layer / layers) * height;
                        const width = (1 - layer / layers) * 40 + 10;
                        
                        const layerGradient = ctx.createLinearGradient(centerX - width, y, centerX + width, y);
                        layerGradient.addColorStop(0, `hsl(${h}, ${s}%, ${l - 8}%)`);
                        layerGradient.addColorStop(0.5, `hsl(${h}, ${s}%, ${l + 5}%)`);
                        layerGradient.addColorStop(1, `hsl(${h}, ${s}%, ${l - 8}%)`);
                        
                        ctx.fillStyle = layerGradient;
                        ctx.beginPath();
                        ctx.ellipse(centerX, y, width, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                function createOvalCrown(ctx, centerX, centerY, radiusX, radiusY, h, s, l) {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusX);
                    gradient.addColorStop(0, `hsl(${h}, ${s}%, ${l + 8}%)`);
                    gradient.addColorStop(0.7, `hsl(${h}, ${s}%, ${l}%)`);
                    gradient.addColorStop(1, `hsl(${h}, ${s - 10}%, ${l - 12}%)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add texture spots
                    for (let i = 0; i < 12; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distX = Math.random() * radiusX * 0.6;
                        const distY = Math.random() * radiusY * 0.6;
                        const x = centerX + Math.cos(angle) * distX;
                        const y = centerY + Math.sin(angle) * distY;
                        
                        ctx.fillStyle = `hsla(${h + (Math.random() - 0.5) * 15}, ${s}%, ${l + (Math.random() - 0.5) * 10}%, 0.7)`;
                        ctx.beginPath();
                        ctx.arc(x, y, 6 + Math.random() * 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                function createIrregularCrown(ctx, centerX, centerY, baseRadius, h, s, l) {
                    // Create irregular shape with multiple overlapping circles
                    const numCircles = 8;
                    for (let i = 0; i < numCircles; i++) {
                        const angle = (i / numCircles) * Math.PI * 2;
                        const offsetRadius = baseRadius * (0.3 + Math.random() * 0.4);
                        const x = centerX + Math.cos(angle) * offsetRadius;
                        const y = centerY + Math.sin(angle) * offsetRadius;
                        const radius = baseRadius * (0.4 + Math.random() * 0.3);
                        
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                        gradient.addColorStop(0, `hsl(${h}, ${s}%, ${l + 5}%)`);
                        gradient.addColorStop(1, `hsl(${h}, ${s - 5}%, ${l - 8}%)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            function createGroundPhysics() {
                // Create physics collision for the ground (invisible box)
                const groundPhysics = new Ammo.btBoxShape(new Ammo.btVector3(150, 0.5, 150));
                const groundTransform = new Ammo.btTransform();
                groundTransform.setIdentity();
                groundTransform.setOrigin(new Ammo.btVector3(0, -0.75, 0));
                
                const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
                const groundRigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundPhysics, new Ammo.btVector3(0, 0, 0));
                const groundRigidBody = new Ammo.btRigidBody(groundRigidBodyInfo);
                groundRigidBody.setFriction(2);
                physicsWorld.addRigidBody(groundRigidBody);
            }

            function createObjects() {
                // Create racing path first
                console.log('Creating racing path...');
                createRacingPath();
                console.log('Racing path created:', !!racingPath, 'Points:', pathPoints.length);
                
                // Create textured ground directly with your forest textures
                createTexturedGround();

                // Transparent walls around the driving area (doubled for larger track)
                createBox(new THREE.Vector3(0, 5, -300), ZERO_QUATERNION, 600, 10, 2, 0, 2, materialTransparent);
                createBox(new THREE.Vector3(0, 5, 300), ZERO_QUATERNION, 600, 10, 2, 0, 2, materialTransparent);
                createBox(new THREE.Vector3(300, 5, 0), ZERO_QUATERNION, 2, 10, 600, 0, 2, materialTransparent);
                createBox(new THREE.Vector3(-300, 5, 0), ZERO_QUATERNION, 2, 10, 600, 0, 2, materialTransparent);

                // Ramp
                var quaternion = new THREE.Quaternion(0, 0, 0, 1);
                quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 18);
                createBox(new THREE.Vector3(0, -1.5, 0), quaternion, 8, 4, 10, 0);

                // Stack of boxes (moved away from track)
                var size = .75;
                var nw = 8;
                var nh = 6;
                for (var j = 0; j < nw; j++)
                    for (var i = 0; i < nh; i++)
                        createBox(new THREE.Vector3(size * j - (size * (nw - 1)) / 2 + 120, size * i, 10), ZERO_QUATERNION, size, size, size, 10);

                // Random cones - fewer and away from track (doubled area for larger track)
                const isQuest = renderer.xr.isPresenting || navigator.userAgent.includes('Quest');
                const coneCount = isQuest ? 5 : 25; // Much fewer cones on Quest
                for (var c = 0; c < coneCount; c++) {
                    var x, z;
                    do {
                        x = (Math.random() - 0.5) * 560; // Doubled from 280
                        z = (Math.random() - 0.5) * 560; // Doubled from 280
                        
                        // Check if too close to racing path (only if path exists)
                        var testPos = new THREE.Vector3(x, 0, z);
                        var pathInfo = racingPath ? findNearestPathPoint(testPos) : {distance: 100};
                        
                    } while ((Math.abs(x) < 60 && Math.abs(z) < 60) || pathInfo.distance < 40); // Doubled exclusion zones
                    
                    createBox(new THREE.Vector3(x, 2, z), ZERO_QUATERNION, 1, 4, 1, 10, 1);
                }

                // Create player and bot cars at the first checkpoint (start line)
                var playerStartPosition = new THREE.Vector3(0, 0, -50); // Default X,Z fallback
                var botStartPosition = new THREE.Vector3(-5, 0, -45); // Default X,Z fallback
                
                // Calculate proper Y positions for fallback
                var playerFallbackElevation = getRoadSurfaceElevation(0, -50);
                var botFallbackElevation = getRoadSurfaceElevation(-5, -45);
                playerStartPosition.y = playerFallbackElevation + 1; // 1m above road
                botStartPosition.y = botFallbackElevation + 1; // 1m above road
                
                if (checkpointMarkers && checkpointMarkers.length > 0) {
                    var firstCheckpoint = checkpointMarkers[0];
                    
                    // Player car at first checkpoint
                    playerStartPosition = firstCheckpoint.position.clone();
                    playerStartPosition.x += 2; // Slightly to the right
                    var playerRoadElevation = getRoadSurfaceElevation(playerStartPosition.x, playerStartPosition.z);
                    if (playerRoadElevation < firstCheckpoint.position.y - 10) {
                        playerStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        playerStartPosition.y = playerRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    // Bot car slightly behind and to the left
                    botStartPosition = firstCheckpoint.position.clone();
                    botStartPosition.x -= 2; // Slightly to the left
                    botStartPosition.z -= 5; // 5m behind
                    var botRoadElevation = getRoadSurfaceElevation(botStartPosition.x, botStartPosition.z);
                    if (botRoadElevation < firstCheckpoint.position.y - 10) {
                        botStartPosition.y = firstCheckpoint.position.y + 2; // Safety fallback
                    } else {
                        botStartPosition.y = botRoadElevation + 1; // 1m above actual road surface
                    }
                    
                    console.log('🏁 Starting positions at first checkpoint:');
                    console.log('🚗 Player:', playerStartPosition.x.toFixed(1), playerStartPosition.y.toFixed(1), playerStartPosition.z.toFixed(1));
                    console.log('🤖 Bot:', botStartPosition.x.toFixed(1), botStartPosition.y.toFixed(1), botStartPosition.z.toFixed(1));
                } else {
                    console.warn('⚠️ No checkpoints available, using default start positions');
                }
                
                // Create rotation quaternion for 90 degrees left (counter-clockwise around Y-axis)
                var leftRotation = new THREE.Quaternion();
                leftRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); // 90 degrees in radians
                console.log('🔄 Cars will be rotated 90° left at spawn');
                
                console.log('Creating player car...');
                createVehicle(playerStartPosition, leftRotation);
                
                // Bot creation will be handled when game mode is determined
                console.log('🤖 Bot creation deferred until game mode is set');
                
                // Create multiplayer remote player cars
                createRemotePlayerCars();
                
                // Confirm both cars are starting at the correct positions
                console.log('✅ Both cars positioned at first checkpoint (start line)');
                
                // Initialize lap timing
                currentLapStartTime = Date.now();
                loadBestTime(); // Load saved best time from localStorage
                console.log('🏁 Lap timing started');
                
                // Initialize audio system
                initAudioSystem();
            }

            // - Init -
            initGraphics();
            initPhysics();
            createObjects();
            
            // Initialize menu system
            setupMenuEventListeners();
            updateMenuDisplay();
            
            // Initialize default game mode (singleplayer) after everything is loaded
            setTimeout(() => {
                if (!isMultiplayer && !botVehicleRef && racingPath) {
                    console.log('🎮 Initializing default singleplayer mode...');
                    switchToSingleplayer();
                }
            }, 1000); // Wait 1 second for everything to initialize
            
            tick();

        });
    </script>

    </body>
</html>
